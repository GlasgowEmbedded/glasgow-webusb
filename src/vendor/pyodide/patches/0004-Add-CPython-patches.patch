From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: miyuko <miyuko@calayucu.com>
Date: Sat, 30 Aug 2025 15:38:23 +0100
Subject: [PATCH] Add CPython patches

---
 ...pten-Add-support-for-async-input-dev.patch |  249 +++
 ...pten-Fix-regression-in-use-after-clo.patch |   33 +
 ...pten-Support-pyrepl-in-browser-GH-13.patch |  462 +++++
 ...pten-Fix-__syscall_ioctl-patch-GH-13.patch |   44 +
 ...l-unpaired-backticks-in-docstrings-1.patch | 1322 +++++++++++++
 ...r-real-singals-on-Ctrl-C-and-Ctrl-Z-.patch |   19 +
 ...sting-of-characters-containing-unico.patch |   18 +
 ...ents-with-non-bool-conditions-in-_py.patch |   38 +
 ...-on-Windows-add-meta-and-ctrl-arrow-.patch |  102 ++
 ...-REPL-virtual-terminal-support-on-Wi.patch |  645 +++++++
 ...ncode-return-value-for-failing-early.patch |  120 ++
 ...nversion-issue-between-coordinates-a.patch |   70 +
 ...pport-of-typing-unicode-chars-in-pyr.patch |   65 +
 ...-unused-imports-in-_pyrepl-and-ctype.patch |   39 +
 ...up-tests-and-type-checking-for-_pyre.patch |  825 +++++++++
 ...or-screen-and-cursor-position-calcul.patch |  293 +++
 ...using-content-of-_pyrepl-__main__.py.patch |   85 +
 ...module-autocomplete-to-PyREPL-129329.patch |  674 +++++++
 ...-to-history-file-after-every-stateme.patch |  137 ++
 ...g-in-new-REPL-is-slow-on-Windows-GH-.patch |  131 ++
 ...pport-for-syntax-highlighting-in-PyR.patch | 1124 ++++++++++++
 .../1022-Bump-mypy-to-1.15-133405.patch       |   49 +
 ...-top-level-exceptions-in-new-pyrepl-.patch |   36 +
 ...put-of-unicode-characters-with-two-o.patch |  205 +++
 ...PL-swallowing-characters-entered-wit.patch |  307 ++++
 ...2017-Handle-SIGCONT-in-pyrepl-132918.patch |   35 +
 ...-SyntaxError-raised-by-the-tokenizer.patch |   69 +
 ...number-of-refs-blocks-after-each-sta.patch |   78 +
 ...REPL-coloring-of-double-braces-in-f-.patch |   89 +
 ...-Autocomplete-for-Builtin-Modules-GH.patch |   73 +
 ...ly-handle-history-file-writes-for-RO.patch |   70 +
 ...-Do-not-show-underscored-modules-by-.patch |  142 ++
 ...-PyREPL-module-autocomplete-fallback.patch |  121 ++
 ...vcrt-import-warning-on-Linux-when-_c.patch |   33 +
 ...-using-system-terminal-for-pip-insta.patch |  106 ++
 ...REPL-syntax-highlightning-on-match-c.patch |   83 +
 ...-dependency-on-curses-from-PyREPL-GH.patch | 1628 +++++++++++++++++
 ...h-135621-Simplify-TermInfo-GH-136916.patch |  182 ++
 ...rl-C-corrupts-REPL-autocomplete-1349.patch |   30 +
 cpython/patches/1040-hacks.patch              |   14 +
 40 files changed, 9845 insertions(+)
 create mode 100644 cpython/patches/1001-gh-124621-Emscripten-Add-support-for-async-input-dev.patch
 create mode 100644 cpython/patches/1002-gh-124621-Emscripten-Fix-regression-in-use-after-clo.patch
 create mode 100644 cpython/patches/1003-gh-124621-Emscripten-Support-pyrepl-in-browser-GH-13.patch
 create mode 100644 cpython/patches/1004-gh-124621-Emscripten-Fix-__syscall_ioctl-patch-GH-13.patch
 create mode 100644 cpython/patches/1005-Remove-almost-all-unpaired-backticks-in-docstrings-1.patch
 create mode 100644 cpython/patches/1006-gh-120221-Deliver-real-singals-on-Ctrl-C-and-Ctrl-Z-.patch
 create mode 100644 cpython/patches/1007-gh-121609-Fix-pasting-of-characters-containing-unico.patch
 create mode 100644 cpython/patches/1008-Fix-while-statements-with-non-bool-conditions-in-_py.patch
 create mode 100644 cpython/patches/1009-gh-128388-pyrepl-on-Windows-add-meta-and-ctrl-arrow-.patch
 create mode 100644 cpython/patches/1010-gh-124096-Enable-REPL-virtual-terminal-support-on-Wi.patch
 create mode 100644 cpython/patches/1011-gh-128231-Use-runcode-return-value-for-failing-early.patch
 create mode 100644 cpython/patches/1012-gh-124927-Fix-conversion-issue-between-coordinates-a.patch
 create mode 100644 cpython/patches/1013-gh-130804-Fix-support-of-typing-unicode-chars-in-pyr.patch
 create mode 100644 cpython/patches/1014-gh-131152-Remove-unused-imports-in-_pyrepl-and-ctype.patch
 create mode 100644 cpython/patches/1015-gh-131507-Clean-up-tests-and-type-checking-for-_pyre.patch
 create mode 100644 cpython/patches/1016-gh-131507-Refactor-screen-and-cursor-position-calcul.patch
 create mode 100644 cpython/patches/1017-gh-129098-avoid-using-content-of-_pyrepl-__main__.py.patch
 create mode 100644 cpython/patches/1018-gh-69605-Add-module-autocomplete-to-PyREPL-129329.patch
 create mode 100644 cpython/patches/1019-gh-127495-Append-to-history-file-after-every-stateme.patch
 create mode 100644 cpython/patches/1020-GH-130328-pasting-in-new-REPL-is-slow-on-Windows-GH-.patch
 create mode 100644 cpython/patches/1021-gh-131507-Add-support-for-syntax-highlighting-in-PyR.patch
 create mode 100644 cpython/patches/1022-Bump-mypy-to-1.15-133405.patch
 create mode 100644 cpython/patches/1023-gh-131878-Handle-top-level-exceptions-in-new-pyrepl-.patch
 create mode 100644 cpython/patches/1024-gh-131878-Fix-input-of-unicode-characters-with-two-o.patch
 create mode 100644 cpython/patches/1025-GH-132439-Fix-REPL-swallowing-characters-entered-wit.patch
 create mode 100644 cpython/patches/1026-gh-132017-Handle-SIGCONT-in-pyrepl-132918.patch
 create mode 100644 cpython/patches/1027-gh-133541-Handle-SyntaxError-raised-by-the-tokenizer.patch
 create mode 100644 cpython/patches/1028-gh-134097-Print-number-of-refs-blocks-after-each-sta.patch
 create mode 100644 cpython/patches/1029-gh-134158-Fix-PyREPL-coloring-of-double-braces-in-f-.patch
 create mode 100644 cpython/patches/1030-gh-134235-Import-Autocomplete-for-Builtin-Modules-GH.patch
 create mode 100644 cpython/patches/1031-gh-128066-Properly-handle-history-file-writes-for-RO.patch
 create mode 100644 cpython/patches/1032-gh-134215-PyREPL-Do-not-show-underscored-modules-by-.patch
 create mode 100644 cpython/patches/1033-gh-69605-Disable-PyREPL-module-autocomplete-fallback.patch
 create mode 100644 cpython/patches/1034-gh-131189-Fix-msvcrt-import-warning-on-Linux-when-_c.patch
 create mode 100644 cpython/patches/1035-gh-72327-Suggest-using-system-terminal-for-pip-insta.patch
 create mode 100644 cpython/patches/1036-gh-136801-Fix-PyREPL-syntax-highlightning-on-match-c.patch
 create mode 100644 cpython/patches/1037-gh-135621-Remove-dependency-on-curses-from-PyREPL-GH.patch
 create mode 100644 cpython/patches/1038-gh-135621-Simplify-TermInfo-GH-136916.patch
 create mode 100644 cpython/patches/1039-gh-134869-Fix-Ctrl-C-corrupts-REPL-autocomplete-1349.patch
 create mode 100644 cpython/patches/1040-hacks.patch

diff --git a/cpython/patches/1001-gh-124621-Emscripten-Add-support-for-async-input-dev.patch b/cpython/patches/1001-gh-124621-Emscripten-Add-support-for-async-input-dev.patch
new file mode 100644
index 00000000..67f15c09
--- /dev/null
+++ b/cpython/patches/1001-gh-124621-Emscripten-Add-support-for-async-input-dev.patch
@@ -0,0 +1,249 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Hood Chatham <roberthoodchatham@gmail.com>
+Date: Sat, 19 Jul 2025 17:14:29 +0200
+Subject: [PATCH] gh-124621: Emscripten: Add support for async input devices
+ (GH-136822)
+
+This is useful for implementing proper `input()`. It requires the
+JavaScript engine to support the wasm JSPI spec which is now stage 4.
+It is supported on Chrome since version 137 and on Firefox and node
+behind a flag.
+
+We override the `__wasi_fd_read()` syscall with our own variant that
+checks for a readAsync operation. If it has it, we use our own async
+variant of `fd_read()`, otherwise we use the original `fd_read()`.
+We also add a variant of `FS.createDevice()` called
+`FS.createAsyncInputDevice()`.
+
+Finally, if JSPI is available, we wrap the `main()` symbol with
+`WebAssembly.promising()` so that we can stack switch from `fd_read()`.
+If JSPI is not available, attempting to read from an AsyncInputDevice
+will raise an `OSError`.
+---
+ Python/emscripten_syscalls.c        | 176 ++++++++++++++++++++++++++++
+ Tools/c-analyzer/cpython/_parser.py |   1 +
+ configure                           |   2 +-
+ configure.ac                        |   2 +-
+ 4 files changed, 179 insertions(+), 2 deletions(-)
+ create mode 100644 Python/emscripten_syscalls.c
+
+diff --git a/Python/emscripten_syscalls.c b/Python/emscripten_syscalls.c
+new file mode 100644
+index 00000000000..6d71dde0a73
+--- /dev/null
++++ b/Python/emscripten_syscalls.c
+@@ -0,0 +1,176 @@
++#include "emscripten.h"
++
++#include <wasi/api.h>
++#include <errno.h>
++#undef errno
++
++// Variant of EM_JS that does C preprocessor substitution on the body
++#define EM_JS_MACROS(ret, func_name, args, body...)                            \
++  EM_JS(ret, func_name, args, body)
++
++EM_JS_MACROS(void, _emscripten_promising_main_js, (void), {
++    // Define FS.createAsyncInputDevice(), This is quite similar to
++    // FS.createDevice() defined here:
++    // https://github.com/emscripten-core/emscripten/blob/4.0.11/src/lib/libfs.js?plain=1#L1642
++    // but instead of returning one byte at a time, the input() function should
++    // return a Uint8Array. This makes the handler code simpler, the
++    // `createAsyncInputDevice` simpler, and everything faster.
++    FS.createAsyncInputDevice = function(parent, name, input) {
++        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
++        var path = PATH.join2(parent, name);
++        var mode = FS_getMode(true, false);
++        FS.createDevice.major ||= 64;
++        var dev = FS.makedev(FS.createDevice.major++, 0);
++        async function getDataBuf() {
++            var buf;
++            try {
++                buf = await input();
++            } catch (e) {
++                throw new FS.ErrnoError(EIO);
++            }
++            if (!buf?.byteLength) {
++                throw new FS.ErrnoError(EAGAIN);
++            }
++            ops._dataBuf = buf;
++        }
++
++        var ops = {
++            _dataBuf: new Uint8Array(0),
++            open(stream) {
++                stream.seekable = false;
++            },
++            async readAsync(stream, buffer, offset, length, pos /* ignored */) {
++                buffer = buffer.subarray(offset, offset + length);
++                if (!ops._dataBuf.byteLength) {
++                    await getDataBuf();
++                }
++                var toRead = Math.min(ops._dataBuf.byteLength, buffer.byteLength);
++                buffer.subarray(0, toRead).set(ops._dataBuf);
++                buffer = buffer.subarray(toRead);
++                ops._dataBuf = ops._dataBuf.subarray(toRead);
++                if (toRead) {
++                    stream.node.atime = Date.now();
++                }
++                return toRead;
++            },
++        };
++        FS.registerDevice(dev, ops);
++        return FS.mkdev(path, mode, dev);
++    };
++    if (!WebAssembly.promising) {
++        // No stack switching support =(
++        return;
++    }
++    const origResolveGlobalSymbol = resolveGlobalSymbol;
++    if (!Module.onExit && process?.exit) {
++        Module.onExit = (code) => process.exit(code);
++    }
++    // * wrap the main symbol with WebAssembly.promising,
++    // * call exit_with_live_runtime() to prevent emscripten from shutting down
++    //   the runtime before the promise resolves,
++    // * call onExit / process.exit ourselves, since exit_with_live_runtime()
++    //   prevented Emscripten from calling it normally.
++    resolveGlobalSymbol = function (name, direct = false) {
++        const orig = origResolveGlobalSymbol(name, direct);
++        if (name === "main") {
++            const main = WebAssembly.promising(orig.sym);
++            orig.sym = (...args) => {
++                (async () => {
++                    const ret = await main(...args);
++                    process?.exit?.(ret);
++                })();
++                _emscripten_exit_with_live_runtime();
++            };
++        }
++        return orig;
++    };
++})
++
++__attribute__((constructor)) void _emscripten_promising_main(void) {
++    _emscripten_promising_main_js();
++}
++
++
++#define IOVEC_T_BUF_OFFSET 0
++#define IOVEC_T_BUF_LEN_OFFSET 4
++#define IOVEC_T_SIZE 8
++_Static_assert(offsetof(__wasi_iovec_t, buf) == IOVEC_T_BUF_OFFSET,
++               "Unexpected __wasi_iovec_t layout");
++_Static_assert(offsetof(__wasi_iovec_t, buf_len) == IOVEC_T_BUF_LEN_OFFSET,
++               "Unexpected __wasi_iovec_t layout");
++_Static_assert(sizeof(__wasi_iovec_t) == IOVEC_T_SIZE,
++               "Unexpected __wasi_iovec_t layout");
++
++// If the stream has a readAsync handler, read to buffer defined in iovs, write
++// number of bytes read to *nread, and return a promise that resolves to the
++// errno. Otherwise, return null.
++EM_JS_MACROS(__externref_t, __maybe_fd_read_async, (
++    __wasi_fd_t fd,
++    const __wasi_iovec_t *iovs,
++    size_t iovcnt,
++    __wasi_size_t *nread
++), {
++    var stream = SYSCALLS.getStreamFromFD(fd);
++    if (!WebAssembly.promising) {
++        return null;
++    }
++    if (!stream.stream_ops.readAsync) {
++        // Not an async device. Fall back to __wasi_fd_read_orig().
++        return null;
++    }
++    return (async () => {
++        // This is the same as libwasi.js fd_read() and doReadv() except we use
++        // readAsync and we await it.
++        // https://github.com/emscripten-core/emscripten/blob/4.0.11/src/lib/libwasi.js?plain=1#L331
++        // https://github.com/emscripten-core/emscripten/blob/4.0.11/src/lib/libwasi.js?plain=1#L197
++        try {
++            var ret = 0;
++            for (var i = 0; i < iovcnt; i++) {
++                var ptr = HEAP32[(iovs + IOVEC_T_BUF_OFFSET)/4];
++                var len = HEAP32[(iovs + IOVEC_T_BUF_LEN_OFFSET)/4];
++                iovs += IOVEC_T_SIZE;
++                var curr = await stream.stream_ops.readAsync(stream, HEAP8, ptr, len);
++                if (curr < 0) return -1;
++                ret += curr;
++                if (curr < len) break; // nothing more to read
++            }
++            HEAP32[nread/4] = ret;
++            return 0;
++        } catch (e) {
++            if (e.name !== 'ErrnoError') {
++                throw e;
++            }
++            return e.errno;
++        }
++    })();
++};
++);
++
++// Bind original fd_read syscall to __wasi_fd_read_orig().
++__wasi_errno_t __wasi_fd_read_orig(__wasi_fd_t fd, const __wasi_iovec_t *iovs,
++                                   size_t iovs_len, __wasi_size_t *nread)
++    __attribute__((__import_module__("wasi_snapshot_preview1"),
++                   __import_name__("fd_read"), __warn_unused_result__));
++
++// Take a promise that resolves to __wasi_errno_t and suspend until it resolves,
++// get the output.
++EM_JS(__wasi_errno_t, __block_for_errno, (__externref_t p), {
++    return p;
++}
++if (WebAssembly.Suspending) {
++    __block_for_errno = new WebAssembly.Suspending(__block_for_errno);
++}
++)
++
++// Replacement for fd_read syscall. Call __maybe_fd_read_async. If it returned
++// null, delegate back to __wasi_fd_read_orig. Otherwise, use __block_for_errno
++// to get the result.
++__wasi_errno_t __wasi_fd_read(__wasi_fd_t fd, const __wasi_iovec_t *iovs,
++                              size_t iovs_len, __wasi_size_t *nread) {
++  __externref_t p = __maybe_fd_read_async(fd, iovs, iovs_len, nread);
++  if (__builtin_wasm_ref_is_null_extern(p)) {
++    return __wasi_fd_read_orig(fd, iovs, iovs_len, nread);
++  }
++  __wasi_errno_t res = __block_for_errno(p);
++  return res;
++}
+diff --git a/Tools/c-analyzer/cpython/_parser.py b/Tools/c-analyzer/cpython/_parser.py
+index 12010f0e9c0..af63347b363 100644
+--- a/Tools/c-analyzer/cpython/_parser.py
++++ b/Tools/c-analyzer/cpython/_parser.py
+@@ -66,6 +66,7 @@ def clean_lines(text):
+ Python/dynload_dl.c             # dl.h
+ Python/dynload_hpux.c           # dl.h
+ Python/emscripten_signal.c
++Python/emscripten_syscalls.c
+ Python/thread_pthread.h
+ Python/thread_pthread_stubs.h
+ 
+diff --git a/configure b/configure
+index 1cd1f690f7b..579161501a2 100755
+--- a/configure
++++ b/configure
+@@ -17809,7 +17809,7 @@ PLATFORM_OBJS=
+ case $ac_sys_system in #(
+   Emscripten) :
+ 
+-    as_fn_append PLATFORM_OBJS ' Python/emscripten_signal.o Python/emscripten_trampoline.o'
++    as_fn_append PLATFORM_OBJS ' Python/emscripten_signal.o Python/emscripten_trampoline.o Python/emscripten_syscalls.o'
+     as_fn_append PLATFORM_HEADERS ' $(srcdir)/Include/internal/pycore_emscripten_signal.h $(srcdir)/Include/internal/pycore_emscripten_trampoline.h'
+    ;; #(
+   *) :
+diff --git a/configure.ac b/configure.ac
+index 3fcb18922c5..891092959c5 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -5029,7 +5029,7 @@ PLATFORM_OBJS=
+ 
+ AS_CASE([$ac_sys_system],
+   [Emscripten], [
+-    AS_VAR_APPEND([PLATFORM_OBJS], [' Python/emscripten_signal.o Python/emscripten_trampoline.o'])
++    AS_VAR_APPEND([PLATFORM_OBJS], [' Python/emscripten_signal.o Python/emscripten_trampoline.o Python/emscripten_syscalls.o'])
+     AS_VAR_APPEND([PLATFORM_HEADERS], [' $(srcdir)/Include/internal/pycore_emscripten_signal.h $(srcdir)/Include/internal/pycore_emscripten_trampoline.h'])
+   ],
+ )
diff --git a/cpython/patches/1002-gh-124621-Emscripten-Fix-regression-in-use-after-clo.patch b/cpython/patches/1002-gh-124621-Emscripten-Fix-regression-in-use-after-clo.patch
new file mode 100644
index 00000000..179fde8b
--- /dev/null
+++ b/cpython/patches/1002-gh-124621-Emscripten-Fix-regression-in-use-after-clo.patch
@@ -0,0 +1,33 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Hood Chatham <roberthoodchatham@gmail.com>
+Date: Sat, 19 Jul 2025 21:43:50 +0200
+Subject: [PATCH] gh-124621: Emscripten: Fix regression in use-after-close
+ error handling (#136837)
+
+---
+ Python/emscripten_syscalls.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+diff --git a/Python/emscripten_syscalls.c b/Python/emscripten_syscalls.c
+index 6d71dde0a73..54226613847 100644
+--- a/Python/emscripten_syscalls.c
++++ b/Python/emscripten_syscalls.c
+@@ -110,10 +110,17 @@ EM_JS_MACROS(__externref_t, __maybe_fd_read_async, (
+     size_t iovcnt,
+     __wasi_size_t *nread
+ ), {
+-    var stream = SYSCALLS.getStreamFromFD(fd);
+     if (!WebAssembly.promising) {
+         return null;
+     }
++    var stream;
++    try {
++        stream = SYSCALLS.getStreamFromFD(fd);
++    } catch (e) {
++        // If the fd was already closed or never existed, getStreamFromFD()
++        // raises. We'll let fd_read_orig() handle setting errno.
++        return null;
++    }
+     if (!stream.stream_ops.readAsync) {
+         // Not an async device. Fall back to __wasi_fd_read_orig().
+         return null;
diff --git a/cpython/patches/1003-gh-124621-Emscripten-Support-pyrepl-in-browser-GH-13.patch b/cpython/patches/1003-gh-124621-Emscripten-Support-pyrepl-in-browser-GH-13.patch
new file mode 100644
index 00000000..04cc96bb
--- /dev/null
+++ b/cpython/patches/1003-gh-124621-Emscripten-Support-pyrepl-in-browser-GH-13.patch
@@ -0,0 +1,462 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Hood Chatham <roberthoodchatham@gmail.com>
+Date: Tue, 22 Jul 2025 12:13:38 +0200
+Subject: [PATCH] gh-124621: Emscripten: Support pyrepl in browser (GH-136931)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Basic support for pyrepl in Emscripten. Limitations:
+* requires JSPI
+* no signal handling implemented
+
+As followup work, it would be nice to implement a webworker variant
+for when JSPI is not available and proper signal handling.
+
+Because it requires JSPI, it doesn't work in Safari. Firefox requires
+setting an experimental flag. All the Chromiums have full support since
+May. Until we make it work without JSPI, let's keep the original web_example
+around.
+
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+Co-authored-by: Éric <merwok@netwok.org>
+---
+ Lib/_pyrepl/trace.py                          |  27 ++--
+ ...-07-21-16-10-24.gh-issue-124621.wyoWc1.rst |   1 +
+ Modules/clinic/posixmodule.c.h                |  77 +++++++++++-
+ Modules/posixmodule.c                         |  27 ++++
+ Python/emscripten_syscalls.c                  | 116 ++++++++++++++++--
+ Tools/wasm/config.site-wasm32-emscripten      |   1 -
+ configure                                     |   8 +-
+ configure.ac                                  |   9 +-
+ 8 files changed, 242 insertions(+), 24 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-07-21-16-10-24.gh-issue-124621.wyoWc1.rst
+
+diff --git a/Lib/_pyrepl/trace.py b/Lib/_pyrepl/trace.py
+index a8eb2433cd3..943ee12f964 100644
+--- a/Lib/_pyrepl/trace.py
++++ b/Lib/_pyrepl/trace.py
+@@ -1,6 +1,7 @@
+ from __future__ import annotations
+ 
+ import os
++import sys
+ 
+ # types
+ if False:
+@@ -12,10 +13,22 @@
+     trace_file = open(trace_filename, "a")
+ 
+ 
+-def trace(line: str, *k: object, **kw: object) -> None:
+-    if trace_file is None:
+-        return
+-    if k or kw:
+-        line = line.format(*k, **kw)
+-    trace_file.write(line + "\n")
+-    trace_file.flush()
++
++if sys.platform == "emscripten":
++    from posix import _emscripten_log
++
++    def trace(line: str, *k: object, **kw: object) -> None:
++        if "PYREPL_TRACE" not in os.environ:
++            return
++        if k or kw:
++            line = line.format(*k, **kw)
++        _emscripten_log(line)
++
++else:
++    def trace(line: str, *k: object, **kw: object) -> None:
++        if trace_file is None:
++            return
++        if k or kw:
++            line = line.format(*k, **kw)
++        trace_file.write(line + "\n")
++        trace_file.flush()
+diff --git a/Misc/NEWS.d/next/Library/2025-07-21-16-10-24.gh-issue-124621.wyoWc1.rst b/Misc/NEWS.d/next/Library/2025-07-21-16-10-24.gh-issue-124621.wyoWc1.rst
+new file mode 100644
+index 00000000000..34049183649
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-07-21-16-10-24.gh-issue-124621.wyoWc1.rst
+@@ -0,0 +1 @@
++pyrepl now works in Emscripten.
+diff --git a/Modules/clinic/posixmodule.c.h b/Modules/clinic/posixmodule.c.h
+index b69817ae9bb..819c9514f8c 100644
+--- a/Modules/clinic/posixmodule.c.h
++++ b/Modules/clinic/posixmodule.c.h
+@@ -12212,6 +12212,77 @@ os__is_inputhook_installed(PyObject *module, PyObject *Py_UNUSED(ignored))
+     return os__is_inputhook_installed_impl(module);
+ }
+ 
++#if defined(__EMSCRIPTEN__)
++
++PyDoc_STRVAR(os__emscripten_log__doc__,
++"_emscripten_log($module, /, arg)\n"
++"--\n"
++"\n"
++"Log something to the JS console. Emscripten only.");
++
++#define OS__EMSCRIPTEN_LOG_METHODDEF    \
++    {"_emscripten_log", _PyCFunction_CAST(os__emscripten_log), METH_FASTCALL|METH_KEYWORDS, os__emscripten_log__doc__},
++
++static PyObject *
++os__emscripten_log_impl(PyObject *module, const char *arg);
++
++static PyObject *
++os__emscripten_log(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
++{
++    PyObject *return_value = NULL;
++    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
++
++    #define NUM_KEYWORDS 1
++    static struct {
++        PyGC_Head _this_is_not_used;
++        PyObject_VAR_HEAD
++        PyObject *ob_item[NUM_KEYWORDS];
++    } _kwtuple = {
++        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
++        .ob_item = { &_Py_ID(arg), },
++    };
++    #undef NUM_KEYWORDS
++    #define KWTUPLE (&_kwtuple.ob_base.ob_base)
++
++    #else  // !Py_BUILD_CORE
++    #  define KWTUPLE NULL
++    #endif  // !Py_BUILD_CORE
++
++    static const char * const _keywords[] = {"arg", NULL};
++    static _PyArg_Parser _parser = {
++        .keywords = _keywords,
++        .fname = "_emscripten_log",
++        .kwtuple = KWTUPLE,
++    };
++    #undef KWTUPLE
++    PyObject *argsbuf[1];
++    const char *arg;
++
++    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
++    if (!args) {
++        goto exit;
++    }
++    if (!PyUnicode_Check(args[0])) {
++        _PyArg_BadArgument("_emscripten_log", "argument 'arg'", "str", args[0]);
++        goto exit;
++    }
++    Py_ssize_t arg_length;
++    arg = PyUnicode_AsUTF8AndSize(args[0], &arg_length);
++    if (arg == NULL) {
++        goto exit;
++    }
++    if (strlen(arg) != (size_t)arg_length) {
++        PyErr_SetString(PyExc_ValueError, "embedded null character");
++        goto exit;
++    }
++    return_value = os__emscripten_log_impl(module, arg);
++
++exit:
++    return return_value;
++}
++
++#endif /* defined(__EMSCRIPTEN__) */
++
+ #ifndef OS_TTYNAME_METHODDEF
+     #define OS_TTYNAME_METHODDEF
+ #endif /* !defined(OS_TTYNAME_METHODDEF) */
+@@ -12879,4 +12950,8 @@ os__is_inputhook_installed(PyObject *module, PyObject *Py_UNUSED(ignored))
+ #ifndef OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF
+     #define OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF
+ #endif /* !defined(OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF) */
+-/*[clinic end generated code: output=a75be356cd4abca5 input=a9049054013a1b77]*/
++
++#ifndef OS__EMSCRIPTEN_LOG_METHODDEF
++    #define OS__EMSCRIPTEN_LOG_METHODDEF
++#endif /* !defined(OS__EMSCRIPTEN_LOG_METHODDEF) */
++/*[clinic end generated code: output=2001a60ca6c94058 input=a9049054013a1b77]*/
+diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
+index 40d0f86e6ae..8988bd28cda 100644
+--- a/Modules/posixmodule.c
++++ b/Modules/posixmodule.c
+@@ -72,6 +72,9 @@
+ #ifdef HAVE_SYS_PIDFD_H
+ #  include <sys/pidfd.h>          // PIDFD_NONBLOCK
+ #endif
++#ifdef __EMSCRIPTEN__
++#  include "emscripten.h"         // emscripten_debugger()
++#endif
+ 
+ 
+ // SGI apparently needs this forward declaration
+@@ -16837,6 +16840,29 @@ os__is_inputhook_installed_impl(PyObject *module)
+     return PyBool_FromLong(PyOS_InputHook != NULL);
+ }
+ 
++
++#ifdef __EMSCRIPTEN__
++EM_JS(void, emscripten_log_impl_js, (const char* arg), {
++    console.warn(UTF8ToString(arg));
++});
++
++/*[clinic input]
++os._emscripten_log
++   arg: str
++
++Log something to the JS console. Emscripten only.
++[clinic start generated code]*/
++
++static PyObject *
++os__emscripten_log_impl(PyObject *module, const char *arg)
++/*[clinic end generated code: output=9749e5e293c42784 input=350aa1f70bc1e905]*/
++{
++    emscripten_log_impl_js(arg);
++    Py_RETURN_NONE;
++}
++#endif /* __EMSCRIPTEN__ */
++
++
+ static PyMethodDef posix_methods[] = {
+ 
+     OS_STAT_METHODDEF
+@@ -17051,6 +17077,7 @@ static PyMethodDef posix_methods[] = {
+     OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF
+     OS__INPUTHOOK_METHODDEF
+     OS__IS_INPUTHOOK_INSTALLED_METHODDEF
++    OS__EMSCRIPTEN_LOG_METHODDEF
+     {NULL,              NULL}            /* Sentinel */
+ };
+ 
+diff --git a/Python/emscripten_syscalls.c b/Python/emscripten_syscalls.c
+index 54226613847..8d4a5082de1 100644
+--- a/Python/emscripten_syscalls.c
++++ b/Python/emscripten_syscalls.c
+@@ -1,8 +1,9 @@
+ #include "emscripten.h"
++#include "stdio.h"
+ 
+ #include <wasi/api.h>
+ #include <errno.h>
+-#undef errno
++#include <fcntl.h>
+ 
+ // Variant of EM_JS that does C preprocessor substitution on the body
+ #define EM_JS_MACROS(ret, func_name, args, body...)                            \
+@@ -62,7 +63,7 @@ EM_JS_MACROS(void, _emscripten_promising_main_js, (void), {
+         return;
+     }
+     const origResolveGlobalSymbol = resolveGlobalSymbol;
+-    if (!Module.onExit && process?.exit) {
++    if (ENVIRONMENT_IS_NODE && !Module.onExit) {
+         Module.onExit = (code) => process.exit(code);
+     }
+     // * wrap the main symbol with WebAssembly.promising,
+@@ -77,7 +78,7 @@ EM_JS_MACROS(void, _emscripten_promising_main_js, (void), {
+             orig.sym = (...args) => {
+                 (async () => {
+                     const ret = await main(...args);
+-                    process?.exit?.(ret);
++                    Module.onExit?.(ret);
+                 })();
+                 _emscripten_exit_with_live_runtime();
+             };
+@@ -147,7 +148,7 @@ EM_JS_MACROS(__externref_t, __maybe_fd_read_async, (
+             if (e.name !== 'ErrnoError') {
+                 throw e;
+             }
+-            return e.errno;
++            return e["errno"];
+         }
+     })();
+ };
+@@ -161,16 +162,16 @@ __wasi_errno_t __wasi_fd_read_orig(__wasi_fd_t fd, const __wasi_iovec_t *iovs,
+ 
+ // Take a promise that resolves to __wasi_errno_t and suspend until it resolves,
+ // get the output.
+-EM_JS(__wasi_errno_t, __block_for_errno, (__externref_t p), {
++EM_JS(int, __block_for_int, (__externref_t p), {
+     return p;
+ }
+ if (WebAssembly.Suspending) {
+-    __block_for_errno = new WebAssembly.Suspending(__block_for_errno);
++    __block_for_int = new WebAssembly.Suspending(__block_for_int);
+ }
+ )
+ 
+ // Replacement for fd_read syscall. Call __maybe_fd_read_async. If it returned
+-// null, delegate back to __wasi_fd_read_orig. Otherwise, use __block_for_errno
++// null, delegate back to __wasi_fd_read_orig. Otherwise, use __block_for_int
+ // to get the result.
+ __wasi_errno_t __wasi_fd_read(__wasi_fd_t fd, const __wasi_iovec_t *iovs,
+                               size_t iovs_len, __wasi_size_t *nread) {
+@@ -178,6 +179,103 @@ __wasi_errno_t __wasi_fd_read(__wasi_fd_t fd, const __wasi_iovec_t *iovs,
+   if (__builtin_wasm_ref_is_null_extern(p)) {
+     return __wasi_fd_read_orig(fd, iovs, iovs_len, nread);
+   }
+-  __wasi_errno_t res = __block_for_errno(p);
+-  return res;
++  return __block_for_int(p);
++}
++
++#include <poll.h>
++#define POLLFD_FD 0
++#define POLLFD_EVENTS 4
++#define POLLFD_REVENTS 6
++#define POLLFD_SIZE 8
++_Static_assert(offsetof(struct pollfd, fd) == 0, "Unepxected pollfd struct layout");
++_Static_assert(offsetof(struct pollfd, events) == 4, "Unepxected pollfd struct layout");
++_Static_assert(offsetof(struct pollfd, revents) == 6, "Unepxected pollfd struct layout");
++_Static_assert(sizeof(struct pollfd) == 8, "Unepxected pollfd struct layout");
++
++EM_JS_MACROS(__externref_t, __maybe_poll_async, (intptr_t fds, int nfds, int timeout), {
++    if (!WebAssembly.promising) {
++        return null;
++    }
++    return (async function() {
++        try {
++            var nonzero = 0;
++            var promises = [];
++            for (var i = 0; i < nfds; i++) {
++                var pollfd = fds + POLLFD_SIZE * i;
++                var fd = HEAP32[(pollfd + POLLFD_FD)/4];
++                var events = HEAP16[(pollfd + POLLFD_EVENTS)/2];
++                var mask = POLLNVAL;
++                var stream = FS.getStream(fd);
++                if (stream) {
++                    mask = POLLIN | POLLOUT;
++                    if (stream.stream_ops.pollAsync) {
++                        promises.push(stream.stream_ops.pollAsync(stream, timeout).then((mask) => {
++                            mask &= events | POLLERR | POLLHUP;
++                            HEAP16[(pollfd + POLLFD_REVENTS)/2] = mask;
++                            if (mask) {
++                                nonzero ++;
++                            }
++                        }));
++                    } else if (stream.stream_ops.poll) {
++                        var mask = stream.stream_ops.poll(stream, timeout);
++                        mask &= events | POLLERR | POLLHUP;
++                        HEAP16[(pollfd + POLLFD_REVENTS)/2] = mask;
++                        if (mask) {
++                            nonzero ++;
++                        }
++                    }
++                }
++            }
++            await Promise.all(promises);
++            return nonzero;
++        } catch(e) {
++            if (e?.name !== "ErrnoError") throw e;
++            return -e["errno"];
++        }
++    })();
++});
++
++// Bind original poll syscall to syscall_poll_orig().
++int syscall_poll_orig(intptr_t fds, int nfds, int timeout)
++    __attribute__((__import_module__("env"),
++                   __import_name__("__syscall_poll"), __warn_unused_result__));
++
++int __syscall_poll(intptr_t fds, int nfds, int timeout) {
++    __externref_t p = __maybe_poll_async(fds, nfds, timeout);
++    if (__builtin_wasm_ref_is_null_extern(p)) {
++        return syscall_poll_orig(fds, nfds, timeout);
++    }
++    return __block_for_int(p);
++}
++
++#include <sys/ioctl.h>
++
++int syscall_ioctl_orig(int fd, int request, void* varargs)
++    __attribute__((__import_module__("env"),
++                   __import_name__("__syscall_ioctl"), __warn_unused_result__));
++
++int __syscall_ioctl(int fd, int request, void* varargs) {
++    if (request == FIOCLEX || request == FIONCLEX) {
++        return 0;
++    }
++    if (request == FIONBIO) {
++        // Implement FIONBIO via fcntl.
++        // TODO: Upstream this.
++        int flags = fcntl(fd, F_GETFL, 0);
++        int nonblock = **((int**)varargs);
++        if (flags < 0) {
++            return errno;
++        }
++        if (nonblock) {
++            flags |= O_NONBLOCK;
++        } else {
++            flags &= (~O_NONBLOCK);
++        }
++        int res = fcntl(fd, F_SETFL, flags);
++        if (res < 0) {
++            return errno;
++        }
++        return res;
++    }
++    return syscall_ioctl_orig(fd, request, varargs);
+ }
+diff --git a/Tools/wasm/config.site-wasm32-emscripten b/Tools/wasm/config.site-wasm32-emscripten
+index 1471546a5ee..b60ea0f6261 100644
+--- a/Tools/wasm/config.site-wasm32-emscripten
++++ b/Tools/wasm/config.site-wasm32-emscripten
+@@ -69,7 +69,6 @@ ac_cv_func_posix_fallocate=no
+ 
+ # Syscalls that resulted in a segfault
+ ac_cv_func_utimensat=no
+-ac_cv_header_sys_ioctl_h=no
+ 
+ # sockets are supported, but only AF_INET / AF_INET6 in non-blocking mode.
+ # Disable AF_UNIX and AF_PACKET support, see socketmodule.h.
+diff --git a/configure b/configure
+index 579161501a2..332b9e5e904 100755
+--- a/configure
++++ b/configure
+@@ -9551,7 +9551,11 @@ fi
+ 
+         as_fn_append LDFLAGS_NODIST " -sWASM_BIGINT"
+ 
+-        as_fn_append LDFLAGS_NODIST " -sFORCE_FILESYSTEM -lidbfs.js -lnodefs.js -lproxyfs.js -lworkerfs.js"
++        as_fn_append LINKFORSHARED " -sFORCE_FILESYSTEM -lidbfs.js -lnodefs.js -lproxyfs.js -lworkerfs.js"
++    as_fn_append LINKFORSHARED " -sEXPORTED_RUNTIME_METHODS=FS,callMain,ENV,HEAPU32,TTY"
++    as_fn_append LINKFORSHARED " -sEXPORTED_FUNCTIONS=_main,_Py_Version,__PyRuntime,__PyEM_EMSCRIPTEN_COUNT_ARGS_OFFSET,_PyGILState_GetThisThreadState,__Py_DumpTraceback"
++    as_fn_append LINKFORSHARED " -sSTACK_SIZE=5MB"
++        as_fn_append LINKFORSHARED " -sTEXTDECODER=2"
+ 
+     if test "x$enable_wasm_dynamic_linking" = xyes
+ then :
+@@ -28786,9 +28790,7 @@ case $ac_sys_system in #(
+ 
+ 
+ 
+-    py_cv_module_fcntl=n/a
+     py_cv_module_readline=n/a
+-    py_cv_module_termios=n/a
+     py_cv_module_=n/a
+ 
+        ;; #(
+diff --git a/configure.ac b/configure.ac
+index 891092959c5..a7ae9e039a8 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -2417,7 +2417,12 @@ AS_CASE([$ac_sys_system],
+     AS_VAR_APPEND([LDFLAGS_NODIST], [" -sWASM_BIGINT"])
+ 
+     dnl Include file system support
+-    AS_VAR_APPEND([LDFLAGS_NODIST], [" -sFORCE_FILESYSTEM -lidbfs.js -lnodefs.js -lproxyfs.js -lworkerfs.js"])
++    AS_VAR_APPEND([LINKFORSHARED], [" -sFORCE_FILESYSTEM -lidbfs.js -lnodefs.js -lproxyfs.js -lworkerfs.js"])
++    AS_VAR_APPEND([LINKFORSHARED], [" -sEXPORTED_RUNTIME_METHODS=FS,callMain,ENV,HEAPU32,TTY"])
++    AS_VAR_APPEND([LINKFORSHARED], [" -sEXPORTED_FUNCTIONS=_main,_Py_Version,__PyRuntime,__PyEM_EMSCRIPTEN_COUNT_ARGS_OFFSET,_PyGILState_GetThisThreadState,__Py_DumpTraceback"])
++    AS_VAR_APPEND([LINKFORSHARED], [" -sSTACK_SIZE=5MB"])
++    dnl Avoid bugs in JS fallback string decoding path
++    AS_VAR_APPEND([LINKFORSHARED], [" -sTEXTDECODER=2"])
+ 
+     AS_VAR_IF([enable_wasm_dynamic_linking], [yes], [
+       AS_VAR_APPEND([LINKFORSHARED], [" -sMAIN_MODULE"])
+@@ -7532,9 +7537,7 @@ AS_CASE([$ac_sys_system],
+       [Emscripten/browser*], [
+         dnl These modules are not particularly useful in browsers.
+         PY_STDLIB_MOD_SET_NA(
+-          [fcntl],
+           [readline],
+-          [termios],
+         )
+       ],
+       [Emscripten/node*], [],
diff --git a/cpython/patches/1004-gh-124621-Emscripten-Fix-__syscall_ioctl-patch-GH-13.patch b/cpython/patches/1004-gh-124621-Emscripten-Fix-__syscall_ioctl-patch-GH-13.patch
new file mode 100644
index 00000000..76315f4b
--- /dev/null
+++ b/cpython/patches/1004-gh-124621-Emscripten-Fix-__syscall_ioctl-patch-GH-13.patch
@@ -0,0 +1,44 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Hood Chatham <roberthoodchatham@gmail.com>
+Date: Tue, 22 Jul 2025 15:05:26 +0200
+Subject: [PATCH] gh-124621: Emscripten: Fix __syscall_ioctl patch (GH-136993)
+
+If there is an error, we have to return `-errno` not positive errno.
+Included in backport of GH-136931: #136988
+---
+ Python/emscripten_syscalls.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+diff --git a/Python/emscripten_syscalls.c b/Python/emscripten_syscalls.c
+index 8d4a5082de1..44044ca3fc1 100644
+--- a/Python/emscripten_syscalls.c
++++ b/Python/emscripten_syscalls.c
+@@ -1,6 +1,10 @@
+ #include "emscripten.h"
+ #include "stdio.h"
+ 
++// All system calls: return nonnegative number on success, return -errno on
++// failure. Negative results get stored back into errno here:
++// https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/src/internal/syscall_ret.c#L7
++
+ #include <wasi/api.h>
+ #include <errno.h>
+ #include <fcntl.h>
+@@ -264,7 +268,7 @@ int __syscall_ioctl(int fd, int request, void* varargs) {
+         int flags = fcntl(fd, F_GETFL, 0);
+         int nonblock = **((int**)varargs);
+         if (flags < 0) {
+-            return errno;
++            return -errno;
+         }
+         if (nonblock) {
+             flags |= O_NONBLOCK;
+@@ -273,7 +277,7 @@ int __syscall_ioctl(int fd, int request, void* varargs) {
+         }
+         int res = fcntl(fd, F_SETFL, flags);
+         if (res < 0) {
+-            return errno;
++            return -errno;
+         }
+         return res;
+     }
diff --git a/cpython/patches/1005-Remove-almost-all-unpaired-backticks-in-docstrings-1.patch b/cpython/patches/1005-Remove-almost-all-unpaired-backticks-in-docstrings-1.patch
new file mode 100644
index 00000000..7fdf963d
--- /dev/null
+++ b/cpython/patches/1005-Remove-almost-all-unpaired-backticks-in-docstrings-1.patch
@@ -0,0 +1,1322 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Geoffrey Thomas <geofft@ldpreload.com>
+Date: Wed, 22 May 2024 12:35:18 -0400
+Subject: [PATCH] Remove almost all unpaired backticks in docstrings (#119231)
+
+As reported in #117847 and #115366, an unpaired backtick in a docstring
+tends to confuse e.g. Sphinx running on subclasses of standard library
+objects, and the typographic style of using a backtick as an opening
+quote is no longer in favor. Convert almost all uses of the form
+
+    The variable `foo' should do xyz
+
+to
+
+    The variable 'foo' should do xyz
+
+and also fix up miscellaneous other unpaired backticks (extraneous /
+missing characters).
+
+No functional change is intended here other than in human-readable
+docstrings.
+---
+ Lib/_pyrepl/keymap.py                       | 18 +++----
+ Lib/_pyrepl/reader.py                       |  8 +--
+ Lib/cmd.py                                  | 24 ++++-----
+ Lib/configparser.py                         |  2 +-
+ Lib/doctest.py                              |  4 +-
+ Lib/email/_parseaddr.py                     | 14 ++---
+ Lib/email/_policybase.py                    |  2 +-
+ Lib/email/base64mime.py                     |  2 +-
+ Lib/email/charset.py                        |  4 +-
+ Lib/email/generator.py                      |  6 +--
+ Lib/email/header.py                         |  6 +--
+ Lib/email/iterators.py                      |  4 +-
+ Lib/email/message.py                        | 26 ++++-----
+ Lib/email/mime/multipart.py                 |  2 +-
+ Lib/email/parser.py                         |  4 +-
+ Lib/email/quoprimime.py                     |  8 +--
+ Lib/ftplib.py                               |  2 +-
+ Lib/getopt.py                               |  6 +--
+ Lib/heapq.py                                |  6 +--
+ Lib/http/client.py                          | 10 ++--
+ Lib/http/cookiejar.py                       |  2 +-
+ Lib/imaplib.py                              | 10 ++--
+ Lib/mimetypes.py                            | 26 ++++-----
+ Lib/smtplib.py                              |  6 +--
+ Lib/tarfile.py                              | 60 ++++++++++-----------
+ Lib/test/support/smtpd.py                   | 14 ++---
+ Lib/test/test_asyncio/test_locks.py         |  4 +-
+ Lib/trace.py                                |  4 +-
+ Lib/unittest/mock.py                        |  2 +-
+ Lib/wsgiref/headers.py                      |  2 +-
+ Lib/zipfile/__init__.py                     |  8 +--
+ Modules/_heapqmodule.c                      |  6 +--
+ Modules/_interpretersmodule.c               |  2 +-
+ Modules/cjkcodecs/clinic/multibytecodec.c.h |  4 +-
+ Modules/cjkcodecs/multibytecodec.c          |  4 +-
+ Modules/clinic/pyexpat.c.h                  |  4 +-
+ Modules/pyexpat.c                           |  4 +-
+ Objects/bytesobject.c                       | 22 ++++----
+ Objects/odictobject.c                       |  2 +-
+ 39 files changed, 172 insertions(+), 172 deletions(-)
+
+diff --git a/Lib/_pyrepl/keymap.py b/Lib/_pyrepl/keymap.py
+index 2fb03d19523..d11df4b5164 100644
+--- a/Lib/_pyrepl/keymap.py
++++ b/Lib/_pyrepl/keymap.py
+@@ -30,20 +30,20 @@
+ pyrepl uses its own keyspec format that is meant to be a strict superset of
+ readline's KEYSEQ format. This means that if a spec is found that readline
+ accepts that this doesn't, it should be logged as a bug. Note that this means
+-we're using the `\\C-o' style of readline's keyspec, not the `Control-o' sort.
++we're using the '\\C-o' style of readline's keyspec, not the 'Control-o' sort.
+ 
+ The extension to readline is that the sequence \\<KEY> denotes the
+ sequence of characters produced by hitting KEY.
+ 
+ Examples:
+-`a'      - what you get when you hit the `a' key
+-`\\EOA'  - Escape - O - A (up, on my terminal)
+-`\\<UP>' - the up arrow key
+-`\\<up>' - ditto (keynames are case-insensitive)
+-`\\C-o', `\\c-o'  - control-o
+-`\\M-.'  - meta-period
+-`\\E.'   - ditto (that's how meta works for pyrepl)
+-`\\<tab>', `\\<TAB>', `\\t', `\\011', '\\x09', '\\X09', '\\C-i', '\\C-I'
++'a'      - what you get when you hit the 'a' key
++'\\EOA'  - Escape - O - A (up, on my terminal)
++'\\<UP>' - the up arrow key
++'\\<up>' - ditto (keynames are case-insensitive)
++'\\C-o', '\\c-o'  - control-o
++'\\M-.'  - meta-period
++'\\E.'   - ditto (that's how meta works for pyrepl)
++'\\<tab>', '\\<TAB>', '\\t', '\\011', '\\x09', '\\X09', '\\C-i', '\\C-I'
+    - all of these are the tab character.
+ """
+ 
+diff --git a/Lib/_pyrepl/reader.py b/Lib/_pyrepl/reader.py
+index dc26bfd3a34..1252847e02b 100644
+--- a/Lib/_pyrepl/reader.py
++++ b/Lib/_pyrepl/reader.py
+@@ -180,7 +180,7 @@ class Reader:
+       * console:
+         Hopefully encapsulates the OS dependent stuff.
+       * pos:
+-        A 0-based index into `buffer' for where the insertion point
++        A 0-based index into 'buffer' for where the insertion point
+         is.
+       * screeninfo:
+         Ahem.  This list contains some info needed to move the
+@@ -188,7 +188,7 @@ class Reader:
+       * cxy, lxy:
+         the position of the insertion point in screen ...
+       * syntax_table:
+-        Dictionary mapping characters to `syntax class'; read the
++        Dictionary mapping characters to 'syntax class'; read the
+         emacs docs to see what this means :-)
+       * commands:
+         Dictionary mapping command names to command classes.
+@@ -525,7 +525,7 @@ def max_row(self) -> int:
+ 
+     def get_arg(self, default: int = 1) -> int:
+         """Return any prefix argument that the user has supplied,
+-        returning `default' if there is None.  Defaults to 1.
++        returning 'default' if there is None.  Defaults to 1.
+         """
+         if self.arg is None:
+             return default
+@@ -533,7 +533,7 @@ def get_arg(self, default: int = 1) -> int:
+ 
+     def get_prompt(self, lineno: int, cursor_on_line: bool) -> str:
+         """Return what should be in the left-hand margin for line
+-        `lineno'."""
++        'lineno'."""
+         if self.arg is not None and cursor_on_line:
+             prompt = f"(arg: {self.arg}) "
+         elif self.paste_mode and not self.in_bracketed_paste:
+diff --git a/Lib/cmd.py b/Lib/cmd.py
+index a37d16cd7bd..c333e099bd8 100644
+--- a/Lib/cmd.py
++++ b/Lib/cmd.py
+@@ -5,16 +5,16 @@
+ 1. End of file on input is processed as the command 'EOF'.
+ 2. A command is parsed out of each line by collecting the prefix composed
+    of characters in the identchars member.
+-3. A command `foo' is dispatched to a method 'do_foo()'; the do_ method
++3. A command 'foo' is dispatched to a method 'do_foo()'; the do_ method
+    is passed a single argument consisting of the remainder of the line.
+ 4. Typing an empty line repeats the last command.  (Actually, it calls the
+-   method `emptyline', which may be overridden in a subclass.)
+-5. There is a predefined `help' method.  Given an argument `topic', it
+-   calls the command `help_topic'.  With no arguments, it lists all topics
++   method 'emptyline', which may be overridden in a subclass.)
++5. There is a predefined 'help' method.  Given an argument 'topic', it
++   calls the command 'help_topic'.  With no arguments, it lists all topics
+    with defined help_ functions, broken into up to three topics; documented
+    commands, miscellaneous help topics, and undocumented commands.
+-6. The command '?' is a synonym for `help'.  The command '!' is a synonym
+-   for `shell', if a do_shell method exists.
++6. The command '?' is a synonym for 'help'.  The command '!' is a synonym
++   for 'shell', if a do_shell method exists.
+ 7. If completion is enabled, completing commands will be done automatically,
+    and completing of commands args is done by calling complete_foo() with
+    arguments text, line, begidx, endidx.  text is string we are matching
+@@ -23,21 +23,21 @@
+    indexes of the text being matched, which could be used to provide
+    different completion depending upon which position the argument is in.
+ 
+-The `default' method may be overridden to intercept commands for which there
++The 'default' method may be overridden to intercept commands for which there
+ is no do_ method.
+ 
+-The `completedefault' method may be overridden to intercept completions for
++The 'completedefault' method may be overridden to intercept completions for
+ commands that have no complete_ method.
+ 
+-The data member `self.ruler' sets the character used to draw separator lines
++The data member 'self.ruler' sets the character used to draw separator lines
+ in the help messages.  If empty, no ruler line is drawn.  It defaults to "=".
+ 
+-If the value of `self.intro' is nonempty when the cmdloop method is called,
++If the value of 'self.intro' is nonempty when the cmdloop method is called,
+ it is printed out on interpreter startup.  This value may be overridden
+ via an optional argument to the cmdloop() method.
+ 
+-The data members `self.doc_header', `self.misc_header', and
+-`self.undoc_header' set the headers used for the help function's
++The data members 'self.doc_header', 'self.misc_header', and
++'self.undoc_header' set the headers used for the help function's
+ listings of documented functions, miscellaneous topics, and undocumented
+ functions respectively.
+ """
+diff --git a/Lib/configparser.py b/Lib/configparser.py
+index 42d0ae1c0b5..1ec23ad3b47 100644
+--- a/Lib/configparser.py
++++ b/Lib/configparser.py
+@@ -957,7 +957,7 @@ def write(self, fp, space_around_delimiters=True):
+                                 self._sections[section].items(), d)
+ 
+     def _write_section(self, fp, section_name, section_items, delimiter, unnamed=False):
+-        """Write a single section to the specified `fp'."""
++        """Write a single section to the specified 'fp'."""
+         if not unnamed:
+             fp.write("[{}]\n".format(section_name))
+         for key, value in section_items:
+diff --git a/Lib/doctest.py b/Lib/doctest.py
+index dd4d62a210a..fecf2e432c9 100644
+--- a/Lib/doctest.py
++++ b/Lib/doctest.py
+@@ -1227,7 +1227,7 @@ class DocTestRunner:
+     `OutputChecker` to the constructor.
+ 
+     The test runner's display output can be controlled in two ways.
+-    First, an output function (`out) can be passed to
++    First, an output function (`out`) can be passed to
+     `TestRunner.run`; this function will be called with strings that
+     should be displayed.  It defaults to `sys.stdout.write`.  If
+     capturing the output is not sufficient, then the display output
+@@ -2734,7 +2734,7 @@ def testsource(module, name):
+     return testsrc
+ 
+ def debug_src(src, pm=False, globs=None):
+-    """Debug a single doctest docstring, in argument `src`'"""
++    """Debug a single doctest docstring, in argument `src`"""
+     testsrc = script_from_examples(src)
+     debug_script(testsrc, pm, globs)
+ 
+diff --git a/Lib/email/_parseaddr.py b/Lib/email/_parseaddr.py
+index 0f1bf8e4253..36625e35ffb 100644
+--- a/Lib/email/_parseaddr.py
++++ b/Lib/email/_parseaddr.py
+@@ -224,7 +224,7 @@ class AddrlistClass:
+     def __init__(self, field):
+         """Initialize a new instance.
+ 
+-        `field' is an unparsed address header field, containing
++        'field' is an unparsed address header field, containing
+         one or more addresses.
+         """
+         self.specials = '()<>@,:;.\"[]'
+@@ -233,7 +233,7 @@ def __init__(self, field):
+         self.CR = '\r\n'
+         self.FWS = self.LWS + self.CR
+         self.atomends = self.specials + self.LWS + self.CR
+-        # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
++        # Note that RFC 2822 now specifies '.' as obs-phrase, meaning that it
+         # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
+         # syntax, so allow dots in phrases.
+         self.phraseends = self.atomends.replace('.', '')
+@@ -423,14 +423,14 @@ def getdomain(self):
+     def getdelimited(self, beginchar, endchars, allowcomments=True):
+         """Parse a header fragment delimited by special characters.
+ 
+-        `beginchar' is the start character for the fragment.
+-        If self is not looking at an instance of `beginchar' then
++        'beginchar' is the start character for the fragment.
++        If self is not looking at an instance of 'beginchar' then
+         getdelimited returns the empty string.
+ 
+-        `endchars' is a sequence of allowable end-delimiting characters.
++        'endchars' is a sequence of allowable end-delimiting characters.
+         Parsing stops when one of these is encountered.
+ 
+-        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
++        If 'allowcomments' is non-zero, embedded RFC 2822 comments are allowed
+         within the parsed fragment.
+         """
+         if self.field[self.pos] != beginchar:
+@@ -474,7 +474,7 @@ def getatom(self, atomends=None):
+ 
+         Optional atomends specifies a different set of end token delimiters
+         (the default is to use self.atomends).  This is used e.g. in
+-        getphraselist() since phrase endings must not include the `.' (which
++        getphraselist() since phrase endings must not include the '.' (which
+         is legal in phrases)."""
+         atomlist = ['']
+         if atomends is None:
+diff --git a/Lib/email/_policybase.py b/Lib/email/_policybase.py
+index c9f0d743090..4b63b97217a 100644
+--- a/Lib/email/_policybase.py
++++ b/Lib/email/_policybase.py
+@@ -150,7 +150,7 @@ class Policy(_PolicyBase, metaclass=abc.ABCMeta):
+                            wrapping is done.  Default is 78.
+ 
+     mangle_from_        -- a flag that, when True escapes From_ lines in the
+-                           body of the message by putting a `>' in front of
++                           body of the message by putting a '>' in front of
+                            them. This is used when the message is being
+                            serialized by a generator. Default: False.
+ 
+diff --git a/Lib/email/base64mime.py b/Lib/email/base64mime.py
+index 4cdf22666e3..d440de95255 100644
+--- a/Lib/email/base64mime.py
++++ b/Lib/email/base64mime.py
+@@ -15,7 +15,7 @@
+ with Base64 encoding.
+ 
+ RFC 2045 defines a method for including character set information in an
+-`encoded-word' in a header.  This method is commonly used for 8-bit real names
++'encoded-word' in a header.  This method is commonly used for 8-bit real names
+ in To:, From:, Cc:, etc. fields, as well as Subject: lines.
+ 
+ This module does not do the line wrapping or end-of-line character conversion
+diff --git a/Lib/email/charset.py b/Lib/email/charset.py
+index 043801107b6..cfd5a0c456e 100644
+--- a/Lib/email/charset.py
++++ b/Lib/email/charset.py
+@@ -175,7 +175,7 @@ class Charset:
+     module expose the following information about a character set:
+ 
+     input_charset: The initial character set specified.  Common aliases
+-                   are converted to their `official' email names (e.g. latin_1
++                   are converted to their 'official' email names (e.g. latin_1
+                    is converted to iso-8859-1).  Defaults to 7-bit us-ascii.
+ 
+     header_encoding: If the character set must be encoded before it can be
+@@ -245,7 +245,7 @@ def __eq__(self, other):
+     def get_body_encoding(self):
+         """Return the content-transfer-encoding used for body encoding.
+ 
+-        This is either the string `quoted-printable' or `base64' depending on
++        This is either the string 'quoted-printable' or 'base64' depending on
+         the encoding used, or it is a function in which case you should call
+         the function with a single argument, the Message object being
+         encoded.  The function should then set the Content-Transfer-Encoding
+diff --git a/Lib/email/generator.py b/Lib/email/generator.py
+index 47b9df8f4e6..42c84aa4da1 100644
+--- a/Lib/email/generator.py
++++ b/Lib/email/generator.py
+@@ -43,7 +43,7 @@ def __init__(self, outfp, mangle_from_=None, maxheaderlen=None, *,
+ 
+         Optional mangle_from_ is a flag that, when True (the default if policy
+         is not set), escapes From_ lines in the body of the message by putting
+-        a `>' in front of them.
++        a '>' in front of them.
+ 
+         Optional maxheaderlen specifies the longest length for a non-continued
+         header.  When a header line is longer (in characters, with tabs
+@@ -76,7 +76,7 @@ def flatten(self, msg, unixfrom=False, linesep=None):
+ 
+         unixfrom is a flag that forces the printing of a Unix From_ delimiter
+         before the first object in the message tree.  If the original message
+-        has no From_ delimiter, a `standard' one is crafted.  By default, this
++        has no From_ delimiter, a 'standard' one is crafted.  By default, this
+         is False to inhibit the printing of any From_ delimiter.
+ 
+         Note that for subobjects, no From_ line is printed.
+@@ -467,7 +467,7 @@ def __init__(self, outfp, mangle_from_=None, maxheaderlen=None, fmt=None, *,
+         argument is allowed.
+ 
+         Walks through all subparts of a message.  If the subpart is of main
+-        type `text', then it prints the decoded payload of the subpart.
++        type 'text', then it prints the decoded payload of the subpart.
+ 
+         Otherwise, fmt is a format string that is used instead of the message
+         payload.  fmt is expanded with the following keywords (in
+diff --git a/Lib/email/header.py b/Lib/email/header.py
+index 984851a7d9a..66a1d46db50 100644
+--- a/Lib/email/header.py
++++ b/Lib/email/header.py
+@@ -192,7 +192,7 @@ def __init__(self, s=None, charset=None,
+ 
+         The maximum line length can be specified explicitly via maxlinelen. For
+         splitting the first line to a shorter value (to account for the field
+-        header which isn't included in s, e.g. `Subject') pass in the name of
++        header which isn't included in s, e.g. 'Subject') pass in the name of
+         the field in header_name.  The default maxlinelen is 78 as recommended
+         by RFC 2822.
+ 
+@@ -276,7 +276,7 @@ def append(self, s, charset=None, errors='strict'):
+         output codec of the charset.  If the string cannot be encoded to the
+         output codec, a UnicodeError will be raised.
+ 
+-        Optional `errors' is passed as the errors argument to the decode
++        Optional 'errors' is passed as the errors argument to the decode
+         call if s is a byte string.
+         """
+         if charset is None:
+@@ -326,7 +326,7 @@ def encode(self, splitchars=';, \t', maxlinelen=None, linesep='\n'):
+ 
+         Optional splitchars is a string containing characters which should be
+         given extra weight by the splitting algorithm during normal header
+-        wrapping.  This is in very rough support of RFC 2822's `higher level
++        wrapping.  This is in very rough support of RFC 2822's 'higher level
+         syntactic breaks':  split points preceded by a splitchar are preferred
+         during line splitting, with the characters preferred in the order in
+         which they appear in the string.  Space and tab may be included in the
+diff --git a/Lib/email/iterators.py b/Lib/email/iterators.py
+index 3410935e38f..2f436aefc23 100644
+--- a/Lib/email/iterators.py
++++ b/Lib/email/iterators.py
+@@ -43,8 +43,8 @@ def body_line_iterator(msg, decode=False):
+ def typed_subpart_iterator(msg, maintype='text', subtype=None):
+     """Iterate over the subparts with a given MIME type.
+ 
+-    Use `maintype' as the main MIME type to match against; this defaults to
+-    "text".  Optional `subtype' is the MIME subtype to match against; if
++    Use 'maintype' as the main MIME type to match against; this defaults to
++    "text".  Optional 'subtype' is the MIME subtype to match against; if
+     omitted, only the main type is matched.
+     """
+     for subpart in msg.walk():
+diff --git a/Lib/email/message.py b/Lib/email/message.py
+index 6b7c3a23777..79f3135d017 100644
+--- a/Lib/email/message.py
++++ b/Lib/email/message.py
+@@ -21,7 +21,7 @@
+ 
+ SEMISPACE = '; '
+ 
+-# Regular expression that matches `special' characters in parameters, the
++# Regular expression that matches 'special' characters in parameters, the
+ # existence of which force quoting of the parameter value.
+ tspecials = re.compile(r'[ \(\)<>@,;:\\"/\[\]\?=]')
+ 
+@@ -141,7 +141,7 @@ class Message:
+     multipart or a message/rfc822), then the payload is a list of Message
+     objects, otherwise it is a string.
+ 
+-    Message objects implement part of the `mapping' interface, which assumes
++    Message objects implement part of the 'mapping' interface, which assumes
+     there is exactly one occurrence of the header per message.  Some headers
+     do in fact appear multiple times (e.g. Received) and for those headers,
+     you must use the explicit API to set or get all the headers.  Not all of
+@@ -601,7 +601,7 @@ def get_content_type(self):
+         """Return the message's content type.
+ 
+         The returned string is coerced to lower case of the form
+-        `maintype/subtype'.  If there was no Content-Type header in the
++        'maintype/subtype'.  If there was no Content-Type header in the
+         message, the default type as given by get_default_type() will be
+         returned.  Since according to RFC 2045, messages always have a default
+         type this will always return a value.
+@@ -624,7 +624,7 @@ def get_content_type(self):
+     def get_content_maintype(self):
+         """Return the message's main content type.
+ 
+-        This is the `maintype' part of the string returned by
++        This is the 'maintype' part of the string returned by
+         get_content_type().
+         """
+         ctype = self.get_content_type()
+@@ -633,14 +633,14 @@ def get_content_maintype(self):
+     def get_content_subtype(self):
+         """Returns the message's sub-content type.
+ 
+-        This is the `subtype' part of the string returned by
++        This is the 'subtype' part of the string returned by
+         get_content_type().
+         """
+         ctype = self.get_content_type()
+         return ctype.split('/')[1]
+ 
+     def get_default_type(self):
+-        """Return the `default' content type.
++        """Return the 'default' content type.
+ 
+         Most messages have a default content type of text/plain, except for
+         messages that are subparts of multipart/digest containers.  Such
+@@ -649,7 +649,7 @@ def get_default_type(self):
+         return self._default_type
+ 
+     def set_default_type(self, ctype):
+-        """Set the `default' content type.
++        """Set the 'default' content type.
+ 
+         ctype should be either "text/plain" or "message/rfc822", although this
+         is not enforced.  The default content type is not stored in the
+@@ -682,8 +682,8 @@ def get_params(self, failobj=None, header='content-type', unquote=True):
+         """Return the message's Content-Type parameters, as a list.
+ 
+         The elements of the returned list are 2-tuples of key/value pairs, as
+-        split on the `=' sign.  The left hand side of the `=' is the key,
+-        while the right hand side is the value.  If there is no `=' sign in
++        split on the '=' sign.  The left hand side of the '=' is the key,
++        while the right hand side is the value.  If there is no '=' sign in
+         the parameter the value is the empty string.  The value is as
+         described in the get_param() method.
+ 
+@@ -843,9 +843,9 @@ def get_filename(self, failobj=None):
+         """Return the filename associated with the payload if present.
+ 
+         The filename is extracted from the Content-Disposition header's
+-        `filename' parameter, and it is unquoted.  If that header is missing
+-        the `filename' parameter, this method falls back to looking for the
+-        `name' parameter.
++        'filename' parameter, and it is unquoted.  If that header is missing
++        the 'filename' parameter, this method falls back to looking for the
++        'name' parameter.
+         """
+         missing = object()
+         filename = self.get_param('filename', missing, 'content-disposition')
+@@ -858,7 +858,7 @@ def get_filename(self, failobj=None):
+     def get_boundary(self, failobj=None):
+         """Return the boundary associated with the payload if present.
+ 
+-        The boundary is extracted from the Content-Type header's `boundary'
++        The boundary is extracted from the Content-Type header's 'boundary'
+         parameter, and it is unquoted.
+         """
+         missing = object()
+diff --git a/Lib/email/mime/multipart.py b/Lib/email/mime/multipart.py
+index 94d81c771a4..47fc218e1ae 100644
+--- a/Lib/email/mime/multipart.py
++++ b/Lib/email/mime/multipart.py
+@@ -21,7 +21,7 @@ def __init__(self, _subtype='mixed', boundary=None, _subparts=None,
+         Content-Type and MIME-Version headers.
+ 
+         _subtype is the subtype of the multipart content type, defaulting to
+-        `mixed'.
++        'mixed'.
+ 
+         boundary is the multipart boundary string.  By default it is
+         calculated as needed.
+diff --git a/Lib/email/parser.py b/Lib/email/parser.py
+index 06d99b17f2f..475aa2b1a66 100644
+--- a/Lib/email/parser.py
++++ b/Lib/email/parser.py
+@@ -22,7 +22,7 @@ def __init__(self, _class=None, *, policy=compat32):
+         textual representation of the message.
+ 
+         The string must be formatted as a block of RFC 2822 headers and header
+-        continuation lines, optionally preceded by a `Unix-from' header.  The
++        continuation lines, optionally preceded by a 'Unix-from' header.  The
+         header block is terminated either by the end of the string or by a
+         blank line.
+ 
+@@ -82,7 +82,7 @@ def __init__(self, *args, **kw):
+         textual representation of the message.
+ 
+         The input must be formatted as a block of RFC 2822 headers and header
+-        continuation lines, optionally preceded by a `Unix-from' header.  The
++        continuation lines, optionally preceded by a 'Unix-from' header.  The
+         header block is terminated either by the end of the input or by a
+         blank line.
+ 
+diff --git a/Lib/email/quoprimime.py b/Lib/email/quoprimime.py
+index 27fcbb5a26e..500bbc51517 100644
+--- a/Lib/email/quoprimime.py
++++ b/Lib/email/quoprimime.py
+@@ -5,7 +5,7 @@
+ """Quoted-printable content transfer encoding per RFCs 2045-2047.
+ 
+ This module handles the content transfer encoding method defined in RFC 2045
+-to encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to
++to encode US ASCII-like 8-bit data called 'quoted-printable'.  It is used to
+ safely encode text that is in a character set similar to the 7-bit US ASCII
+ character set, but that includes some 8-bit characters that are normally not
+ allowed in email bodies or headers.
+@@ -17,7 +17,7 @@
+ with quoted-printable encoding.
+ 
+ RFC 2045 defines a method for including character set information in an
+-`encoded-word' in a header.  This method is commonly used for 8-bit real names
++'encoded-word' in a header.  This method is commonly used for 8-bit real names
+ in To:/From:/Cc: etc. fields, as well as Subject: lines.
+ 
+ This module does not do the line wrapping or end-of-line character
+@@ -127,7 +127,7 @@ def quote(c):
+ def header_encode(header_bytes, charset='iso-8859-1'):
+     """Encode a single header line with quoted-printable (like) encoding.
+ 
+-    Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but
++    Defined in RFC 2045, this 'Q' encoding is similar to quoted-printable, but
+     used specifically for email header fields to allow charsets with mostly 7
+     bit characters (and some 8 bit) to remain more or less readable in non-RFC
+     2045 aware mail clients.
+@@ -290,7 +290,7 @@ def _unquote_match(match):
+ 
+ # Header decoding is done a bit differently
+ def header_decode(s):
+-    """Decode a string encoded with RFC 2045 MIME header `Q' encoding.
++    """Decode a string encoded with RFC 2045 MIME header 'Q' encoding.
+ 
+     This function does not parse a full MIME header value encoded with
+     quoted-printable (like =?iso-8859-1?q?Hello_World?=) -- please use
+diff --git a/Lib/ftplib.py b/Lib/ftplib.py
+index 10c5d1ea08a..50771e8c17c 100644
+--- a/Lib/ftplib.py
++++ b/Lib/ftplib.py
+@@ -343,7 +343,7 @@ def ntransfercmd(self, cmd, rest=None):
+         connection and the expected size of the transfer.  The
+         expected size may be None if it could not be determined.
+ 
+-        Optional `rest' argument can be a string that is sent as the
++        Optional 'rest' argument can be a string that is sent as the
+         argument to a REST command.  This is essentially a server
+         marker used to tell the server to skip over any data up to the
+         given marker.
+diff --git a/Lib/getopt.py b/Lib/getopt.py
+index 5419d77f5d7..e5fd04fe12a 100644
+--- a/Lib/getopt.py
++++ b/Lib/getopt.py
+@@ -2,8 +2,8 @@
+ 
+ This module helps scripts to parse the command line arguments in
+ sys.argv.  It supports the same conventions as the Unix getopt()
+-function (including the special meanings of arguments of the form `-'
+-and `--').  Long options similar to those supported by GNU software
++function (including the special meanings of arguments of the form '-'
++and '--').  Long options similar to those supported by GNU software
+ may be used as well via an optional third argument.  This module
+ provides two functions and an exception:
+ 
+@@ -105,7 +105,7 @@ def gnu_getopt(args, shortopts, longopts = []):
+     processing options as soon as a non-option argument is
+     encountered.
+ 
+-    If the first character of the option string is `+', or if the
++    If the first character of the option string is '+', or if the
+     environment variable POSIXLY_CORRECT is set, then option
+     processing stops as soon as a non-option argument is encountered.
+ 
+diff --git a/Lib/heapq.py b/Lib/heapq.py
+index 2fd9d1ff4bf..c53cb5537db 100644
+--- a/Lib/heapq.py
++++ b/Lib/heapq.py
+@@ -42,7 +42,7 @@
+ property of a heap is that a[0] is always its smallest element.
+ 
+ The strange invariant above is meant to be an efficient memory
+-representation for a tournament.  The numbers below are `k', not a[k]:
++representation for a tournament.  The numbers below are 'k', not a[k]:
+ 
+                                    0
+ 
+@@ -55,7 +55,7 @@
+     15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30
+ 
+ 
+-In the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In
++In the tree above, each cell 'k' is topping '2*k+1' and '2*k+2'.  In
+ a usual binary tournament we see in sports, each cell is the winner
+ over the two cells it tops, and we can trace the winner down the tree
+ to see all opponents s/he had.  However, in many computer applications
+@@ -110,7 +110,7 @@
+ effective!
+ 
+ In a word, heaps are useful memory structures to know.  I use them in
+-a few applications, and I think it is good to keep a `heap' module
++a few applications, and I think it is good to keep a 'heap' module
+ around. :-)
+ 
+ --------------------
+diff --git a/Lib/http/client.py b/Lib/http/client.py
+index fb29923d942..33a858d34ae 100644
+--- a/Lib/http/client.py
++++ b/Lib/http/client.py
+@@ -1027,7 +1027,7 @@ def close(self):
+                 response.close()
+ 
+     def send(self, data):
+-        """Send `data' to the server.
++        """Send 'data' to the server.
+         ``data`` can be a string object, a bytes object, an array object, a
+         file-like object that supports a .read() method, or an iterable object.
+         """
+@@ -1139,10 +1139,10 @@ def putrequest(self, method, url, skip_host=False,
+                    skip_accept_encoding=False):
+         """Send a request to the server.
+ 
+-        `method' specifies an HTTP request method, e.g. 'GET'.
+-        `url' specifies the object being requested, e.g. '/index.html'.
+-        `skip_host' if True does not add automatically a 'Host:' header
+-        `skip_accept_encoding' if True does not add automatically an
++        'method' specifies an HTTP request method, e.g. 'GET'.
++        'url' specifies the object being requested, e.g. '/index.html'.
++        'skip_host' if True does not add automatically a 'Host:' header
++        'skip_accept_encoding' if True does not add automatically an
+            'Accept-Encoding:' header
+         """
+ 
+diff --git a/Lib/http/cookiejar.py b/Lib/http/cookiejar.py
+index bd89370e168..fb0fd2e9799 100644
+--- a/Lib/http/cookiejar.py
++++ b/Lib/http/cookiejar.py
+@@ -1986,7 +1986,7 @@ class MozillaCookieJar(FileCookieJar):
+ 
+     This class differs from CookieJar only in the format it uses to save and
+     load cookies to and from a file.  This class uses the Mozilla/Netscape
+-    `cookies.txt' format.  curl and lynx use this file format, too.
++    'cookies.txt' format.  curl and lynx use this file format, too.
+ 
+     Don't expect cookies saved while the browser is running to be noticed by
+     the browser (in fact, Mozilla on unix will overwrite your saved cookies if
+diff --git a/Lib/imaplib.py b/Lib/imaplib.py
+index e337fe64710..db708580a0a 100644
+--- a/Lib/imaplib.py
++++ b/Lib/imaplib.py
+@@ -242,7 +242,7 @@ def _connect(self):
+         if __debug__:
+             self._cmd_log_len = 10
+             self._cmd_log_idx = 0
+-            self._cmd_log = {}           # Last `_cmd_log_len' interactions
++            self._cmd_log = {}           # Last '_cmd_log_len' interactions
+             if self.debug >= 1:
+                 self._mesg('imaplib version %s' % __version__)
+                 self._mesg('new IMAP4 connection, tag=%s' % self.tagpre)
+@@ -405,7 +405,7 @@ def append(self, mailbox, flags, date_time, message):
+ 
+         (typ, [data]) = <instance>.append(mailbox, flags, date_time, message)
+ 
+-                All args except `message' can be None.
++                All args except 'message' can be None.
+         """
+         name = 'APPEND'
+         if not mailbox:
+@@ -936,7 +936,7 @@ def xatom(self, name, *args):
+ 
+         (typ, [data]) = <instance>.xatom(name, arg, ...)
+ 
+-        Returns response appropriate to extension command `name'.
++        Returns response appropriate to extension command 'name'.
+         """
+         name = name.upper()
+         #if not name in self.capabilities:      # Let the server decide!
+@@ -1176,7 +1176,7 @@ def _get_tagged_response(self, tag, expect_bye=False):
+             # Some have reported "unexpected response" exceptions.
+             # Note that ignoring them here causes loops.
+             # Instead, send me details of the unexpected response and
+-            # I'll update the code in `_get_response()'.
++            # I'll update the code in '_get_response()'.
+ 
+             try:
+                 self._get_response()
+@@ -1268,7 +1268,7 @@ def _dump_ur(self, untagged_resp_dict):
+             self._mesg('untagged responses dump:' + '\n\t\t'.join(items))
+ 
+         def _log(self, line):
+-            # Keep log of last `_cmd_log_len' interactions for debugging.
++            # Keep log of last '_cmd_log_len' interactions for debugging.
+             self._cmd_log[self._cmd_log_idx] = (line, time.time())
+             self._cmd_log_idx += 1
+             if self._cmd_log_idx >= self._cmd_log_len:
+diff --git a/Lib/mimetypes.py b/Lib/mimetypes.py
+index 8604000ed77..bacee8ba164 100644
+--- a/Lib/mimetypes.py
++++ b/Lib/mimetypes.py
+@@ -116,7 +116,7 @@ def guess_type(self, url, strict=True):
+         mapped to '.tar.gz'.  (This is table-driven too, using the
+         dictionary suffix_map.)
+ 
+-        Optional `strict' argument when False adds a bunch of commonly found,
++        Optional 'strict' argument when False adds a bunch of commonly found,
+         but non-standard types.
+         """
+         # TODO: Deprecate accepting file paths (in particular path-like objects).
+@@ -185,9 +185,9 @@ def guess_all_extensions(self, type, strict=True):
+         Return value is a list of strings giving the possible filename
+         extensions, including the leading dot ('.').  The extension is not
+         guaranteed to have been associated with any particular data stream,
+-        but would be mapped to the MIME type `type' by guess_type().
++        but would be mapped to the MIME type 'type' by guess_type().
+ 
+-        Optional `strict' argument when false adds a bunch of commonly found,
++        Optional 'strict' argument when false adds a bunch of commonly found,
+         but non-standard types.
+         """
+         type = type.lower()
+@@ -204,11 +204,11 @@ def guess_extension(self, type, strict=True):
+         Return value is a string giving a filename extension,
+         including the leading dot ('.').  The extension is not
+         guaranteed to have been associated with any particular data
+-        stream, but would be mapped to the MIME type `type' by
+-        guess_type().  If no extension can be guessed for `type', None
++        stream, but would be mapped to the MIME type 'type' by
++        guess_type().  If no extension can be guessed for 'type', None
+         is returned.
+ 
+-        Optional `strict' argument when false adds a bunch of commonly found,
++        Optional 'strict' argument when false adds a bunch of commonly found,
+         but non-standard types.
+         """
+         extensions = self.guess_all_extensions(type, strict)
+@@ -314,7 +314,7 @@ def guess_type(url, strict=True):
+     to ".tar.gz".  (This is table-driven too, using the dictionary
+     suffix_map).
+ 
+-    Optional `strict' argument when false adds a bunch of commonly found, but
++    Optional 'strict' argument when false adds a bunch of commonly found, but
+     non-standard types.
+     """
+     if _db is None:
+@@ -338,11 +338,11 @@ def guess_all_extensions(type, strict=True):
+     Return value is a list of strings giving the possible filename
+     extensions, including the leading dot ('.').  The extension is not
+     guaranteed to have been associated with any particular data
+-    stream, but would be mapped to the MIME type `type' by
+-    guess_type().  If no extension can be guessed for `type', None
++    stream, but would be mapped to the MIME type 'type' by
++    guess_type().  If no extension can be guessed for 'type', None
+     is returned.
+ 
+-    Optional `strict' argument when false adds a bunch of commonly found,
++    Optional 'strict' argument when false adds a bunch of commonly found,
+     but non-standard types.
+     """
+     if _db is None:
+@@ -355,10 +355,10 @@ def guess_extension(type, strict=True):
+     Return value is a string giving a filename extension, including the
+     leading dot ('.').  The extension is not guaranteed to have been
+     associated with any particular data stream, but would be mapped to the
+-    MIME type `type' by guess_type().  If no extension can be guessed for
+-    `type', None is returned.
++    MIME type 'type' by guess_type().  If no extension can be guessed for
++    'type', None is returned.
+ 
+-    Optional `strict' argument when false adds a bunch of commonly found,
++    Optional 'strict' argument when false adds a bunch of commonly found,
+     but non-standard types.
+     """
+     if _db is None:
+diff --git a/Lib/smtplib.py b/Lib/smtplib.py
+index b3cc68a789a..75163f75781 100755
+--- a/Lib/smtplib.py
++++ b/Lib/smtplib.py
+@@ -105,7 +105,7 @@ class SMTPSenderRefused(SMTPResponseException):
+     """Sender address refused.
+ 
+     In addition to the attributes set by on all SMTPResponseException
+-    exceptions, this sets `sender' to the string that the SMTP refused.
++    exceptions, this sets 'sender' to the string that the SMTP refused.
+     """
+ 
+     def __init__(self, code, msg, sender):
+@@ -315,7 +315,7 @@ def _get_socket(self, host, port, timeout):
+     def connect(self, host='localhost', port=0, source_address=None):
+         """Connect to a host on a given port.
+ 
+-        If the hostname ends with a colon (`:') followed by a number, and
++        If the hostname ends with a colon (':') followed by a number, and
+         there is no port specified, that suffix will be stripped off and the
+         number interpreted as the port number to use.
+ 
+@@ -346,7 +346,7 @@ def connect(self, host='localhost', port=0, source_address=None):
+         return (code, msg)
+ 
+     def send(self, s):
+-        """Send `s' to the server."""
++        """Send 's' to the server."""
+         if self.debuglevel > 0:
+             self._print_debug('send:', repr(s))
+         if self.sock:
+diff --git a/Lib/tarfile.py b/Lib/tarfile.py
+index ea036193411..2d1e81b646f 100755
+--- a/Lib/tarfile.py
++++ b/Lib/tarfile.py
+@@ -1220,7 +1220,7 @@ def _create_pax_generic_header(cls, pax_headers, type, encoding):
+         for keyword, value in pax_headers.items():
+             keyword = keyword.encode("utf-8")
+             if binary:
+-                # Try to restore the original byte representation of `value'.
++                # Try to restore the original byte representation of 'value'.
+                 # Needless to say, that the encoding must match the string.
+                 value = value.encode(encoding, "surrogateescape")
+             else:
+@@ -1696,13 +1696,13 @@ def __init__(self, name=None, mode="r", fileobj=None, format=None,
+             tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,
+             errors="surrogateescape", pax_headers=None, debug=None,
+             errorlevel=None, copybufsize=None, stream=False):
+-        """Open an (uncompressed) tar archive `name'. `mode' is either 'r' to
++        """Open an (uncompressed) tar archive 'name'. 'mode' is either 'r' to
+            read from an existing archive, 'a' to append data to an existing
+-           file or 'w' to create a new file overwriting an existing one. `mode'
++           file or 'w' to create a new file overwriting an existing one. 'mode'
+            defaults to 'r'.
+-           If `fileobj' is given, it is used for reading or writing data. If it
+-           can be determined, `mode' is overridden by `fileobj's mode.
+-           `fileobj' is not closed, when TarFile is closed.
++           If 'fileobj' is given, it is used for reading or writing data. If it
++           can be determined, 'mode' is overridden by 'fileobj's mode.
++           'fileobj' is not closed, when TarFile is closed.
+         """
+         modes = {"r": "rb", "a": "r+b", "w": "wb", "x": "xb"}
+         if mode not in modes:
+@@ -2031,7 +2031,7 @@ def close(self):
+                 self.fileobj.close()
+ 
+     def getmember(self, name):
+-        """Return a TarInfo object for member `name'. If `name' can not be
++        """Return a TarInfo object for member 'name'. If 'name' can not be
+            found in the archive, KeyError is raised. If a member occurs more
+            than once in the archive, its last occurrence is assumed to be the
+            most up-to-date version.
+@@ -2059,9 +2059,9 @@ def getnames(self):
+ 
+     def gettarinfo(self, name=None, arcname=None, fileobj=None):
+         """Create a TarInfo object from the result of os.stat or equivalent
+-           on an existing file. The file is either named by `name', or
+-           specified as a file object `fileobj' with a file descriptor. If
+-           given, `arcname' specifies an alternative name for the file in the
++           on an existing file. The file is either named by 'name', or
++           specified as a file object 'fileobj' with a file descriptor. If
++           given, 'arcname' specifies an alternative name for the file in the
+            archive, otherwise, the name is taken from the 'name' attribute of
+            'fileobj', or the 'name' argument. The name should be a text
+            string.
+@@ -2157,9 +2157,9 @@ def gettarinfo(self, name=None, arcname=None, fileobj=None):
+         return tarinfo
+ 
+     def list(self, verbose=True, *, members=None):
+-        """Print a table of contents to sys.stdout. If `verbose' is False, only
+-           the names of the members are printed. If it is True, an `ls -l'-like
+-           output is produced. `members' is optional and must be a subset of the
++        """Print a table of contents to sys.stdout. If 'verbose' is False, only
++           the names of the members are printed. If it is True, an 'ls -l'-like
++           output is produced. 'members' is optional and must be a subset of the
+            list returned by getmembers().
+         """
+         # Convert tarinfo type to stat type.
+@@ -2200,11 +2200,11 @@ def list(self, verbose=True, *, members=None):
+             print()
+ 
+     def add(self, name, arcname=None, recursive=True, *, filter=None):
+-        """Add the file `name' to the archive. `name' may be any type of file
+-           (directory, fifo, symbolic link, etc.). If given, `arcname'
++        """Add the file 'name' to the archive. 'name' may be any type of file
++           (directory, fifo, symbolic link, etc.). If given, 'arcname'
+            specifies an alternative name for the file in the archive.
+            Directories are added recursively by default. This can be avoided by
+-           setting `recursive' to False. `filter' is a function
++           setting 'recursive' to False. 'filter' is a function
+            that expects a TarInfo object argument and returns the changed
+            TarInfo object, if it returns None the TarInfo object will be
+            excluded from the archive.
+@@ -2251,8 +2251,8 @@ def add(self, name, arcname=None, recursive=True, *, filter=None):
+             self.addfile(tarinfo)
+ 
+     def addfile(self, tarinfo, fileobj=None):
+-        """Add the TarInfo object `tarinfo' to the archive. If `tarinfo' represents
+-           a non zero-size regular file, the `fileobj' argument should be a binary file,
++        """Add the TarInfo object 'tarinfo' to the archive. If 'tarinfo' represents
++           a non zero-size regular file, the 'fileobj' argument should be a binary file,
+            and tarinfo.size bytes are read from it and added to the archive.
+            You can create TarInfo objects directly, or by using gettarinfo().
+         """
+@@ -2306,12 +2306,12 @@ def extractall(self, path=".", members=None, *, numeric_owner=False,
+                    filter=None):
+         """Extract all members from the archive to the current working
+            directory and set owner, modification time and permissions on
+-           directories afterwards. `path' specifies a different directory
+-           to extract to. `members' is optional and must be a subset of the
+-           list returned by getmembers(). If `numeric_owner` is True, only
++           directories afterwards. 'path' specifies a different directory
++           to extract to. 'members' is optional and must be a subset of the
++           list returned by getmembers(). If 'numeric_owner' is True, only
+            the numbers for user/group names are used and not the names.
+ 
+-           The `filter` function will be called on each member just
++           The 'filter' function will be called on each member just
+            before extraction.
+            It can return a changed TarInfo or None to skip the member.
+            String names of common filters are accepted.
+@@ -2351,13 +2351,13 @@ def extract(self, member, path="", set_attrs=True, *, numeric_owner=False,
+                 filter=None):
+         """Extract a member from the archive to the current working directory,
+            using its full name. Its file information is extracted as accurately
+-           as possible. `member' may be a filename or a TarInfo object. You can
+-           specify a different directory using `path'. File attributes (owner,
+-           mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`
++           as possible. 'member' may be a filename or a TarInfo object. You can
++           specify a different directory using 'path'. File attributes (owner,
++           mtime, mode) are set unless 'set_attrs' is False. If 'numeric_owner'
+            is True, only the numbers for user/group names are used and not
+            the names.
+ 
+-           The `filter` function will be called before extraction.
++           The 'filter' function will be called before extraction.
+            It can return a changed TarInfo or None to skip the member.
+            String names of common filters are accepted.
+         """
+@@ -2422,10 +2422,10 @@ def _handle_fatal_error(self, e):
+             self._dbg(1, "tarfile: %s %s" % (type(e).__name__, e))
+ 
+     def extractfile(self, member):
+-        """Extract a member from the archive as a file object. `member' may be
+-           a filename or a TarInfo object. If `member' is a regular file or
++        """Extract a member from the archive as a file object. 'member' may be
++           a filename or a TarInfo object. If 'member' is a regular file or
+            a link, an io.BufferedReader object is returned. For all other
+-           existing members, None is returned. If `member' does not appear
++           existing members, None is returned. If 'member' does not appear
+            in the archive, KeyError is raised.
+         """
+         self._check("r")
+@@ -2623,7 +2623,7 @@ def chown(self, tarinfo, targetpath, numeric_owner):
+                 else:
+                     os.chown(targetpath, u, g)
+             except (OSError, OverflowError) as e:
+-                # OverflowError can be raised if an ID doesn't fit in `id_t`
++                # OverflowError can be raised if an ID doesn't fit in 'id_t'
+                 raise ExtractError("could not change owner") from e
+ 
+     def chmod(self, tarinfo, targetpath):
+diff --git a/Lib/test/support/smtpd.py b/Lib/test/support/smtpd.py
+index 6052232ec2b..c2e17cad422 100755
+--- a/Lib/test/support/smtpd.py
++++ b/Lib/test/support/smtpd.py
+@@ -7,7 +7,7 @@
+ 
+     --nosetuid
+     -n
+-        This program generally tries to setuid `nobody', unless this flag is
++        This program generally tries to setuid 'nobody', unless this flag is
+         set.  The setuid call will fail if this program is not run as root (in
+         which case, use this flag).
+ 
+@@ -17,7 +17,7 @@
+ 
+     --class classname
+     -c classname
+-        Use `classname' as the concrete SMTP proxy class.  Uses `PureProxy' by
++        Use 'classname' as the concrete SMTP proxy class.  Uses 'PureProxy' by
+         default.
+ 
+     --size limit
+@@ -39,8 +39,8 @@
+ 
+ Version: %(__version__)s
+ 
+-If localhost is not given then `localhost' is used, and if localport is not
+-given then 8025 is used.  If remotehost is not given then `localhost' is used,
++If localhost is not given then 'localhost' is used, and if localport is not
++given then 8025 is used.  If remotehost is not given then 'localhost' is used,
+ and if remoteport is not given, then 25 is used.
+ """
+ 
+@@ -672,9 +672,9 @@ def process_message(self, peer, mailfrom, rcpttos, data, **kwargs):
+         message to.
+ 
+         data is a string containing the entire full text of the message,
+-        headers (if supplied) and all.  It has been `de-transparencied'
++        headers (if supplied) and all.  It has been 'de-transparencied'
+         according to RFC 821, Section 4.5.2.  In other words, a line
+-        containing a `.' followed by other text has had the leading dot
++        containing a '.' followed by other text has had the leading dot
+         removed.
+ 
+         kwargs is a dictionary containing additional information.  It is
+@@ -685,7 +685,7 @@ def process_message(self, peer, mailfrom, rcpttos, data, **kwargs):
+                             ['BODY=8BITMIME', 'SMTPUTF8'].
+             'rcpt_options': same, for the rcpt command.
+ 
+-        This function should return None for a normal `250 Ok' response;
++        This function should return None for a normal '250 Ok' response;
+         otherwise, it should return the desired response string in RFC 821
+         format.
+ 
+diff --git a/Lib/test/test_asyncio/test_locks.py b/Lib/test/test_asyncio/test_locks.py
+index a0884bffe6b..c961dadff9f 100644
+--- a/Lib/test/test_asyncio/test_locks.py
++++ b/Lib/test/test_asyncio/test_locks.py
+@@ -1481,7 +1481,7 @@ async def coro():
+                 # wait again only for rewait tasks
+                 await barrier.wait()
+             else:
+-                # wait for end of draining state`
++                # wait for end of draining state
+                 await barrier_nowaiting.wait()
+                 # wait for other waiting tasks
+                 await barrier.wait()
+@@ -1780,7 +1780,7 @@ async def coro():
+         self.assertEqual(barrier.n_waiting, 0)
+ 
+     async def test_abort_barrier_when_exception_then_resetting(self):
+-        # test from threading.Barrier: see `lock_tests.test_abort_and_reset``
++        # test from threading.Barrier: see `lock_tests.test_abort_and_reset`
+         barrier1 = asyncio.Barrier(self.N)
+         barrier2 = asyncio.Barrier(self.N)
+         results1 = []
+diff --git a/Lib/trace.py b/Lib/trace.py
+index 64fc8037e35..8550475e3a7 100755
+--- a/Lib/trace.py
++++ b/Lib/trace.py
+@@ -402,7 +402,7 @@ def __init__(self, count=1, trace=1, countfuncs=0, countcallers=0,
+         @param countfuncs true iff it should just output a list of
+                      (filename, modulename, funcname,) for functions
+                      that were called at least once;  This overrides
+-                     `count' and `trace'
++                     'count' and 'trace'
+         @param ignoremods a list of the names of modules to ignore
+         @param ignoredirs a list of the names of directories to ignore
+                      all of the (recursive) contents of
+@@ -534,7 +534,7 @@ def globaltrace_countfuncs(self, frame, why, arg):
+     def globaltrace_lt(self, frame, why, arg):
+         """Handler for call events.
+ 
+-        If the code block being entered is to be ignored, returns `None',
++        If the code block being entered is to be ignored, returns 'None',
+         else returns self.localtrace.
+         """
+         if why == 'call':
+diff --git a/Lib/unittest/mock.py b/Lib/unittest/mock.py
+index 495a666eddb..e971def7e43 100644
+--- a/Lib/unittest/mock.py
++++ b/Lib/unittest/mock.py
+@@ -1764,7 +1764,7 @@ def patch(
+     the patch is undone.
+ 
+     If `new` is omitted, then the target is replaced with an
+-    `AsyncMock if the patched object is an async function or a
++    `AsyncMock` if the patched object is an async function or a
+     `MagicMock` otherwise. If `patch` is used as a decorator and `new` is
+     omitted, the created mock is passed in as an extra argument to the
+     decorated function. If `patch` is used as a context manager the created
+diff --git a/Lib/wsgiref/headers.py b/Lib/wsgiref/headers.py
+index fab851c5a44..05d2ba4c664 100644
+--- a/Lib/wsgiref/headers.py
++++ b/Lib/wsgiref/headers.py
+@@ -5,7 +5,7 @@
+ written by Barry Warsaw.
+ """
+ 
+-# Regular expression that matches `special' characters in parameters, the
++# Regular expression that matches 'special' characters in parameters, the
+ # existence of which force quoting of the parameter value.
+ import re
+ tspecials = re.compile(r'[ \(\)<>@,;:\\"/\[\]\?=]')
+diff --git a/Lib/zipfile/__init__.py b/Lib/zipfile/__init__.py
+index 82e307f78e8..c93580558ae 100644
+--- a/Lib/zipfile/__init__.py
++++ b/Lib/zipfile/__init__.py
+@@ -1750,8 +1750,8 @@ def _open_to_write(self, zinfo, force_zip64=False):
+     def extract(self, member, path=None, pwd=None):
+         """Extract a member from the archive to the current working directory,
+            using its full name. Its file information is extracted as accurately
+-           as possible. `member' may be a filename or a ZipInfo object. You can
+-           specify a different directory using `path'. You can specify the
++           as possible. 'member' may be a filename or a ZipInfo object. You can
++           specify a different directory using 'path'. You can specify the
+            password to decrypt the file using 'pwd'.
+         """
+         if path is None:
+@@ -1763,8 +1763,8 @@ def extract(self, member, path=None, pwd=None):
+ 
+     def extractall(self, path=None, members=None, pwd=None):
+         """Extract all members from the archive to the current working
+-           directory. `path' specifies a different directory to extract to.
+-           `members' is optional and must be a subset of the list returned
++           directory. 'path' specifies a different directory to extract to.
++           'members' is optional and must be a subset of the list returned
+            by namelist(). You can specify the password to decrypt all files
+            using 'pwd'.
+         """
+diff --git a/Modules/_heapqmodule.c b/Modules/_heapqmodule.c
+index 695ce22f804..80fe9cff985 100644
+--- a/Modules/_heapqmodule.c
++++ b/Modules/_heapqmodule.c
+@@ -585,7 +585,7 @@ non-existing elements are considered to be infinite.  The interesting\n\
+ property of a heap is that a[0] is always its smallest element.\n"
+ "\n\
+ The strange invariant above is meant to be an efficient memory\n\
+-representation for a tournament.  The numbers below are `k', not a[k]:\n\
++representation for a tournament.  The numbers below are 'k', not a[k]:\n\
+ \n\
+                                    0\n\
+ \n\
+@@ -598,7 +598,7 @@ representation for a tournament.  The numbers below are `k', not a[k]:\n\
+     15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\
+ \n\
+ \n\
+-In the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\n\
++In the tree above, each cell 'k' is topping '2*k+1' and '2*k+2'.  In\n\
+ a usual binary tournament we see in sports, each cell is the winner\n\
+ over the two cells it tops, and we can trace the winner down the tree\n\
+ to see all opponents s/he had.  However, in many computer applications\n\
+@@ -653,7 +653,7 @@ vanishes, you switch heaps and start a new run.  Clever and quite\n\
+ effective!\n\
+ \n\
+ In a word, heaps are useful memory structures to know.  I use them in\n\
+-a few applications, and I think it is good to keep a `heap' module\n\
++a few applications, and I think it is good to keep a 'heap' module\n\
+ around. :-)\n"
+ "\n\
+ --------------------\n\
+diff --git a/Modules/_interpretersmodule.c b/Modules/_interpretersmodule.c
+index c968b33939c..726522c893b 100644
+--- a/Modules/_interpretersmodule.c
++++ b/Modules/_interpretersmodule.c
+@@ -665,7 +665,7 @@ Create a new interpreter and return a unique generated ID.\n\
+ The caller is responsible for destroying the interpreter before exiting,\n\
+ typically by using _interpreters.destroy().  This can be managed \n\
+ automatically by passing \"reqrefs=True\" and then using _incref() and\n\
+-_decref()` appropriately.\n\
++_decref() appropriately.\n\
+ \n\
+ \"config\" must be a valid interpreter config or the name of a\n\
+ predefined config (\"isolated\" or \"legacy\").  The default\n\
+diff --git a/Modules/cjkcodecs/clinic/multibytecodec.c.h b/Modules/cjkcodecs/clinic/multibytecodec.c.h
+index b5639d5cf10..73edd5c3b25 100644
+--- a/Modules/cjkcodecs/clinic/multibytecodec.c.h
++++ b/Modules/cjkcodecs/clinic/multibytecodec.c.h
+@@ -12,7 +12,7 @@ PyDoc_STRVAR(_multibytecodec_MultibyteCodec_encode__doc__,
+ "encode($self, /, input, errors=None)\n"
+ "--\n"
+ "\n"
+-"Return an encoded string version of `input\'.\n"
++"Return an encoded string version of \'input\'.\n"
+ "\n"
+ "\'errors\' may be given to set a different error handling scheme. Default is\n"
+ "\'strict\' meaning that encoding errors raise a UnicodeEncodeError. Other possible\n"
+@@ -682,4 +682,4 @@ PyDoc_STRVAR(_multibytecodec___create_codec__doc__,
+ 
+ #define _MULTIBYTECODEC___CREATE_CODEC_METHODDEF    \
+     {"__create_codec", (PyCFunction)_multibytecodec___create_codec, METH_O, _multibytecodec___create_codec__doc__},
+-/*[clinic end generated code: output=ee767a6d93c7108a input=a9049054013a1b77]*/
++/*[clinic end generated code: output=f09052c5a28cc6e6 input=a9049054013a1b77]*/
+diff --git a/Modules/cjkcodecs/multibytecodec.c b/Modules/cjkcodecs/multibytecodec.c
+index 1c671adb4ff..373518673dd 100644
+--- a/Modules/cjkcodecs/multibytecodec.c
++++ b/Modules/cjkcodecs/multibytecodec.c
+@@ -574,7 +574,7 @@ _multibytecodec.MultibyteCodec.encode
+   input: object
+   errors: str(accept={str, NoneType}) = None
+ 
+-Return an encoded string version of `input'.
++Return an encoded string version of 'input'.
+ 
+ 'errors' may be given to set a different error handling scheme. Default is
+ 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible
+@@ -586,7 +586,7 @@ static PyObject *
+ _multibytecodec_MultibyteCodec_encode_impl(MultibyteCodecObject *self,
+                                            PyObject *input,
+                                            const char *errors)
+-/*[clinic end generated code: output=7b26652045ba56a9 input=606d0e128a577bae]*/
++/*[clinic end generated code: output=7b26652045ba56a9 input=2841745b95ed338f]*/
+ {
+     MultibyteCodec_State state;
+     PyObject *errorcb, *r, *ucvt;
+diff --git a/Modules/clinic/pyexpat.c.h b/Modules/clinic/pyexpat.c.h
+index 03b74ba5715..682d8481a2a 100644
+--- a/Modules/clinic/pyexpat.c.h
++++ b/Modules/clinic/pyexpat.c.h
+@@ -61,7 +61,7 @@ PyDoc_STRVAR(pyexpat_xmlparser_Parse__doc__,
+ "\n"
+ "Parse XML data.\n"
+ "\n"
+-"`isfinal\' should be true at end of input.");
++"\'isfinal\' should be true at end of input.");
+ 
+ #define PYEXPAT_XMLPARSER_PARSE_METHODDEF    \
+     {"Parse", _PyCFunction_CAST(pyexpat_xmlparser_Parse), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, pyexpat_xmlparser_Parse__doc__},
+@@ -545,4 +545,4 @@ exit:
+ #ifndef PYEXPAT_XMLPARSER_USEFOREIGNDTD_METHODDEF
+     #define PYEXPAT_XMLPARSER_USEFOREIGNDTD_METHODDEF
+ #endif /* !defined(PYEXPAT_XMLPARSER_USEFOREIGNDTD_METHODDEF) */
+-/*[clinic end generated code: output=729eafd7abf72a57 input=a9049054013a1b77]*/
++/*[clinic end generated code: output=9f1e9a7192d29976 input=a9049054013a1b77]*/
+diff --git a/Modules/pyexpat.c b/Modules/pyexpat.c
+index e131389805b..cf7714e7656 100644
+--- a/Modules/pyexpat.c
++++ b/Modules/pyexpat.c
+@@ -754,13 +754,13 @@ pyexpat.xmlparser.Parse
+ 
+ Parse XML data.
+ 
+-`isfinal' should be true at end of input.
++'isfinal' should be true at end of input.
+ [clinic start generated code]*/
+ 
+ static PyObject *
+ pyexpat_xmlparser_Parse_impl(xmlparseobject *self, PyTypeObject *cls,
+                              PyObject *data, int isfinal)
+-/*[clinic end generated code: output=8faffe07fe1f862a input=d0eb2a69fab3b9f1]*/
++/*[clinic end generated code: output=8faffe07fe1f862a input=053e0f047e55c05a]*/
+ {
+     const char *s;
+     Py_ssize_t slen;
+diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
+index 32cb9966ff1..86867dfe436 100644
+--- a/Objects/bytesobject.c
++++ b/Objects/bytesobject.c
+@@ -52,25 +52,25 @@ static inline PyObject* bytes_get_empty(void)
+ 
+ 
+ /*
+-   For PyBytes_FromString(), the parameter `str' points to a null-terminated
+-   string containing exactly `size' bytes.
++   For PyBytes_FromString(), the parameter 'str' points to a null-terminated
++   string containing exactly 'size' bytes.
+ 
+-   For PyBytes_FromStringAndSize(), the parameter `str' is
+-   either NULL or else points to a string containing at least `size' bytes.
+-   For PyBytes_FromStringAndSize(), the string in the `str' parameter does
++   For PyBytes_FromStringAndSize(), the parameter 'str' is
++   either NULL or else points to a string containing at least 'size' bytes.
++   For PyBytes_FromStringAndSize(), the string in the 'str' parameter does
+    not have to be null-terminated.  (Therefore it is safe to construct a
+-   substring by calling `PyBytes_FromStringAndSize(origstring, substrlen)'.)
+-   If `str' is NULL then PyBytes_FromStringAndSize() will allocate `size+1'
++   substring by calling 'PyBytes_FromStringAndSize(origstring, substrlen)'.)
++   If 'str' is NULL then PyBytes_FromStringAndSize() will allocate 'size+1'
+    bytes (setting the last byte to the null terminating character) and you can
+-   fill in the data yourself.  If `str' is non-NULL then the resulting
++   fill in the data yourself.  If 'str' is non-NULL then the resulting
+    PyBytes object must be treated as immutable and you must not fill in nor
+    alter the data yourself, since the strings may be shared.
+ 
+-   The PyObject member `op->ob_size', which denotes the number of "extra
++   The PyObject member 'op->ob_size', which denotes the number of "extra
+    items" in a variable-size object, will contain the number of bytes
+    allocated for string data, not counting the null terminating character.
+-   It is therefore equal to the `size' parameter (for
+-   PyBytes_FromStringAndSize()) or the length of the string in the `str'
++   It is therefore equal to the 'size' parameter (for
++   PyBytes_FromStringAndSize()) or the length of the string in the 'str'
+    parameter (for PyBytes_FromString()).
+ */
+ static PyObject *
+diff --git a/Objects/odictobject.c b/Objects/odictobject.c
+index 858f0cbaf9e..233cdcdc039 100644
+--- a/Objects/odictobject.c
++++ b/Objects/odictobject.c
+@@ -200,7 +200,7 @@ Here are some ways to address this challenge:
+ Adding the checks to the concrete API would help make any interpreter
+ switch to OrderedDict less painful for extension modules.  However, this
+ won't work.  The equivalent C API call to `dict.__setitem__(obj, k, v)`
+-is 'PyDict_SetItem(obj, k, v)`.  This illustrates how subclasses in C call
++is `PyDict_SetItem(obj, k, v)`.  This illustrates how subclasses in C call
+ the base class's methods, since there is no equivalent of super() in the
+ C API.  Calling into Python for parent class API would work, but some
+ extension modules already rely on this feature of the concrete API.
diff --git a/cpython/patches/1006-gh-120221-Deliver-real-singals-on-Ctrl-C-and-Ctrl-Z-.patch b/cpython/patches/1006-gh-120221-Deliver-real-singals-on-Ctrl-C-and-Ctrl-Z-.patch
new file mode 100644
index 00000000..17d44514
--- /dev/null
+++ b/cpython/patches/1006-gh-120221-Deliver-real-singals-on-Ctrl-C-and-Ctrl-Z-.patch
@@ -0,0 +1,19 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Pablo Galindo Salgado <Pablogsal@gmail.com>
+Date: Tue, 11 Jun 2024 20:20:25 +0100
+Subject: [PATCH] gh-120221: Deliver real singals on Ctrl-C and Ctrl-Z in the
+ new REPL (#120354)
+
+---
+ .../2024-06-11-17-56-12.gh-issue-120221.si9hM9.rst              | 2 ++
+ 1 file changed, 2 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Core and Builtins/2024-06-11-17-56-12.gh-issue-120221.si9hM9.rst
+
+diff --git a/Misc/NEWS.d/next/Core and Builtins/2024-06-11-17-56-12.gh-issue-120221.si9hM9.rst b/Misc/NEWS.d/next/Core and Builtins/2024-06-11-17-56-12.gh-issue-120221.si9hM9.rst
+new file mode 100644
+index 00000000000..3781576bc5a
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core and Builtins/2024-06-11-17-56-12.gh-issue-120221.si9hM9.rst	
+@@ -0,0 +1,2 @@
++Deliver real signals on Ctrl-C and Ctrl-Z in the new REPL. Patch by Pablo
++Galindo
diff --git a/cpython/patches/1007-gh-121609-Fix-pasting-of-characters-containing-unico.patch b/cpython/patches/1007-gh-121609-Fix-pasting-of-characters-containing-unico.patch
new file mode 100644
index 00000000..9db50dd9
--- /dev/null
+++ b/cpython/patches/1007-gh-121609-Fix-pasting-of-characters-containing-unico.patch
@@ -0,0 +1,18 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marta=20G=C3=B3mez=20Mac=C3=ADas?= <mgmacias@google.com>
+Date: Sat, 13 Jul 2024 12:44:18 +0200
+Subject: [PATCH] gh-121609: Fix pasting of characters containing unicode
+ character joiner (#121667)
+
+---
+ .../2024-07-13-09-51-44.gh-issue-121609.jWsE5t.rst               | 1 +
+ 1 file changed, 1 insertion(+)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2024-07-13-09-51-44.gh-issue-121609.jWsE5t.rst
+
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2024-07-13-09-51-44.gh-issue-121609.jWsE5t.rst b/Misc/NEWS.d/next/Core_and_Builtins/2024-07-13-09-51-44.gh-issue-121609.jWsE5t.rst
+new file mode 100644
+index 00000000000..72b5c071a5c
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2024-07-13-09-51-44.gh-issue-121609.jWsE5t.rst
+@@ -0,0 +1 @@
++Fix pasting of characters containing unicode character joiners in the new REPL. Patch by Marta Gomez Macias
diff --git a/cpython/patches/1008-Fix-while-statements-with-non-bool-conditions-in-_py.patch b/cpython/patches/1008-Fix-while-statements-with-non-bool-conditions-in-_py.patch
new file mode 100644
index 00000000..1fa70aeb
--- /dev/null
+++ b/cpython/patches/1008-Fix-while-statements-with-non-bool-conditions-in-_py.patch
@@ -0,0 +1,38 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: "RUANG (James Roy)" <rruuaanng@outlook.com>
+Date: Thu, 2 Jan 2025 04:39:28 +0800
+Subject: [PATCH] Fix while statements with non-bool conditions in `_pyrepl`
+ (#127509)
+
+Fix non-bool value conditions
+---
+ Lib/_pyrepl/simple_interact.py | 2 +-
+ Lib/_pyrepl/unix_console.py    | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index 66e66eae7ea..a065174ad42 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -130,7 +130,7 @@ def maybe_run_command(statement: str) -> bool:
+             return True
+         return False
+ 
+-    while 1:
++    while True:
+         try:
+             try:
+                 sys.stdout.flush()
+diff --git a/Lib/_pyrepl/unix_console.py b/Lib/_pyrepl/unix_console.py
+index e69c96b1159..ca816e6b9a3 100644
+--- a/Lib/_pyrepl/unix_console.py
++++ b/Lib/_pyrepl/unix_console.py
+@@ -792,7 +792,7 @@ def __tputs(self, fmt, prog=delayprog):
+         # only if the bps is actually needed (which I'm
+         # betting is pretty unlkely)
+         bps = ratedict.get(self.__svtermstate.ospeed)
+-        while 1:
++        while True:
+             m = prog.search(fmt)
+             if not m:
+                 os.write(self.output_fd, fmt)
diff --git a/cpython/patches/1009-gh-128388-pyrepl-on-Windows-add-meta-and-ctrl-arrow-.patch b/cpython/patches/1009-gh-128388-pyrepl-on-Windows-add-meta-and-ctrl-arrow-.patch
new file mode 100644
index 00000000..9c204cb5
--- /dev/null
+++ b/cpython/patches/1009-gh-128388-pyrepl-on-Windows-add-meta-and-ctrl-arrow-.patch
@@ -0,0 +1,102 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Paulie=20Pe=C3=B1a?=
+ <203125+paulie4@users.noreply.github.com>
+Date: Fri, 10 Jan 2025 07:52:19 -0500
+Subject: [PATCH] gh-128388: pyrepl on Windows: add meta and ctrl+arrow
+ keybindings (GH-128389)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Fix `Lib/_pyrepl/windows_console.py` to support more keybindings, like the
+`Ctrl`+`←` and `Ctrl`+`→` word-skipping keybindings and those with meta (i.e. Alt),
+e.g. to `kill-word` or `backward-kill-word`.
+
+Specifics: if Ctrl is pressed, emit "ctrl left" and "ctrl right" instead of just "left" or
+"right," and if Meta/Alt is pressed, emit the special key code for meta before
+emitting the other key that was pressed.
+
+Co-authored-by: Hugo van Kemenade <1324225+hugovk@users.noreply.github.com>
+Co-authored-by: Pieter Eendebak <pieter.eendebak@gmail.com>
+---
+ Lib/_pyrepl/windows_console.py                | 42 ++++++++++++-------
+ ...-01-01-19-24-43.gh-issue-128388.8UdMz_.rst |  1 +
+ 2 files changed, 27 insertions(+), 16 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-01-01-19-24-43.gh-issue-128388.8UdMz_.rst
+
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index fffadd5e2ec..48f328e4de3 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -102,6 +102,10 @@ def __init__(self, err: int | None, descr: str | None = None) -> None:
+ MOVE_DOWN = "\x1b[{}B"
+ CLEAR = "\x1b[H\x1b[J"
+ 
++# State of control keys: https://learn.microsoft.com/en-us/windows/console/key-event-record-str
++ALT_ACTIVE = 0x01 | 0x02
++CTRL_ACTIVE = 0x04 | 0x08
++
+ 
+ class _error(Exception):
+     pass
+@@ -407,31 +411,37 @@ def get_event(self, block: bool = True) -> Event | None:
+                     continue
+                 return None
+ 
+-            key = rec.Event.KeyEvent.uChar.UnicodeChar
++            key_event = rec.Event.KeyEvent
++            raw_key = key = key_event.uChar.UnicodeChar
+ 
+-            if rec.Event.KeyEvent.uChar.UnicodeChar == "\r":
+-                # Make enter make unix-like
++            if key == "\r":
++                # Make enter unix-like
+                 return Event(evt="key", data="\n", raw=b"\n")
+-            elif rec.Event.KeyEvent.wVirtualKeyCode == 8:
++            elif key_event.wVirtualKeyCode == 8:
+                 # Turn backspace directly into the command
+-                return Event(
+-                    evt="key",
+-                    data="backspace",
+-                    raw=rec.Event.KeyEvent.uChar.UnicodeChar,
+-                )
+-            elif rec.Event.KeyEvent.uChar.UnicodeChar == "\x00":
++                key = "backspace"
++            elif key == "\x00":
+                 # Handle special keys like arrow keys and translate them into the appropriate command
+-                code = VK_MAP.get(rec.Event.KeyEvent.wVirtualKeyCode)
+-                if code:
+-                    return Event(
+-                        evt="key", data=code, raw=rec.Event.KeyEvent.uChar.UnicodeChar
+-                    )
++                key = VK_MAP.get(key_event.wVirtualKeyCode)
++                if key:
++                    if key_event.dwControlKeyState & CTRL_ACTIVE:
++                        key = f"ctrl {key}"
++                    elif key_event.dwControlKeyState & ALT_ACTIVE:
++                        # queue the key, return the meta command
++                        self.event_queue.insert(0, Event(evt="key", data=key, raw=key))
++                        return Event(evt="key", data="\033")  # keymap.py uses this for meta
++                    return Event(evt="key", data=key, raw=key)
+                 if block:
+                     continue
+ 
+                 return None
+ 
+-            return Event(evt="key", data=key, raw=rec.Event.KeyEvent.uChar.UnicodeChar)
++            if key_event.dwControlKeyState & ALT_ACTIVE:
++                # queue the key, return the meta command
++                self.event_queue.insert(0, Event(evt="key", data=key, raw=raw_key))
++                return Event(evt="key", data="\033")  # keymap.py uses this for meta
++
++            return Event(evt="key", data=key, raw=raw_key)
+ 
+     def push_char(self, char: int | bytes) -> None:
+         """
+diff --git a/Misc/NEWS.d/next/Library/2025-01-01-19-24-43.gh-issue-128388.8UdMz_.rst b/Misc/NEWS.d/next/Library/2025-01-01-19-24-43.gh-issue-128388.8UdMz_.rst
+new file mode 100644
+index 00000000000..5bef0fd6bca
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-01-01-19-24-43.gh-issue-128388.8UdMz_.rst
+@@ -0,0 +1 @@
++Fix ``PyREPL`` on Windows to support more keybindings, like the :kbd:`Control-←` and :kbd:`Control-→` word-skipping keybindings and those with meta (i.e. :kbd:`Alt`), e.g. :kbd:`Alt-d` to ``kill-word`` or :kbd:`Alt-Backspace` ``backward-kill-word``.
diff --git a/cpython/patches/1010-gh-124096-Enable-REPL-virtual-terminal-support-on-Wi.patch b/cpython/patches/1010-gh-124096-Enable-REPL-virtual-terminal-support-on-Wi.patch
new file mode 100644
index 00000000..0b83712d
--- /dev/null
+++ b/cpython/patches/1010-gh-124096-Enable-REPL-virtual-terminal-support-on-Wi.patch
@@ -0,0 +1,645 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Y5 <124019959+y5c4l3@users.noreply.github.com>
+Date: Mon, 24 Feb 2025 03:30:33 +0800
+Subject: [PATCH] gh-124096: Enable REPL virtual terminal support on Windows
+ (#124119)
+
+To support virtual terminal mode in Windows PYREPL, we need a scanner
+to read over the supported escaped VT sequences.
+
+Windows REPL input was using virtual key mode, which does not support
+terminal escape sequences. This patch calls `SetConsoleMode` properly
+when initializing and send sequences to enable bracketed-paste modes
+to support verbatim copy-and-paste.
+
+Signed-off-by: y5c4l3 <y5c4l3@proton.me>
+Co-authored-by: Petr Viktorin <encukou@gmail.com>
+Co-authored-by: Pablo Galindo Salgado <Pablogsal@gmail.com>
+Co-authored-by: Dustin L. Howett <dustin@howett.net>
+Co-authored-by: wheeheee <104880306+wheeheee@users.noreply.github.com>
+---
+ Lib/_pyrepl/base_eventqueue.py                | 108 ++++++++++++++++++
+ Lib/_pyrepl/unix_eventqueue.py                |  86 +-------------
+ Lib/_pyrepl/windows_console.py                |  67 +++++++++--
+ Lib/_pyrepl/windows_eventqueue.py             |  42 +++++++
+ ..._unix_eventqueue.py => test_eventqueue.py} |  70 ++++++++----
+ ...-09-16-17-03-52.gh-issue-124096.znin0O.rst |   3 +
+ 6 files changed, 264 insertions(+), 112 deletions(-)
+ create mode 100644 Lib/_pyrepl/base_eventqueue.py
+ create mode 100644 Lib/_pyrepl/windows_eventqueue.py
+ rename Lib/test/test_pyrepl/{test_unix_eventqueue.py => test_eventqueue.py} (68%)
+ create mode 100644 Misc/NEWS.d/next/Library/2024-09-16-17-03-52.gh-issue-124096.znin0O.rst
+
+diff --git a/Lib/_pyrepl/base_eventqueue.py b/Lib/_pyrepl/base_eventqueue.py
+new file mode 100644
+index 00000000000..9cae1db112a
+--- /dev/null
++++ b/Lib/_pyrepl/base_eventqueue.py
+@@ -0,0 +1,108 @@
++#   Copyright 2000-2008 Michael Hudson-Doyle <micahel@gmail.com>
++#                       Armin Rigo
++#
++#                        All Rights Reserved
++#
++#
++# Permission to use, copy, modify, and distribute this software and
++# its documentation for any purpose is hereby granted without fee,
++# provided that the above copyright notice appear in all copies and
++# that both that copyright notice and this permission notice appear in
++# supporting documentation.
++#
++# THE AUTHOR MICHAEL HUDSON DISCLAIMS ALL WARRANTIES WITH REGARD TO
++# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
++# AND FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
++# INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
++# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
++# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
++# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++
++"""
++OS-independent base for an event and VT sequence scanner
++
++See unix_eventqueue and windows_eventqueue for subclasses.
++"""
++
++from collections import deque
++
++from . import keymap
++from .console import Event
++from .trace import trace
++
++class BaseEventQueue:
++    def __init__(self, encoding: str, keymap_dict: dict[bytes, str]) -> None:
++        self.compiled_keymap = keymap.compile_keymap(keymap_dict)
++        self.keymap = self.compiled_keymap
++        trace("keymap {k!r}", k=self.keymap)
++        self.encoding = encoding
++        self.events: deque[Event] = deque()
++        self.buf = bytearray()
++
++    def get(self) -> Event | None:
++        """
++        Retrieves the next event from the queue.
++        """
++        if self.events:
++            return self.events.popleft()
++        else:
++            return None
++
++    def empty(self) -> bool:
++        """
++        Checks if the queue is empty.
++        """
++        return not self.events
++
++    def flush_buf(self) -> bytearray:
++        """
++        Flushes the buffer and returns its contents.
++        """
++        old = self.buf
++        self.buf = bytearray()
++        return old
++
++    def insert(self, event: Event) -> None:
++        """
++        Inserts an event into the queue.
++        """
++        trace('added event {event}', event=event)
++        self.events.append(event)
++
++    def push(self, char: int | bytes) -> None:
++        """
++        Processes a character by updating the buffer and handling special key mappings.
++        """
++        ord_char = char if isinstance(char, int) else ord(char)
++        char = bytes(bytearray((ord_char,)))
++        self.buf.append(ord_char)
++        if char in self.keymap:
++            if self.keymap is self.compiled_keymap:
++                # sanity check, buffer is empty when a special key comes
++                assert len(self.buf) == 1
++            k = self.keymap[char]
++            trace('found map {k!r}', k=k)
++            if isinstance(k, dict):
++                self.keymap = k
++            else:
++                self.insert(Event('key', k, self.flush_buf()))
++                self.keymap = self.compiled_keymap
++
++        elif self.buf and self.buf[0] == 27:  # escape
++            # escape sequence not recognized by our keymap: propagate it
++            # outside so that i can be recognized as an M-... key (see also
++            # the docstring in keymap.py
++            trace('unrecognized escape sequence, propagating...')
++            self.keymap = self.compiled_keymap
++            self.insert(Event('key', '\033', bytearray(b'\033')))
++            for _c in self.flush_buf()[1:]:
++                self.push(_c)
++
++        else:
++            try:
++                decoded = bytes(self.buf).decode(self.encoding)
++            except UnicodeError:
++                return
++            else:
++                self.insert(Event('key', decoded, self.flush_buf()))
++            self.keymap = self.compiled_keymap
+diff --git a/Lib/_pyrepl/unix_eventqueue.py b/Lib/_pyrepl/unix_eventqueue.py
+index 70cfade26e2..29b3e9dd5ef 100644
+--- a/Lib/_pyrepl/unix_eventqueue.py
++++ b/Lib/_pyrepl/unix_eventqueue.py
+@@ -18,12 +18,9 @@
+ # CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+-from collections import deque
+-
+-from . import keymap
+-from .console import Event
+ from . import curses
+ from .trace import trace
++from .base_eventqueue import BaseEventQueue
+ from termios import tcgetattr, VERASE
+ import os
+ 
+@@ -70,83 +67,10 @@ def get_terminal_keycodes() -> dict[bytes, str]:
+     keycodes.update(CTRL_ARROW_KEYCODES)
+     return keycodes
+ 
+-class EventQueue:
++class EventQueue(BaseEventQueue):
+     def __init__(self, fd: int, encoding: str) -> None:
+-        self.keycodes = get_terminal_keycodes()
++        keycodes = get_terminal_keycodes()
+         if os.isatty(fd):
+             backspace = tcgetattr(fd)[6][VERASE]
+-            self.keycodes[backspace] = "backspace"
+-        self.compiled_keymap = keymap.compile_keymap(self.keycodes)
+-        self.keymap = self.compiled_keymap
+-        trace("keymap {k!r}", k=self.keymap)
+-        self.encoding = encoding
+-        self.events: deque[Event] = deque()
+-        self.buf = bytearray()
+-
+-    def get(self) -> Event | None:
+-        """
+-        Retrieves the next event from the queue.
+-        """
+-        if self.events:
+-            return self.events.popleft()
+-        else:
+-            return None
+-
+-    def empty(self) -> bool:
+-        """
+-        Checks if the queue is empty.
+-        """
+-        return not self.events
+-
+-    def flush_buf(self) -> bytearray:
+-        """
+-        Flushes the buffer and returns its contents.
+-        """
+-        old = self.buf
+-        self.buf = bytearray()
+-        return old
+-
+-    def insert(self, event: Event) -> None:
+-        """
+-        Inserts an event into the queue.
+-        """
+-        trace('added event {event}', event=event)
+-        self.events.append(event)
+-
+-    def push(self, char: int | bytes) -> None:
+-        """
+-        Processes a character by updating the buffer and handling special key mappings.
+-        """
+-        ord_char = char if isinstance(char, int) else ord(char)
+-        char = bytes(bytearray((ord_char,)))
+-        self.buf.append(ord_char)
+-        if char in self.keymap:
+-            if self.keymap is self.compiled_keymap:
+-                #sanity check, buffer is empty when a special key comes
+-                assert len(self.buf) == 1
+-            k = self.keymap[char]
+-            trace('found map {k!r}', k=k)
+-            if isinstance(k, dict):
+-                self.keymap = k
+-            else:
+-                self.insert(Event('key', k, self.flush_buf()))
+-                self.keymap = self.compiled_keymap
+-
+-        elif self.buf and self.buf[0] == 27:  # escape
+-            # escape sequence not recognized by our keymap: propagate it
+-            # outside so that i can be recognized as an M-... key (see also
+-            # the docstring in keymap.py
+-            trace('unrecognized escape sequence, propagating...')
+-            self.keymap = self.compiled_keymap
+-            self.insert(Event('key', '\033', bytearray(b'\033')))
+-            for _c in self.flush_buf()[1:]:
+-                self.push(_c)
+-
+-        else:
+-            try:
+-                decoded = bytes(self.buf).decode(self.encoding)
+-            except UnicodeError:
+-                return
+-            else:
+-                self.insert(Event('key', decoded, self.flush_buf()))
+-            self.keymap = self.compiled_keymap
++            keycodes[backspace] = "backspace"
++        BaseEventQueue.__init__(self, encoding, keycodes)
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index 48f328e4de3..7c6b6f3b7a0 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -42,6 +42,7 @@
+ from .console import Event, Console
+ from .trace import trace
+ from .utils import wlen
++from .windows_eventqueue import EventQueue
+ 
+ try:
+     from ctypes import GetLastError, WinDLL, windll, WinError  # type: ignore[attr-defined]
+@@ -94,7 +95,9 @@ def __init__(self, err: int | None, descr: str | None = None) -> None:
+     0x83: "f20",  # VK_F20
+ }
+ 
+-# Console escape codes: https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences
++# Virtual terminal output sequences
++# Reference: https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#output-sequences
++# Check `windows_eventqueue.py` for input sequences
+ ERASE_IN_LINE = "\x1b[K"
+ MOVE_LEFT = "\x1b[{}D"
+ MOVE_RIGHT = "\x1b[{}C"
+@@ -110,6 +113,12 @@ def __init__(self, err: int | None, descr: str | None = None) -> None:
+ class _error(Exception):
+     pass
+ 
++def _supports_vt():
++    try:
++        import nt
++        return nt._supports_virtual_terminal()
++    except (ImportError, AttributeError):
++        return False
+ 
+ class WindowsConsole(Console):
+     def __init__(
+@@ -121,17 +130,29 @@ def __init__(
+     ):
+         super().__init__(f_in, f_out, term, encoding)
+ 
++        self.__vt_support = _supports_vt()
++
++        if self.__vt_support:
++            trace('console supports virtual terminal')
++
++        # Save original console modes so we can recover on cleanup.
++        original_input_mode = DWORD()
++        GetConsoleMode(InHandle, original_input_mode)
++        trace(f'saved original input mode 0x{original_input_mode.value:x}')
++        self.__original_input_mode = original_input_mode.value
++
+         SetConsoleMode(
+             OutHandle,
+             ENABLE_WRAP_AT_EOL_OUTPUT
+             | ENABLE_PROCESSED_OUTPUT
+             | ENABLE_VIRTUAL_TERMINAL_PROCESSING,
+         )
++
+         self.screen: list[str] = []
+         self.width = 80
+         self.height = 25
+         self.__offset = 0
+-        self.event_queue: deque[Event] = deque()
++        self.event_queue = EventQueue(encoding)
+         try:
+             self.out = io._WindowsConsoleIO(self.output_fd, "w")  # type: ignore[attr-defined]
+         except ValueError:
+@@ -295,6 +316,12 @@ def _enable_blinking(self):
+     def _disable_blinking(self):
+         self.__write("\x1b[?12l")
+ 
++    def _enable_bracketed_paste(self) -> None:
++        self.__write("\x1b[?2004h")
++
++    def _disable_bracketed_paste(self) -> None:
++        self.__write("\x1b[?2004l")
++
+     def __write(self, text: str) -> None:
+         if "\x1a" in text:
+             text = ''.join(["^Z" if x == '\x1a' else x for x in text])
+@@ -324,8 +351,15 @@ def prepare(self) -> None:
+         self.__gone_tall = 0
+         self.__offset = 0
+ 
++        if self.__vt_support:
++            SetConsoleMode(InHandle, self.__original_input_mode | ENABLE_VIRTUAL_TERMINAL_INPUT)
++            self._enable_bracketed_paste()
++
+     def restore(self) -> None:
+-        pass
++        if self.__vt_support:
++            # Recover to original mode before running REPL
++            self._disable_bracketed_paste()
++            SetConsoleMode(InHandle, self.__original_input_mode)
+ 
+     def _move_relative(self, x: int, y: int) -> None:
+         """Moves relative to the current posxy"""
+@@ -346,7 +380,7 @@ def move_cursor(self, x: int, y: int) -> None:
+             raise ValueError(f"Bad cursor position {x}, {y}")
+ 
+         if y < self.__offset or y >= self.__offset + self.height:
+-            self.event_queue.insert(0, Event("scroll", ""))
++            self.event_queue.insert(Event("scroll", ""))
+         else:
+             self._move_relative(x, y)
+             self.posxy = x, y
+@@ -394,10 +428,8 @@ def get_event(self, block: bool = True) -> Event | None:
+         """Return an Event instance.  Returns None if |block| is false
+         and there is no event pending, otherwise waits for the
+         completion of an event."""
+-        if self.event_queue:
+-            return self.event_queue.pop()
+ 
+-        while True:
++        while self.event_queue.empty():
+             rec = self._read_input(block)
+             if rec is None:
+                 return None
+@@ -428,20 +460,25 @@ def get_event(self, block: bool = True) -> Event | None:
+                         key = f"ctrl {key}"
+                     elif key_event.dwControlKeyState & ALT_ACTIVE:
+                         # queue the key, return the meta command
+-                        self.event_queue.insert(0, Event(evt="key", data=key, raw=key))
++                        self.event_queue.insert(Event(evt="key", data=key, raw=key))
+                         return Event(evt="key", data="\033")  # keymap.py uses this for meta
+                     return Event(evt="key", data=key, raw=key)
+                 if block:
+                     continue
+ 
+                 return None
++            elif self.__vt_support:
++                # If virtual terminal is enabled, scanning VT sequences
++                self.event_queue.push(rec.Event.KeyEvent.uChar.UnicodeChar)
++                continue
+ 
+             if key_event.dwControlKeyState & ALT_ACTIVE:
+                 # queue the key, return the meta command
+-                self.event_queue.insert(0, Event(evt="key", data=key, raw=raw_key))
++                self.event_queue.insert(Event(evt="key", data=key, raw=raw_key))
+                 return Event(evt="key", data="\033")  # keymap.py uses this for meta
+ 
+             return Event(evt="key", data=key, raw=raw_key)
++        return self.event_queue.get()
+ 
+     def push_char(self, char: int | bytes) -> None:
+         """
+@@ -563,6 +600,13 @@ class INPUT_RECORD(Structure):
+ MOUSE_EVENT = 0x02
+ WINDOW_BUFFER_SIZE_EVENT = 0x04
+ 
++ENABLE_PROCESSED_INPUT = 0x0001
++ENABLE_LINE_INPUT = 0x0002
++ENABLE_ECHO_INPUT = 0x0004
++ENABLE_MOUSE_INPUT = 0x0010
++ENABLE_INSERT_MODE = 0x0020
++ENABLE_VIRTUAL_TERMINAL_INPUT = 0x0200
++
+ ENABLE_PROCESSED_OUTPUT = 0x01
+ ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
+ ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x04
+@@ -594,6 +638,10 @@ class INPUT_RECORD(Structure):
+     ]
+     ScrollConsoleScreenBuffer.restype = BOOL
+ 
++    GetConsoleMode = _KERNEL32.GetConsoleMode
++    GetConsoleMode.argtypes = [HANDLE, POINTER(DWORD)]
++    GetConsoleMode.restype = BOOL
++
+     SetConsoleMode = _KERNEL32.SetConsoleMode
+     SetConsoleMode.argtypes = [HANDLE, DWORD]
+     SetConsoleMode.restype = BOOL
+@@ -620,6 +668,7 @@ def _win_only(*args, **kwargs):
+     GetStdHandle = _win_only
+     GetConsoleScreenBufferInfo = _win_only
+     ScrollConsoleScreenBuffer = _win_only
++    GetConsoleMode = _win_only
+     SetConsoleMode = _win_only
+     ReadConsoleInput = _win_only
+     GetNumberOfConsoleInputEvents = _win_only
+diff --git a/Lib/_pyrepl/windows_eventqueue.py b/Lib/_pyrepl/windows_eventqueue.py
+new file mode 100644
+index 00000000000..d99722f9a16
+--- /dev/null
++++ b/Lib/_pyrepl/windows_eventqueue.py
+@@ -0,0 +1,42 @@
++"""
++Windows event and VT sequence scanner
++"""
++
++from .base_eventqueue import BaseEventQueue
++
++
++# Reference: https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#input-sequences
++VT_MAP: dict[bytes, str] = {
++    b'\x1b[A': 'up',
++    b'\x1b[B': 'down',
++    b'\x1b[C': 'right',
++    b'\x1b[D': 'left',
++    b'\x1b[1;5D': 'ctrl left',
++    b'\x1b[1;5C': 'ctrl right',
++
++    b'\x1b[H': 'home',
++    b'\x1b[F': 'end',
++
++    b'\x7f': 'backspace',
++    b'\x1b[2~': 'insert',
++    b'\x1b[3~': 'delete',
++    b'\x1b[5~': 'page up',
++    b'\x1b[6~': 'page down',
++
++    b'\x1bOP':   'f1',
++    b'\x1bOQ':   'f2',
++    b'\x1bOR':   'f3',
++    b'\x1bOS':   'f4',
++    b'\x1b[15~': 'f5',
++    b'\x1b[17~': 'f6',
++    b'\x1b[18~': 'f7',
++    b'\x1b[19~': 'f8',
++    b'\x1b[20~': 'f9',
++    b'\x1b[21~': 'f10',
++    b'\x1b[23~': 'f11',
++    b'\x1b[24~': 'f12',
++}
++
++class EventQueue(BaseEventQueue):
++    def __init__(self, encoding: str) -> None:
++        BaseEventQueue.__init__(self, encoding, VT_MAP)
+diff --git a/Lib/test/test_pyrepl/test_unix_eventqueue.py b/Lib/test/test_pyrepl/test_eventqueue.py
+similarity index 68%
+rename from Lib/test/test_pyrepl/test_unix_eventqueue.py
+rename to Lib/test/test_pyrepl/test_eventqueue.py
+index 301f79927a7..a1bac38fbd4 100644
+--- a/Lib/test/test_pyrepl/test_unix_eventqueue.py
++++ b/Lib/test/test_pyrepl/test_eventqueue.py
+@@ -2,70 +2,77 @@
+ import unittest
+ import sys
+ from unittest.mock import patch
++from test import support
+ 
+ try:
+     from _pyrepl.console import Event
+-    from _pyrepl.unix_eventqueue import EventQueue
++    from _pyrepl import base_eventqueue
+ except ImportError:
+     pass
+ 
+-@unittest.skipIf(sys.platform == "win32", "No Unix event queue on Windows")
+-@patch("_pyrepl.curses.tigetstr", lambda x: b"")
+-class TestUnixEventQueue(unittest.TestCase):
+-    def setUp(self):
+-        self.file = tempfile.TemporaryFile()
++try:
++    from _pyrepl import unix_eventqueue
++except ImportError:
++    pass
+ 
+-    def tearDown(self) -> None:
+-        self.file.close()
++try:
++    from _pyrepl import windows_eventqueue
++except ImportError:
++    pass
++
++class EventQueueTestBase:
++    """OS-independent mixin"""
++    def make_eventqueue(self) -> base_eventqueue.BaseEventQueue:
++        raise NotImplementedError()
+ 
+     def test_get(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         event = Event("key", "a", b"a")
+         eq.insert(event)
+         self.assertEqual(eq.get(), event)
+ 
+     def test_empty(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         self.assertTrue(eq.empty())
+         eq.insert(Event("key", "a", b"a"))
+         self.assertFalse(eq.empty())
+ 
+     def test_flush_buf(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.buf.extend(b"test")
+         self.assertEqual(eq.flush_buf(), b"test")
+         self.assertEqual(eq.buf, bytearray())
+ 
+     def test_insert(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         event = Event("key", "a", b"a")
+         eq.insert(event)
+         self.assertEqual(eq.events[0], event)
+ 
+-    @patch("_pyrepl.unix_eventqueue.keymap")
++    @patch("_pyrepl.base_eventqueue.keymap")
+     def test_push_with_key_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {b"a": "b"}
+         eq.push("a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "b")
+ 
+-    @patch("_pyrepl.unix_eventqueue.keymap")
++    @patch("_pyrepl.base_eventqueue.keymap")
+     def test_push_without_key_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {b"c": "d"}
+         eq.push("a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "a")
+ 
+-    @patch("_pyrepl.unix_eventqueue.keymap")
++    @patch("_pyrepl.base_eventqueue.keymap")
+     def test_push_with_keymap_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {b"a": {b"b": "c"}}
+         eq.push("a")
+         mock_keymap.compile_keymap.assert_called()
+@@ -77,10 +84,10 @@ def test_push_with_keymap_in_keymap(self, mock_keymap):
+         self.assertEqual(eq.events[1].evt, "key")
+         self.assertEqual(eq.events[1].data, "d")
+ 
+-    @patch("_pyrepl.unix_eventqueue.keymap")
++    @patch("_pyrepl.base_eventqueue.keymap")
+     def test_push_with_keymap_in_keymap_and_escape(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {b"a": {b"b": "c"}}
+         eq.push("a")
+         mock_keymap.compile_keymap.assert_called()
+@@ -94,7 +101,7 @@ def test_push_with_keymap_in_keymap_and_escape(self, mock_keymap):
+         self.assertEqual(eq.events[1].data, "b")
+ 
+     def test_push_special_key(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {}
+         eq.push("\x1b")
+         eq.push("[")
+@@ -103,7 +110,7 @@ def test_push_special_key(self):
+         self.assertEqual(eq.events[0].data, "\x1b")
+ 
+     def test_push_unrecognized_escape_sequence(self):
+-        eq = EventQueue(self.file.fileno(), "utf-8")
++        eq = self.make_eventqueue()
+         eq.keymap = {}
+         eq.push("\x1b")
+         eq.push("[")
+@@ -115,3 +122,22 @@ def test_push_unrecognized_escape_sequence(self):
+         self.assertEqual(eq.events[1].data, "[")
+         self.assertEqual(eq.events[2].evt, "key")
+         self.assertEqual(eq.events[2].data, "Z")
++
++
++@unittest.skipIf(support.MS_WINDOWS, "No Unix event queue on Windows")
++class TestUnixEventQueue(EventQueueTestBase, unittest.TestCase):
++    def setUp(self):
++        self.enterContext(patch("_pyrepl.curses.tigetstr", lambda x: b""))
++        self.file = tempfile.TemporaryFile()
++
++    def tearDown(self) -> None:
++        self.file.close()
++
++    def make_eventqueue(self) -> base_eventqueue.BaseEventQueue:
++        return unix_eventqueue.EventQueue(self.file.fileno(), "utf-8")
++
++
++@unittest.skipUnless(support.MS_WINDOWS, "No Windows event queue on Unix")
++class TestWindowsEventQueue(EventQueueTestBase, unittest.TestCase):
++    def make_eventqueue(self) -> base_eventqueue.BaseEventQueue:
++        return windows_eventqueue.EventQueue("utf-8")
+diff --git a/Misc/NEWS.d/next/Library/2024-09-16-17-03-52.gh-issue-124096.znin0O.rst b/Misc/NEWS.d/next/Library/2024-09-16-17-03-52.gh-issue-124096.znin0O.rst
+new file mode 100644
+index 00000000000..2a6aed98c55
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2024-09-16-17-03-52.gh-issue-124096.znin0O.rst
+@@ -0,0 +1,3 @@
++Turn on virtual terminal mode and enable bracketed paste in REPL on Windows
++console. (If the terminal does not support bracketed paste, enabling it
++does nothing.)
diff --git a/cpython/patches/1011-gh-128231-Use-runcode-return-value-for-failing-early.patch b/cpython/patches/1011-gh-128231-Use-runcode-return-value-for-failing-early.patch
new file mode 100644
index 00000000..66599beb
--- /dev/null
+++ b/cpython/patches/1011-gh-128231-Use-runcode-return-value-for-failing-early.patch
@@ -0,0 +1,120 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Bartosz=20S=C5=82awecki?= <bartoszpiotrslawecki@gmail.com>
+Date: Mon, 24 Feb 2025 15:50:13 +0100
+Subject: [PATCH] gh-128231: Use `runcode()` return value for failing early
+ (GH-129488)
+
+---
+ Lib/_pyrepl/console.py                           | 16 +++++++++++++++-
+ Lib/asyncio/__main__.py                          |  2 +-
+ Lib/test/test_pyrepl/test_interact.py            | 13 +++++++++++++
+ Lib/test/test_repl.py                            | 10 +++++++++-
+ ...025-01-30-22-49-42.gh-issue-128231.SuEC18.rst |  2 ++
+ 5 files changed, 40 insertions(+), 3 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-01-30-22-49-42.gh-issue-128231.SuEC18.rst
+
+diff --git a/Lib/_pyrepl/console.py b/Lib/_pyrepl/console.py
+index 0d78890b4f4..db911b3e1f0 100644
+--- a/Lib/_pyrepl/console.py
++++ b/Lib/_pyrepl/console.py
+@@ -152,6 +152,8 @@ def repaint(self) -> None: ...
+ 
+ 
+ class InteractiveColoredConsole(code.InteractiveConsole):
++    STATEMENT_FAILED = object()
++
+     def __init__(
+         self,
+         locals: dict[str, object] | None = None,
+@@ -173,6 +175,16 @@ def _excepthook(self, typ, value, tb):
+                 limit=traceback.BUILTIN_EXCEPTION_LIMIT)
+         self.write(''.join(lines))
+ 
++    def runcode(self, code):
++        try:
++            exec(code, self.locals)
++        except SystemExit:
++            raise
++        except BaseException:
++            self.showtraceback()
++            return self.STATEMENT_FAILED
++        return None
++
+     def runsource(self, source, filename="<input>", symbol="single"):
+         try:
+             tree = self.compile.compiler(
+@@ -209,5 +221,7 @@ def runsource(self, source, filename="<input>", symbol="single"):
+             if code is None:
+                 return True
+ 
+-            self.runcode(code)
++            result = self.runcode(code)
++            if result is self.STATEMENT_FAILED:
++                break
+         return False
+diff --git a/Lib/asyncio/__main__.py b/Lib/asyncio/__main__.py
+index 95c636f9e02..69f5a30cfe5 100644
+--- a/Lib/asyncio/__main__.py
++++ b/Lib/asyncio/__main__.py
+@@ -75,7 +75,7 @@ def callback():
+                 self.write("\nKeyboardInterrupt\n")
+             else:
+                 self.showtraceback()
+-
++            return self.STATEMENT_FAILED
+ 
+ class REPLThread(threading.Thread):
+ 
+diff --git a/Lib/test/test_pyrepl/test_interact.py b/Lib/test/test_pyrepl/test_interact.py
+index 8b941b93670..2651cf7d32d 100644
+--- a/Lib/test/test_pyrepl/test_interact.py
++++ b/Lib/test/test_pyrepl/test_interact.py
+@@ -53,6 +53,19 @@ def test_multiple_statements_output(self):
+         self.assertFalse(more)
+         self.assertEqual(f.getvalue(), "1\n")
+ 
++    @force_not_colorized
++    def test_multiple_statements_fail_early(self):
++        console = InteractiveColoredConsole()
++        code = dedent("""\
++        raise Exception('foobar')
++        print('spam&eggs')
++        """)
++        f = io.StringIO()
++        with contextlib.redirect_stderr(f):
++            console.runsource(code)
++        self.assertIn('Exception: foobar', f.getvalue())
++        self.assertNotIn('spam&eggs', f.getvalue())
++
+     def test_empty(self):
+         namespace = {}
+         code = ""
+diff --git a/Lib/test/test_repl.py b/Lib/test/test_repl.py
+index 356ff5b198d..cb7b1938871 100644
+--- a/Lib/test/test_repl.py
++++ b/Lib/test/test_repl.py
+@@ -294,7 +294,15 @@ def f():
+         self.assertEqual(traceback_lines, expected_lines)
+ 
+ 
+-class TestAsyncioREPLContextVars(unittest.TestCase):
++class TestAsyncioREPL(unittest.TestCase):
++    def test_multiple_statements_fail_early(self):
++        user_input = "1 / 0; print('afterwards')"
++        p = spawn_repl("-m", "asyncio")
++        p.stdin.write(user_input)
++        output = kill_python(p)
++        self.assertIn("ZeroDivisionError", output)
++        self.assertNotIn("afterwards", output)
++
+     def test_toplevel_contextvars_sync(self):
+         user_input = dedent("""\
+         from contextvars import ContextVar
+diff --git a/Misc/NEWS.d/next/Library/2025-01-30-22-49-42.gh-issue-128231.SuEC18.rst b/Misc/NEWS.d/next/Library/2025-01-30-22-49-42.gh-issue-128231.SuEC18.rst
+new file mode 100644
+index 00000000000..a70b6a1fc14
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-01-30-22-49-42.gh-issue-128231.SuEC18.rst
+@@ -0,0 +1,2 @@
++Execution of multiple statements in the new REPL now stops immediately upon
++the first exception encountered. Patch by Bartosz Sławecki.
diff --git a/cpython/patches/1012-gh-124927-Fix-conversion-issue-between-coordinates-a.patch b/cpython/patches/1012-gh-124927-Fix-conversion-issue-between-coordinates-a.patch
new file mode 100644
index 00000000..4f32498e
--- /dev/null
+++ b/cpython/patches/1012-gh-124927-Fix-conversion-issue-between-coordinates-a.patch
@@ -0,0 +1,70 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: FeH2 <i@feh2.im>
+Date: Tue, 11 Mar 2025 05:54:49 +0800
+Subject: [PATCH] gh-124927: Fix conversion issue between coordinates and
+ position in REPL (#125001)
+
+---
+ Lib/_pyrepl/reader.py                                     | 3 ++-
+ Lib/test/test_pyrepl/test_reader.py                       | 8 ++++++++
+ Misc/ACKS                                                 | 1 +
+ .../2024-10-05-13-25-07.gh-issue-124927.uzNA32.rst        | 1 +
+ 4 files changed, 12 insertions(+), 1 deletion(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2024-10-05-13-25-07.gh-issue-124927.uzNA32.rst
+
+diff --git a/Lib/_pyrepl/reader.py b/Lib/_pyrepl/reader.py
+index 1252847e02b..4795c51296a 100644
+--- a/Lib/_pyrepl/reader.py
++++ b/Lib/_pyrepl/reader.py
+@@ -62,7 +62,7 @@ def disp_str(buffer: str) -> tuple[str, list[int]]:
+         elif unicodedata.category(c).startswith("C"):
+             c = r"\u%04x" % ord(c)
+             s.append(c)
+-            b.extend([0] * (len(c) - 1))
++            b.append(len(c))
+         else:
+             s.append(c)
+             b.append(str_width(c))
+@@ -577,6 +577,7 @@ def setpos_from_xy(self, x: int, y: int) -> None:
+         cur_x = self.screeninfo[i][0]
+         while cur_x < x:
+             if self.screeninfo[i][1][j] == 0:
++                j += 1  # prevent potential future infinite loop
+                 continue
+             cur_x += self.screeninfo[i][1][j]
+             j += 1
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 27c6d6664ed..270d4d4fb8a 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -319,3 +319,11 @@ def test_pos2xy_with_no_columns(self):
+         # Simulate a resize to 0 columns
+         reader.screeninfo = []
+         self.assertEqual(reader.pos2xy(), (0, 0))
++
++    def test_setpos_from_xy_for_non_printing_char(self):
++        code = "# non \u200c printing character"
++        events = code_to_events(code)
++
++        reader, _ = handle_all_events(events)
++        reader.setpos_from_xy(8, 0)
++        self.assertEqual(reader.pos, 7)
+diff --git a/Misc/ACKS b/Misc/ACKS
+index 54e60767737..b60ce58ca00 100644
+--- a/Misc/ACKS
++++ b/Misc/ACKS
+@@ -277,6 +277,7 @@ Laurent De Buyst
+ Zach Byrne
+ Vedran Čačić
+ Nicolas Cadou
++Zhikai Cai
+ Jp Calderone
+ Ben Caller
+ Arnaud Calmettes
+diff --git a/Misc/NEWS.d/next/Library/2024-10-05-13-25-07.gh-issue-124927.uzNA32.rst b/Misc/NEWS.d/next/Library/2024-10-05-13-25-07.gh-issue-124927.uzNA32.rst
+new file mode 100644
+index 00000000000..1fc485cd052
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2024-10-05-13-25-07.gh-issue-124927.uzNA32.rst
+@@ -0,0 +1 @@
++Non-printing characters are now properly handled in the new REPL.
diff --git a/cpython/patches/1013-gh-130804-Fix-support-of-typing-unicode-chars-in-pyr.patch b/cpython/patches/1013-gh-130804-Fix-support-of-typing-unicode-chars-in-pyr.patch
new file mode 100644
index 00000000..5daa4f75
--- /dev/null
+++ b/cpython/patches/1013-gh-130804-Fix-support-of-typing-unicode-chars-in-pyr.patch
@@ -0,0 +1,65 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Sergey Miryanov <sergey.miryanov@gmail.com>
+Date: Tue, 11 Mar 2025 03:13:50 +0500
+Subject: [PATCH] gh-130804: Fix support of typing unicode chars in pyrepl
+ (#130805)
+
+---
+ Lib/_pyrepl/base_eventqueue.py                       | 12 +++++++++---
+ Lib/test/test_pyrepl/test_eventqueue.py              |  7 +++++++
+ .../2025-03-10-21-46-37.gh-issue-130804.0PpcTx.rst   |  1 +
+ 3 files changed, 17 insertions(+), 3 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-03-10-21-46-37.gh-issue-130804.0PpcTx.rst
+
+diff --git a/Lib/_pyrepl/base_eventqueue.py b/Lib/_pyrepl/base_eventqueue.py
+index 9cae1db112a..e018c4fc183 100644
+--- a/Lib/_pyrepl/base_eventqueue.py
++++ b/Lib/_pyrepl/base_eventqueue.py
+@@ -69,13 +69,19 @@ def insert(self, event: Event) -> None:
+         trace('added event {event}', event=event)
+         self.events.append(event)
+ 
+-    def push(self, char: int | bytes) -> None:
++    def push(self, char: int | bytes | str) -> None:
+         """
+         Processes a character by updating the buffer and handling special key mappings.
+         """
+         ord_char = char if isinstance(char, int) else ord(char)
+-        char = bytes(bytearray((ord_char,)))
+-        self.buf.append(ord_char)
++        if ord_char > 255:
++            assert isinstance(char, str)
++            char = bytes(char.encode(self.encoding, "replace"))
++            self.buf.extend(char)
++        else:
++            char = bytes(bytearray((ord_char,)))
++            self.buf.append(ord_char)
++
+         if char in self.keymap:
+             if self.keymap is self.compiled_keymap:
+                 # sanity check, buffer is empty when a special key comes
+diff --git a/Lib/test/test_pyrepl/test_eventqueue.py b/Lib/test/test_pyrepl/test_eventqueue.py
+index a1bac38fbd4..b25bdb956b0 100644
+--- a/Lib/test/test_pyrepl/test_eventqueue.py
++++ b/Lib/test/test_pyrepl/test_eventqueue.py
+@@ -123,6 +123,13 @@ def test_push_unrecognized_escape_sequence(self):
+         self.assertEqual(eq.events[2].evt, "key")
+         self.assertEqual(eq.events[2].data, "Z")
+ 
++    def test_push_unicode_character(self):
++        eq = self.make_eventqueue()
++        eq.keymap = {}
++        eq.push("ч")
++        self.assertEqual(eq.events[0].evt, "key")
++        self.assertEqual(eq.events[0].data, "ч")
++
+ 
+ @unittest.skipIf(support.MS_WINDOWS, "No Unix event queue on Windows")
+ class TestUnixEventQueue(EventQueueTestBase, unittest.TestCase):
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-03-10-21-46-37.gh-issue-130804.0PpcTx.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-10-21-46-37.gh-issue-130804.0PpcTx.rst
+new file mode 100644
+index 00000000000..37a9b83c858
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-10-21-46-37.gh-issue-130804.0PpcTx.rst
+@@ -0,0 +1 @@
++Fix support of unicode characters on Windows in the new REPL.
diff --git a/cpython/patches/1014-gh-131152-Remove-unused-imports-in-_pyrepl-and-ctype.patch b/cpython/patches/1014-gh-131152-Remove-unused-imports-in-_pyrepl-and-ctype.patch
new file mode 100644
index 00000000..c4cdb13f
--- /dev/null
+++ b/cpython/patches/1014-gh-131152-Remove-unused-imports-in-_pyrepl-and-ctype.patch
@@ -0,0 +1,39 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Victor Stinner <vstinner@python.org>
+Date: Wed, 12 Mar 2025 15:04:12 +0100
+Subject: [PATCH] gh-131152: Remove unused imports in `_pyrepl` and `ctypes`
+ (#131150)
+
+---
+ Lib/_pyrepl/simple_interact.py | 5 -----
+ Lib/_pyrepl/windows_console.py | 1 -
+ 2 files changed, 6 deletions(-)
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index a065174ad42..57b37d34518 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -34,11 +34,6 @@
+ 
+ from .readline import _get_reader, multiline_input
+ 
+-TYPE_CHECKING = False
+-
+-if TYPE_CHECKING:
+-    from typing import Any
+-
+ 
+ _error: tuple[type[Exception], ...] | type[Exception]
+ try:
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index 7c6b6f3b7a0..c874c922cea 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -25,7 +25,6 @@
+ import time
+ import msvcrt
+ 
+-from collections import deque
+ import ctypes
+ from ctypes.wintypes import (
+     _COORD,
diff --git a/cpython/patches/1015-gh-131507-Clean-up-tests-and-type-checking-for-_pyre.patch b/cpython/patches/1015-gh-131507-Clean-up-tests-and-type-checking-for-_pyre.patch
new file mode 100644
index 00000000..b901934f
--- /dev/null
+++ b/cpython/patches/1015-gh-131507-Clean-up-tests-and-type-checking-for-_pyre.patch
@@ -0,0 +1,825 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C5=81ukasz=20Langa?= <lukasz@langa.pl>
+Date: Fri, 21 Mar 2025 15:48:10 +0100
+Subject: [PATCH] gh-131507: Clean up tests and type checking for `_pyrepl`
+ (#131509)
+
+---
+ Lib/_colorize.py                          |  63 ++++++++++--
+ Lib/_pyrepl/commands.py                   |   2 +-
+ Lib/_pyrepl/console.py                    |   4 +-
+ Lib/_pyrepl/mypy.ini                      |   7 +-
+ Lib/_pyrepl/reader.py                     |  47 ++-------
+ Lib/_pyrepl/readline.py                   |   2 +-
+ Lib/_pyrepl/utils.py                      |  19 +++-
+ Lib/test/test_pyrepl/support.py           |  31 ++++--
+ Lib/test/test_pyrepl/test_pyrepl.py       |  48 ++++-----
+ Lib/test/test_pyrepl/test_reader.py       | 120 +++++++++++++---------
+ Lib/test/test_pyrepl/test_unix_console.py |   6 +-
+ Misc/mypy/README.md                       |  16 +++
+ Misc/mypy/_colorize.py                    |   1 +
+ Misc/mypy/_pyrepl                         |   1 +
+ 14 files changed, 234 insertions(+), 133 deletions(-)
+ create mode 100644 Misc/mypy/README.md
+ create mode 120000 Misc/mypy/_colorize.py
+ create mode 120000 Misc/mypy/_pyrepl
+
+diff --git a/Lib/_colorize.py b/Lib/_colorize.py
+index 70acfd4ad0b..9eb6f0933b8 100644
+--- a/Lib/_colorize.py
++++ b/Lib/_colorize.py
+@@ -1,20 +1,63 @@
++from __future__ import annotations
+ import io
+ import os
+ import sys
+ 
+ COLORIZE = True
+ 
++# types
++if False:
++    from typing import IO
++
+ 
+ class ANSIColors:
++    RESET = "\x1b[0m"
++
++    BLACK = "\x1b[30m"
++    BLUE = "\x1b[34m"
++    CYAN = "\x1b[36m"
++    GREEN = "\x1b[32m"
++    MAGENTA = "\x1b[35m"
++    RED = "\x1b[31m"
++    WHITE = "\x1b[37m"  # more like LIGHT GRAY
++    YELLOW = "\x1b[33m"
++
++    BOLD_BLACK = "\x1b[1;30m"  # DARK GRAY
++    BOLD_BLUE = "\x1b[1;34m"
++    BOLD_CYAN = "\x1b[1;36m"
+     BOLD_GREEN = "\x1b[1;32m"
+     BOLD_MAGENTA = "\x1b[1;35m"
+     BOLD_RED = "\x1b[1;31m"
+-    GREEN = "\x1b[32m"
+-    GREY = "\x1b[90m"
+-    MAGENTA = "\x1b[35m"
+-    RED = "\x1b[31m"
+-    RESET = "\x1b[0m"
+-    YELLOW = "\x1b[33m"
++    BOLD_WHITE = "\x1b[1;37m"  # actual WHITE
++    BOLD_YELLOW = "\x1b[1;33m"
++
++    # intense = like bold but without being bold
++    INTENSE_BLACK = "\x1b[90m"
++    INTENSE_BLUE = "\x1b[94m"
++    INTENSE_CYAN = "\x1b[96m"
++    INTENSE_GREEN = "\x1b[92m"
++    INTENSE_MAGENTA = "\x1b[95m"
++    INTENSE_RED = "\x1b[91m"
++    INTENSE_WHITE = "\x1b[97m"
++    INTENSE_YELLOW = "\x1b[93m"
++
++    BACKGROUND_BLACK = "\x1b[40m"
++    BACKGROUND_BLUE = "\x1b[44m"
++    BACKGROUND_CYAN = "\x1b[46m"
++    BACKGROUND_GREEN = "\x1b[42m"
++    BACKGROUND_MAGENTA = "\x1b[45m"
++    BACKGROUND_RED = "\x1b[41m"
++    BACKGROUND_WHITE = "\x1b[47m"
++    BACKGROUND_YELLOW = "\x1b[43m"
++
++    INTENSE_BACKGROUND_BLACK = "\x1b[100m"
++    INTENSE_BACKGROUND_BLUE = "\x1b[104m"
++    INTENSE_BACKGROUND_CYAN = "\x1b[106m"
++    INTENSE_BACKGROUND_GREEN = "\x1b[102m"
++    INTENSE_BACKGROUND_MAGENTA = "\x1b[105m"
++    INTENSE_BACKGROUND_RED = "\x1b[101m"
++    INTENSE_BACKGROUND_WHITE = "\x1b[107m"
++    INTENSE_BACKGROUND_YELLOW = "\x1b[103m"
+ 
+ 
+ NoColors = ANSIColors()
+@@ -24,14 +67,16 @@ class ANSIColors:
+         setattr(NoColors, attr, "")
+ 
+ 
+-def get_colors(colorize: bool = False, *, file=None) -> ANSIColors:
++def get_colors(
++    colorize: bool = False, *, file: IO[str] | IO[bytes] | None = None
++) -> ANSIColors:
+     if colorize or can_colorize(file=file):
+         return ANSIColors()
+     else:
+         return NoColors
+ 
+ 
+-def can_colorize(*, file=None) -> bool:
++def can_colorize(*, file: IO[str] | IO[bytes] | None = None) -> bool:
+     if file is None:
+         file = sys.stdout
+ 
+@@ -64,4 +109,4 @@ def can_colorize(*, file=None) -> bool:
+     try:
+         return os.isatty(file.fileno())
+     except io.UnsupportedOperation:
+-        return file.isatty()
++        return hasattr(file, "isatty") and file.isatty()
+diff --git a/Lib/_pyrepl/commands.py b/Lib/_pyrepl/commands.py
+index 503ca1da329..cbb6d85f683 100644
+--- a/Lib/_pyrepl/commands.py
++++ b/Lib/_pyrepl/commands.py
+@@ -456,7 +456,7 @@ def do(self) -> None:
+ class show_history(Command):
+     def do(self) -> None:
+         from .pager import get_pager
+-        from site import gethistoryfile  # type: ignore[attr-defined]
++        from site import gethistoryfile
+ 
+         history = os.linesep.join(self.reader.history[:])
+         self.reader.console.restore()
+diff --git a/Lib/_pyrepl/console.py b/Lib/_pyrepl/console.py
+index db911b3e1f0..30fc4d4a264 100644
+--- a/Lib/_pyrepl/console.py
++++ b/Lib/_pyrepl/console.py
+@@ -19,7 +19,7 @@
+ 
+ from __future__ import annotations
+ 
+-import _colorize  # type: ignore[import-not-found]
++import _colorize
+ 
+ from abc import ABC, abstractmethod
+ import ast
+@@ -161,7 +161,7 @@ def __init__(
+         *,
+         local_exit: bool = False,
+     ) -> None:
+-        super().__init__(locals=locals, filename=filename, local_exit=local_exit)  # type: ignore[call-arg]
++        super().__init__(locals=locals, filename=filename, local_exit=local_exit)
+         self.can_colorize = _colorize.can_colorize()
+ 
+     def showsyntaxerror(self, filename=None, **kwargs):
+diff --git a/Lib/_pyrepl/mypy.ini b/Lib/_pyrepl/mypy.ini
+index 395f5945ab7..eabd0e9b440 100644
+--- a/Lib/_pyrepl/mypy.ini
++++ b/Lib/_pyrepl/mypy.ini
+@@ -4,8 +4,9 @@
+ 
+ [mypy]
+ files = Lib/_pyrepl
++mypy_path = $MYPY_CONFIG_FILE_DIR/../../Misc/mypy
+ explicit_package_bases = True
+-python_version = 3.12
++python_version = 3.13
+ platform = linux
+ pretty = True
+ 
+@@ -22,3 +23,7 @@ check_untyped_defs = False
+ # Various internal modules that typeshed deliberately doesn't have stubs for:
+ [mypy-_abc.*,_opcode.*,_overlapped.*,_testcapi.*,_testinternalcapi.*,test.*]
+ ignore_missing_imports = True
++
++# Other untyped parts of the stdlib
++[mypy-idlelib.*]
++ignore_missing_imports = True
+diff --git a/Lib/_pyrepl/reader.py b/Lib/_pyrepl/reader.py
+index 4795c51296a..b38f0bf82db 100644
+--- a/Lib/_pyrepl/reader.py
++++ b/Lib/_pyrepl/reader.py
+@@ -26,11 +26,11 @@
+ from contextlib import contextmanager
+ from dataclasses import dataclass, field, fields
+ import unicodedata
+-from _colorize import can_colorize, ANSIColors  # type: ignore[import-not-found]
++from _colorize import can_colorize, ANSIColors
+ 
+ 
+ from . import commands, console, input
+-from .utils import ANSI_ESCAPE_SEQUENCE, wlen, str_width
++from .utils import wlen, unbracket, str_width
+ from .trace import trace
+ 
+ 
+@@ -421,42 +421,15 @@ def calc_screen(self) -> list[str]:
+ 
+     @staticmethod
+     def process_prompt(prompt: str) -> tuple[str, int]:
+-        """Process the prompt.
++        r"""Return a tuple with the prompt string and its visible length.
+ 
+-        This means calculate the length of the prompt. The character \x01
+-        and \x02 are used to bracket ANSI control sequences and need to be
+-        excluded from the length calculation.  So also a copy of the prompt
+-        is returned with these control characters removed."""
+-
+-        # The logic below also ignores the length of common escape
+-        # sequences if they were not explicitly within \x01...\x02.
+-        # They are CSI (or ANSI) sequences  ( ESC [ ... LETTER )
+-
+-        # wlen from utils already excludes ANSI_ESCAPE_SEQUENCE chars,
+-        # which breaks the logic below so we redefine it here.
+-        def wlen(s: str) -> int:
+-            return sum(str_width(i) for i in s)
+-
+-        out_prompt = ""
+-        l = wlen(prompt)
+-        pos = 0
+-        while True:
+-            s = prompt.find("\x01", pos)
+-            if s == -1:
+-                break
+-            e = prompt.find("\x02", s)
+-            if e == -1:
+-                break
+-            # Found start and end brackets, subtract from string length
+-            l = l - (e - s + 1)
+-            keep = prompt[pos:s]
+-            l -= sum(map(wlen, ANSI_ESCAPE_SEQUENCE.findall(keep)))
+-            out_prompt += keep + prompt[s + 1 : e]
+-            pos = e + 1
+-        keep = prompt[pos:]
+-        l -= sum(map(wlen, ANSI_ESCAPE_SEQUENCE.findall(keep)))
+-        out_prompt += keep
+-        return out_prompt, l
++        The prompt string has the zero-width brackets recognized by shells
++        (\x01 and \x02) removed.  The length ignores anything between those
++        brackets as well as any ANSI escape sequences.
++        """
++        out_prompt = unbracket(prompt, including_content=False)
++        visible_prompt = unbracket(prompt, including_content=True)
++        return out_prompt, wlen(visible_prompt)
+ 
+     def bow(self, p: int | None = None) -> int:
+         """Return the 0-based index of the word break preceding p most
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index 888185eb03b..be229488e54 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -32,7 +32,7 @@
+ from dataclasses import dataclass, field
+ 
+ import os
+-from site import gethistoryfile   # type: ignore[attr-defined]
++from site import gethistoryfile
+ import sys
+ from rlcompleter import Completer as RLCompleter
+ 
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 4651717bd7e..0eb5f8c0097 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -3,6 +3,8 @@
+ import functools
+ 
+ ANSI_ESCAPE_SEQUENCE = re.compile(r"\x1b\[[ -@]*[A-~]")
++ZERO_WIDTH_BRACKET = re.compile(r"\x01.*?\x02")
++ZERO_WIDTH_TRANS = str.maketrans({"\x01": "", "\x02": ""})
+ 
+ 
+ @functools.cache
+@@ -10,16 +12,27 @@ def str_width(c: str) -> int:
+     if ord(c) < 128:
+         return 1
+     w = unicodedata.east_asian_width(c)
+-    if w in ('N', 'Na', 'H', 'A'):
++    if w in ("N", "Na", "H", "A"):
+         return 1
+     return 2
+ 
+ 
+ def wlen(s: str) -> int:
+-    if len(s) == 1 and s != '\x1a':
++    if len(s) == 1 and s != "\x1a":
+         return str_width(s)
+     length = sum(str_width(i) for i in s)
+     # remove lengths of any escape sequences
+     sequence = ANSI_ESCAPE_SEQUENCE.findall(s)
+-    ctrl_z_cnt = s.count('\x1a')
++    ctrl_z_cnt = s.count("\x1a")
+     return length - sum(len(i) for i in sequence) + ctrl_z_cnt
++
++
++def unbracket(s: str, including_content: bool = False) -> str:
++    r"""Return `s` with \001 and \002 characters removed.
++
++    If `including_content` is True, content between \001 and \002 is also
++    stripped.
++    """
++    if including_content:
++        return ZERO_WIDTH_BRACKET.sub("", s)
++    return s.translate(ZERO_WIDTH_TRANS)
+diff --git a/Lib/test/test_pyrepl/support.py b/Lib/test/test_pyrepl/support.py
+index 45e3bf758f1..e8cf5812f3b 100644
+--- a/Lib/test/test_pyrepl/support.py
++++ b/Lib/test/test_pyrepl/support.py
+@@ -7,14 +7,24 @@
+ from _pyrepl.console import Console, Event
+ from _pyrepl.readline import ReadlineAlikeReader, ReadlineConfig
+ from _pyrepl.simple_interact import _strip_final_indent
++from _pyrepl.utils import unbracket, ANSI_ESCAPE_SEQUENCE
++
++
++class ScreenEqualMixin:
++    def assert_screen_equal(
++        self, reader: ReadlineAlikeReader, expected: str, clean: bool = False
++    ):
++        actual = clean_screen(reader) if clean else reader.screen
++        expected = expected.split("\n")
++        self.assertListEqual(actual, expected)
+ 
+ 
+ def multiline_input(reader: ReadlineAlikeReader, namespace: dict | None = None):
+     saved = reader.more_lines
+     try:
+         reader.more_lines = partial(more_lines, namespace=namespace)
+-        reader.ps1 = reader.ps2 = ">>>"
+-        reader.ps3 = reader.ps4 = "..."
++        reader.ps1 = reader.ps2 = ">>> "
++        reader.ps3 = reader.ps4 = "... "
+         return reader.readline()
+     finally:
+         reader.more_lines = saved
+@@ -39,18 +49,22 @@ def code_to_events(code: str):
+         yield Event(evt="key", data=c, raw=bytearray(c.encode("utf-8")))
+ 
+ 
+-def clean_screen(screen: Iterable[str]):
++def clean_screen(reader: ReadlineAlikeReader) -> list[str]:
+     """Cleans color and console characters out of a screen output.
+ 
+     This is useful for screen testing, it increases the test readability since
+     it strips out all the unreadable side of the screen.
+     """
+     output = []
+-    for line in screen:
+-        if line.startswith(">>>") or line.startswith("..."):
+-            line = line[3:]
++    for line in reader.screen:
++        line = unbracket(line, including_content=True)
++        line = ANSI_ESCAPE_SEQUENCE.sub("", line)
++        for prefix in (reader.ps1, reader.ps2, reader.ps3, reader.ps4):
++            if line.startswith(prefix):
++                line = line[len(prefix):]
++                break
+         output.append(line)
+-    return "\n".join(output).strip()
++    return output
+ 
+ 
+ def prepare_reader(console: Console, **kwargs):
+@@ -100,6 +114,9 @@ def handle_all_events(
+     prepare_console=partial(prepare_console, width=10),
+ )
+ 
++reader_no_colors = partial(prepare_reader, can_colorize=False)
++reader_force_colors = partial(prepare_reader, can_colorize=True)
++
+ 
+ class FakeConsole(Console):
+     def __init__(self, events, encoding="utf-8") -> None:
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 191fce3f7ae..6e2c47c3362 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -17,12 +17,12 @@
+ 
+ from .support import (
+     FakeConsole,
++    ScreenEqualMixin,
+     handle_all_events,
+     handle_events_narrow_console,
+     more_lines,
+     multiline_input,
+     code_to_events,
+-    clean_screen,
+ )
+ from _pyrepl.console import Event
+ from _pyrepl.readline import (ReadlineAlikeReader, ReadlineConfig,
+@@ -587,7 +587,7 @@ def test_auto_indent_ignore_comments(self):
+         self.assertEqual(output, output_code)
+ 
+ 
+-class TestPyReplOutput(TestCase):
++class TestPyReplOutput(ScreenEqualMixin, TestCase):
+     def prepare_reader(self, events):
+         console = FakeConsole(events)
+         config = ReadlineConfig(readline_completer=None)
+@@ -620,7 +620,7 @@ def test_basic(self):
+ 
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+ 
+     def test_get_line_buffer_returns_str(self):
+         reader = self.prepare_reader(code_to_events("\n"))
+@@ -654,11 +654,13 @@ def test_multiline_edit(self):
+         reader = self.prepare_reader(events)
+ 
+         output = multiline_input(reader)
+-        self.assertEqual(output, "def f():\n    ...\n    ")
+-        self.assertEqual(clean_screen(reader.screen), "def f():\n    ...")
++        expected = "def f():\n    ...\n    "
++        self.assertEqual(output, expected)
++        self.assert_screen_equal(reader, expected, clean=True)
+         output = multiline_input(reader)
+-        self.assertEqual(output, "def g():\n    pass\n    ")
+-        self.assertEqual(clean_screen(reader.screen), "def g():\n    pass")
++        expected = "def g():\n    pass\n    "
++        self.assertEqual(output, expected)
++        self.assert_screen_equal(reader, expected, clean=True)
+ 
+     def test_history_navigation_with_up_arrow(self):
+         events = itertools.chain(
+@@ -677,16 +679,16 @@ def test_history_navigation_with_up_arrow(self):
+ 
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "2+2")
+-        self.assertEqual(clean_screen(reader.screen), "2+2")
++        self.assert_screen_equal(reader, "2+2", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "2+2")
+-        self.assertEqual(clean_screen(reader.screen), "2+2")
++        self.assert_screen_equal(reader, "2+2", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+ 
+     def test_history_with_multiline_entries(self):
+         code = "def foo():\nx = 1\ny = 2\nz = 3\n\ndef bar():\nreturn 42\n\n"
+@@ -705,11 +707,9 @@ def test_history_with_multiline_entries(self):
+         output = multiline_input(reader)
+         output = multiline_input(reader)
+         output = multiline_input(reader)
+-        self.assertEqual(
+-            clean_screen(reader.screen),
+-            'def foo():\n    x = 1\n    y = 2\n    z = 3'
+-        )
+-        self.assertEqual(output, "def foo():\n    x = 1\n    y = 2\n    z = 3\n    ")
++        expected = "def foo():\n    x = 1\n    y = 2\n    z = 3\n    "
++        self.assert_screen_equal(reader, expected, clean=True)
++        self.assertEqual(output, expected)
+ 
+ 
+     def test_history_navigation_with_down_arrow(self):
+@@ -728,7 +728,7 @@ def test_history_navigation_with_down_arrow(self):
+ 
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+ 
+     def test_history_search(self):
+         events = itertools.chain(
+@@ -745,23 +745,23 @@ def test_history_search(self):
+ 
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "2+2")
+-        self.assertEqual(clean_screen(reader.screen), "2+2")
++        self.assert_screen_equal(reader, "2+2", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "3+3")
+-        self.assertEqual(clean_screen(reader.screen), "3+3")
++        self.assert_screen_equal(reader, "3+3", clean=True)
+         output = multiline_input(reader)
+         self.assertEqual(output, "1+1")
+-        self.assertEqual(clean_screen(reader.screen), "1+1")
++        self.assert_screen_equal(reader, "1+1", clean=True)
+ 
+     def test_control_character(self):
+         events = code_to_events("c\x1d\n")
+         reader = self.prepare_reader(events)
+         output = multiline_input(reader)
+         self.assertEqual(output, "c\x1d")
+-        self.assertEqual(clean_screen(reader.screen), "c")
++        self.assert_screen_equal(reader, "c\x1d", clean=True)
+ 
+     def test_history_search_backward(self):
+         # Test <page up> history search backward with "imp" input
+@@ -781,7 +781,7 @@ def test_history_search_backward(self):
+         # search for "imp" in history
+         output = multiline_input(reader)
+         self.assertEqual(output, "import os")
+-        self.assertEqual(clean_screen(reader.screen), "import os")
++        self.assert_screen_equal(reader, "import os", clean=True)
+ 
+     def test_history_search_backward_empty(self):
+         # Test <page up> history search backward with an empty input
+@@ -800,7 +800,7 @@ def test_history_search_backward_empty(self):
+         # search backward in history
+         output = multiline_input(reader)
+         self.assertEqual(output, "import os")
+-        self.assertEqual(clean_screen(reader.screen), "import os")
++        self.assert_screen_equal(reader, "import os", clean=True)
+ 
+ 
+ class TestPyReplCompleter(TestCase):
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 270d4d4fb8a..40d9c2f91b1 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -4,31 +4,28 @@
+ from unittest import TestCase
+ from unittest.mock import MagicMock
+ 
+-from .support import handle_all_events, handle_events_narrow_console, code_to_events, prepare_reader, prepare_console
++from .support import handle_all_events, handle_events_narrow_console
++from .support import ScreenEqualMixin, code_to_events
++from .support import prepare_reader, prepare_console
+ from _pyrepl.console import Event
+ from _pyrepl.reader import Reader
+ 
+ 
+-class TestReader(TestCase):
+-    def assert_screen_equals(self, reader, expected):
+-        actual = reader.screen
+-        expected = expected.split("\n")
+-        self.assertListEqual(actual, expected)
+-
++class TestReader(ScreenEqualMixin, TestCase):
+     def test_calc_screen_wrap_simple(self):
+         events = code_to_events(10 * "a")
+         reader, _ = handle_events_narrow_console(events)
+-        self.assert_screen_equals(reader, f"{9*"a"}\\\na")
++        self.assert_screen_equal(reader, f"{9*"a"}\\\na")
+ 
+     def test_calc_screen_wrap_wide_characters(self):
+         events = code_to_events(8 * "a" + "樂")
+         reader, _ = handle_events_narrow_console(events)
+-        self.assert_screen_equals(reader, f"{8*"a"}\\\n樂")
++        self.assert_screen_equal(reader, f"{8*"a"}\\\n樂")
+ 
+     def test_calc_screen_wrap_three_lines(self):
+         events = code_to_events(20 * "a")
+         reader, _ = handle_events_narrow_console(events)
+-        self.assert_screen_equals(reader, f"{9*"a"}\\\n{9*"a"}\\\naa")
++        self.assert_screen_equal(reader, f"{9*"a"}\\\n{9*"a"}\\\naa")
+ 
+     def test_calc_screen_prompt_handling(self):
+         def prepare_reader_keep_prompts(*args, **kwargs):
+@@ -48,7 +45,7 @@ def prepare_reader_keep_prompts(*args, **kwargs):
+             prepare_reader=prepare_reader_keep_prompts,
+         )
+         # fmt: off
+-        self.assert_screen_equals(
++        self.assert_screen_equal(
+             reader,
+             (
+             ">>> if so\\\n"
+@@ -74,13 +71,17 @@ def test_calc_screen_wrap_three_lines_mixed_character(self):
+         reader, _ = handle_events_narrow_console(events)
+ 
+         # fmt: off
+-        self.assert_screen_equals(reader, (
+-            "def f():\n"
+-           f"  {7*"a"}\\\n"
+-            "a\n"
+-           f"  {3*"樂"}\\\n"
+-            "樂樂"
+-        ))
++        self.assert_screen_equal(
++            reader,
++            (
++                "def f():\n"
++               f"  {7*"a"}\\\n"
++                "a\n"
++               f"  {3*"樂"}\\\n"
++                "樂樂"
++            ),
++            clean=True,
++        )
+         # fmt: on
+ 
+     def test_calc_screen_backspace(self):
+@@ -91,7 +92,7 @@ def test_calc_screen_backspace(self):
+             ],
+         )
+         reader, _ = handle_all_events(events)
+-        self.assert_screen_equals(reader, "aa")
++        self.assert_screen_equal(reader, "aa")
+ 
+     def test_calc_screen_wrap_removes_after_backspace(self):
+         events = itertools.chain(
+@@ -101,7 +102,7 @@ def test_calc_screen_wrap_removes_after_backspace(self):
+             ],
+         )
+         reader, _ = handle_events_narrow_console(events)
+-        self.assert_screen_equals(reader, 9 * "a")
++        self.assert_screen_equal(reader, 9 * "a")
+ 
+     def test_calc_screen_backspace_in_second_line_after_wrap(self):
+         events = itertools.chain(
+@@ -111,7 +112,7 @@ def test_calc_screen_backspace_in_second_line_after_wrap(self):
+             ],
+         )
+         reader, _ = handle_events_narrow_console(events)
+-        self.assert_screen_equals(reader, f"{9*"a"}\\\na")
++        self.assert_screen_equal(reader, f"{9*"a"}\\\na")
+ 
+     def test_setpos_for_xy_simple(self):
+         events = code_to_events("11+11")
+@@ -123,7 +124,7 @@ def test_control_characters(self):
+         code = 'flag = "🏳️‍🌈"'
+         events = code_to_events(code)
+         reader, _ = handle_all_events(events)
+-        self.assert_screen_equals(reader, 'flag = "🏳️\\u200d🌈"')
++        self.assert_screen_equal(reader, 'flag = "🏳️\\u200d🌈"', clean=True)
+ 
+     def test_setpos_from_xy_multiple_lines(self):
+         # fmt: off
+@@ -173,7 +174,7 @@ def test_up_arrow_after_ctrl_r(self):
+         )
+ 
+         reader, _ = handle_all_events(events)
+-        self.assert_screen_equals(reader, "")
++        self.assert_screen_equal(reader, "")
+ 
+     def test_newline_within_block_trailing_whitespace(self):
+         # fmt: off
+@@ -212,13 +213,14 @@ def test_newline_within_block_trailing_whitespace(self):
+             "    \n"
+             "    a = 1\n"
+             "    \n"
+-            "    "    # HistoricalReader will trim trailing whitespace
++            "    "  # HistoricalReader will trim trailing whitespace
+         )
+-        self.assert_screen_equals(reader, expected)
++        self.assert_screen_equal(reader, expected, clean=True)
+         self.assertTrue(reader.finished)
+ 
+     def test_input_hook_is_called_if_set(self):
+         input_hook = MagicMock()
++
+         def _prepare_console(events):
+             console = MagicMock()
+             console.get_event.side_effect = events
+@@ -235,18 +237,35 @@ def _prepare_console(events):
+     def test_keyboard_interrupt_clears_screen(self):
+         namespace = {"itertools": itertools}
+         code = "import itertools\nitertools."
+-        events = itertools.chain(code_to_events(code), [
+-            Event(evt='key', data='\t', raw=bytearray(b'\t')),  # Two tabs for completion
+-            Event(evt='key', data='\t', raw=bytearray(b'\t')),
+-            Event(evt='key', data='\x03', raw=bytearray(b'\x03')),  # Ctrl-C
+-        ])
+-
+-        completing_reader = functools.partial(
+-            prepare_reader,
+-            readline_completer=rlcompleter.Completer(namespace).complete
++        events = itertools.chain(
++            code_to_events(code),
++            [
++                # Two tabs for completion
++                Event(evt="key", data="\t", raw=bytearray(b"\t")),
++                Event(evt="key", data="\t", raw=bytearray(b"\t")),
++                Event(evt="key", data="\x03", raw=bytearray(b"\x03")),  # Ctrl-C
++            ],
+         )
+-        reader, _ = handle_all_events(events, prepare_reader=completing_reader)
+-        self.assertEqual(reader.calc_screen(), code.split("\n"))
++        console = prepare_console(events)
++        reader = prepare_reader(
++            console,
++            readline_completer=rlcompleter.Completer(namespace).complete,
++        )
++        try:
++            # we're not using handle_all_events() here to be able to
++            # follow the KeyboardInterrupt sequence of events. Normally this
++            # happens in simple_interact.run_multiline_interactive_console.
++            while True:
++                reader.handle1()
++        except KeyboardInterrupt:
++            # at this point the completions are still visible
++            self.assertTrue(len(reader.screen) > 2)
++            reader.refresh()
++            # after the refresh, they are gone
++            self.assertEqual(len(reader.screen), 2)
++            self.assert_screen_equal(reader, code, clean=True)
++        else:
++            self.fail("KeyboardInterrupt not raised.")
+ 
+     def test_prompt_length(self):
+         # Handles simple ASCII prompt
+@@ -282,14 +301,19 @@ def test_prompt_length(self):
+     def test_completions_updated_on_key_press(self):
+         namespace = {"itertools": itertools}
+         code = "itertools."
+-        events = itertools.chain(code_to_events(code), [
+-            Event(evt='key', data='\t', raw=bytearray(b'\t')),  # Two tabs for completion
+-            Event(evt='key', data='\t', raw=bytearray(b'\t')),
+-        ], code_to_events("a"))
++        events = itertools.chain(
++            code_to_events(code),
++            [
++                # Two tabs for completion
++                Event(evt="key", data="\t", raw=bytearray(b"\t")),
++                Event(evt="key", data="\t", raw=bytearray(b"\t")),
++            ],
++            code_to_events("a"),
++        )
+ 
+         completing_reader = functools.partial(
+             prepare_reader,
+-            readline_completer=rlcompleter.Completer(namespace).complete
++            readline_completer=rlcompleter.Completer(namespace).complete,
+         )
+         reader, _ = handle_all_events(events, prepare_reader=completing_reader)
+ 
+@@ -301,17 +325,21 @@ def test_completions_updated_on_key_press(self):
+     def test_key_press_on_tab_press_once(self):
+         namespace = {"itertools": itertools}
+         code = "itertools."
+-        events = itertools.chain(code_to_events(code), [
+-            Event(evt='key', data='\t', raw=bytearray(b'\t')),
+-        ], code_to_events("a"))
++        events = itertools.chain(
++            code_to_events(code),
++            [
++                Event(evt="key", data="\t", raw=bytearray(b"\t")),
++            ],
++            code_to_events("a"),
++        )
+ 
+         completing_reader = functools.partial(
+             prepare_reader,
+-            readline_completer=rlcompleter.Completer(namespace).complete
++            readline_completer=rlcompleter.Completer(namespace).complete,
+         )
+         reader, _ = handle_all_events(events, prepare_reader=completing_reader)
+ 
+-        self.assert_screen_equals(reader, f"{code}a")
++        self.assert_screen_equal(reader, f"{code}a")
+ 
+     def test_pos2xy_with_no_columns(self):
+         console = prepare_console([])
+diff --git a/Lib/test/test_pyrepl/test_unix_console.py b/Lib/test/test_pyrepl/test_unix_console.py
+index 15dbf48bcf0..057cdd11285 100644
+--- a/Lib/test/test_pyrepl/test_unix_console.py
++++ b/Lib/test/test_pyrepl/test_unix_console.py
+@@ -7,7 +7,7 @@
+ from unittest import TestCase
+ from unittest.mock import MagicMock, call, patch, ANY
+ 
+-from .support import handle_all_events, code_to_events
++from .support import handle_all_events, code_to_events, reader_no_colors
+ 
+ try:
+     from _pyrepl.console import Event
+@@ -252,7 +252,9 @@ def test_resize_bigger_on_multiline_function(self, _os_write):
+         # fmt: on
+ 
+         events = itertools.chain(code_to_events(code))
+-        reader, console = handle_events_short_unix_console(events)
++        reader, console = handle_events_short_unix_console(
++            events, prepare_reader=reader_no_colors
++        )
+ 
+         console.height = 2
+         console.getheightwidth = MagicMock(lambda _: (2, 80))
+diff --git a/Misc/mypy/README.md b/Misc/mypy/README.md
+new file mode 100644
+index 00000000000..05eda6c0b82
+--- /dev/null
++++ b/Misc/mypy/README.md
+@@ -0,0 +1,16 @@
++# Mypy path symlinks
++
++This directory stores symlinks to standard library modules and packages
++that are fully type-annotated and ready to be used in type checking of
++the rest of the stdlib or Tools/ and so on.
++
++Due to most of the standard library being untyped, we prefer not to
++point mypy directly at `Lib/` for type checking.  Additionally, mypy
++as a tool does not support shadowing typing-related standard libraries
++like `types`, `typing`, and `collections.abc`.
++
++So instead, we set `mypy_path` to include this directory,
++which only links modules and packages we know are safe to be
++type-checked themselves and used as dependencies.
++
++See `Lib/_pyrepl/mypy.ini` for an example.
+\ No newline at end of file
+diff --git a/Misc/mypy/_colorize.py b/Misc/mypy/_colorize.py
+new file mode 120000
+index 00000000000..9b7304769ec
+--- /dev/null
++++ b/Misc/mypy/_colorize.py
+@@ -0,0 +1 @@
++../../Lib/_colorize.py
+\ No newline at end of file
+diff --git a/Misc/mypy/_pyrepl b/Misc/mypy/_pyrepl
+new file mode 120000
+index 00000000000..bd7b6990966
+--- /dev/null
++++ b/Misc/mypy/_pyrepl
+@@ -0,0 +1 @@
++../../Lib/_pyrepl
+\ No newline at end of file
diff --git a/cpython/patches/1016-gh-131507-Refactor-screen-and-cursor-position-calcul.patch b/cpython/patches/1016-gh-131507-Refactor-screen-and-cursor-position-calcul.patch
new file mode 100644
index 00000000..48e35a0a
--- /dev/null
+++ b/cpython/patches/1016-gh-131507-Refactor-screen-and-cursor-position-calcul.patch
@@ -0,0 +1,293 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C5=81ukasz=20Langa?= <lukasz@langa.pl>
+Date: Fri, 21 Mar 2025 18:27:35 +0100
+Subject: [PATCH] gh-131507: Refactor screen and cursor position calculations
+ (GH-131547)
+
+This is based off #131509.
+---
+ Lib/_pyrepl/reader.py | 124 +++++++++++++++++-------------------------
+ Lib/_pyrepl/types.py  |  14 +++--
+ Lib/_pyrepl/utils.py  |  39 +++++++++++++
+ 3 files changed, 96 insertions(+), 81 deletions(-)
+
+diff --git a/Lib/_pyrepl/reader.py b/Lib/_pyrepl/reader.py
+index b38f0bf82db..7fc2422dac9 100644
+--- a/Lib/_pyrepl/reader.py
++++ b/Lib/_pyrepl/reader.py
+@@ -25,12 +25,11 @@
+ 
+ from contextlib import contextmanager
+ from dataclasses import dataclass, field, fields
+-import unicodedata
+ from _colorize import can_colorize, ANSIColors
+ 
+ 
+ from . import commands, console, input
+-from .utils import wlen, unbracket, str_width
++from .utils import wlen, unbracket, disp_str
+ from .trace import trace
+ 
+ 
+@@ -39,36 +38,6 @@
+ from .types import Callback, SimpleContextManager, KeySpec, CommandName
+ 
+ 
+-def disp_str(buffer: str) -> tuple[str, list[int]]:
+-    """disp_str(buffer:string) -> (string, [int])
+-
+-    Return the string that should be the printed representation of
+-    |buffer| and a list detailing where the characters of |buffer|
+-    get used up.  E.g.:
+-
+-    >>> disp_str(chr(3))
+-    ('^C', [1, 0])
+-
+-    """
+-    b: list[int] = []
+-    s: list[str] = []
+-    for c in buffer:
+-        if c == '\x1a':
+-            s.append(c)
+-            b.append(2)
+-        elif ord(c) < 128:
+-            s.append(c)
+-            b.append(1)
+-        elif unicodedata.category(c).startswith("C"):
+-            c = r"\u%04x" % ord(c)
+-            s.append(c)
+-            b.append(len(c))
+-        else:
+-            s.append(c)
+-            b.append(str_width(c))
+-    return "".join(s), b
+-
+-
+ # syntax classes:
+ 
+ SYNTAX_WHITESPACE, SYNTAX_WORD, SYNTAX_SYMBOL = range(3)
+@@ -347,14 +316,12 @@ def calc_screen(self) -> list[str]:
+         pos -= offset
+ 
+         prompt_from_cache = (offset and self.buffer[offset - 1] != "\n")
+-
+         lines = "".join(self.buffer[offset:]).split("\n")
+-
+         cursor_found = False
+         lines_beyond_cursor = 0
+         for ln, line in enumerate(lines, num_common_lines):
+-            ll = len(line)
+-            if 0 <= pos <= ll:
++            line_len = len(line)
++            if 0 <= pos <= line_len:
+                 self.lxy = pos, ln
+                 cursor_found = True
+             elif cursor_found:
+@@ -368,34 +335,34 @@ def calc_screen(self) -> list[str]:
+                 prompt_from_cache = False
+                 prompt = ""
+             else:
+-                prompt = self.get_prompt(ln, ll >= pos >= 0)
++                prompt = self.get_prompt(ln, line_len >= pos >= 0)
+             while "\n" in prompt:
+                 pre_prompt, _, prompt = prompt.partition("\n")
+                 last_refresh_line_end_offsets.append(offset)
+                 screen.append(pre_prompt)
+                 screeninfo.append((0, []))
+-            pos -= ll + 1
+-            prompt, lp = self.process_prompt(prompt)
+-            l, l2 = disp_str(line)
+-            wrapcount = (wlen(l) + lp) // self.console.width
+-            if wrapcount == 0:
+-                offset += ll + 1  # Takes all of the line plus the newline
++            pos -= line_len + 1
++            prompt, prompt_len = self.process_prompt(prompt)
++            chars, char_widths = disp_str(line)
++            wrapcount = (sum(char_widths) + prompt_len) // self.console.width
++            trace("wrapcount = {wrapcount}", wrapcount=wrapcount)
++            if wrapcount == 0 or not char_widths:
++                offset += line_len + 1  # Takes all of the line plus the newline
+                 last_refresh_line_end_offsets.append(offset)
+-                screen.append(prompt + l)
+-                screeninfo.append((lp, l2))
++                screen.append(prompt + "".join(chars))
++                screeninfo.append((prompt_len, char_widths))
+             else:
+-                i = 0
+-                while l:
+-                    prelen = lp if i == 0 else 0
++                pre = prompt
++                prelen = prompt_len
++                for wrap in range(wrapcount + 1):
+                     index_to_wrap_before = 0
+                     column = 0
+-                    for character_width in l2:
+-                        if column + character_width >= self.console.width - prelen:
++                    for char_width in char_widths:
++                        if column + char_width + prelen >= self.console.width:
+                             break
+                         index_to_wrap_before += 1
+-                        column += character_width
+-                    pre = prompt if i == 0 else ""
+-                    if len(l) > index_to_wrap_before:
++                        column += char_width
++                    if len(chars) > index_to_wrap_before:
+                         offset += index_to_wrap_before
+                         post = "\\"
+                         after = [1]
+@@ -404,11 +371,14 @@ def calc_screen(self) -> list[str]:
+                         post = ""
+                         after = []
+                     last_refresh_line_end_offsets.append(offset)
+-                    screen.append(pre + l[:index_to_wrap_before] + post)
+-                    screeninfo.append((prelen, l2[:index_to_wrap_before] + after))
+-                    l = l[index_to_wrap_before:]
+-                    l2 = l2[index_to_wrap_before:]
+-                    i += 1
++                    render = pre + "".join(chars[:index_to_wrap_before]) + post
++                    render_widths = char_widths[:index_to_wrap_before] + after
++                    screen.append(render)
++                    screeninfo.append((prelen, render_widths))
++                    chars = chars[index_to_wrap_before:]
++                    char_widths = char_widths[index_to_wrap_before:]
++                    pre = ""
++                    prelen = 0
+         self.screeninfo = screeninfo
+         self.cxy = self.pos2xy()
+         if self.msg:
+@@ -537,9 +507,9 @@ def setpos_from_xy(self, x: int, y: int) -> None:
+         pos = 0
+         i = 0
+         while i < y:
+-            prompt_len, character_widths = self.screeninfo[i]
+-            offset = len(character_widths) - character_widths.count(0)
+-            in_wrapped_line = prompt_len + sum(character_widths) >= self.console.width
++            prompt_len, char_widths = self.screeninfo[i]
++            offset = len(char_widths)
++            in_wrapped_line = prompt_len + sum(char_widths) >= self.console.width
+             if in_wrapped_line:
+                 pos += offset - 1  # -1 cause backslash is not in buffer
+             else:
+@@ -560,29 +530,33 @@ def setpos_from_xy(self, x: int, y: int) -> None:
+ 
+     def pos2xy(self) -> tuple[int, int]:
+         """Return the x, y coordinates of position 'pos'."""
+-        # this *is* incomprehensible, yes.
+-        p, y = 0, 0
+-        l2: list[int] = []
++
++        prompt_len, y = 0, 0
++        char_widths: list[int] = []
+         pos = self.pos
+         assert 0 <= pos <= len(self.buffer)
++
++        # optimize for the common case: typing at the end of the buffer
+         if pos == len(self.buffer) and len(self.screeninfo) > 0:
+             y = len(self.screeninfo) - 1
+-            p, l2 = self.screeninfo[y]
+-            return p + sum(l2) + l2.count(0), y
++            prompt_len, char_widths = self.screeninfo[y]
++            return prompt_len + sum(char_widths), y
++
++        for prompt_len, char_widths in self.screeninfo:
++            offset = len(char_widths)
++            in_wrapped_line = prompt_len + sum(char_widths) >= self.console.width
++            if in_wrapped_line:
++                offset -= 1  # need to remove line-wrapping backslash
+ 
+-        for p, l2 in self.screeninfo:
+-            l = len(l2) - l2.count(0)
+-            in_wrapped_line = p + sum(l2) >= self.console.width
+-            offset = l - 1 if in_wrapped_line else l  # need to remove backslash
+             if offset >= pos:
+                 break
+ 
+-            if p + sum(l2) >= self.console.width:
+-                pos -= l - 1  # -1 cause backslash is not in buffer
+-            else:
+-                pos -= l + 1  # +1 cause newline is in buffer
++            if not in_wrapped_line:
++                offset += 1  # there's a newline in buffer
++
++            pos -= offset
+             y += 1
+-        return p + sum(l2[:pos]), y
++        return prompt_len + sum(char_widths[:pos]), y
+ 
+     def insert(self, text: str | list[str]) -> None:
+         """Insert 'text' at the insertion point."""
+diff --git a/Lib/_pyrepl/types.py b/Lib/_pyrepl/types.py
+index f9d48b828c7..c5b7ebc1a40 100644
+--- a/Lib/_pyrepl/types.py
++++ b/Lib/_pyrepl/types.py
+@@ -1,8 +1,10 @@
+ from collections.abc import Callable, Iterator
+ 
+-Callback = Callable[[], object]
+-SimpleContextManager = Iterator[None]
+-KeySpec = str  # like r"\C-c"
+-CommandName = str  # like "interrupt"
+-EventTuple = tuple[CommandName, str]
+-Completer = Callable[[str, int], str | None]
++type Callback = Callable[[], object]
++type SimpleContextManager = Iterator[None]
++type KeySpec = str  # like r"\C-c"
++type CommandName = str  # like "interrupt"
++type EventTuple = tuple[CommandName, str]
++type Completer = Callable[[str, int], str | None]
++type CharBuffer = list[str]
++type CharWidths = list[int]
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 0eb5f8c0097..7437fbe1ab9 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -2,6 +2,9 @@
+ import unicodedata
+ import functools
+ 
++from .types import CharBuffer, CharWidths
++from .trace import trace
++
+ ANSI_ESCAPE_SEQUENCE = re.compile(r"\x1b\[[ -@]*[A-~]")
+ ZERO_WIDTH_BRACKET = re.compile(r"\x01.*?\x02")
+ ZERO_WIDTH_TRANS = str.maketrans({"\x01": "", "\x02": ""})
+@@ -36,3 +39,39 @@ def unbracket(s: str, including_content: bool = False) -> str:
+     if including_content:
+         return ZERO_WIDTH_BRACKET.sub("", s)
+     return s.translate(ZERO_WIDTH_TRANS)
++
++
++def disp_str(buffer: str) -> tuple[CharBuffer, CharWidths]:
++    r"""Decompose the input buffer into a printable variant.
++
++    Returns a tuple of two lists:
++    - the first list is the input buffer, character by character;
++    - the second list is the visible width of each character in the input
++      buffer.
++
++    Examples:
++    >>> utils.disp_str("a = 9")
++    (['a', ' ', '=', ' ', '9'], [1, 1, 1, 1, 1])
++    """
++    chars: CharBuffer = []
++    char_widths: CharWidths = []
++
++    if not buffer:
++        return chars, char_widths
++
++    for c in buffer:
++        if c == "\x1a":  # CTRL-Z on Windows
++            chars.append(c)
++            char_widths.append(2)
++        elif ord(c) < 128:
++            chars.append(c)
++            char_widths.append(1)
++        elif unicodedata.category(c).startswith("C"):
++            c = r"\u%04x" % ord(c)
++            chars.append(c)
++            char_widths.append(len(c))
++        else:
++            chars.append(c)
++            char_widths.append(str_width(c))
++    trace("disp_str({buffer}) = {s}, {b}", buffer=repr(buffer), s=chars, b=char_widths)
++    return chars, char_widths
diff --git a/cpython/patches/1017-gh-129098-avoid-using-content-of-_pyrepl-__main__.py.patch b/cpython/patches/1017-gh-129098-avoid-using-content-of-_pyrepl-__main__.py.patch
new file mode 100644
index 00000000..d95ae014
--- /dev/null
+++ b/cpython/patches/1017-gh-129098-avoid-using-content-of-_pyrepl-__main__.py.patch
@@ -0,0 +1,85 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?B=C3=A9n=C3=A9dikt=20Tran?=
+ <10796600+picnixz@users.noreply.github.com>
+Date: Sun, 20 Apr 2025 19:24:30 +0200
+Subject: [PATCH] gh-129098: avoid using content of `_pyrepl/__main__.py` when
+ reporting tracebacks (#130721)
+
+---
+ Lib/_pyrepl/__main__.py                       |  4 +++
+ Lib/test/test_pyrepl/test_pyrepl.py           | 29 +++++++++++++++++--
+ ...-03-01-12-37-08.gh-issue-129098.eJ2-6L.rst |  2 ++
+ 3 files changed, 33 insertions(+), 2 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-03-01-12-37-08.gh-issue-129098.eJ2-6L.rst
+
+diff --git a/Lib/_pyrepl/__main__.py b/Lib/_pyrepl/__main__.py
+index 3fa992eee8e..9c66812e13a 100644
+--- a/Lib/_pyrepl/__main__.py
++++ b/Lib/_pyrepl/__main__.py
+@@ -1,6 +1,10 @@
+ # Important: don't add things to this module, as they will end up in the REPL's
+ # default globals.  Use _pyrepl.main instead.
+ 
++# Avoid caching this file by linecache and incorrectly report tracebacks.
++# See https://github.com/python/cpython/issues/129098.
++__spec__ = __loader__ = None
++
+ if __name__ == "__main__":
+     from .main import interactive_console as __pyrepl_interactive_console
+     __pyrepl_interactive_console()
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 6e2c47c3362..5e46e887912 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -11,9 +11,9 @@
+ from unittest import TestCase, skipUnless, skipIf
+ from unittest.mock import patch
+ from test.support import force_not_colorized, make_clean_env
+-from test.support import SHORT_TIMEOUT
++from test.support import SHORT_TIMEOUT, STDLIB_DIR
+ from test.support.import_helper import import_module
+-from test.support.os_helper import unlink
++from test.support.os_helper import EnvironmentVarGuard, unlink
+ 
+ from .support import (
+     FakeConsole,
+@@ -1216,6 +1216,31 @@ def test_python_basic_repl(self):
+         self.assertNotIn("Exception", output)
+         self.assertNotIn("Traceback", output)
+ 
++    @force_not_colorized
++    def test_no_pyrepl_source_in_exc(self):
++        # Avoid using _pyrepl/__main__.py in traceback reports
++        # See https://github.com/python/cpython/issues/129098.
++        pyrepl_main_file = os.path.join(STDLIB_DIR, "_pyrepl", "__main__.py")
++        self.assertTrue(os.path.exists(pyrepl_main_file), pyrepl_main_file)
++        with open(pyrepl_main_file) as fp:
++            excluded_lines = fp.readlines()
++        excluded_lines = list(filter(None, map(str.strip, excluded_lines)))
++
++        for filename in ['?', 'unknown-filename', '<foo>', '<...>']:
++            self._test_no_pyrepl_source_in_exc(filename, excluded_lines)
++
++    def _test_no_pyrepl_source_in_exc(self, filename, excluded_lines):
++        with EnvironmentVarGuard() as env, self.subTest(filename=filename):
++            env.unset("PYTHON_BASIC_REPL")
++            commands = (f"eval(compile('spam', {filename!r}, 'eval'))\n"
++                        f"exit()\n")
++            output, _ = self.run_repl(commands, env=env)
++            self.assertIn("Traceback (most recent call last)", output)
++            self.assertIn("NameError: name 'spam' is not defined", output)
++            for line in excluded_lines:
++                with self.subTest(line=line):
++                    self.assertNotIn(line, output)
++
+     @force_not_colorized
+     def test_bad_sys_excepthook_doesnt_crash_pyrepl(self):
+         env = os.environ.copy()
+diff --git a/Misc/NEWS.d/next/Library/2025-03-01-12-37-08.gh-issue-129098.eJ2-6L.rst b/Misc/NEWS.d/next/Library/2025-03-01-12-37-08.gh-issue-129098.eJ2-6L.rst
+new file mode 100644
+index 00000000000..8ac9082a7b4
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-03-01-12-37-08.gh-issue-129098.eJ2-6L.rst
+@@ -0,0 +1,2 @@
++Fix REPL traceback reporting when using :func:`compile` with an inexisting
++file. Patch by Bénédikt Tran.
diff --git a/cpython/patches/1018-gh-69605-Add-module-autocomplete-to-PyREPL-129329.patch b/cpython/patches/1018-gh-69605-Add-module-autocomplete-to-PyREPL-129329.patch
new file mode 100644
index 00000000..655d41b1
--- /dev/null
+++ b/cpython/patches/1018-gh-69605-Add-module-autocomplete-to-PyREPL-129329.patch
@@ -0,0 +1,674 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: "Tomas R." <tomas.roun8@gmail.com>
+Date: Fri, 25 Apr 2025 03:24:26 +0200
+Subject: [PATCH] gh-69605: Add module autocomplete to PyREPL (#129329)
+
+---
+ Lib/_pyrepl/_module_completer.py              | 377 ++++++++++++++++++
+ Lib/_pyrepl/completing_reader.py              |   4 +
+ Lib/_pyrepl/readline.py                       |   9 +-
+ Lib/test/test_pyrepl/test_pyrepl.py           | 198 +++++++++
+ ...5-01-26-23-46-43.gh-issue-69605._2Qc1w.rst |   1 +
+ 5 files changed, 588 insertions(+), 1 deletion(-)
+ create mode 100644 Lib/_pyrepl/_module_completer.py
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-01-26-23-46-43.gh-issue-69605._2Qc1w.rst
+
+diff --git a/Lib/_pyrepl/_module_completer.py b/Lib/_pyrepl/_module_completer.py
+new file mode 100644
+index 00000000000..1fb043e0b70
+--- /dev/null
++++ b/Lib/_pyrepl/_module_completer.py
+@@ -0,0 +1,377 @@
++from __future__ import annotations
++
++import pkgutil
++import sys
++import tokenize
++from io import StringIO
++from contextlib import contextmanager
++from dataclasses import dataclass
++from itertools import chain
++from tokenize import TokenInfo
++
++TYPE_CHECKING = False
++
++if TYPE_CHECKING:
++    from typing import Any, Iterable, Iterator, Mapping
++
++
++def make_default_module_completer() -> ModuleCompleter:
++    # Inside pyrepl, __package__ is set to '_pyrepl'
++    return ModuleCompleter(namespace={'__package__': '_pyrepl'})
++
++
++class ModuleCompleter:
++    """A completer for Python import statements.
++
++    Examples:
++        - import <tab>
++        - import foo<tab>
++        - import foo.<tab>
++        - import foo as bar, baz<tab>
++
++        - from <tab>
++        - from foo<tab>
++        - from foo import <tab>
++        - from foo import bar<tab>
++        - from foo import (bar as baz, qux<tab>
++    """
++
++    def __init__(self, namespace: Mapping[str, Any] | None = None) -> None:
++        self.namespace = namespace or {}
++        self._global_cache: list[pkgutil.ModuleInfo] = []
++        self._curr_sys_path: list[str] = sys.path[:]
++
++    def get_completions(self, line: str) -> list[str]:
++        """Return the next possible import completions for 'line'."""
++        result = ImportParser(line).parse()
++        if not result:
++            return []
++        try:
++            return self.complete(*result)
++        except Exception:
++            # Some unexpected error occurred, make it look like
++            # no completions are available
++            return []
++
++    def complete(self, from_name: str | None, name: str | None) -> list[str]:
++        if from_name is None:
++            # import x.y.z<tab>
++            assert name is not None
++            path, prefix = self.get_path_and_prefix(name)
++            modules = self.find_modules(path, prefix)
++            return [self.format_completion(path, module) for module in modules]
++
++        if name is None:
++            # from x.y.z<tab>
++            path, prefix = self.get_path_and_prefix(from_name)
++            modules = self.find_modules(path, prefix)
++            return [self.format_completion(path, module) for module in modules]
++
++        # from x.y import z<tab>
++        return self.find_modules(from_name, name)
++
++    def find_modules(self, path: str, prefix: str) -> list[str]:
++        """Find all modules under 'path' that start with 'prefix'."""
++        modules = self._find_modules(path, prefix)
++        # Filter out invalid module names
++        # (for example those containing dashes that cannot be imported with 'import')
++        return [mod for mod in modules if mod.isidentifier()]
++
++    def _find_modules(self, path: str, prefix: str) -> list[str]:
++        if not path:
++            # Top-level import (e.g. `import foo<tab>`` or `from foo<tab>`)`
++            return [name for _, name, _ in self.global_cache
++                    if name.startswith(prefix)]
++
++        if path.startswith('.'):
++            # Convert relative path to absolute path
++            package = self.namespace.get('__package__', '')
++            path = self.resolve_relative_name(path, package)  # type: ignore[assignment]
++            if path is None:
++                return []
++
++        modules: Iterable[pkgutil.ModuleInfo] = self.global_cache
++        for segment in path.split('.'):
++            modules = [mod_info for mod_info in modules
++                       if mod_info.ispkg and mod_info.name == segment]
++            modules = self.iter_submodules(modules)
++        return [module.name for module in modules
++                if module.name.startswith(prefix)]
++
++    def iter_submodules(self, parent_modules: list[pkgutil.ModuleInfo]) -> Iterator[pkgutil.ModuleInfo]:
++        """Iterate over all submodules of the given parent modules."""
++        specs = [info.module_finder.find_spec(info.name, None)
++                 for info in parent_modules if info.ispkg]
++        search_locations = set(chain.from_iterable(
++            getattr(spec, 'submodule_search_locations', [])
++            for spec in specs if spec
++        ))
++        return pkgutil.iter_modules(search_locations)
++
++    def get_path_and_prefix(self, dotted_name: str) -> tuple[str, str]:
++        """
++        Split a dotted name into an import path and a
++        final prefix that is to be completed.
++
++        Examples:
++            'foo.bar' -> 'foo', 'bar'
++            'foo.' -> 'foo', ''
++            '.foo' -> '.', 'foo'
++        """
++        if '.' not in dotted_name:
++            return '', dotted_name
++        if dotted_name.startswith('.'):
++            stripped = dotted_name.lstrip('.')
++            dots = '.' * (len(dotted_name) - len(stripped))
++            if '.' not in stripped:
++                return dots, stripped
++            path, prefix = stripped.rsplit('.', 1)
++            return dots + path, prefix
++        path, prefix = dotted_name.rsplit('.', 1)
++        return path, prefix
++
++    def format_completion(self, path: str, module: str) -> str:
++        if path == '' or path.endswith('.'):
++            return f'{path}{module}'
++        return f'{path}.{module}'
++
++    def resolve_relative_name(self, name: str, package: str) -> str | None:
++        """Resolve a relative module name to an absolute name.
++
++        Example: resolve_relative_name('.foo', 'bar') -> 'bar.foo'
++        """
++        # taken from importlib._bootstrap
++        level = 0
++        for character in name:
++            if character != '.':
++                break
++            level += 1
++        bits = package.rsplit('.', level - 1)
++        if len(bits) < level:
++            return None
++        base = bits[0]
++        name = name[level:]
++        return f'{base}.{name}' if name else base
++
++    @property
++    def global_cache(self) -> list[pkgutil.ModuleInfo]:
++        """Global module cache"""
++        if not self._global_cache or self._curr_sys_path != sys.path:
++            self._curr_sys_path = sys.path[:]
++            # print('getting packages')
++            self._global_cache = list(pkgutil.iter_modules())
++        return self._global_cache
++
++
++class ImportParser:
++    """
++    Parses incomplete import statements that are
++    suitable for autocomplete suggestions.
++
++    Examples:
++        - import foo          -> Result(from_name=None, name='foo')
++        - import foo.         -> Result(from_name=None, name='foo.')
++        - from foo            -> Result(from_name='foo', name=None)
++        - from foo import bar -> Result(from_name='foo', name='bar')
++        - from .foo import (  -> Result(from_name='.foo', name='')
++
++    Note that the parser works in reverse order, starting from the
++    last token in the input string. This makes the parser more robust
++    when parsing multiple statements.
++    """
++    _ignored_tokens = {
++        tokenize.INDENT, tokenize.DEDENT, tokenize.COMMENT,
++        tokenize.NL, tokenize.NEWLINE, tokenize.ENDMARKER
++    }
++    _keywords = {'import', 'from', 'as'}
++
++    def __init__(self, code: str) -> None:
++        self.code = code
++        tokens = []
++        try:
++            for t in tokenize.generate_tokens(StringIO(code).readline):
++                if t.type not in self._ignored_tokens:
++                    tokens.append(t)
++        except tokenize.TokenError as e:
++            if 'unexpected EOF' not in str(e):
++                # unexpected EOF is fine, since we're parsing an
++                # incomplete statement, but other errors are not
++                # because we may not have all the tokens so it's
++                # safer to bail out
++                tokens = []
++        except SyntaxError:
++            tokens = []
++        self.tokens = TokenQueue(tokens[::-1])
++
++    def parse(self) -> tuple[str | None, str | None] | None:
++        if not (res := self._parse()):
++            return None
++        return res.from_name, res.name
++
++    def _parse(self) -> Result | None:
++        with self.tokens.save_state():
++            return self.parse_from_import()
++        with self.tokens.save_state():
++            return self.parse_import()
++
++    def parse_import(self) -> Result:
++        if self.code.rstrip().endswith('import') and self.code.endswith(' '):
++            return Result(name='')
++        if self.tokens.peek_string(','):
++            name = ''
++        else:
++            if self.code.endswith(' '):
++                raise ParseError('parse_import')
++            name = self.parse_dotted_name()
++        if name.startswith('.'):
++            raise ParseError('parse_import')
++        while self.tokens.peek_string(','):
++            self.tokens.pop()
++            self.parse_dotted_as_name()
++        if self.tokens.peek_string('import'):
++            return Result(name=name)
++        raise ParseError('parse_import')
++
++    def parse_from_import(self) -> Result:
++        stripped = self.code.rstrip()
++        if stripped.endswith('import') and self.code.endswith(' '):
++            return Result(from_name=self.parse_empty_from_import(), name='')
++        if stripped.endswith('from') and self.code.endswith(' '):
++            return Result(from_name='')
++        if self.tokens.peek_string('(') or self.tokens.peek_string(','):
++            return Result(from_name=self.parse_empty_from_import(), name='')
++        if self.code.endswith(' '):
++            raise ParseError('parse_from_import')
++        name = self.parse_dotted_name()
++        if '.' in name:
++            self.tokens.pop_string('from')
++            return Result(from_name=name)
++        if self.tokens.peek_string('from'):
++            return Result(from_name=name)
++        from_name = self.parse_empty_from_import()
++        return Result(from_name=from_name, name=name)
++
++    def parse_empty_from_import(self) -> str:
++        if self.tokens.peek_string(','):
++            self.tokens.pop()
++            self.parse_as_names()
++        if self.tokens.peek_string('('):
++            self.tokens.pop()
++        self.tokens.pop_string('import')
++        return self.parse_from()
++
++    def parse_from(self) -> str:
++        from_name = self.parse_dotted_name()
++        self.tokens.pop_string('from')
++        return from_name
++
++    def parse_dotted_as_name(self) -> str:
++        self.tokens.pop_name()
++        if self.tokens.peek_string('as'):
++            self.tokens.pop()
++        with self.tokens.save_state():
++            return self.parse_dotted_name()
++
++    def parse_dotted_name(self) -> str:
++        name = []
++        if self.tokens.peek_string('.'):
++            name.append('.')
++            self.tokens.pop()
++        if (self.tokens.peek_name()
++            and (tok := self.tokens.peek())
++            and tok.string not in self._keywords):
++            name.append(self.tokens.pop_name())
++        if not name:
++            raise ParseError('parse_dotted_name')
++        while self.tokens.peek_string('.'):
++            name.append('.')
++            self.tokens.pop()
++            if (self.tokens.peek_name()
++                and (tok := self.tokens.peek())
++                and tok.string not in self._keywords):
++                name.append(self.tokens.pop_name())
++            else:
++                break
++
++        while self.tokens.peek_string('.'):
++            name.append('.')
++            self.tokens.pop()
++        return ''.join(name[::-1])
++
++    def parse_as_names(self) -> None:
++        self.parse_as_name()
++        while self.tokens.peek_string(','):
++            self.tokens.pop()
++            self.parse_as_name()
++
++    def parse_as_name(self) -> None:
++        self.tokens.pop_name()
++        if self.tokens.peek_string('as'):
++            self.tokens.pop()
++            self.tokens.pop_name()
++
++
++class ParseError(Exception):
++    pass
++
++
++@dataclass(frozen=True)
++class Result:
++    from_name: str | None = None
++    name: str | None = None
++
++
++class TokenQueue:
++    """Provides helper functions for working with a sequence of tokens."""
++
++    def __init__(self, tokens: list[TokenInfo]) -> None:
++        self.tokens: list[TokenInfo] = tokens
++        self.index: int = 0
++        self.stack: list[int] = []
++
++    @contextmanager
++    def save_state(self) -> Any:
++        try:
++            self.stack.append(self.index)
++            yield
++        except ParseError:
++            self.index = self.stack.pop()
++        else:
++            self.stack.pop()
++
++    def __bool__(self) -> bool:
++        return self.index < len(self.tokens)
++
++    def peek(self) -> TokenInfo | None:
++        if not self:
++            return None
++        return self.tokens[self.index]
++
++    def peek_name(self) -> bool:
++        if not (tok := self.peek()):
++            return False
++        return tok.type == tokenize.NAME
++
++    def pop_name(self) -> str:
++        tok = self.pop()
++        if tok.type != tokenize.NAME:
++            raise ParseError('pop_name')
++        return tok.string
++
++    def peek_string(self, string: str) -> bool:
++        if not (tok := self.peek()):
++            return False
++        return tok.string == string
++
++    def pop_string(self, string: str) -> str:
++        tok = self.pop()
++        if tok.string != string:
++            raise ParseError('pop_string')
++        return tok.string
++
++    def pop(self) -> TokenInfo:
++        if not self:
++            raise ParseError('pop')
++        tok = self.tokens[self.index]
++        self.index += 1
++        return tok
+diff --git a/Lib/_pyrepl/completing_reader.py b/Lib/_pyrepl/completing_reader.py
+index 9a005281dab..0fe72359a18 100644
+--- a/Lib/_pyrepl/completing_reader.py
++++ b/Lib/_pyrepl/completing_reader.py
+@@ -293,3 +293,7 @@ def get_stem(self) -> str:
+ 
+     def get_completions(self, stem: str) -> list[str]:
+         return []
++
++    def get_line(self) -> str:
++        """Return the current line until the cursor position."""
++        return ''.join(self.buffer[:self.pos])
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index be229488e54..27037f730c2 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -39,6 +39,7 @@
+ from . import commands, historical_reader
+ from .completing_reader import CompletingReader
+ from .console import Console as ConsoleType
++from ._module_completer import ModuleCompleter, make_default_module_completer
+ 
+ Console: type[ConsoleType]
+ _error: tuple[type[Exception], ...] | type[Exception]
+@@ -99,7 +100,7 @@
+ class ReadlineConfig:
+     readline_completer: Completer | None = None
+     completer_delims: frozenset[str] = frozenset(" \t\n`~!@#$%^&*()-=+[{]}\\|;:'\",<>/?")
+-
++    module_completer: ModuleCompleter = field(default_factory=make_default_module_completer)
+ 
+ @dataclass(kw_only=True)
+ class ReadlineAlikeReader(historical_reader.HistoricalReader, CompletingReader):
+@@ -132,6 +133,8 @@ def get_stem(self) -> str:
+         return "".join(b[p + 1 : self.pos])
+ 
+     def get_completions(self, stem: str) -> list[str]:
++        if module_completions := self.get_module_completions():
++            return module_completions
+         if len(stem) == 0 and self.more_lines is not None:
+             b = self.buffer
+             p = self.pos
+@@ -161,6 +164,10 @@ def get_completions(self, stem: str) -> list[str]:
+             result.sort()
+         return result
+ 
++    def get_module_completions(self) -> list[str]:
++        line = self.get_line()
++        return self.config.module_completer.get_completions(line)
++
+     def get_trimmed_history(self, maxlength: int) -> list[str]:
+         if maxlength >= 0:
+             cut = len(self.history) - maxlength
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 5e46e887912..a24570fafe3 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -25,6 +25,7 @@
+     code_to_events,
+ )
+ from _pyrepl.console import Event
++from _pyrepl._module_completer import ImportParser, ModuleCompleter
+ from _pyrepl.readline import (ReadlineAlikeReader, ReadlineConfig,
+                               _ReadlineWrapper)
+ from _pyrepl.readline import multiline_input as readline_multiline_input
+@@ -896,6 +897,203 @@ def test_func(self):
+         self.assertEqual(mock_stderr.getvalue(), "")
+ 
+ 
++class TestPyReplModuleCompleter(TestCase):
++    def setUp(self):
++        self._saved_sys_path = sys.path
++
++    def tearDown(self):
++        sys.path = self._saved_sys_path
++
++    def prepare_reader(self, events, namespace):
++        console = FakeConsole(events)
++        config = ReadlineConfig()
++        config.readline_completer = rlcompleter.Completer(namespace).complete
++        reader = ReadlineAlikeReader(console=console, config=config)
++        return reader
++
++    def test_import_completions(self):
++        import importlib
++        # Make iter_modules() search only the standard library.
++        # This makes the test more reliable in case there are
++        # other user packages/scripts on PYTHONPATH which can
++        # intefere with the completions.
++        lib_path = os.path.dirname(importlib.__path__[0])
++        sys.path = [lib_path]
++
++        cases = (
++            ("import path\t\n", "import pathlib"),
++            ("import importlib.\t\tres\t\n", "import importlib.resources"),
++            ("import importlib.resources.\t\ta\t\n", "import importlib.resources.abc"),
++            ("import foo, impo\t\n", "import foo, importlib"),
++            ("import foo as bar, impo\t\n", "import foo as bar, importlib"),
++            ("from impo\t\n", "from importlib"),
++            ("from importlib.res\t\n", "from importlib.resources"),
++            ("from importlib.\t\tres\t\n", "from importlib.resources"),
++            ("from importlib.resources.ab\t\n", "from importlib.resources.abc"),
++            ("from importlib import mac\t\n", "from importlib import machinery"),
++            ("from importlib import res\t\n", "from importlib import resources"),
++            ("from importlib.res\t import a\t\n", "from importlib.resources import abc"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
++    def test_relative_import_completions(self):
++        cases = (
++            ("from .readl\t\n", "from .readline"),
++            ("from . import readl\t\n", "from . import readline"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
++    @patch("pkgutil.iter_modules", lambda: [(None, 'valid_name', None),
++                                            (None, 'invalid-name', None)])
++    def test_invalid_identifiers(self):
++        # Make sure modules which are not valid identifiers
++        # are not suggested as those cannot be imported via 'import'.
++        cases = (
++            ("import valid\t\n", "import valid_name"),
++            # 'invalid-name' contains a dash and should not be completed
++            ("import invalid\t\n", "import invalid"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
++    def test_get_path_and_prefix(self):
++        cases = (
++            ('', ('', '')),
++            ('.', ('.', '')),
++            ('..', ('..', '')),
++            ('.foo', ('.', 'foo')),
++            ('..foo', ('..', 'foo')),
++            ('..foo.', ('..foo', '')),
++            ('..foo.bar', ('..foo', 'bar')),
++            ('.foo.bar.', ('.foo.bar', '')),
++            ('..foo.bar.', ('..foo.bar', '')),
++            ('foo', ('', 'foo')),
++            ('foo.', ('foo', '')),
++            ('foo.bar', ('foo', 'bar')),
++            ('foo.bar.', ('foo.bar', '')),
++            ('foo.bar.baz', ('foo.bar', 'baz')),
++        )
++        completer = ModuleCompleter()
++        for name, expected in cases:
++            with self.subTest(name=name):
++                self.assertEqual(completer.get_path_and_prefix(name), expected)
++
++    def test_parse(self):
++        cases = (
++            ('import ', (None, '')),
++            ('import foo', (None, 'foo')),
++            ('import foo,', (None, '')),
++            ('import foo, ', (None, '')),
++            ('import foo, bar', (None, 'bar')),
++            ('import foo, bar, baz', (None, 'baz')),
++            ('import foo as bar,', (None, '')),
++            ('import foo as bar, ', (None, '')),
++            ('import foo as bar, baz', (None, 'baz')),
++            ('import a.', (None, 'a.')),
++            ('import a.b', (None, 'a.b')),
++            ('import a.b.', (None, 'a.b.')),
++            ('import a.b.c', (None, 'a.b.c')),
++            ('import a.b.c, foo', (None, 'foo')),
++            ('import a.b.c, foo.bar', (None, 'foo.bar')),
++            ('import a.b.c, foo.bar,', (None, '')),
++            ('import a.b.c, foo.bar, ', (None, '')),
++            ('from foo', ('foo', None)),
++            ('from a.', ('a.', None)),
++            ('from a.b', ('a.b', None)),
++            ('from a.b.', ('a.b.', None)),
++            ('from a.b.c', ('a.b.c', None)),
++            ('from foo import ', ('foo', '')),
++            ('from foo import a', ('foo', 'a')),
++            ('from ', ('', None)),
++            ('from . import a', ('.', 'a')),
++            ('from .foo import a', ('.foo', 'a')),
++            ('from ..foo import a', ('..foo', 'a')),
++            ('from foo import (', ('foo', '')),
++            ('from foo import ( ', ('foo', '')),
++            ('from foo import (a', ('foo', 'a')),
++            ('from foo import (a,', ('foo', '')),
++            ('from foo import (a, ', ('foo', '')),
++            ('from foo import (a, c', ('foo', 'c')),
++            ('from foo import (a as b, c', ('foo', 'c')),
++        )
++        for code, parsed in cases:
++            parser = ImportParser(code)
++            actual = parser.parse()
++            with self.subTest(code=code):
++                self.assertEqual(actual, parsed)
++            # The parser should not get tripped up by any
++            # other preceding statements
++            code = f'import xyz\n{code}'
++            with self.subTest(code=code):
++                self.assertEqual(actual, parsed)
++            code = f'import xyz;{code}'
++            with self.subTest(code=code):
++                self.assertEqual(actual, parsed)
++
++    def test_parse_error(self):
++        cases = (
++            '',
++            'import foo ',
++            'from foo ',
++            'import foo. ',
++            'import foo.bar ',
++            'from foo ',
++            'from foo. ',
++            'from foo.bar ',
++            'from foo import bar ',
++            'from foo import (bar ',
++            'from foo import bar, baz ',
++            'import foo as',
++            'import a. as',
++            'import a.b as',
++            'import a.b. as',
++            'import a.b.c as',
++            'import (foo',
++            'import (',
++            'import .foo',
++            'import ..foo',
++            'import .foo.bar',
++            'import foo; x = 1',
++            'import a.; x = 1',
++            'import a.b; x = 1',
++            'import a.b.; x = 1',
++            'import a.b.c; x = 1',
++            'from foo import a as',
++            'from foo import a. as',
++            'from foo import a.b as',
++            'from foo import a.b. as',
++            'from foo import a.b.c as',
++            'from foo impo',
++            'import import',
++            'import from',
++            'import as',
++            'from import',
++            'from from',
++            'from as',
++            'from foo import import',
++            'from foo import from',
++            'from foo import as',
++        )
++        for code in cases:
++            parser = ImportParser(code)
++            actual = parser.parse()
++            with self.subTest(code=code):
++                self.assertEqual(actual, None)
++
+ class TestPasteEvent(TestCase):
+     def prepare_reader(self, events):
+         console = FakeConsole(events)
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-01-26-23-46-43.gh-issue-69605._2Qc1w.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-01-26-23-46-43.gh-issue-69605._2Qc1w.rst
+new file mode 100644
+index 00000000000..1f85be8bc61
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-01-26-23-46-43.gh-issue-69605._2Qc1w.rst
+@@ -0,0 +1 @@
++Add module autocomplete to PyREPL.
diff --git a/cpython/patches/1019-gh-127495-Append-to-history-file-after-every-stateme.patch b/cpython/patches/1019-gh-127495-Append-to-history-file-after-every-stateme.patch
new file mode 100644
index 00000000..ab7d939c
--- /dev/null
+++ b/cpython/patches/1019-gh-127495-Append-to-history-file-after-every-stateme.patch
@@ -0,0 +1,137 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Sergey B Kirpichev <skirpichev@gmail.com>
+Date: Sun, 27 Apr 2025 16:32:37 +0300
+Subject: [PATCH] gh-127495: Append to history file after every statement in
+ PyREPL (GH-132294)
+
+---
+ Lib/_pyrepl/readline.py                       | 16 ++++++++++++++
+ Lib/_pyrepl/simple_interact.py                |  7 +++++-
+ Lib/test/test_pyrepl/test_pyrepl.py           | 22 +++++++++++++++++++
+ ...-04-08-14-50-39.gh-issue-127495.Q0V0bS.rst |  3 +++
+ 4 files changed, 47 insertions(+), 1 deletion(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-04-08-14-50-39.gh-issue-127495.Q0V0bS.rst
+
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index 27037f730c2..9d58829faf1 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -90,6 +90,7 @@
+     # "set_pre_input_hook",
+     "set_startup_hook",
+     "write_history_file",
++    "append_history_file",
+     # ---- multiline extensions ----
+     "multiline_input",
+ ]
+@@ -453,6 +454,7 @@ def read_history_file(self, filename: str = gethistoryfile()) -> None:
+                         del buffer[:]
+                     if line:
+                         history.append(line)
++        self.set_history_length(self.get_current_history_length())
+ 
+     def write_history_file(self, filename: str = gethistoryfile()) -> None:
+         maxlength = self.saved_history_length
+@@ -464,6 +466,19 @@ def write_history_file(self, filename: str = gethistoryfile()) -> None:
+                 entry = entry.replace("\n", "\r\n")  # multiline history support
+                 f.write(entry + "\n")
+ 
++    def append_history_file(self, filename: str = gethistoryfile()) -> None:
++        reader = self.get_reader()
++        saved_length = self.get_history_length()
++        length = self.get_current_history_length() - saved_length
++        history = reader.get_trimmed_history(length)
++        f = open(os.path.expanduser(filename), "a",
++                 encoding="utf-8", newline="\n")
++        with f:
++            for entry in history:
++                entry = entry.replace("\n", "\r\n")  # multiline history support
++                f.write(entry + "\n")
++        self.set_history_length(saved_length + length)
++
+     def clear_history(self) -> None:
+         del self.get_reader().history[:]
+ 
+@@ -533,6 +548,7 @@ def insert_text(self, text: str) -> None:
+ get_current_history_length = _wrapper.get_current_history_length
+ read_history_file = _wrapper.read_history_file
+ write_history_file = _wrapper.write_history_file
++append_history_file = _wrapper.append_history_file
+ clear_history = _wrapper.clear_history
+ get_history_item = _wrapper.get_history_item
+ remove_history_item = _wrapper.remove_history_item
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index 57b37d34518..3b322ab6b6c 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -31,8 +31,9 @@
+ import os
+ import sys
+ import code
++import warnings
+ 
+-from .readline import _get_reader, multiline_input
++from .readline import _get_reader, multiline_input, append_history_file
+ 
+ 
+ _error: tuple[type[Exception], ...] | type[Exception]
+@@ -146,6 +147,10 @@ def maybe_run_command(statement: str) -> bool:
+             linecache._register_code(input_name, statement, "<stdin>")  # type: ignore[attr-defined]
+             more = console.push(_strip_final_indent(statement), filename=input_name, _symbol="single")  # type: ignore[call-arg]
+             assert not more
++            try:
++                append_history_file()
++            except (FileNotFoundError, PermissionError, OSError) as e:
++                warnings.warn(f"failed to open the history file for writing: {e}")
+             input_n += 1
+         except KeyboardInterrupt:
+             r = _get_reader()
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index a24570fafe3..6f9adac2277 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -112,6 +112,7 @@ def _run_repl(
+         else:
+             os.close(master_fd)
+             process.kill()
++            process.wait(timeout=SHORT_TIMEOUT)
+             self.fail(f"Timeout while waiting for output, got: {''.join(output)}")
+ 
+         os.close(master_fd)
+@@ -1563,6 +1564,27 @@ def test_readline_history_file(self):
+             self.assertEqual(exit_code, 0)
+             self.assertNotIn("\\040", pathlib.Path(hfile.name).read_text())
+ 
++    def test_history_survive_crash(self):
++        env = os.environ.copy()
++        commands = "1\nexit()\n"
++        output, exit_code = self.run_repl(commands, env=env)
++        if "can't use pyrepl" in output:
++            self.skipTest("pyrepl not available")
++
++        with tempfile.NamedTemporaryFile() as hfile:
++            env["PYTHON_HISTORY"] = hfile.name
++            commands = "spam\nimport time\ntime.sleep(1000)\npreved\n"
++            try:
++                self.run_repl(commands, env=env)
++            except AssertionError:
++                pass
++
++            history = pathlib.Path(hfile.name).read_text()
++            self.assertIn("spam", history)
++            self.assertIn("time", history)
++            self.assertNotIn("sleep", history)
++            self.assertNotIn("preved", history)
++
+     def test_keyboard_interrupt_after_isearch(self):
+         output, exit_code = self.run_repl(["\x12", "\x03", "exit"])
+         self.assertEqual(exit_code, 0)
+diff --git a/Misc/NEWS.d/next/Library/2025-04-08-14-50-39.gh-issue-127495.Q0V0bS.rst b/Misc/NEWS.d/next/Library/2025-04-08-14-50-39.gh-issue-127495.Q0V0bS.rst
+new file mode 100644
+index 00000000000..135d0f65117
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-04-08-14-50-39.gh-issue-127495.Q0V0bS.rst
+@@ -0,0 +1,3 @@
++In PyREPL, append a new entry to the ``PYTHON_HISTORY`` file *after* every
++statement.  This should preserve command-line history after interpreter is
++terminated.  Patch by Sergey B Kirpichev.
diff --git a/cpython/patches/1020-GH-130328-pasting-in-new-REPL-is-slow-on-Windows-GH-.patch b/cpython/patches/1020-GH-130328-pasting-in-new-REPL-is-slow-on-Windows-GH-.patch
new file mode 100644
index 00000000..344ea099
--- /dev/null
+++ b/cpython/patches/1020-GH-130328-pasting-in-new-REPL-is-slow-on-Windows-GH-.patch
@@ -0,0 +1,131 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Chris Eibl <138194463+chris-eibl@users.noreply.github.com>
+Date: Tue, 29 Apr 2025 18:03:45 +0200
+Subject: [PATCH] GH-130328: pasting in new REPL is slow on Windows (GH-132884)
+
+---
+ Lib/_pyrepl/windows_console.py                | 48 +++++++++++--------
+ ...-04-24-18-07-49.gh-issue-130328.z7CN8z.rst |  1 +
+ 2 files changed, 28 insertions(+), 21 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-04-24-18-07-49.gh-issue-130328.z7CN8z.rst
+
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index c874c922cea..5fe73a55711 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -22,8 +22,6 @@
+ import io
+ import os
+ import sys
+-import time
+-import msvcrt
+ 
+ import ctypes
+ from ctypes.wintypes import (
+@@ -44,7 +42,7 @@
+ from .windows_eventqueue import EventQueue
+ 
+ try:
+-    from ctypes import GetLastError, WinDLL, windll, WinError  # type: ignore[attr-defined]
++    from ctypes import get_last_error, GetLastError, WinDLL, windll, WinError  # type: ignore[attr-defined]
+ except:
+     # Keep MyPy happy off Windows
+     from ctypes import CDLL as WinDLL, cdll as windll
+@@ -52,6 +50,9 @@
+     def GetLastError() -> int:
+         return 42
+ 
++    def get_last_error() -> int:
++        return 42
++
+     class WinError(OSError):  # type: ignore[no-redef]
+         def __init__(self, err: int | None, descr: str | None = None) -> None:
+             self.err = err
+@@ -108,6 +109,12 @@ def __init__(self, err: int | None, descr: str | None = None) -> None:
+ ALT_ACTIVE = 0x01 | 0x02
+ CTRL_ACTIVE = 0x04 | 0x08
+ 
++WAIT_TIMEOUT = 0x102
++WAIT_FAILED = 0xFFFFFFFF
++
++# from winbase.h
++INFINITE = 0xFFFFFFFF
++
+ 
+ class _error(Exception):
+     pass
+@@ -409,12 +416,8 @@ def _getscrollbacksize(self) -> int:
+         return info.srWindow.Bottom  # type: ignore[no-any-return]
+ 
+     def _read_input(self, block: bool = True) -> INPUT_RECORD | None:
+-        if not block:
+-            events = DWORD()
+-            if not GetNumberOfConsoleInputEvents(InHandle, events):
+-                raise WinError(GetLastError())
+-            if not events.value:
+-                return None
++        if not block and not self.wait(timeout=0):
++            return None
+ 
+         rec = INPUT_RECORD()
+         read = DWORD()
+@@ -522,14 +525,16 @@ def getpending(self) -> Event:
+ 
+     def wait(self, timeout: float | None) -> bool:
+         """Wait for an event."""
+-        # Poor man's Windows select loop
+-        start_time = time.time()
+-        while True:
+-            if msvcrt.kbhit(): # type: ignore[attr-defined]
+-                return True
+-            if timeout and time.time() - start_time > timeout / 1000:
+-                return False
+-            time.sleep(0.01)
++        if timeout is None:
++            timeout = INFINITE
++        else:
++            timeout = int(timeout)
++        ret = WaitForSingleObject(InHandle, timeout)
++        if ret == WAIT_FAILED:
++            raise WinError(get_last_error())
++        elif ret == WAIT_TIMEOUT:
++            return False
++        return True
+ 
+     def repaint(self) -> None:
+         raise NotImplementedError("No repaint support")
+@@ -649,14 +654,15 @@ class INPUT_RECORD(Structure):
+     ReadConsoleInput.argtypes = [HANDLE, POINTER(INPUT_RECORD), DWORD, POINTER(DWORD)]
+     ReadConsoleInput.restype = BOOL
+ 
+-    GetNumberOfConsoleInputEvents = _KERNEL32.GetNumberOfConsoleInputEvents
+-    GetNumberOfConsoleInputEvents.argtypes = [HANDLE, POINTER(DWORD)]
+-    GetNumberOfConsoleInputEvents.restype = BOOL
+ 
+     FlushConsoleInputBuffer = _KERNEL32.FlushConsoleInputBuffer
+     FlushConsoleInputBuffer.argtypes = [HANDLE]
+     FlushConsoleInputBuffer.restype = BOOL
+ 
++    WaitForSingleObject = _KERNEL32.WaitForSingleObject
++    WaitForSingleObject.argtypes = [HANDLE, DWORD]
++    WaitForSingleObject.restype = DWORD
++
+     OutHandle = GetStdHandle(STD_OUTPUT_HANDLE)
+     InHandle = GetStdHandle(STD_INPUT_HANDLE)
+ else:
+@@ -670,7 +676,7 @@ def _win_only(*args, **kwargs):
+     GetConsoleMode = _win_only
+     SetConsoleMode = _win_only
+     ReadConsoleInput = _win_only
+-    GetNumberOfConsoleInputEvents = _win_only
+     FlushConsoleInputBuffer = _win_only
++    WaitForSingleObject = _win_only
+     OutHandle = 0
+     InHandle = 0
+diff --git a/Misc/NEWS.d/next/Library/2025-04-24-18-07-49.gh-issue-130328.z7CN8z.rst b/Misc/NEWS.d/next/Library/2025-04-24-18-07-49.gh-issue-130328.z7CN8z.rst
+new file mode 100644
+index 00000000000..f53b2bd3512
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-04-24-18-07-49.gh-issue-130328.z7CN8z.rst
+@@ -0,0 +1 @@
++Speedup pasting in ``PyREPL`` on Windows. Fix by Chris Eibl.
diff --git a/cpython/patches/1021-gh-131507-Add-support-for-syntax-highlighting-in-PyR.patch b/cpython/patches/1021-gh-131507-Add-support-for-syntax-highlighting-in-PyR.patch
new file mode 100644
index 00000000..ddc81a32
--- /dev/null
+++ b/cpython/patches/1021-gh-131507-Add-support-for-syntax-highlighting-in-PyR.patch
@@ -0,0 +1,1124 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C5=81ukasz=20Langa?= <lukasz@langa.pl>
+Date: Fri, 2 May 2025 20:22:31 +0200
+Subject: [PATCH] gh-131507: Add support for syntax highlighting in PyREPL
+ (GH-133247)
+
+Co-authored-by: Victorien <65306057+Viicos@users.noreply.github.com>
+Co-authored-by: Hugo van Kemenade <1324225+hugovk@users.noreply.github.com>
+---
+ Lib/_colorize.py                              |  43 ++-
+ Lib/_pyrepl/_module_completer.py              |   9 +-
+ Lib/_pyrepl/commands.py                       |  27 +-
+ Lib/_pyrepl/mypy.ini                          |   4 -
+ Lib/_pyrepl/reader.py                         |  49 +--
+ Lib/_pyrepl/readline.py                       |   4 -
+ Lib/_pyrepl/simple_interact.py                |   1 -
+ Lib/_pyrepl/unix_console.py                   |  20 +-
+ Lib/_pyrepl/utils.py                          | 291 +++++++++++++++++-
+ Lib/_pyrepl/windows_console.py                |  32 +-
+ Lib/test/test_pyrepl/test_reader.py           | 149 ++++++++-
+ Lib/test/test_pyrepl/test_unix_console.py     |   4 +-
+ Lib/test/test_pyrepl/test_windows_console.py  |  17 +-
+ Lib/token.py                                  |   6 +-
+ ...-03-21-19-03-42.gh-issue-131507.q9fvyM.rst |   1 +
+ Misc/mypy/token.py                            |   1 +
+ Tools/build/generate_token.py                 |   6 +-
+ 17 files changed, 577 insertions(+), 87 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-03-21-19-03-42.gh-issue-131507.q9fvyM.rst
+ create mode 120000 Misc/mypy/token.py
+
+diff --git a/Lib/_colorize.py b/Lib/_colorize.py
+index 9eb6f0933b8..d2d879b659c 100644
+--- a/Lib/_colorize.py
++++ b/Lib/_colorize.py
+@@ -7,7 +7,22 @@
+ 
+ # types
+ if False:
+-    from typing import IO
++    from typing import IO, Literal
++
++    type ColorTag = Literal[
++        "PROMPT",
++        "KEYWORD",
++        "BUILTIN",
++        "COMMENT",
++        "STRING",
++        "NUMBER",
++        "OP",
++        "DEFINITION",
++        "SOFT_KEYWORD",
++        "RESET",
++    ]
++
++    theme: dict[ColorTag, str]
+ 
+ 
+ class ANSIColors:
+@@ -22,6 +37,7 @@ class ANSIColors:
+     WHITE = "\x1b[37m"  # more like LIGHT GRAY
+     YELLOW = "\x1b[33m"
+ 
++    BOLD = "\x1b[1m"
+     BOLD_BLACK = "\x1b[1;30m"  # DARK GRAY
+     BOLD_BLUE = "\x1b[1;34m"
+     BOLD_CYAN = "\x1b[1;36m"
+@@ -110,3 +126,28 @@ def can_colorize(*, file: IO[str] | IO[bytes] | None = None) -> bool:
+         return os.isatty(file.fileno())
+     except io.UnsupportedOperation:
+         return hasattr(file, "isatty") and file.isatty()
++
++
++def set_theme(t: dict[ColorTag, str] | None = None) -> None:
++    global theme
++
++    if t:
++        theme = t
++        return
++
++    colors = get_colors()
++    theme = {
++        "PROMPT": colors.BOLD_MAGENTA,
++        "KEYWORD": colors.BOLD_BLUE,
++        "BUILTIN": colors.CYAN,
++        "COMMENT": colors.RED,
++        "STRING": colors.GREEN,
++        "NUMBER": colors.YELLOW,
++        "OP": colors.RESET,
++        "DEFINITION": colors.BOLD,
++        "SOFT_KEYWORD": colors.BOLD_BLUE,
++        "RESET": colors.RESET,
++    }
++
++
++set_theme()
+diff --git a/Lib/_pyrepl/_module_completer.py b/Lib/_pyrepl/_module_completer.py
+index 1fb043e0b70..347f05607c7 100644
+--- a/Lib/_pyrepl/_module_completer.py
++++ b/Lib/_pyrepl/_module_completer.py
+@@ -2,6 +2,7 @@
+ 
+ import pkgutil
+ import sys
++import token
+ import tokenize
+ from io import StringIO
+ from contextlib import contextmanager
+@@ -180,8 +181,8 @@ class ImportParser:
+     when parsing multiple statements.
+     """
+     _ignored_tokens = {
+-        tokenize.INDENT, tokenize.DEDENT, tokenize.COMMENT,
+-        tokenize.NL, tokenize.NEWLINE, tokenize.ENDMARKER
++        token.INDENT, token.DEDENT, token.COMMENT,
++        token.NL, token.NEWLINE, token.ENDMARKER
+     }
+     _keywords = {'import', 'from', 'as'}
+ 
+@@ -350,11 +351,11 @@ def peek(self) -> TokenInfo | None:
+     def peek_name(self) -> bool:
+         if not (tok := self.peek()):
+             return False
+-        return tok.type == tokenize.NAME
++        return tok.type == token.NAME
+ 
+     def pop_name(self) -> str:
+         tok = self.pop()
+-        if tok.type != tokenize.NAME:
++        if tok.type != token.NAME:
+             raise ParseError('pop_name')
+         return tok.string
+ 
+diff --git a/Lib/_pyrepl/commands.py b/Lib/_pyrepl/commands.py
+index cbb6d85f683..2054a8e400f 100644
+--- a/Lib/_pyrepl/commands.py
++++ b/Lib/_pyrepl/commands.py
+@@ -21,6 +21,7 @@
+ 
+ from __future__ import annotations
+ import os
++import time
+ 
+ # Categories of actions:
+ #  killing
+@@ -31,6 +32,7 @@
+ #  finishing
+ # [completion]
+ 
++from .trace import trace
+ 
+ # types
+ if False:
+@@ -471,19 +473,24 @@ def do(self) -> None:
+ 
+ 
+ class paste_mode(Command):
+-
+     def do(self) -> None:
+         self.reader.paste_mode = not self.reader.paste_mode
+         self.reader.dirty = True
+ 
+ 
+-class enable_bracketed_paste(Command):
++class perform_bracketed_paste(Command):
+     def do(self) -> None:
+-        self.reader.paste_mode = True
+-        self.reader.in_bracketed_paste = True
+-
+-class disable_bracketed_paste(Command):
+-    def do(self) -> None:
+-        self.reader.paste_mode = False
+-        self.reader.in_bracketed_paste = False
+-        self.reader.dirty = True
++        done = "\x1b[201~"
++        data = ""
++        start = time.time()
++        while done not in data:
++            self.reader.console.wait(100)
++            ev = self.reader.console.getpending()
++            data += ev.data
++        trace(
++            "bracketed pasting of {l} chars done in {s:.2f}s",
++            l=len(data),
++            s=time.time() - start,
++        )
++        self.reader.insert(data.replace(done, ""))
++        self.reader.last_refresh_cache.invalidated = True
+diff --git a/Lib/_pyrepl/mypy.ini b/Lib/_pyrepl/mypy.ini
+index eabd0e9b440..9375a55b53c 100644
+--- a/Lib/_pyrepl/mypy.ini
++++ b/Lib/_pyrepl/mypy.ini
+@@ -23,7 +23,3 @@ check_untyped_defs = False
+ # Various internal modules that typeshed deliberately doesn't have stubs for:
+ [mypy-_abc.*,_opcode.*,_overlapped.*,_testcapi.*,_testinternalcapi.*,test.*]
+ ignore_missing_imports = True
+-
+-# Other untyped parts of the stdlib
+-[mypy-idlelib.*]
+-ignore_missing_imports = True
+diff --git a/Lib/_pyrepl/reader.py b/Lib/_pyrepl/reader.py
+index 7fc2422dac9..65c2230dfd6 100644
+--- a/Lib/_pyrepl/reader.py
++++ b/Lib/_pyrepl/reader.py
+@@ -22,14 +22,13 @@
+ from __future__ import annotations
+ 
+ import sys
++import _colorize
+ 
+ from contextlib import contextmanager
+ from dataclasses import dataclass, field, fields
+-from _colorize import can_colorize, ANSIColors
+-
+ 
+ from . import commands, console, input
+-from .utils import wlen, unbracket, disp_str
++from .utils import wlen, unbracket, disp_str, gen_colors
+ from .trace import trace
+ 
+ 
+@@ -38,8 +37,7 @@
+ from .types import Callback, SimpleContextManager, KeySpec, CommandName
+ 
+ 
+-# syntax classes:
+-
++# syntax classes
+ SYNTAX_WHITESPACE, SYNTAX_WORD, SYNTAX_SYMBOL = range(3)
+ 
+ 
+@@ -105,8 +103,7 @@ def make_default_commands() -> dict[CommandName, type[Command]]:
+         (r"\M-9", "digit-arg"),
+         (r"\M-\n", "accept"),
+         ("\\\\", "self-insert"),
+-        (r"\x1b[200~", "enable_bracketed_paste"),
+-        (r"\x1b[201~", "disable_bracketed_paste"),
++        (r"\x1b[200~", "perform-bracketed-paste"),
+         (r"\x03", "ctrl-c"),
+     ]
+     + [(c, "self-insert") for c in map(chr, range(32, 127)) if c != "\\"]
+@@ -144,16 +141,17 @@ class Reader:
+     Instance variables of note include:
+ 
+       * buffer:
+-        A *list* (*not* a string at the moment :-) containing all the
+-        characters that have been entered.
++        A per-character list containing all the characters that have been
++        entered. Does not include color information.
+       * console:
+         Hopefully encapsulates the OS dependent stuff.
+       * pos:
+         A 0-based index into 'buffer' for where the insertion point
+         is.
+       * screeninfo:
+-        Ahem.  This list contains some info needed to move the
+-        insertion point around reasonably efficiently.
++        A list of screen position tuples. Each list element is a tuple
++        representing information on visible line length for a given line.
++        Allows for efficient skipping of color escape sequences.
+       * cxy, lxy:
+         the position of the insertion point in screen ...
+       * syntax_table:
+@@ -203,7 +201,6 @@ class Reader:
+     dirty: bool = False
+     finished: bool = False
+     paste_mode: bool = False
+-    in_bracketed_paste: bool = False
+     commands: dict[str, type[Command]] = field(default_factory=make_default_commands)
+     last_command: type[Command] | None = None
+     syntax_table: dict[str, int] = field(default_factory=make_default_syntax_table)
+@@ -221,7 +218,6 @@ class Reader:
+     ## cached metadata to speed up screen refreshes
+     @dataclass
+     class RefreshCache:
+-        in_bracketed_paste: bool = False
+         screen: list[str] = field(default_factory=list)
+         screeninfo: list[tuple[int, list[int]]] = field(init=False)
+         line_end_offsets: list[int] = field(default_factory=list)
+@@ -235,7 +231,6 @@ def update_cache(self,
+                          screen: list[str],
+                          screeninfo: list[tuple[int, list[int]]],
+             ) -> None:
+-            self.in_bracketed_paste = reader.in_bracketed_paste
+             self.screen = screen.copy()
+             self.screeninfo = screeninfo.copy()
+             self.pos = reader.pos
+@@ -248,8 +243,7 @@ def valid(self, reader: Reader) -> bool:
+                 return False
+             dimensions = reader.console.width, reader.console.height
+             dimensions_changed = dimensions != self.dimensions
+-            paste_changed = reader.in_bracketed_paste != self.in_bracketed_paste
+-            return not (dimensions_changed or paste_changed)
++            return not dimensions_changed
+ 
+         def get_cached_location(self, reader: Reader) -> tuple[int, int]:
+             if self.invalidated:
+@@ -279,7 +273,7 @@ def __post_init__(self) -> None:
+         self.screeninfo = [(0, [])]
+         self.cxy = self.pos2xy()
+         self.lxy = (self.pos, 0)
+-        self.can_colorize = can_colorize()
++        self.can_colorize = _colorize.can_colorize()
+ 
+         self.last_refresh_cache.screeninfo = self.screeninfo
+         self.last_refresh_cache.pos = self.pos
+@@ -316,6 +310,12 @@ def calc_screen(self) -> list[str]:
+         pos -= offset
+ 
+         prompt_from_cache = (offset and self.buffer[offset - 1] != "\n")
++
++        if self.can_colorize:
++            colors = list(gen_colors(self.get_unicode()))
++        else:
++            colors = None
++        trace("colors = {colors}", colors=colors)
+         lines = "".join(self.buffer[offset:]).split("\n")
+         cursor_found = False
+         lines_beyond_cursor = 0
+@@ -343,9 +343,8 @@ def calc_screen(self) -> list[str]:
+                 screeninfo.append((0, []))
+             pos -= line_len + 1
+             prompt, prompt_len = self.process_prompt(prompt)
+-            chars, char_widths = disp_str(line)
++            chars, char_widths = disp_str(line, colors, offset)
+             wrapcount = (sum(char_widths) + prompt_len) // self.console.width
+-            trace("wrapcount = {wrapcount}", wrapcount=wrapcount)
+             if wrapcount == 0 or not char_widths:
+                 offset += line_len + 1  # Takes all of the line plus the newline
+                 last_refresh_line_end_offsets.append(offset)
+@@ -479,7 +478,7 @@ def get_prompt(self, lineno: int, cursor_on_line: bool) -> str:
+         'lineno'."""
+         if self.arg is not None and cursor_on_line:
+             prompt = f"(arg: {self.arg}) "
+-        elif self.paste_mode and not self.in_bracketed_paste:
++        elif self.paste_mode:
+             prompt = "(paste) "
+         elif "\n" in self.buffer:
+             if lineno == 0:
+@@ -492,7 +491,11 @@ def get_prompt(self, lineno: int, cursor_on_line: bool) -> str:
+             prompt = self.ps1
+ 
+         if self.can_colorize:
+-            prompt = f"{ANSIColors.BOLD_MAGENTA}{prompt}{ANSIColors.RESET}"
++            prompt = (
++                f"{_colorize.theme["PROMPT"]}"
++                f"{prompt}"
++                f"{_colorize.theme["RESET"]}"
++            )
+         return prompt
+ 
+     def push_input_trans(self, itrans: input.KeymapTranslator) -> None:
+@@ -567,6 +570,7 @@ def insert(self, text: str | list[str]) -> None:
+     def update_cursor(self) -> None:
+         """Move the cursor to reflect changes in self.pos"""
+         self.cxy = self.pos2xy()
++        trace("update_cursor({pos}) = {cxy}", pos=self.pos, cxy=self.cxy)
+         self.console.move_cursor(*self.cxy)
+ 
+     def after_command(self, cmd: Command) -> None:
+@@ -633,9 +637,6 @@ def update_screen(self) -> None:
+ 
+     def refresh(self) -> None:
+         """Recalculate and refresh the screen."""
+-        if self.in_bracketed_paste and self.buffer and not self.buffer[-1] == "\n":
+-            return
+-
+         # this call sets up self.cxy, so call it first.
+         self.screen = self.calc_screen()
+         self.console.refresh(self.screen, self.cxy)
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index 9d58829faf1..560a9db1921 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -276,10 +276,6 @@ def do(self) -> None:
+         r = self.reader  # type: ignore[assignment]
+         r.dirty = True  # this is needed to hide the completion menu, if visible
+ 
+-        if self.reader.in_bracketed_paste:
+-            r.insert("\n")
+-            return
+-
+         # if there are already several lines and the cursor
+         # is not on the last one, always insert a new \n.
+         text = r.get_unicode()
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index 3b322ab6b6c..80bd38444d1 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -159,7 +159,6 @@ def maybe_run_command(statement: str) -> bool:
+             r.pos = len(r.get_unicode())
+             r.dirty = True
+             r.refresh()
+-            r.in_bracketed_paste = False
+             console.write("\nKeyboardInterrupt\n")
+             console.resetbuffer()
+         except MemoryError:
+diff --git a/Lib/_pyrepl/unix_console.py b/Lib/_pyrepl/unix_console.py
+index ca816e6b9a3..00018b493be 100644
+--- a/Lib/_pyrepl/unix_console.py
++++ b/Lib/_pyrepl/unix_console.py
+@@ -150,8 +150,6 @@ def __init__(
+ 
+         self.pollob = poll()
+         self.pollob.register(self.input_fd, select.POLLIN)
+-        self.input_buffer = b""
+-        self.input_buffer_pos = 0
+         curses.setupterm(term or None, self.output_fd)
+         self.term = term
+ 
+@@ -199,22 +197,8 @@ def _my_getstr(cap: str, optional: bool = False) -> bytes | None:
+         self.event_queue = EventQueue(self.input_fd, self.encoding)
+         self.cursor_visible = 1
+ 
+-    def more_in_buffer(self) -> bool:
+-        return bool(
+-            self.input_buffer
+-            and self.input_buffer_pos < len(self.input_buffer)
+-        )
+-
+     def __read(self, n: int) -> bytes:
+-        if not self.more_in_buffer():
+-            self.input_buffer = os.read(self.input_fd, 10000)
+-
+-        ret = self.input_buffer[self.input_buffer_pos : self.input_buffer_pos + n]
+-        self.input_buffer_pos += len(ret)
+-        if self.input_buffer_pos >= len(self.input_buffer):
+-            self.input_buffer = b""
+-            self.input_buffer_pos = 0
+-        return ret
++        return os.read(self.input_fd, n)
+ 
+ 
+     def change_encoding(self, encoding: str) -> None:
+@@ -422,7 +406,6 @@ def wait(self, timeout: float | None = None) -> bool:
+         """
+         return (
+             not self.event_queue.empty()
+-            or self.more_in_buffer()
+             or bool(self.pollob.poll(timeout))
+         )
+ 
+@@ -525,6 +508,7 @@ def getpending(self):
+                 e.raw += e.raw
+ 
+             amount = struct.unpack("i", ioctl(self.input_fd, FIONREAD, b"\0\0\0\0"))[0]
++            trace("getpending({a})", a=amount)
+             raw = self.__read(amount)
+             data = str(raw, self.encoding, "replace")
+             e.data += data
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 7437fbe1ab9..1b46c3e5799 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -1,6 +1,17 @@
+-import re
+-import unicodedata
++from __future__ import annotations
++import builtins
+ import functools
++import keyword
++import re
++import token as T
++import tokenize
++import unicodedata
++import _colorize
++
++from collections import deque
++from io import StringIO
++from tokenize import TokenInfo as TI
++from typing import Iterable, Iterator, Match, NamedTuple, Self
+ 
+ from .types import CharBuffer, CharWidths
+ from .trace import trace
+@@ -8,6 +19,32 @@
+ ANSI_ESCAPE_SEQUENCE = re.compile(r"\x1b\[[ -@]*[A-~]")
+ ZERO_WIDTH_BRACKET = re.compile(r"\x01.*?\x02")
+ ZERO_WIDTH_TRANS = str.maketrans({"\x01": "", "\x02": ""})
++IDENTIFIERS_AFTER = {"def", "class"}
++BUILTINS = {str(name) for name in dir(builtins) if not name.startswith('_')}
++
++
++class Span(NamedTuple):
++    """Span indexing that's inclusive on both ends."""
++
++    start: int
++    end: int
++
++    @classmethod
++    def from_re(cls, m: Match[str], group: int | str) -> Self:
++        re_span = m.span(group)
++        return cls(re_span[0], re_span[1] - 1)
++
++    @classmethod
++    def from_token(cls, token: TI, line_len: list[int]) -> Self:
++        return cls(
++            line_len[token.start[0] - 1] + token.start[1],
++            line_len[token.end[0] - 1] + token.end[1] - 1,
++        )
++
++
++class ColorSpan(NamedTuple):
++    span: Span
++    tag: _colorize.ColorTag
+ 
+ 
+ @functools.cache
+@@ -41,17 +78,206 @@ def unbracket(s: str, including_content: bool = False) -> str:
+     return s.translate(ZERO_WIDTH_TRANS)
+ 
+ 
+-def disp_str(buffer: str) -> tuple[CharBuffer, CharWidths]:
+-    r"""Decompose the input buffer into a printable variant.
++def gen_colors(buffer: str) -> Iterator[ColorSpan]:
++    """Returns a list of index spans to color using the given color tag.
++
++    The input `buffer` should be a valid start of a Python code block, i.e.
++    it cannot be a block starting in the middle of a multiline string.
++    """
++    sio = StringIO(buffer)
++    line_lengths = [0] + [len(line) for line in sio.readlines()]
++    # make line_lengths cumulative
++    for i in range(1, len(line_lengths)):
++        line_lengths[i] += line_lengths[i-1]
++
++    sio.seek(0)
++    gen = tokenize.generate_tokens(sio.readline)
++    last_emitted: ColorSpan | None = None
++    try:
++        for color in gen_colors_from_token_stream(gen, line_lengths):
++            yield color
++            last_emitted = color
++    except tokenize.TokenError as te:
++        yield from recover_unterminated_string(
++            te, line_lengths, last_emitted, buffer
++        )
++
++
++def recover_unterminated_string(
++    exc: tokenize.TokenError,
++    line_lengths: list[int],
++    last_emitted: ColorSpan | None,
++    buffer: str,
++) -> Iterator[ColorSpan]:
++    msg, loc = exc.args
++    if loc is None:
++        return
++
++    line_no, column = loc
++
++    if msg.startswith(
++        (
++            "unterminated string literal",
++            "unterminated f-string literal",
++            "unterminated t-string literal",
++            "EOF in multi-line string",
++            "unterminated triple-quoted f-string literal",
++            "unterminated triple-quoted t-string literal",
++        )
++    ):
++        start = line_lengths[line_no - 1] + column - 1
++        end = line_lengths[-1] - 1
++
++        # in case FSTRING_START was already emitted
++        if last_emitted and start <= last_emitted.span.start:
++            trace("before last emitted = {s}", s=start)
++            start = last_emitted.span.end + 1
++
++        span = Span(start, end)
++        trace("yielding span {a} -> {b}", a=span.start, b=span.end)
++        yield ColorSpan(span, "STRING")
++    else:
++        trace(
++            "unhandled token error({buffer}) = {te}",
++            buffer=repr(buffer),
++            te=str(exc),
++        )
++
++
++def gen_colors_from_token_stream(
++    token_generator: Iterator[TI],
++    line_lengths: list[int],
++) -> Iterator[ColorSpan]:
++    token_window = prev_next_window(token_generator)
++
++    is_def_name = False
++    bracket_level = 0
++    for prev_token, token, next_token in token_window:
++        assert token is not None
++        if token.start == token.end:
++            continue
++
++        match token.type:
++            case (
++                T.STRING
++                | T.FSTRING_START | T.FSTRING_MIDDLE | T.FSTRING_END
++            ):
++                span = Span.from_token(token, line_lengths)
++                yield ColorSpan(span, "STRING")
++            case T.COMMENT:
++                span = Span.from_token(token, line_lengths)
++                yield ColorSpan(span, "COMMENT")
++            case T.NUMBER:
++                span = Span.from_token(token, line_lengths)
++                yield ColorSpan(span, "NUMBER")
++            case T.OP:
++                if token.string in "([{":
++                    bracket_level += 1
++                elif token.string in ")]}":
++                    bracket_level -= 1
++                span = Span.from_token(token, line_lengths)
++                yield ColorSpan(span, "OP")
++            case T.NAME:
++                if is_def_name:
++                    is_def_name = False
++                    span = Span.from_token(token, line_lengths)
++                    yield ColorSpan(span, "DEFINITION")
++                elif keyword.iskeyword(token.string):
++                    span = Span.from_token(token, line_lengths)
++                    yield ColorSpan(span, "KEYWORD")
++                    if token.string in IDENTIFIERS_AFTER:
++                        is_def_name = True
++                elif (
++                    keyword.issoftkeyword(token.string)
++                    and bracket_level == 0
++                    and is_soft_keyword_used(prev_token, token, next_token)
++                ):
++                    span = Span.from_token(token, line_lengths)
++                    yield ColorSpan(span, "SOFT_KEYWORD")
++                elif token.string in BUILTINS:
++                    span = Span.from_token(token, line_lengths)
++                    yield ColorSpan(span, "BUILTIN")
++
++
++keyword_first_sets_match = {"False", "None", "True", "await", "lambda", "not"}
++keyword_first_sets_case = {"False", "None", "True"}
++
++
++def is_soft_keyword_used(*tokens: TI | None) -> bool:
++    """Returns True if the current token is a keyword in this context.
++
++    For the `*tokens` to match anything, they have to be a three-tuple of
++    (previous, current, next).
++    """
++    trace("is_soft_keyword_used{t}", t=tokens)
++    match tokens:
++        case (
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            TI(string="match"),
++            TI(T.NUMBER | T.STRING | T.FSTRING_START)
++            | TI(T.OP, string="(" | "*" | "[" | "{" | "~" | "...")
++        ):
++            return True
++        case (
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            TI(string="match"),
++            TI(T.NAME, string=s)
++        ):
++            if keyword.iskeyword(s):
++                return s in keyword_first_sets_match
++            return True
++        case (
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            TI(string="case"),
++            TI(T.NUMBER | T.STRING | T.FSTRING_START)
++            | TI(T.OP, string="(" | "*" | "-" | "[" | "{")
++        ):
++            return True
++        case (
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            TI(string="case"),
++            TI(T.NAME, string=s)
++        ):
++            if keyword.iskeyword(s):
++                return s in keyword_first_sets_case
++            return True
++        case (TI(string="case"), TI(string="_"), TI(string=":")):
++            return True
++        case _:
++            return False
++
++
++def disp_str(
++    buffer: str, colors: list[ColorSpan] | None = None, start_index: int = 0
++) -> tuple[CharBuffer, CharWidths]:
++    r"""Decompose the input buffer into a printable variant with applied colors.
+ 
+     Returns a tuple of two lists:
+-    - the first list is the input buffer, character by character;
++    - the first list is the input buffer, character by character, with color
++      escape codes added (while those codes contain multiple ASCII characters,
++      each code is considered atomic *and is attached for the corresponding
++      visible character*);
+     - the second list is the visible width of each character in the input
+       buffer.
+ 
++    Note on colors:
++    - The `colors` list, if provided, is partially consumed within. We're using
++      a list and not a generator since we need to hold onto the current
++      unfinished span between calls to disp_str in case of multiline strings.
++    - The `colors` list is computed from the start of the input block. `buffer`
++      is only a subset of that input block, a single line within. This is why
++      we need `start_index` to inform us which position is the start of `buffer`
++      actually within user input. This allows us to match color spans correctly.
++
+     Examples:
+     >>> utils.disp_str("a = 9")
+     (['a', ' ', '=', ' ', '9'], [1, 1, 1, 1, 1])
++
++    >>> line = "while 1:"
++    >>> colors = list(utils.gen_colors(line))
++    >>> utils.disp_str(line, colors=colors)
++    (['\x1b[1;34mw', 'h', 'i', 'l', 'e\x1b[0m', ' ', '1', ':'], [1, 1, 1, 1, 1, 1, 1, 1])
++
+     """
+     chars: CharBuffer = []
+     char_widths: CharWidths = []
+@@ -59,7 +285,20 @@ def disp_str(buffer: str) -> tuple[CharBuffer, CharWidths]:
+     if not buffer:
+         return chars, char_widths
+ 
+-    for c in buffer:
++    while colors and colors[0].span.end < start_index:
++        # move past irrelevant spans
++        colors.pop(0)
++
++    pre_color = ""
++    post_color = ""
++    if colors and colors[0].span.start < start_index:
++        # looks like we're continuing a previous color (e.g. a multiline str)
++        pre_color = _colorize.theme[colors[0].tag]
++
++    for i, c in enumerate(buffer, start_index):
++        if colors and colors[0].span.start == i:  # new color starts now
++            pre_color = _colorize.theme[colors[0].tag]
++
+         if c == "\x1a":  # CTRL-Z on Windows
+             chars.append(c)
+             char_widths.append(2)
+@@ -73,5 +312,43 @@ def disp_str(buffer: str) -> tuple[CharBuffer, CharWidths]:
+         else:
+             chars.append(c)
+             char_widths.append(str_width(c))
+-    trace("disp_str({buffer}) = {s}, {b}", buffer=repr(buffer), s=chars, b=char_widths)
++
++        if colors and colors[0].span.end == i:  # current color ends now
++            post_color = _colorize.theme["RESET"]
++            colors.pop(0)
++
++        chars[-1] = pre_color + chars[-1] + post_color
++        pre_color = ""
++        post_color = ""
++
++    if colors and colors[0].span.start < i and colors[0].span.end > i:
++        # even though the current color should be continued, reset it for now.
++        # the next call to `disp_str()` will revive it.
++        chars[-1] += _colorize.theme["RESET"]
++
+     return chars, char_widths
++
++
++def prev_next_window[T](
++    iterable: Iterable[T]
++) -> Iterator[tuple[T | None, ...]]:
++    """Generates three-tuples of (previous, current, next) items.
++
++    On the first iteration previous is None. On the last iteration next
++    is None. In case of exception next is None and the exception is re-raised
++    on a subsequent next() call.
++
++    Inspired by `sliding_window` from `itertools` recipes.
++    """
++
++    iterator = iter(iterable)
++    window = deque((None, next(iterator)), maxlen=3)
++    try:
++        for x in iterator:
++            window.append(x)
++            yield tuple(window)
++    except Exception:
++        raise
++    finally:
++        window.append(None)
++        yield tuple(window)
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index 5fe73a55711..4c5b3eb1ea6 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -426,6 +426,20 @@ def _read_input(self, block: bool = True) -> INPUT_RECORD | None:
+ 
+         return rec
+ 
++    def _read_input_bulk(
++        self, block: bool, n: int
++    ) -> tuple[ctypes.Array[INPUT_RECORD], int]:
++        rec = (n * INPUT_RECORD)()
++        read = DWORD()
++
++        if not block and not self.wait(timeout=0):
++            return rec, 0
++
++        if not ReadConsoleInput(InHandle, rec, n, read):
++            raise WinError(GetLastError())
++
++        return rec, read.value
++
+     def get_event(self, block: bool = True) -> Event | None:
+         """Return an Event instance.  Returns None if |block| is false
+         and there is no event pending, otherwise waits for the
+@@ -521,7 +535,23 @@ def forgetinput(self) -> None:
+     def getpending(self) -> Event:
+         """Return the characters that have been typed but not yet
+         processed."""
+-        return Event("key", "", b"")
++        e = Event("key", "", b"")
++
++        while not self.event_queue.empty():
++            e2 = self.event_queue.get()
++            if e2:
++                e.data += e2.data
++
++        recs, rec_count = self._read_input_bulk(False, 1024)
++        for i in range(rec_count):
++            rec = recs[i]
++            if rec and rec.EventType == KEY_EVENT:
++                key_event = rec.Event.KeyEvent
++                ch = key_event.uChar.UnicodeChar
++                if ch == "\r":
++                    ch += "\n"
++                e.data += ch
++        return e
+ 
+     def wait(self, timeout: float | None) -> bool:
+         """Wait for an event."""
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 40d9c2f91b1..813d55400f2 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -1,14 +1,21 @@
+ import itertools
+ import functools
+ import rlcompleter
++from textwrap import dedent
+ from unittest import TestCase
+ from unittest.mock import MagicMock
+ 
+ from .support import handle_all_events, handle_events_narrow_console
+ from .support import ScreenEqualMixin, code_to_events
+-from .support import prepare_reader, prepare_console
++from .support import prepare_console, reader_force_colors
++from .support import reader_no_colors as prepare_reader
+ from _pyrepl.console import Event
+ from _pyrepl.reader import Reader
++from _colorize import theme
++
++
++overrides = {"RESET": "z", "SOFT_KEYWORD": "K"}
++colors = {overrides.get(k, k[0].lower()): v for k, v in theme.items()}
+ 
+ 
+ class TestReader(ScreenEqualMixin, TestCase):
+@@ -123,8 +130,9 @@ def test_setpos_for_xy_simple(self):
+     def test_control_characters(self):
+         code = 'flag = "🏳️‍🌈"'
+         events = code_to_events(code)
+-        reader, _ = handle_all_events(events)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
+         self.assert_screen_equal(reader, 'flag = "🏳️\\u200d🌈"', clean=True)
++        self.assert_screen_equal(reader, 'flag {o}={z} {s}"🏳️\\u200d🌈"{z}'.format(**colors))
+ 
+     def test_setpos_from_xy_multiple_lines(self):
+         # fmt: off
+@@ -355,3 +363,140 @@ def test_setpos_from_xy_for_non_printing_char(self):
+         reader, _ = handle_all_events(events)
+         reader.setpos_from_xy(8, 0)
+         self.assertEqual(reader.pos, 7)
++
++    def test_syntax_highlighting_basic(self):
++        code = dedent(
++            """\
++            import re, sys
++            def funct(case: str = sys.platform) -> None:
++                match = re.search(
++                    "(me)",
++                    '''
++                    Come on
++                      Come on now
++                        You know that it's time to emerge
++                    ''',
++                )
++                match case:
++                    case "emscripten": print("on the web")
++                    case "ios" | "android": print("on the phone")
++                    case _: print('arms around', match.group(1))
++            """
++        )
++        expected = dedent(
++            """\
++            {k}import{z} re{o},{z} sys
++            {a}{k}def{z} {d}funct{z}{o}({z}case{o}:{z} {b}str{z} {o}={z} sys{o}.{z}platform{o}){z} {o}->{z} {k}None{z}{o}:{z}
++                match {o}={z} re{o}.{z}search{o}({z}
++                    {s}"(me)"{z}{o},{z}
++                    {s}'''{z}
++            {s}        Come on{z}
++            {s}          Come on now{z}
++            {s}            You know that it's time to emerge{z}
++            {s}        '''{z}{o},{z}
++                {o}){z}
++                {K}match{z} case{o}:{z}
++                    {K}case{z} {s}"emscripten"{z}{o}:{z} {b}print{z}{o}({z}{s}"on the web"{z}{o}){z}
++                    {K}case{z} {s}"ios"{z} {o}|{z} {s}"android"{z}{o}:{z} {b}print{z}{o}({z}{s}"on the phone"{z}{o}){z}
++                    {K}case{z} {K}_{z}{o}:{z} {b}print{z}{o}({z}{s}'arms around'{z}{o},{z} match{o}.{z}group{o}({z}{n}1{z}{o}){z}{o}){z}
++            """
++        )
++        expected_sync = expected.format(a="", **colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected_sync)
++        self.assertEqual(reader.pos, 2**7 + 2**8)
++        self.assertEqual(reader.cxy, (0, 14))
++
++        async_msg = "{k}async{z} ".format(**colors)
++        expected_async = expected.format(a=async_msg, **colors)
++        more_events = itertools.chain(
++            code_to_events(code),
++            [Event(evt="key", data="up", raw=bytearray(b"\x1bOA"))] * 13,
++            code_to_events("async "),
++        )
++        reader, _ = handle_all_events(more_events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, expected_async)
++        self.assertEqual(reader.pos, 21)
++        self.assertEqual(reader.cxy, (6, 1))
++
++    def test_syntax_highlighting_incomplete_string_first_line(self):
++        code = dedent(
++            """\
++            def unfinished_function(arg: str = "still typing
++            """
++        )
++        expected = dedent(
++            """\
++            {k}def{z} {d}unfinished_function{z}{o}({z}arg{o}:{z} {b}str{z} {o}={z} {s}"still typing{z}
++            """
++        ).format(**colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected)
++
++    def test_syntax_highlighting_incomplete_string_another_line(self):
++        code = dedent(
++            """\
++            def unfinished_function(
++                arg: str = "still typing
++            """
++        )
++        expected = dedent(
++            """\
++            {k}def{z} {d}unfinished_function{z}{o}({z}
++                arg{o}:{z} {b}str{z} {o}={z} {s}"still typing{z}
++            """
++        ).format(**colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected)
++
++    def test_syntax_highlighting_incomplete_multiline_string(self):
++        code = dedent(
++            """\
++            def unfinished_function():
++                '''Still writing
++                the docstring
++            """
++        )
++        expected = dedent(
++            """\
++            {k}def{z} {d}unfinished_function{z}{o}({z}{o}){z}{o}:{z}
++                {s}'''Still writing{z}
++            {s}    the docstring{z}
++            """
++        ).format(**colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected)
++
++    def test_syntax_highlighting_incomplete_fstring(self):
++        code = dedent(
++            """\
++            def unfinished_function():
++                var = f"Single-quote but {
++                1
++                +
++                1
++                } multi-line!
++            """
++        )
++        expected = dedent(
++            """\
++            {k}def{z} {d}unfinished_function{z}{o}({z}{o}){z}{o}:{z}
++                var {o}={z} {s}f"{z}{s}Single-quote but {z}{o}{OB}{z}
++                {n}1{z}
++                {o}+{z}
++                {n}1{z}
++                {o}{CB}{z}{s} multi-line!{z}
++            """
++        ).format(OB="{", CB="}", **colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected)
+diff --git a/Lib/test/test_pyrepl/test_unix_console.py b/Lib/test/test_pyrepl/test_unix_console.py
+index 057cdd11285..73c057d6512 100644
+--- a/Lib/test/test_pyrepl/test_unix_console.py
++++ b/Lib/test/test_pyrepl/test_unix_console.py
+@@ -32,10 +32,12 @@ def unix_console(events, **kwargs):
+ 
+ handle_events_unix_console = partial(
+     handle_all_events,
+-    prepare_console=partial(unix_console),
++    prepare_reader=reader_no_colors,
++    prepare_console=unix_console,
+ )
+ handle_events_narrow_unix_console = partial(
+     handle_all_events,
++    prepare_reader=reader_no_colors,
+     prepare_console=partial(unix_console, width=5),
+ )
+ handle_events_short_unix_console = partial(
+diff --git a/Lib/test/test_pyrepl/test_windows_console.py b/Lib/test/test_pyrepl/test_windows_console.py
+index 07eaccd1124..051671a5de6 100644
+--- a/Lib/test/test_pyrepl/test_windows_console.py
++++ b/Lib/test/test_pyrepl/test_windows_console.py
+@@ -12,6 +12,7 @@
+ from unittest.mock import MagicMock, call
+ 
+ from .support import handle_all_events, code_to_events
++from .support import reader_no_colors as default_prepare_reader
+ 
+ try:
+     from _pyrepl.console import Event, Console
+@@ -46,14 +47,22 @@ def console(self, events, **kwargs) -> Console:
+             setattr(console, key, val)
+         return console
+ 
+-    def handle_events(self, events: Iterable[Event], **kwargs):
+-        return handle_all_events(events, partial(self.console, **kwargs))
++    def handle_events(
++        self,
++        events: Iterable[Event],
++        prepare_console=None,
++        prepare_reader=None,
++        **kwargs,
++    ):
++        prepare_console = prepare_console or partial(self.console, **kwargs)
++        prepare_reader = prepare_reader or default_prepare_reader
++        return handle_all_events(events, prepare_console, prepare_reader)
+ 
+     def handle_events_narrow(self, events):
+         return self.handle_events(events, width=5)
+ 
+-    def handle_events_short(self, events):
+-        return self.handle_events(events, height=1)
++    def handle_events_short(self, events, **kwargs):
++        return self.handle_events(events, height=1, **kwargs)
+ 
+     def handle_events_height_3(self, events):
+         return self.handle_events(events, height=3)
+diff --git a/Lib/token.py b/Lib/token.py
+index 54d7cdccadc..bd44ff6abd1 100644
+--- a/Lib/token.py
++++ b/Lib/token.py
+@@ -131,11 +131,11 @@ EXACT_TOKEN_TYPES = {
+     '~': TILDE,
+ }
+ 
+-def ISTERMINAL(x):
++def ISTERMINAL(x: int) -> bool:
+     return x < NT_OFFSET
+ 
+-def ISNONTERMINAL(x):
++def ISNONTERMINAL(x: int) -> bool:
+     return x >= NT_OFFSET
+ 
+-def ISEOF(x):
++def ISEOF(x: int) -> bool:
+     return x == ENDMARKER
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-03-21-19-03-42.gh-issue-131507.q9fvyM.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-21-19-03-42.gh-issue-131507.q9fvyM.rst
+new file mode 100644
+index 00000000000..354a116c533
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-21-19-03-42.gh-issue-131507.q9fvyM.rst
+@@ -0,0 +1 @@
++PyREPL now supports syntax highlighing. Contributed by Łukasz Langa.
+diff --git a/Misc/mypy/token.py b/Misc/mypy/token.py
+new file mode 120000
+index 00000000000..0a39f726dda
+--- /dev/null
++++ b/Misc/mypy/token.py
+@@ -0,0 +1 @@
++../../Lib/token.py
+\ No newline at end of file
+diff --git a/Tools/build/generate_token.py b/Tools/build/generate_token.py
+index d32747f1994..bda61e23154 100755
+--- a/Tools/build/generate_token.py
++++ b/Tools/build/generate_token.py
+@@ -243,13 +243,13 @@ def make_rst(infile, outfile='Doc/library/token-list.inc'):
+ %s
+ }
+ 
+-def ISTERMINAL(x):
++def ISTERMINAL(x: int) -> bool:
+     return x < NT_OFFSET
+ 
+-def ISNONTERMINAL(x):
++def ISNONTERMINAL(x: int) -> bool:
+     return x >= NT_OFFSET
+ 
+-def ISEOF(x):
++def ISEOF(x: int) -> bool:
+     return x == ENDMARKER
+ '''
+ 
diff --git a/cpython/patches/1022-Bump-mypy-to-1.15-133405.patch b/cpython/patches/1022-Bump-mypy-to-1.15-133405.patch
new file mode 100644
index 00000000..4bf85841
--- /dev/null
+++ b/cpython/patches/1022-Bump-mypy-to-1.15-133405.patch
@@ -0,0 +1,49 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: sobolevn <mail@sobolevn.me>
+Date: Mon, 5 May 2025 13:29:48 +0300
+Subject: [PATCH] Bump mypy to 1.15 (#133405)
+
+---
+ Lib/_pyrepl/commands.py       | 2 +-
+ Lib/test/libregrtest/setup.py | 2 +-
+ Tools/requirements-dev.txt    | 2 +-
+ 3 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/Lib/_pyrepl/commands.py b/Lib/_pyrepl/commands.py
+index 2054a8e400f..2354fbb2ec2 100644
+--- a/Lib/_pyrepl/commands.py
++++ b/Lib/_pyrepl/commands.py
+@@ -439,7 +439,7 @@ def do(self) -> None:
+         import _sitebuiltins
+ 
+         with self.reader.suspend():
+-            self.reader.msg = _sitebuiltins._Helper()()  # type: ignore[assignment, call-arg]
++            self.reader.msg = _sitebuiltins._Helper()()  # type: ignore[assignment]
+ 
+ 
+ class invalid_key(Command):
+diff --git a/Lib/test/libregrtest/setup.py b/Lib/test/libregrtest/setup.py
+index ba57f06b484..7277dcbc206 100644
+--- a/Lib/test/libregrtest/setup.py
++++ b/Lib/test/libregrtest/setup.py
+@@ -42,7 +42,7 @@ def setup_process() -> None:
+         faulthandler.enable(all_threads=True, file=stderr_fd)
+ 
+         # Display the Python traceback on SIGALRM or SIGUSR1 signal
+-        signals = []
++        signals: list[signal.Signals] = []
+         if hasattr(signal, 'SIGALRM'):
+             signals.append(signal.SIGALRM)
+         if hasattr(signal, 'SIGUSR1'):
+diff --git a/Tools/requirements-dev.txt b/Tools/requirements-dev.txt
+index b1d0e023541..acbc7b7b71f 100644
+--- a/Tools/requirements-dev.txt
++++ b/Tools/requirements-dev.txt
+@@ -1,6 +1,6 @@
+ # Requirements file for external linters and checks we run on
+ # Tools/clinic, Tools/cases_generator/, and Tools/peg_generator/ in CI
+-mypy==1.13
++mypy==1.15
+ 
+ # needed for peg_generator:
+ types-psutil==5.9.5.20240423
diff --git a/cpython/patches/1023-gh-131878-Handle-top-level-exceptions-in-new-pyrepl-.patch b/cpython/patches/1023-gh-131878-Handle-top-level-exceptions-in-new-pyrepl-.patch
new file mode 100644
index 00000000..83eb011b
--- /dev/null
+++ b/cpython/patches/1023-gh-131878-Handle-top-level-exceptions-in-new-pyrepl-.patch
@@ -0,0 +1,36 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Sergey Miryanov <sergey.miryanov@gmail.com>
+Date: Mon, 5 May 2025 07:54:19 -0700
+Subject: [PATCH] gh-131878: Handle top level exceptions in new pyrepl and
+ prevent of closing it (#131910)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+---
+ Lib/_pyrepl/simple_interact.py                               | 5 +++++
+ .../2025-03-30-19-58-14.gh-issue-131878.uxM26H.rst           | 1 +
+ 2 files changed, 6 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-58-14.gh-issue-131878.uxM26H.rst
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index 80bd38444d1..c38d07da307 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -164,3 +164,8 @@ def maybe_run_command(statement: str) -> bool:
+         except MemoryError:
+             console.write("\nMemoryError\n")
+             console.resetbuffer()
++        except SystemExit:
++            raise
++        except:
++            console.showtraceback()
++            console.resetbuffer()
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-58-14.gh-issue-131878.uxM26H.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-58-14.gh-issue-131878.uxM26H.rst
+new file mode 100644
+index 00000000000..79b23db6d0b
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-58-14.gh-issue-131878.uxM26H.rst
+@@ -0,0 +1 @@
++Handle uncaught exceptions in the main input loop for the new REPL.
diff --git a/cpython/patches/1024-gh-131878-Fix-input-of-unicode-characters-with-two-o.patch b/cpython/patches/1024-gh-131878-Fix-input-of-unicode-characters-with-two-o.patch
new file mode 100644
index 00000000..fc0f05b0
--- /dev/null
+++ b/cpython/patches/1024-gh-131878-Fix-input-of-unicode-characters-with-two-o.patch
@@ -0,0 +1,205 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Sergey Miryanov <sergey.miryanov@gmail.com>
+Date: Mon, 5 May 2025 09:25:00 -0700
+Subject: [PATCH] gh-131878: Fix input of unicode characters with two or more
+ code points in new pyrepl on Windows (gh-131901)
+
+Co-authored-by: Tomas R. <tomas.roun8@gmail.com>
+Co-authored-by: Chris Eibl <138194463+chris-eibl@users.noreply.github.com>
+---
+ Lib/_pyrepl/base_eventqueue.py                | 12 +--
+ Lib/_pyrepl/windows_console.py                |  3 +-
+ Lib/test/test_pyrepl/test_eventqueue.py       | 78 ++++++++++++++-----
+ ...-03-30-19-49-00.gh-issue-131878.J8_cHB.rst |  2 +
+ 4 files changed, 68 insertions(+), 27 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-49-00.gh-issue-131878.J8_cHB.rst
+
+diff --git a/Lib/_pyrepl/base_eventqueue.py b/Lib/_pyrepl/base_eventqueue.py
+index e018c4fc183..842599bd187 100644
+--- a/Lib/_pyrepl/base_eventqueue.py
++++ b/Lib/_pyrepl/base_eventqueue.py
+@@ -69,18 +69,14 @@ def insert(self, event: Event) -> None:
+         trace('added event {event}', event=event)
+         self.events.append(event)
+ 
+-    def push(self, char: int | bytes | str) -> None:
++    def push(self, char: int | bytes) -> None:
+         """
+         Processes a character by updating the buffer and handling special key mappings.
+         """
++        assert isinstance(char, (int, bytes))
+         ord_char = char if isinstance(char, int) else ord(char)
+-        if ord_char > 255:
+-            assert isinstance(char, str)
+-            char = bytes(char.encode(self.encoding, "replace"))
+-            self.buf.extend(char)
+-        else:
+-            char = bytes(bytearray((ord_char,)))
+-            self.buf.append(ord_char)
++        char = ord_char.to_bytes()
++        self.buf.append(ord_char)
+ 
+         if char in self.keymap:
+             if self.keymap is self.compiled_keymap:
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index 4c5b3eb1ea6..2558a7638c3 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -485,7 +485,8 @@ def get_event(self, block: bool = True) -> Event | None:
+                 return None
+             elif self.__vt_support:
+                 # If virtual terminal is enabled, scanning VT sequences
+-                self.event_queue.push(rec.Event.KeyEvent.uChar.UnicodeChar)
++                for char in raw_key.encode(self.event_queue.encoding, "replace"):
++                    self.event_queue.push(char)
+                 continue
+ 
+             if key_event.dwControlKeyState & ALT_ACTIVE:
+diff --git a/Lib/test/test_pyrepl/test_eventqueue.py b/Lib/test/test_pyrepl/test_eventqueue.py
+index b25bdb956b0..6ba2440426d 100644
+--- a/Lib/test/test_pyrepl/test_eventqueue.py
++++ b/Lib/test/test_pyrepl/test_eventqueue.py
+@@ -54,7 +54,7 @@ def test_push_with_key_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+         eq = self.make_eventqueue()
+         eq.keymap = {b"a": "b"}
+-        eq.push("a")
++        eq.push(b"a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "b")
+@@ -64,7 +64,7 @@ def test_push_without_key_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+         eq = self.make_eventqueue()
+         eq.keymap = {b"c": "d"}
+-        eq.push("a")
++        eq.push(b"a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "a")
+@@ -74,13 +74,13 @@ def test_push_with_keymap_in_keymap(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+         eq = self.make_eventqueue()
+         eq.keymap = {b"a": {b"b": "c"}}
+-        eq.push("a")
++        eq.push(b"a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertTrue(eq.empty())
+-        eq.push("b")
++        eq.push(b"b")
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "c")
+-        eq.push("d")
++        eq.push(b"d")
+         self.assertEqual(eq.events[1].evt, "key")
+         self.assertEqual(eq.events[1].data, "d")
+ 
+@@ -89,32 +89,32 @@ def test_push_with_keymap_in_keymap_and_escape(self, mock_keymap):
+         mock_keymap.compile_keymap.return_value = {"a": "b"}
+         eq = self.make_eventqueue()
+         eq.keymap = {b"a": {b"b": "c"}}
+-        eq.push("a")
++        eq.push(b"a")
+         mock_keymap.compile_keymap.assert_called()
+         self.assertTrue(eq.empty())
+         eq.flush_buf()
+-        eq.push("\033")
++        eq.push(b"\033")
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "\033")
+-        eq.push("b")
++        eq.push(b"b")
+         self.assertEqual(eq.events[1].evt, "key")
+         self.assertEqual(eq.events[1].data, "b")
+ 
+     def test_push_special_key(self):
+         eq = self.make_eventqueue()
+         eq.keymap = {}
+-        eq.push("\x1b")
+-        eq.push("[")
+-        eq.push("A")
++        eq.push(b"\x1b")
++        eq.push(b"[")
++        eq.push(b"A")
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "\x1b")
+ 
+     def test_push_unrecognized_escape_sequence(self):
+         eq = self.make_eventqueue()
+         eq.keymap = {}
+-        eq.push("\x1b")
+-        eq.push("[")
+-        eq.push("Z")
++        eq.push(b"\x1b")
++        eq.push(b"[")
++        eq.push(b"Z")
+         self.assertEqual(len(eq.events), 3)
+         self.assertEqual(eq.events[0].evt, "key")
+         self.assertEqual(eq.events[0].data, "\x1b")
+@@ -123,12 +123,54 @@ def test_push_unrecognized_escape_sequence(self):
+         self.assertEqual(eq.events[2].evt, "key")
+         self.assertEqual(eq.events[2].data, "Z")
+ 
+-    def test_push_unicode_character(self):
++    def test_push_unicode_character_as_str(self):
+         eq = self.make_eventqueue()
+         eq.keymap = {}
+-        eq.push("ч")
+-        self.assertEqual(eq.events[0].evt, "key")
+-        self.assertEqual(eq.events[0].data, "ч")
++        with self.assertRaises(AssertionError):
++            eq.push("ч")
++        with self.assertRaises(AssertionError):
++            eq.push("ñ")
++
++    def test_push_unicode_character_two_bytes(self):
++        eq = self.make_eventqueue()
++        eq.keymap = {}
++
++        encoded = "ч".encode(eq.encoding, "replace")
++        self.assertEqual(len(encoded), 2)
++
++        eq.push(encoded[0])
++        e = eq.get()
++        self.assertIsNone(e)
++
++        eq.push(encoded[1])
++        e = eq.get()
++        self.assertEqual(e.evt, "key")
++        self.assertEqual(e.data, "ч")
++
++    def test_push_single_chars_and_unicode_character_as_str(self):
++        eq = self.make_eventqueue()
++        eq.keymap = {}
++
++        def _event(evt, data, raw=None):
++            r = raw if raw is not None else data.encode(eq.encoding)
++            e = Event(evt, data, r)
++            return e
++
++        def _push(keys):
++            for k in keys:
++                eq.push(k)
++
++        self.assertIsInstance("ñ", str)
++
++        # If an exception happens during push, the existing events must be
++        # preserved and we can continue to push.
++        _push(b"b")
++        with self.assertRaises(AssertionError):
++            _push("ñ")
++        _push(b"a")
++
++        self.assertEqual(eq.get(), _event("key", "b"))
++        self.assertEqual(eq.get(), _event("key", "a"))
+ 
+ 
+ @unittest.skipIf(support.MS_WINDOWS, "No Unix event queue on Windows")
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-49-00.gh-issue-131878.J8_cHB.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-49-00.gh-issue-131878.J8_cHB.rst
+new file mode 100644
+index 00000000000..b1223dac52d
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-03-30-19-49-00.gh-issue-131878.J8_cHB.rst
+@@ -0,0 +1,2 @@
++Fix support of unicode characters with two or more codepoints on Windows in
++the new REPL.
diff --git a/cpython/patches/1025-GH-132439-Fix-REPL-swallowing-characters-entered-wit.patch b/cpython/patches/1025-GH-132439-Fix-REPL-swallowing-characters-entered-wit.patch
new file mode 100644
index 00000000..19220c24
--- /dev/null
+++ b/cpython/patches/1025-GH-132439-Fix-REPL-swallowing-characters-entered-wit.patch
@@ -0,0 +1,307 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Chris Eibl <138194463+chris-eibl@users.noreply.github.com>
+Date: Mon, 5 May 2025 18:45:45 +0200
+Subject: [PATCH] GH-132439: Fix REPL swallowing characters entered with AltGr
+ on cmd.exe (GH-132440)
+
+Co-authored-by: Stan Ulbrych <89152624+StanFromIreland@users.noreply.github.com>
+---
+ Lib/_pyrepl/windows_console.py                |  18 +-
+ Lib/test/test_pyrepl/test_windows_console.py  | 221 +++++++++++++++++-
+ ...-04-12-16-29-42.gh-issue-132439.3twrU6.rst |   2 +
+ 3 files changed, 233 insertions(+), 8 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-04-12-16-29-42.gh-issue-132439.3twrU6.rst
+
+diff --git a/Lib/_pyrepl/windows_console.py b/Lib/_pyrepl/windows_console.py
+index 2558a7638c3..b1834a58ec9 100644
+--- a/Lib/_pyrepl/windows_console.py
++++ b/Lib/_pyrepl/windows_console.py
+@@ -464,7 +464,7 @@ def get_event(self, block: bool = True) -> Event | None:
+ 
+             if key == "\r":
+                 # Make enter unix-like
+-                return Event(evt="key", data="\n", raw=b"\n")
++                return Event(evt="key", data="\n")
+             elif key_event.wVirtualKeyCode == 8:
+                 # Turn backspace directly into the command
+                 key = "backspace"
+@@ -476,9 +476,9 @@ def get_event(self, block: bool = True) -> Event | None:
+                         key = f"ctrl {key}"
+                     elif key_event.dwControlKeyState & ALT_ACTIVE:
+                         # queue the key, return the meta command
+-                        self.event_queue.insert(Event(evt="key", data=key, raw=key))
++                        self.event_queue.insert(Event(evt="key", data=key))
+                         return Event(evt="key", data="\033")  # keymap.py uses this for meta
+-                    return Event(evt="key", data=key, raw=key)
++                    return Event(evt="key", data=key)
+                 if block:
+                     continue
+ 
+@@ -490,11 +490,15 @@ def get_event(self, block: bool = True) -> Event | None:
+                 continue
+ 
+             if key_event.dwControlKeyState & ALT_ACTIVE:
+-                # queue the key, return the meta command
+-                self.event_queue.insert(Event(evt="key", data=key, raw=raw_key))
+-                return Event(evt="key", data="\033")  # keymap.py uses this for meta
++                # Do not swallow characters that have been entered via AltGr:
++                # Windows internally converts AltGr to CTRL+ALT, see
++                # https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-vkkeyscanw
++                if not key_event.dwControlKeyState & CTRL_ACTIVE:
++                    # queue the key, return the meta command
++                    self.event_queue.insert(Event(evt="key", data=key))
++                    return Event(evt="key", data="\033")  # keymap.py uses this for meta
+ 
+-            return Event(evt="key", data=key, raw=raw_key)
++            return Event(evt="key", data=key)
+         return self.event_queue.get()
+ 
+     def push_char(self, char: int | bytes) -> None:
+diff --git a/Lib/test/test_pyrepl/test_windows_console.py b/Lib/test/test_pyrepl/test_windows_console.py
+index 051671a5de6..ed28c4727a9 100644
+--- a/Lib/test/test_pyrepl/test_windows_console.py
++++ b/Lib/test/test_pyrepl/test_windows_console.py
+@@ -24,6 +24,7 @@
+         MOVE_DOWN,
+         ERASE_IN_LINE,
+     )
++    import _pyrepl.windows_console as wc
+ except ImportError:
+     pass
+ 
+@@ -349,8 +350,226 @@ def test_multiline_ctrl_z(self):
+                 Event(evt="key", data='\x1a', raw=bytearray(b'\x1a')),
+             ],
+         )
+-        reader, _ = self.handle_events_narrow(events)
++        reader, con = self.handle_events_narrow(events)
+         self.assertEqual(reader.cxy, (2, 3))
++        con.restore()
++
++
++class WindowsConsoleGetEventTests(TestCase):
++    # Virtual-Key Codes: https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
++    VK_BACK = 0x08
++    VK_RETURN = 0x0D
++    VK_LEFT = 0x25
++    VK_7 = 0x37
++    VK_M = 0x4D
++    # Used for miscellaneous characters; it can vary by keyboard.
++    # For the US standard keyboard, the '" key.
++    # For the German keyboard, the Ä key.
++    VK_OEM_7 = 0xDE
++
++    # State of control keys: https://learn.microsoft.com/en-us/windows/console/key-event-record-str
++    RIGHT_ALT_PRESSED = 0x0001
++    RIGHT_CTRL_PRESSED = 0x0004
++    LEFT_ALT_PRESSED = 0x0002
++    LEFT_CTRL_PRESSED = 0x0008
++    ENHANCED_KEY = 0x0100
++    SHIFT_PRESSED = 0x0010
++
++
++    def get_event(self, input_records, **kwargs) -> Console:
++        self.console = WindowsConsole(encoding='utf-8')
++        self.mock = MagicMock(side_effect=input_records)
++        self.console._read_input = self.mock
++        self.console._WindowsConsole__vt_support = kwargs.get("vt_support",
++                                                              False)
++        event = self.console.get_event(block=False)
++        return event
++
++    def get_input_record(self, unicode_char, vcode=0, control=0):
++        return wc.INPUT_RECORD(
++            wc.KEY_EVENT,
++            wc.ConsoleEvent(KeyEvent=
++                wc.KeyEvent(
++                    bKeyDown=True,
++                    wRepeatCount=1,
++                    wVirtualKeyCode=vcode,
++                    wVirtualScanCode=0, # not used
++                    uChar=wc.Char(unicode_char),
++                    dwControlKeyState=control
++                    )))
++
++    def test_EmptyBuffer(self):
++        self.assertEqual(self.get_event([None]), None)
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_WINDOW_BUFFER_SIZE_EVENT(self):
++        ir = wc.INPUT_RECORD(
++            wc.WINDOW_BUFFER_SIZE_EVENT,
++            wc.ConsoleEvent(WindowsBufferSizeEvent=
++                wc.WindowsBufferSizeEvent(
++                    wc._COORD(0, 0))))
++        self.assertEqual(self.get_event([ir]), Event("resize", ""))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_KEY_EVENT_up_ignored(self):
++        ir = wc.INPUT_RECORD(
++            wc.KEY_EVENT,
++            wc.ConsoleEvent(KeyEvent=
++                wc.KeyEvent(bKeyDown=False)))
++        self.assertEqual(self.get_event([ir]), None)
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_unhandled_events(self):
++        for event in (wc.FOCUS_EVENT, wc.MENU_EVENT, wc.MOUSE_EVENT):
++            ir = wc.INPUT_RECORD(
++                event,
++                # fake data, nothing is read except bKeyDown
++                wc.ConsoleEvent(KeyEvent=
++                    wc.KeyEvent(bKeyDown=False)))
++            self.assertEqual(self.get_event([ir]), None)
++            self.assertEqual(self.mock.call_count, 1)
++
++    def test_enter(self):
++        ir = self.get_input_record("\r", self.VK_RETURN)
++        self.assertEqual(self.get_event([ir]), Event("key", "\n"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_backspace(self):
++        ir = self.get_input_record("\x08", self.VK_BACK)
++        self.assertEqual(
++            self.get_event([ir]), Event("key", "backspace"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_m(self):
++        ir = self.get_input_record("m", self.VK_M)
++        self.assertEqual(self.get_event([ir]), Event("key", "m"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_M(self):
++        ir = self.get_input_record("M", self.VK_M, self.SHIFT_PRESSED)
++        self.assertEqual(self.get_event([ir]), Event("key", "M"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_left(self):
++        # VK_LEFT is sent as ENHANCED_KEY
++        ir = self.get_input_record("\x00", self.VK_LEFT, self.ENHANCED_KEY)
++        self.assertEqual(self.get_event([ir]), Event("key", "left"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_left_RIGHT_CTRL_PRESSED(self):
++        ir = self.get_input_record(
++            "\x00", self.VK_LEFT, self.RIGHT_CTRL_PRESSED | self.ENHANCED_KEY)
++        self.assertEqual(
++            self.get_event([ir]), Event("key", "ctrl left"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_left_LEFT_CTRL_PRESSED(self):
++        ir = self.get_input_record(
++            "\x00", self.VK_LEFT, self.LEFT_CTRL_PRESSED | self.ENHANCED_KEY)
++        self.assertEqual(
++            self.get_event([ir]), Event("key", "ctrl left"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_left_RIGHT_ALT_PRESSED(self):
++        ir = self.get_input_record(
++            "\x00", self.VK_LEFT, self.RIGHT_ALT_PRESSED | self.ENHANCED_KEY)
++        self.assertEqual(self.get_event([ir]), Event(evt="key", data="\033"))
++        self.assertEqual(
++            self.console.get_event(), Event("key", "left"))
++        # self.mock is not called again, since the second time we read from the
++        # command queue
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_left_LEFT_ALT_PRESSED(self):
++        ir = self.get_input_record(
++            "\x00", self.VK_LEFT, self.LEFT_ALT_PRESSED | self.ENHANCED_KEY)
++        self.assertEqual(self.get_event([ir]), Event(evt="key", data="\033"))
++        self.assertEqual(
++            self.console.get_event(), Event("key", "left"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_m_LEFT_ALT_PRESSED_and_LEFT_CTRL_PRESSED(self):
++        # For the shift keys, Windows does not send anything when
++        # ALT and CTRL are both pressed, so let's test with VK_M.
++        # get_event() receives this input, but does not
++        # generate an event.
++        # This is for e.g. an English keyboard layout, for a
++        # German layout this returns `µ`, see test_AltGr_m.
++        ir = self.get_input_record(
++            "\x00", self.VK_M, self.LEFT_ALT_PRESSED | self.LEFT_CTRL_PRESSED)
++        self.assertEqual(self.get_event([ir]), None)
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_m_LEFT_ALT_PRESSED(self):
++        ir = self.get_input_record(
++            "m", vcode=self.VK_M, control=self.LEFT_ALT_PRESSED)
++        self.assertEqual(self.get_event([ir]), Event(evt="key", data="\033"))
++        self.assertEqual(self.console.get_event(), Event("key", "m"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_m_RIGHT_ALT_PRESSED(self):
++        ir = self.get_input_record(
++            "m", vcode=self.VK_M, control=self.RIGHT_ALT_PRESSED)
++        self.assertEqual(self.get_event([ir]), Event(evt="key", data="\033"))
++        self.assertEqual(self.console.get_event(), Event("key", "m"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_AltGr_7(self):
++        # E.g. on a German keyboard layout, '{' is entered via
++        # AltGr + 7, where AltGr is the right Alt key on the keyboard.
++        # In this case, Windows automatically sets
++        # RIGHT_ALT_PRESSED = 0x0001 + LEFT_CTRL_PRESSED = 0x0008
++        # This can also be entered like
++        # LeftAlt + LeftCtrl + 7 or
++        # LeftAlt + RightCtrl + 7
++        # See https://learn.microsoft.com/en-us/windows/console/key-event-record-str
++        # https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-vkkeyscanw
++        ir = self.get_input_record(
++            "{", vcode=self.VK_7,
++            control=self.RIGHT_ALT_PRESSED | self.LEFT_CTRL_PRESSED)
++        self.assertEqual(self.get_event([ir]), Event("key", "{"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_AltGr_m(self):
++        # E.g. on a German keyboard layout, this yields 'µ'
++        # Let's use LEFT_ALT_PRESSED and RIGHT_CTRL_PRESSED this
++        # time, to cover that, too. See above in test_AltGr_7.
++        ir = self.get_input_record(
++            "µ", vcode=self.VK_M, control=self.LEFT_ALT_PRESSED | self.RIGHT_CTRL_PRESSED)
++        self.assertEqual(self.get_event([ir]), Event("key", "µ"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_umlaut_a_german(self):
++        ir = self.get_input_record("ä", self.VK_OEM_7)
++        self.assertEqual(self.get_event([ir]), Event("key", "ä"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    # virtual terminal tests
++    # Note: wVirtualKeyCode, wVirtualScanCode and dwControlKeyState
++    # are always zero in this case.
++    # "\r" and backspace are handled specially, everything else
++    # is handled in "elif self.__vt_support:" in WindowsConsole.get_event().
++    # Hence, only one regular key ("m") and a terminal sequence
++    # are sufficient to test here, the real tests happen in test_eventqueue
++    # and test_keymap.
++
++    def test_enter_vt(self):
++        ir = self.get_input_record("\r")
++        self.assertEqual(self.get_event([ir], vt_support=True),
++                         Event("key", "\n"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_backspace_vt(self):
++        ir = self.get_input_record("\x7f")
++        self.assertEqual(self.get_event([ir], vt_support=True),
++                         Event("key", "backspace", b"\x7f"))
++        self.assertEqual(self.mock.call_count, 1)
++
++    def test_up_vt(self):
++        irs = [self.get_input_record(x) for x in "\x1b[A"]
++        self.assertEqual(self.get_event(irs, vt_support=True),
++                         Event(evt='key', data='up', raw=bytearray(b'\x1b[A')))
++        self.assertEqual(self.mock.call_count, 3)
+ 
+ 
+ if __name__ == "__main__":
+diff --git a/Misc/NEWS.d/next/Library/2025-04-12-16-29-42.gh-issue-132439.3twrU6.rst b/Misc/NEWS.d/next/Library/2025-04-12-16-29-42.gh-issue-132439.3twrU6.rst
+new file mode 100644
+index 00000000000..8d0778d8d3b
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-04-12-16-29-42.gh-issue-132439.3twrU6.rst
+@@ -0,0 +1,2 @@
++Fix ``PyREPL`` on Windows: characters entered via AltGr are swallowed.
++Patch by Chris Eibl.
diff --git a/cpython/patches/1026-gh-132017-Handle-SIGCONT-in-pyrepl-132918.patch b/cpython/patches/1026-gh-132017-Handle-SIGCONT-in-pyrepl-132918.patch
new file mode 100644
index 00000000..3c1ea424
--- /dev/null
+++ b/cpython/patches/1026-gh-132017-Handle-SIGCONT-in-pyrepl-132918.patch
@@ -0,0 +1,35 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Stan Ulbrych <89152624+StanFromIreland@users.noreply.github.com>
+Date: Mon, 5 May 2025 21:37:01 +0100
+Subject: [PATCH] gh-132017: Handle SIGCONT in `pyrepl` (#132918)
+
+---
+ Lib/_pyrepl/unix_console.py                                 | 6 ++++++
+ .../2025-04-25-10-51-00.gh-issue-132017.SIGCONT1.rst        | 1 +
+ 2 files changed, 7 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-04-25-10-51-00.gh-issue-132017.SIGCONT1.rst
+
+diff --git a/Lib/_pyrepl/unix_console.py b/Lib/_pyrepl/unix_console.py
+index 00018b493be..9a4575193af 100644
+--- a/Lib/_pyrepl/unix_console.py
++++ b/Lib/_pyrepl/unix_console.py
+@@ -197,6 +197,12 @@ def _my_getstr(cap: str, optional: bool = False) -> bytes | None:
+         self.event_queue = EventQueue(self.input_fd, self.encoding)
+         self.cursor_visible = 1
+ 
++        signal.signal(signal.SIGCONT, self._sigcont_handler)
++
++    def _sigcont_handler(self, signum, frame):
++        self.restore()
++        self.prepare()
++
+     def __read(self, n: int) -> bytes:
+         return os.read(self.input_fd, n)
+ 
+diff --git a/Misc/NEWS.d/next/Library/2025-04-25-10-51-00.gh-issue-132017.SIGCONT1.rst b/Misc/NEWS.d/next/Library/2025-04-25-10-51-00.gh-issue-132017.SIGCONT1.rst
+new file mode 100644
+index 00000000000..a11ccb9e07e
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-04-25-10-51-00.gh-issue-132017.SIGCONT1.rst
+@@ -0,0 +1 @@
++Fix error when ``pyrepl`` is suspended, then resumed and terminated.
diff --git a/cpython/patches/1027-gh-133541-Handle-SyntaxError-raised-by-the-tokenizer.patch b/cpython/patches/1027-gh-133541-Handle-SyntaxError-raised-by-the-tokenizer.patch
new file mode 100644
index 00000000..277d2229
--- /dev/null
+++ b/cpython/patches/1027-gh-133541-Handle-SyntaxError-raised-by-the-tokenizer.patch
@@ -0,0 +1,69 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C5=81ukasz=20Langa?= <lukasz@langa.pl>
+Date: Thu, 8 May 2025 22:14:38 +0200
+Subject: [PATCH] gh-133541: Handle SyntaxError raised by the tokenizer on user
+ input (#133606)
+
+---
+ Lib/_pyrepl/utils.py                          |  2 ++
+ Lib/test/test_pyrepl/test_reader.py           | 27 +++++++++++++++++++
+ ...-05-07-23-26-53.gh-issue-133541.bHIC55.rst |  2 ++
+ 3 files changed, 31 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-05-07-23-26-53.gh-issue-133541.bHIC55.rst
+
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 1b46c3e5799..1912e2d64d3 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -97,6 +97,8 @@ def gen_colors(buffer: str) -> Iterator[ColorSpan]:
+         for color in gen_colors_from_token_stream(gen, line_lengths):
+             yield color
+             last_emitted = color
++    except SyntaxError:
++        return
+     except tokenize.TokenError as te:
+         yield from recover_unterminated_string(
+             te, line_lengths, last_emitted, buffer
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 813d55400f2..7077aa52ec5 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -500,3 +500,30 @@ def unfinished_function():
+         reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
+         self.assert_screen_equal(reader, code, clean=True)
+         self.assert_screen_equal(reader, expected)
++
++    def test_syntax_highlighting_indentation_error(self):
++        code = dedent(
++            """\
++            def unfinished_function():
++                var = 1
++               oops
++            """
++        )
++        expected = dedent(
++            """\
++            {k}def{z} {d}unfinished_function{z}{o}({z}{o}){z}{o}:{z}
++                var {o}={z} {n}1{z}
++               oops
++            """
++        ).format(**colors)
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.assert_screen_equal(reader, expected)
++
++    def test_control_characters(self):
++        code = 'flag = "🏳️‍🌈"'
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events)
++        self.assert_screen_equal(reader, 'flag = "🏳️\\u200d🌈"', clean=True)
++        self.assert_screen_equal(reader, 'flag {o}={z} {s}"🏳️\\u200d🌈"{z}'.format(**colors))
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-05-07-23-26-53.gh-issue-133541.bHIC55.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-07-23-26-53.gh-issue-133541.bHIC55.rst
+new file mode 100644
+index 00000000000..4f4cd847fa5
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-07-23-26-53.gh-issue-133541.bHIC55.rst
+@@ -0,0 +1,2 @@
++Inconsistent indentation in user input crashed the new REPL when syntax
++highlighting was active. This is now fixed.
diff --git a/cpython/patches/1028-gh-134097-Print-number-of-refs-blocks-after-each-sta.patch b/cpython/patches/1028-gh-134097-Print-number-of-refs-blocks-after-each-sta.patch
new file mode 100644
index 00000000..22a3cbf7
--- /dev/null
+++ b/cpython/patches/1028-gh-134097-Print-number-of-refs-blocks-after-each-sta.patch
@@ -0,0 +1,78 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Kirill Podoprigora <kirill.bast9@mail.ru>
+Date: Mon, 19 May 2025 14:30:43 +0100
+Subject: [PATCH] gh-134097: Print number of refs & blocks after each statement
+ in new REPL (gh-134136)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+---
+ Lib/_pyrepl/simple_interact.py                    |  9 +++++++++
+ Lib/test/test_pyrepl/test_pyrepl.py               | 15 ++++++++++++++-
+ ...2025-05-17-13-46-20.gh-issue-134097.fgkjE1.rst |  1 +
+ 3 files changed, 24 insertions(+), 1 deletion(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-05-17-13-46-20.gh-issue-134097.fgkjE1.rst
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index c38d07da307..fad9966f91b 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -111,6 +111,10 @@ def run_multiline_interactive_console(
+     more_lines = functools.partial(_more_lines, console)
+     input_n = 0
+ 
++    _is_x_showrefcount_set = sys._xoptions.get("showrefcount")
++    _is_pydebug_build = hasattr(sys, "gettotalrefcount")
++    show_ref_count = _is_x_showrefcount_set and _is_pydebug_build
++
+     def maybe_run_command(statement: str) -> bool:
+         statement = statement.strip()
+         if statement in console.locals or statement not in REPL_COMMANDS:
+@@ -169,3 +173,8 @@ def maybe_run_command(statement: str) -> bool:
+         except:
+             console.showtraceback()
+             console.resetbuffer()
++        if show_ref_count:
++            console.write(
++                f"[{sys.gettotalrefcount()} refs,"
++                f" {sys.getallocatedblocks()} blocks]\n"
++            )
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 6f9adac2277..ea69e371299 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -10,7 +10,7 @@
+ import tempfile
+ from unittest import TestCase, skipUnless, skipIf
+ from unittest.mock import patch
+-from test.support import force_not_colorized, make_clean_env
++from test.support import force_not_colorized, make_clean_env, Py_DEBUG
+ from test.support import SHORT_TIMEOUT, STDLIB_DIR
+ from test.support.import_helper import import_module
+ from test.support.os_helper import EnvironmentVarGuard, unlink
+@@ -1601,3 +1601,16 @@ def test_prompt_after_help(self):
+         # Extra stuff (newline and `exit` rewrites) are necessary
+         # because of how run_repl works.
+         self.assertNotIn(">>> \n>>> >>>", cleaned_output)
++
++    @skipUnless(Py_DEBUG, '-X showrefcount requires a Python debug build')
++    def test_showrefcount(self):
++        env = os.environ.copy()
++        env.pop("PYTHON_BASIC_REPL", "")
++        output, _ = self.run_repl("1\n1+2\nexit()\n", cmdline_args=['-Xshowrefcount'], env=env)
++        matches = re.findall(r'\[-?\d+ refs, \d+ blocks\]', output)
++        self.assertEqual(len(matches), 3)
++
++        env["PYTHON_BASIC_REPL"] = "1"
++        output, _ = self.run_repl("1\n1+2\nexit()\n", cmdline_args=['-Xshowrefcount'], env=env)
++        matches = re.findall(r'\[-?\d+ refs, \d+ blocks\]', output)
++        self.assertEqual(len(matches), 3)
+diff --git a/Misc/NEWS.d/next/Library/2025-05-17-13-46-20.gh-issue-134097.fgkjE1.rst b/Misc/NEWS.d/next/Library/2025-05-17-13-46-20.gh-issue-134097.fgkjE1.rst
+new file mode 100644
+index 00000000000..0b388d9db38
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-05-17-13-46-20.gh-issue-134097.fgkjE1.rst
+@@ -0,0 +1 @@
++Fix interaction of the new :term:`REPL` and :option:`-X showrefcount <-X>` command line option.
diff --git a/cpython/patches/1029-gh-134158-Fix-PyREPL-coloring-of-double-braces-in-f-.patch b/cpython/patches/1029-gh-134158-Fix-PyREPL-coloring-of-double-braces-in-f-.patch
new file mode 100644
index 00000000..8d4655ea
--- /dev/null
+++ b/cpython/patches/1029-gh-134158-Fix-PyREPL-coloring-of-double-braces-in-f-.patch
@@ -0,0 +1,89 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Lo=C3=AFc=20Simon?= <loic.pano@gmail.com>
+Date: Mon, 19 May 2025 16:12:23 +0200
+Subject: [PATCH] gh-134158: Fix PyREPL coloring of double braces in
+ f/t-strings (gh-134159)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Loïc Simon <loic.simon@napta.io>
+Co-authored-by: Peter Bierma <zintensitydev@gmail.com>
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+---
+ Lib/_pyrepl/utils.py                          |  8 ++++-
+ Lib/test/test_pyrepl/test_reader.py           | 31 +++++++++++++++++++
+ ...-05-17-20-44-51.gh-issue-134158.ewLNLp.rst |  1 +
+ 3 files changed, 39 insertions(+), 1 deletion(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-05-17-20-44-51.gh-issue-134158.ewLNLp.rst
+
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 1912e2d64d3..9dc74474d5a 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -36,9 +36,15 @@ def from_re(cls, m: Match[str], group: int | str) -> Self:
+ 
+     @classmethod
+     def from_token(cls, token: TI, line_len: list[int]) -> Self:
++        end_offset = -1
++        if (token.type in {T.FSTRING_MIDDLE}
++            and token.string.endswith(("{", "}"))):
++            # gh-134158: a visible trailing brace comes from a double brace in input
++            end_offset += 1
++
+         return cls(
+             line_len[token.start[0] - 1] + token.start[1],
+-            line_len[token.end[0] - 1] + token.end[1] - 1,
++            line_len[token.end[0] - 1] + token.end[1] + end_offset,
+         )
+ 
+ 
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 7077aa52ec5..6537e7e1abc 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -521,6 +521,37 @@ def unfinished_function():
+         self.assert_screen_equal(reader, code, clean=True)
+         self.assert_screen_equal(reader, expected)
+ 
++    def test_syntax_highlighting_literal_brace_in_fstring_or_tstring(self):
++        code = dedent(
++            """\
++            f"{{"
++            f"}}"
++            f"a{{b"
++            f"a}}b"
++            f"a{{b}}c"
++            t"a{{b}}c"
++            f"{{{0}}}"
++            f"{ {0} }"
++            """
++        )
++        expected = dedent(
++            """\
++            {s}f"{z}{s}<<{z}{s}"{z}
++            {s}f"{z}{s}>>{z}{s}"{z}
++            {s}f"{z}{s}a<<{z}{s}b{z}{s}"{z}
++            {s}f"{z}{s}a>>{z}{s}b{z}{s}"{z}
++            {s}f"{z}{s}a<<{z}{s}b>>{z}{s}c{z}{s}"{z}
++            {s}t"{z}{s}a<<{z}{s}b>>{z}{s}c{z}{s}"{z}
++            {s}f"{z}{s}<<{z}{o}<{z}{n}0{z}{o}>{z}{s}>>{z}{s}"{z}
++            {s}f"{z}{o}<{z} {o}<{z}{n}0{z}{o}>{z} {o}>{z}{s}"{z}
++            """
++        ).format(**colors).replace("<", "{").replace(">", "}")
++        events = code_to_events(code)
++        reader, _ = handle_all_events(events)
++        self.assert_screen_equal(reader, code, clean=True)
++        self.maxDiff=None
++        self.assert_screen_equal(reader, expected)
++
+     def test_control_characters(self):
+         code = 'flag = "🏳️‍🌈"'
+         events = code_to_events(code)
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-05-17-20-44-51.gh-issue-134158.ewLNLp.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-17-20-44-51.gh-issue-134158.ewLNLp.rst
+new file mode 100644
+index 00000000000..7b8bab739c3
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-17-20-44-51.gh-issue-134158.ewLNLp.rst
+@@ -0,0 +1 @@
++Fix coloring of double braces in f-strings and t-strings in the :term:`REPL`.
diff --git a/cpython/patches/1030-gh-134235-Import-Autocomplete-for-Builtin-Modules-GH.patch b/cpython/patches/1030-gh-134235-Import-Autocomplete-for-Builtin-Modules-GH.patch
new file mode 100644
index 00000000..f60d4ed8
--- /dev/null
+++ b/cpython/patches/1030-gh-134235-Import-Autocomplete-for-Builtin-Modules-GH.patch
@@ -0,0 +1,73 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Tom Wang <85062819+tommix626@users.noreply.github.com>
+Date: Mon, 19 May 2025 17:21:30 -0400
+Subject: [PATCH] gh-134235: Import Autocomplete for Builtin Modules
+ (GH-134277)
+
+* added enhancement auto completing import with sys builtins
+
+---------
+
+Co-authored-by: Hunter <hyoung3@gmail.com>
+---
+ Lib/_pyrepl/_module_completer.py              |  5 +++--
+ Lib/test/test_pyrepl/test_pyrepl.py           | 20 +++++++++++++++++++
+ ...-05-19-15-05-24.gh-issue-134235.pz9PwV.rst |  2 ++
+ 3 files changed, 25 insertions(+), 2 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-05-19-15-05-24.gh-issue-134235.pz9PwV.rst
+
+diff --git a/Lib/_pyrepl/_module_completer.py b/Lib/_pyrepl/_module_completer.py
+index 347f05607c7..0606797226d 100644
+--- a/Lib/_pyrepl/_module_completer.py
++++ b/Lib/_pyrepl/_module_completer.py
+@@ -81,8 +81,9 @@ def find_modules(self, path: str, prefix: str) -> list[str]:
+     def _find_modules(self, path: str, prefix: str) -> list[str]:
+         if not path:
+             # Top-level import (e.g. `import foo<tab>`` or `from foo<tab>`)`
+-            return [name for _, name, _ in self.global_cache
+-                    if name.startswith(prefix)]
++            builtin_modules = [name for name in sys.builtin_module_names if name.startswith(prefix)]
++            third_party_modules = [name for _, name, _ in self.global_cache if name.startswith(prefix)]
++            return sorted(builtin_modules + third_party_modules)
+ 
+         if path.startswith('.'):
+             # Convert relative path to absolute path
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index ea69e371299..3a23311a7ec 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -942,6 +942,26 @@ def test_import_completions(self):
+                 output = reader.readline()
+                 self.assertEqual(output, expected)
+ 
++    def test_builtin_completion_top_level(self):
++        import importlib
++        # Make iter_modules() search only the standard library.
++        # This makes the test more reliable in case there are
++        # other user packages/scripts on PYTHONPATH which can
++        # intefere with the completions.
++        lib_path = os.path.dirname(importlib.__path__[0])
++        sys.path = [lib_path]
++
++        cases = (
++            ("import bui\t\n", "import builtins"),
++            ("from bui\t\n", "from builtins"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
+     def test_relative_import_completions(self):
+         cases = (
+             ("from .readl\t\n", "from .readline"),
+diff --git a/Misc/NEWS.d/next/Library/2025-05-19-15-05-24.gh-issue-134235.pz9PwV.rst b/Misc/NEWS.d/next/Library/2025-05-19-15-05-24.gh-issue-134235.pz9PwV.rst
+new file mode 100644
+index 00000000000..a65df886919
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-05-19-15-05-24.gh-issue-134235.pz9PwV.rst
+@@ -0,0 +1,2 @@
++Updated tab completion on REPL to include builtin modules. Contributed by
++Tom Wang, Hunter Young
diff --git a/cpython/patches/1031-gh-128066-Properly-handle-history-file-writes-for-RO.patch b/cpython/patches/1031-gh-128066-Properly-handle-history-file-writes-for-RO.patch
new file mode 100644
index 00000000..b1bb9fde
--- /dev/null
+++ b/cpython/patches/1031-gh-128066-Properly-handle-history-file-writes-for-RO.patch
@@ -0,0 +1,70 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Chris Patti <feoh@feoh.org>
+Date: Tue, 20 May 2025 15:47:57 -0400
+Subject: [PATCH] gh-128066: Properly handle history file writes for RO fs on
+ PyREPL (gh-134380)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+---
+ Lib/_pyrepl/simple_interact.py                              | 2 ++
+ Lib/site.py                                                 | 6 ++++++
+ .../2025-05-20-14-41-50.gh-issue-128066.qzzGfv.rst          | 3 +++
+ 3 files changed, 11 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-05-20-14-41-50.gh-issue-128066.qzzGfv.rst
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index fad9966f91b..2d7fe280b0e 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -32,6 +32,7 @@
+ import sys
+ import code
+ import warnings
++import errno
+ 
+ from .readline import _get_reader, multiline_input, append_history_file
+ 
+@@ -155,6 +156,7 @@ def maybe_run_command(statement: str) -> bool:
+                 append_history_file()
+             except (FileNotFoundError, PermissionError, OSError) as e:
+                 warnings.warn(f"failed to open the history file for writing: {e}")
++
+             input_n += 1
+         except KeyboardInterrupt:
+             r = _get_reader()
+diff --git a/Lib/site.py b/Lib/site.py
+index 89a81c55cb6..aedf36399c3 100644
+--- a/Lib/site.py
++++ b/Lib/site.py
+@@ -75,6 +75,7 @@
+ import _sitebuiltins
+ import io
+ import stat
++import errno
+ 
+ # Prefixes for site-packages; add additional prefixes like /usr/local here
+ PREFIXES = [sys.prefix, sys.exec_prefix]
+@@ -576,6 +577,11 @@ def write_history():
+                 # home directory does not exist or is not writable
+                 # https://bugs.python.org/issue19891
+                 pass
++            except OSError:
++                if errno.EROFS:
++                    pass  # gh-128066: read-only file system
++                else:
++                    raise
+ 
+         atexit.register(write_history)
+ 
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-05-20-14-41-50.gh-issue-128066.qzzGfv.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-20-14-41-50.gh-issue-128066.qzzGfv.rst
+new file mode 100644
+index 00000000000..f7819027685
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-20-14-41-50.gh-issue-128066.qzzGfv.rst
+@@ -0,0 +1,3 @@
++Fixes an edge case where PyREPL improperly threw an error when Python is
++invoked on a read only filesystem while trying to write history file
++entries.
diff --git a/cpython/patches/1032-gh-134215-PyREPL-Do-not-show-underscored-modules-by-.patch b/cpython/patches/1032-gh-134215-PyREPL-Do-not-show-underscored-modules-by-.patch
new file mode 100644
index 00000000..e78595b3
--- /dev/null
+++ b/cpython/patches/1032-gh-134215-PyREPL-Do-not-show-underscored-modules-by-.patch
@@ -0,0 +1,142 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Kevin=20Hern=C3=A1ndez?= <kevin.hernandez@unet.edu.ve>
+Date: Tue, 20 May 2025 16:26:48 -0400
+Subject: [PATCH] gh-134215: PyREPL: Do not show underscored modules by default
+ during autocompletion (gh-134267)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Stan Ulbrych <89152624+StanFromIreland@users.noreply.github.com>
+Co-authored-by: Tomas R. <tomas.roun8@gmail.com>
+Co-authored-by: Łukasz Langa <lukasz@langa.pl>
+---
+ Lib/_pyrepl/_module_completer.py              | 15 +++++--
+ Lib/test/test_pyrepl/test_pyrepl.py           | 45 ++++++++++++++++++-
+ Misc/ACKS                                     |  1 +
+ ...-05-19-14-57-46.gh-issue-134215.sbdDK6.rst |  1 +
+ 4 files changed, 57 insertions(+), 5 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Tools-Demos/2025-05-19-14-57-46.gh-issue-134215.sbdDK6.rst
+
+diff --git a/Lib/_pyrepl/_module_completer.py b/Lib/_pyrepl/_module_completer.py
+index 0606797226d..9aafb55090e 100644
+--- a/Lib/_pyrepl/_module_completer.py
++++ b/Lib/_pyrepl/_module_completer.py
+@@ -81,8 +81,10 @@ def find_modules(self, path: str, prefix: str) -> list[str]:
+     def _find_modules(self, path: str, prefix: str) -> list[str]:
+         if not path:
+             # Top-level import (e.g. `import foo<tab>`` or `from foo<tab>`)`
+-            builtin_modules = [name for name in sys.builtin_module_names if name.startswith(prefix)]
+-            third_party_modules = [name for _, name, _ in self.global_cache if name.startswith(prefix)]
++            builtin_modules = [name for name in sys.builtin_module_names
++                               if self.is_suggestion_match(name, prefix)]
++            third_party_modules = [module.name for module in self.global_cache
++                                   if self.is_suggestion_match(module.name, prefix)]
+             return sorted(builtin_modules + third_party_modules)
+ 
+         if path.startswith('.'):
+@@ -98,7 +100,14 @@ def _find_modules(self, path: str, prefix: str) -> list[str]:
+                        if mod_info.ispkg and mod_info.name == segment]
+             modules = self.iter_submodules(modules)
+         return [module.name for module in modules
+-                if module.name.startswith(prefix)]
++                if self.is_suggestion_match(module.name, prefix)]
++
++    def is_suggestion_match(self, module_name: str, prefix: str) -> bool:
++        if prefix:
++            return module_name.startswith(prefix)
++        # For consistency with attribute completion, which
++        # does not suggest private attributes unless requested.
++        return not module_name.startswith("_")
+ 
+     def iter_submodules(self, parent_modules: list[pkgutil.ModuleInfo]) -> Iterator[pkgutil.ModuleInfo]:
+         """Iterate over all submodules of the given parent modules."""
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 3a23311a7ec..a7c19ead2b2 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -8,6 +8,7 @@
+ import subprocess
+ import sys
+ import tempfile
++from pkgutil import ModuleInfo
+ from unittest import TestCase, skipUnless, skipIf
+ from unittest.mock import patch
+ from test.support import force_not_colorized, make_clean_env, Py_DEBUG
+@@ -942,6 +943,46 @@ def test_import_completions(self):
+                 output = reader.readline()
+                 self.assertEqual(output, expected)
+ 
++    @patch("pkgutil.iter_modules", lambda: [ModuleInfo(None, "public", True),
++                                            ModuleInfo(None, "_private", True)])
++    @patch("sys.builtin_module_names", ())
++    def test_private_completions(self):
++        cases = (
++            # Return public methods by default
++            ("import \t\n", "import public"),
++            ("from \t\n", "from public"),
++            # Return private methods if explicitly specified
++            ("import _\t\n", "import _private"),
++            ("from _\t\n", "from _private"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
++    @patch(
++        "_pyrepl._module_completer.ModuleCompleter.iter_submodules",
++        lambda *_: [
++            ModuleInfo(None, "public", True),
++            ModuleInfo(None, "_private", True),
++        ],
++    )
++    def test_sub_module_private_completions(self):
++        cases = (
++            # Return public methods by default
++            ("from foo import \t\n", "from foo import public"),
++            # Return private methods if explicitly specified
++            ("from foo import _\t\n", "from foo import _private"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
+     def test_builtin_completion_top_level(self):
+         import importlib
+         # Make iter_modules() search only the standard library.
+@@ -974,8 +1015,8 @@ def test_relative_import_completions(self):
+                 output = reader.readline()
+                 self.assertEqual(output, expected)
+ 
+-    @patch("pkgutil.iter_modules", lambda: [(None, 'valid_name', None),
+-                                            (None, 'invalid-name', None)])
++    @patch("pkgutil.iter_modules", lambda: [ModuleInfo(None, "valid_name", True),
++                                            ModuleInfo(None, "invalid-name", True)])
+     def test_invalid_identifiers(self):
+         # Make sure modules which are not valid identifiers
+         # are not suggested as those cannot be imported via 'import'.
+diff --git a/Misc/ACKS b/Misc/ACKS
+index b60ce58ca00..82265ed0e44 100644
+--- a/Misc/ACKS
++++ b/Misc/ACKS
+@@ -756,6 +756,7 @@ Chris Herborth
+ Ivan Herman
+ Jürgen Hermann
+ Joshua Jay Herman
++Kevin Hernandez
+ Gary Herron
+ Ernie Hershey
+ Thomas Herve
+diff --git a/Misc/NEWS.d/next/Tools-Demos/2025-05-19-14-57-46.gh-issue-134215.sbdDK6.rst b/Misc/NEWS.d/next/Tools-Demos/2025-05-19-14-57-46.gh-issue-134215.sbdDK6.rst
+new file mode 100644
+index 00000000000..546ed2a56b6
+--- /dev/null
++++ b/Misc/NEWS.d/next/Tools-Demos/2025-05-19-14-57-46.gh-issue-134215.sbdDK6.rst
+@@ -0,0 +1 @@
++:term:`REPL` import autocomplete only suggests private modules when explicitly specified.
diff --git a/cpython/patches/1033-gh-69605-Disable-PyREPL-module-autocomplete-fallback.patch b/cpython/patches/1033-gh-69605-Disable-PyREPL-module-autocomplete-fallback.patch
new file mode 100644
index 00000000..174910a4
--- /dev/null
+++ b/cpython/patches/1033-gh-69605-Disable-PyREPL-module-autocomplete-fallback.patch
@@ -0,0 +1,121 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Lo=C3=AFc=20Simon?= <loic.pano@gmail.com>
+Date: Mon, 26 May 2025 01:05:08 +0200
+Subject: [PATCH] gh-69605: Disable PyREPL module autocomplete fallback on
+ regular completion (gh-134181)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: Loïc Simon <loic.simon@napta.io>
+---
+ Lib/_pyrepl/_module_completer.py              |  4 +--
+ Lib/_pyrepl/readline.py                       |  5 ++--
+ Lib/test/test_pyrepl/test_pyrepl.py           | 28 +++++++++++++------
+ ...5-05-18-14-33-23.gh-issue-69605.ZMO49F.rst |  2 ++
+ 4 files changed, 27 insertions(+), 12 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-05-18-14-33-23.gh-issue-69605.ZMO49F.rst
+
+diff --git a/Lib/_pyrepl/_module_completer.py b/Lib/_pyrepl/_module_completer.py
+index 9aafb55090e..2d0307d1a36 100644
+--- a/Lib/_pyrepl/_module_completer.py
++++ b/Lib/_pyrepl/_module_completer.py
+@@ -42,11 +42,11 @@ def __init__(self, namespace: Mapping[str, Any] | None = None) -> None:
+         self._global_cache: list[pkgutil.ModuleInfo] = []
+         self._curr_sys_path: list[str] = sys.path[:]
+ 
+-    def get_completions(self, line: str) -> list[str]:
++    def get_completions(self, line: str) -> list[str] | None:
+         """Return the next possible import completions for 'line'."""
+         result = ImportParser(line).parse()
+         if not result:
+-            return []
++            return None
+         try:
+             return self.complete(*result)
+         except Exception:
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index 560a9db1921..dce7e3af3a1 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -134,7 +134,8 @@ def get_stem(self) -> str:
+         return "".join(b[p + 1 : self.pos])
+ 
+     def get_completions(self, stem: str) -> list[str]:
+-        if module_completions := self.get_module_completions():
++        module_completions = self.get_module_completions()
++        if module_completions is not None:
+             return module_completions
+         if len(stem) == 0 and self.more_lines is not None:
+             b = self.buffer
+@@ -165,7 +166,7 @@ def get_completions(self, stem: str) -> list[str]:
+             result.sort()
+         return result
+ 
+-    def get_module_completions(self) -> list[str]:
++    def get_module_completions(self) -> list[str] | None:
+         line = self.get_line()
+         return self.config.module_completer.get_completions(line)
+ 
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index a7c19ead2b2..2e9f49ab499 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -901,7 +901,14 @@ def test_func(self):
+ 
+ class TestPyReplModuleCompleter(TestCase):
+     def setUp(self):
++        import importlib
++        # Make iter_modules() search only the standard library.
++        # This makes the test more reliable in case there are
++        # other user packages/scripts on PYTHONPATH which can
++        # interfere with the completions.
++        lib_path = os.path.dirname(importlib.__path__[0])
+         self._saved_sys_path = sys.path
++        sys.path = [lib_path]
+ 
+     def tearDown(self):
+         sys.path = self._saved_sys_path
+@@ -914,14 +921,6 @@ def prepare_reader(self, events, namespace):
+         return reader
+ 
+     def test_import_completions(self):
+-        import importlib
+-        # Make iter_modules() search only the standard library.
+-        # This makes the test more reliable in case there are
+-        # other user packages/scripts on PYTHONPATH which can
+-        # intefere with the completions.
+-        lib_path = os.path.dirname(importlib.__path__[0])
+-        sys.path = [lib_path]
+-
+         cases = (
+             ("import path\t\n", "import pathlib"),
+             ("import importlib.\t\tres\t\n", "import importlib.resources"),
+@@ -1032,6 +1031,19 @@ def test_invalid_identifiers(self):
+                 output = reader.readline()
+                 self.assertEqual(output, expected)
+ 
++    def test_no_fallback_on_regular_completion(self):
++        cases = (
++            ("import pri\t\n", "import pri"),
++            ("from pri\t\n", "from pri"),
++            ("from typing import Na\t\n", "from typing import Na"),
++        )
++        for code, expected in cases:
++            with self.subTest(code=code):
++                events = code_to_events(code)
++                reader = self.prepare_reader(events, namespace={})
++                output = reader.readline()
++                self.assertEqual(output, expected)
++
+     def test_get_path_and_prefix(self):
+         cases = (
+             ('', ('', '')),
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-05-18-14-33-23.gh-issue-69605.ZMO49F.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-18-14-33-23.gh-issue-69605.ZMO49F.rst
+new file mode 100644
+index 00000000000..7b7275fee69
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-05-18-14-33-23.gh-issue-69605.ZMO49F.rst
+@@ -0,0 +1,2 @@
++When auto-completing an import in the :term:`REPL`, finding no candidates
++now issues no suggestion, rather than suggestions from the current namespace.
diff --git a/cpython/patches/1034-gh-131189-Fix-msvcrt-import-warning-on-Linux-when-_c.patch b/cpython/patches/1034-gh-131189-Fix-msvcrt-import-warning-on-Linux-when-_c.patch
new file mode 100644
index 00000000..2d21279c
--- /dev/null
+++ b/cpython/patches/1034-gh-131189-Fix-msvcrt-import-warning-on-Linux-when-_c.patch
@@ -0,0 +1,33 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Dzmitry Plashchynski <plashchynski@gmail.com>
+Date: Tue, 15 Jul 2025 10:44:31 +0300
+Subject: [PATCH] gh-131189: Fix "msvcrt" import warning on Linux when
+ "_ctypes" is not available. (GH-131201)
+
+Fix "msvcrt" import warning on Linux when "_ctypes" is not available.
+
+On Linux, compiling without "libffi" causes a
+"No module named 'msvcrt'" warning when launching PyREPL.
+---
+ Lib/_pyrepl/readline.py | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/Lib/_pyrepl/readline.py b/Lib/_pyrepl/readline.py
+index dce7e3af3a1..ea3ed421080 100644
+--- a/Lib/_pyrepl/readline.py
++++ b/Lib/_pyrepl/readline.py
+@@ -43,10 +43,11 @@
+ 
+ Console: type[ConsoleType]
+ _error: tuple[type[Exception], ...] | type[Exception]
+-try:
+-    from .unix_console import UnixConsole as Console, _error
+-except ImportError:
++
++if os.name == "nt":
+     from .windows_console import WindowsConsole as Console, _error
++else:
++    from .unix_console import UnixConsole as Console, _error
+ 
+ ENCODING = sys.getdefaultencoding() or "latin1"
+ 
diff --git a/cpython/patches/1035-gh-72327-Suggest-using-system-terminal-for-pip-insta.patch b/cpython/patches/1035-gh-72327-Suggest-using-system-terminal-for-pip-insta.patch
new file mode 100644
index 00000000..93b34ea0
--- /dev/null
+++ b/cpython/patches/1035-gh-72327-Suggest-using-system-terminal-for-pip-insta.patch
@@ -0,0 +1,106 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Richard Si <sichard26@gmail.com>
+Date: Tue, 15 Jul 2025 10:25:07 -0400
+Subject: [PATCH] gh-72327: Suggest using system terminal for pip install in
+ PyREPL (#136328)
+
+Users new to Python packaging often try to use pip from the REPL only to
+be met with a confusing SyntaxError. If this happens, guide the user to
+use a system terminal instead to invoke pip.
+
+Closes #72327
+
+---------
+
+Co-authored-by: Tom Viner <tom@viner.tv>
+Co-authored-by: Brian Schubert <brianm.schubert@gmail.com>
+Co-authored-by: Hugo van Kemenade <1324225+hugovk@users.noreply.github.com>
+Co-authored-by: Alyssa Coghlan <ncoghlan@gmail.com>
+---
+ Lib/_pyrepl/console.py                            | 15 ++++++++++++++-
+ Lib/test/test_pyrepl/test_pyrepl.py               | 11 +++++++++++
+ Misc/ACKS                                         |  2 ++
+ .../2025-07-07-16-46-55.gh-issue-72327.wLvRuj.rst |  2 ++
+ 4 files changed, 29 insertions(+), 1 deletion(-)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-07-07-16-46-55.gh-issue-72327.wLvRuj.rst
+
+diff --git a/Lib/_pyrepl/console.py b/Lib/_pyrepl/console.py
+index 30fc4d4a264..c7b857a4464 100644
+--- a/Lib/_pyrepl/console.py
++++ b/Lib/_pyrepl/console.py
+@@ -26,6 +26,7 @@
+ import code
+ from dataclasses import dataclass, field
+ import os.path
++import re
+ import sys
+ 
+ 
+@@ -194,7 +195,19 @@ def runsource(self, source, filename="<input>", symbol="single"):
+                 ast.PyCF_ONLY_AST,
+                 incomplete_input=False,
+             )
+-        except (SyntaxError, OverflowError, ValueError):
++        except SyntaxError as e:
++            # If it looks like pip install was entered (a common beginner
++            # mistake), provide a hint to use the system command prompt.
++            if re.match(r"^\s*(pip3?|py(thon3?)? -m pip) install.*", source):
++                e.add_note(
++                    "The Python package manager (pip) can only be used"
++                    " outside of the Python REPL.\n"
++                    "Try the 'pip' command in a separate terminal or"
++                    " command prompt."
++                )
++            self.showsyntaxerror(filename, source=source)
++            return False
++        except (OverflowError, ValueError):
+             self.showsyntaxerror(filename, source=source)
+             return False
+         if tree.body:
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index 2e9f49ab499..e80b525ac1f 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -1687,3 +1687,14 @@ def test_showrefcount(self):
+         output, _ = self.run_repl("1\n1+2\nexit()\n", cmdline_args=['-Xshowrefcount'], env=env)
+         matches = re.findall(r'\[-?\d+ refs, \d+ blocks\]', output)
+         self.assertEqual(len(matches), 3)
++
++    def test_detect_pip_usage_in_repl(self):
++        for pip_cmd in ("pip", "pip3", "python -m pip", "python3 -m pip"):
++            with self.subTest(pip_cmd=pip_cmd):
++                output, exit_code = self.run_repl([f"{pip_cmd} install sampleproject", "exit"])
++                self.assertIn("SyntaxError", output)
++                hint = (
++                    "The Python package manager (pip) can only be used"
++                    " outside of the Python REPL"
++                )
++                self.assertIn(hint, output)
+diff --git a/Misc/ACKS b/Misc/ACKS
+index 82265ed0e44..48ab435c335 100644
+--- a/Misc/ACKS
++++ b/Misc/ACKS
+@@ -1713,6 +1713,7 @@ Joel Shprentz
+ Yue Shuaijie
+ Jaysinh Shukla
+ Terrel Shumway
++Richard Si
+ Eric Siegerman
+ Reilly Tucker Siemens
+ Paul Sijben
+@@ -1953,6 +1954,7 @@ Olivier Vielpeau
+ Kannan Vijayan
+ Kurt Vile
+ Norman Vine
++Tom Viner
+ Pauli Virtanen
+ Frank Visser
+ Long Vo
+diff --git a/Misc/NEWS.d/next/Library/2025-07-07-16-46-55.gh-issue-72327.wLvRuj.rst b/Misc/NEWS.d/next/Library/2025-07-07-16-46-55.gh-issue-72327.wLvRuj.rst
+new file mode 100644
+index 00000000000..f305abb655a
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-07-07-16-46-55.gh-issue-72327.wLvRuj.rst
+@@ -0,0 +1,2 @@
++Suggest using the system command prompt when ``pip install`` is typed into
++the REPL. Patch by Tom Viner, Richard Si, and Brian Schubert.
diff --git a/cpython/patches/1036-gh-136801-Fix-PyREPL-syntax-highlightning-on-match-c.patch b/cpython/patches/1036-gh-136801-Fix-PyREPL-syntax-highlightning-on-match-c.patch
new file mode 100644
index 00000000..3d9c7bf8
--- /dev/null
+++ b/cpython/patches/1036-gh-136801-Fix-PyREPL-syntax-highlightning-on-match-c.patch
@@ -0,0 +1,83 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Olga Matoula <olgamatoula@gmail.com>
+Date: Sat, 19 Jul 2025 14:15:49 +0100
+Subject: [PATCH] gh-136801: Fix PyREPL syntax highlightning on match cases
+ after multi-line case (GH-136804)
+
+---
+ Lib/_pyrepl/utils.py                                 |  4 ++--
+ Lib/test/test_pyrepl/test_reader.py                  | 12 +++++++-----
+ .../2025-07-19-12-37-05.gh-issue-136801.XU_tF2.rst   |  1 +
+ 3 files changed, 10 insertions(+), 7 deletions(-)
+ create mode 100644 Misc/NEWS.d/next/Core_and_Builtins/2025-07-19-12-37-05.gh-issue-136801.XU_tF2.rst
+
+diff --git a/Lib/_pyrepl/utils.py b/Lib/_pyrepl/utils.py
+index 9dc74474d5a..44d89c9de0d 100644
+--- a/Lib/_pyrepl/utils.py
++++ b/Lib/_pyrepl/utils.py
+@@ -235,14 +235,14 @@ def is_soft_keyword_used(*tokens: TI | None) -> bool:
+                 return s in keyword_first_sets_match
+             return True
+         case (
+-            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(T.DEDENT) | TI(string=":"),
+             TI(string="case"),
+             TI(T.NUMBER | T.STRING | T.FSTRING_START)
+             | TI(T.OP, string="(" | "*" | "-" | "[" | "{")
+         ):
+             return True
+         case (
+-            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(string=":"),
++            None | TI(T.NEWLINE) | TI(T.INDENT) | TI(T.DEDENT) | TI(string=":"),
+             TI(string="case"),
+             TI(T.NAME, string=s)
+         ):
+diff --git a/Lib/test/test_pyrepl/test_reader.py b/Lib/test/test_pyrepl/test_reader.py
+index 6537e7e1abc..f605b64405f 100644
+--- a/Lib/test/test_pyrepl/test_reader.py
++++ b/Lib/test/test_pyrepl/test_reader.py
+@@ -379,7 +379,8 @@ def funct(case: str = sys.platform) -> None:
+                 )
+                 match case:
+                     case "emscripten": print("on the web")
+-                    case "ios" | "android": print("on the phone")
++                    case "ios" | "android":
++                        print("on the phone")
+                     case _: print('arms around', match.group(1))
+             """
+         )
+@@ -397,7 +398,8 @@ def funct(case: str = sys.platform) -> None:
+                 {o}){z}
+                 {K}match{z} case{o}:{z}
+                     {K}case{z} {s}"emscripten"{z}{o}:{z} {b}print{z}{o}({z}{s}"on the web"{z}{o}){z}
+-                    {K}case{z} {s}"ios"{z} {o}|{z} {s}"android"{z}{o}:{z} {b}print{z}{o}({z}{s}"on the phone"{z}{o}){z}
++                    {K}case{z} {s}"ios"{z} {o}|{z} {s}"android"{z}{o}:{z}
++                        {b}print{z}{o}({z}{s}"on the phone"{z}{o}){z}
+                     {K}case{z} {K}_{z}{o}:{z} {b}print{z}{o}({z}{s}'arms around'{z}{o},{z} match{o}.{z}group{o}({z}{n}1{z}{o}){z}{o}){z}
+             """
+         )
+@@ -406,14 +408,14 @@ def funct(case: str = sys.platform) -> None:
+         reader, _ = handle_all_events(events, prepare_reader=reader_force_colors)
+         self.assert_screen_equal(reader, code, clean=True)
+         self.assert_screen_equal(reader, expected_sync)
+-        self.assertEqual(reader.pos, 2**7 + 2**8)
+-        self.assertEqual(reader.cxy, (0, 14))
++        self.assertEqual(reader.pos, 396)
++        self.assertEqual(reader.cxy, (0, 15))
+ 
+         async_msg = "{k}async{z} ".format(**colors)
+         expected_async = expected.format(a=async_msg, **colors)
+         more_events = itertools.chain(
+             code_to_events(code),
+-            [Event(evt="key", data="up", raw=bytearray(b"\x1bOA"))] * 13,
++            [Event(evt="key", data="up", raw=bytearray(b"\x1bOA"))] * 14,
+             code_to_events("async "),
+         )
+         reader, _ = handle_all_events(more_events, prepare_reader=reader_force_colors)
+diff --git a/Misc/NEWS.d/next/Core_and_Builtins/2025-07-19-12-37-05.gh-issue-136801.XU_tF2.rst b/Misc/NEWS.d/next/Core_and_Builtins/2025-07-19-12-37-05.gh-issue-136801.XU_tF2.rst
+new file mode 100644
+index 00000000000..5c0813b1a0a
+--- /dev/null
++++ b/Misc/NEWS.d/next/Core_and_Builtins/2025-07-19-12-37-05.gh-issue-136801.XU_tF2.rst
+@@ -0,0 +1 @@
++Fix PyREPL syntax highlightning on match cases after multi-line case. Contributed by Olga Matoula.
diff --git a/cpython/patches/1037-gh-135621-Remove-dependency-on-curses-from-PyREPL-GH.patch b/cpython/patches/1037-gh-135621-Remove-dependency-on-curses-from-PyREPL-GH.patch
new file mode 100644
index 00000000..746f29f7
--- /dev/null
+++ b/cpython/patches/1037-gh-135621-Remove-dependency-on-curses-from-PyREPL-GH.patch
@@ -0,0 +1,1628 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C5=81ukasz=20Langa?= <lukasz@langa.pl>
+Date: Mon, 21 Jul 2025 11:57:34 +0200
+Subject: [PATCH] gh-135621: Remove dependency on curses from PyREPL
+ (GH-136758)
+
+---
+ Lib/_pyrepl/_minimal_curses.py                |  68 --
+ Lib/_pyrepl/curses.py                         |  33 -
+ Lib/_pyrepl/terminfo.py                       | 530 ++++++++++++++
+ Lib/_pyrepl/unix_console.py                   |  16 +-
+ Lib/_pyrepl/unix_eventqueue.py                |  11 +-
+ Lib/test/test_pyrepl/__init__.py              |  18 +-
+ Lib/test/test_pyrepl/test_eventqueue.py       |  11 +-
+ Lib/test/test_pyrepl/test_pyrepl.py           |   9 +-
+ Lib/test/test_pyrepl/test_terminfo.py         | 651 ++++++++++++++++++
+ Lib/test/test_pyrepl/test_unix_console.py     |  40 +-
+ ...-07-18-17-15-00.gh-issue-135621.9cyCNb.rst |   2 +
+ 11 files changed, 1229 insertions(+), 160 deletions(-)
+ delete mode 100644 Lib/_pyrepl/_minimal_curses.py
+ delete mode 100644 Lib/_pyrepl/curses.py
+ create mode 100644 Lib/_pyrepl/terminfo.py
+ create mode 100644 Lib/test/test_pyrepl/test_terminfo.py
+ create mode 100644 Misc/NEWS.d/next/Build/2025-07-18-17-15-00.gh-issue-135621.9cyCNb.rst
+
+diff --git a/Lib/_pyrepl/_minimal_curses.py b/Lib/_pyrepl/_minimal_curses.py
+deleted file mode 100644
+index d884f880f50..00000000000
+--- a/Lib/_pyrepl/_minimal_curses.py
++++ /dev/null
+@@ -1,68 +0,0 @@
+-"""Minimal '_curses' module, the low-level interface for curses module
+-which is not meant to be used directly.
+-
+-Based on ctypes.  It's too incomplete to be really called '_curses', so
+-to use it, you have to import it and stick it in sys.modules['_curses']
+-manually.
+-
+-Note that there is also a built-in module _minimal_curses which will
+-hide this one if compiled in.
+-"""
+-
+-import ctypes
+-import ctypes.util
+-
+-
+-class error(Exception):
+-    pass
+-
+-
+-def _find_clib() -> str:
+-    trylibs = ["ncursesw", "ncurses", "curses"]
+-
+-    for lib in trylibs:
+-        path = ctypes.util.find_library(lib)
+-        if path:
+-            return path
+-    raise ModuleNotFoundError("curses library not found", name="_pyrepl._minimal_curses")
+-
+-
+-_clibpath = _find_clib()
+-clib = ctypes.cdll.LoadLibrary(_clibpath)
+-
+-clib.setupterm.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.POINTER(ctypes.c_int)]
+-clib.setupterm.restype = ctypes.c_int
+-
+-clib.tigetstr.argtypes = [ctypes.c_char_p]
+-clib.tigetstr.restype = ctypes.c_ssize_t
+-
+-clib.tparm.argtypes = [ctypes.c_char_p] + 9 * [ctypes.c_int]  # type: ignore[operator]
+-clib.tparm.restype = ctypes.c_char_p
+-
+-OK = 0
+-ERR = -1
+-
+-# ____________________________________________________________
+-
+-
+-def setupterm(termstr, fd):
+-    err = ctypes.c_int(0)
+-    result = clib.setupterm(termstr, fd, ctypes.byref(err))
+-    if result == ERR:
+-        raise error("setupterm() failed (err=%d)" % err.value)
+-
+-
+-def tigetstr(cap):
+-    if not isinstance(cap, bytes):
+-        cap = cap.encode("ascii")
+-    result = clib.tigetstr(cap)
+-    if result == ERR:
+-        return None
+-    return ctypes.cast(result, ctypes.c_char_p).value
+-
+-
+-def tparm(str, i1=0, i2=0, i3=0, i4=0, i5=0, i6=0, i7=0, i8=0, i9=0):
+-    result = clib.tparm(str, i1, i2, i3, i4, i5, i6, i7, i8, i9)
+-    if result is None:
+-        raise error("tparm() returned NULL")
+-    return result
+diff --git a/Lib/_pyrepl/curses.py b/Lib/_pyrepl/curses.py
+deleted file mode 100644
+index 3a624d9f683..00000000000
+--- a/Lib/_pyrepl/curses.py
++++ /dev/null
+@@ -1,33 +0,0 @@
+-#   Copyright 2000-2010 Michael Hudson-Doyle <micahel@gmail.com>
+-#                       Armin Rigo
+-#
+-#                        All Rights Reserved
+-#
+-#
+-# Permission to use, copy, modify, and distribute this software and
+-# its documentation for any purpose is hereby granted without fee,
+-# provided that the above copyright notice appear in all copies and
+-# that both that copyright notice and this permission notice appear in
+-# supporting documentation.
+-#
+-# THE AUTHOR MICHAEL HUDSON DISCLAIMS ALL WARRANTIES WITH REGARD TO
+-# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+-# AND FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
+-# INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+-# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+-# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+-
+-
+-try:
+-    import _curses
+-except ImportError:
+-    try:
+-        import curses as _curses  # type: ignore[no-redef]
+-    except ImportError:
+-        from . import _minimal_curses as _curses  # type: ignore[no-redef]
+-
+-setupterm = _curses.setupterm
+-tigetstr = _curses.tigetstr
+-tparm = _curses.tparm
+-error = _curses.error
+diff --git a/Lib/_pyrepl/terminfo.py b/Lib/_pyrepl/terminfo.py
+new file mode 100644
+index 00000000000..063a285bb99
+--- /dev/null
++++ b/Lib/_pyrepl/terminfo.py
+@@ -0,0 +1,530 @@
++"""Pure Python curses-like terminal capability queries."""
++
++from dataclasses import dataclass, field
++import errno
++import os
++from pathlib import Path
++import re
++import struct
++
++
++# Terminfo constants
++MAGIC16 = 0o432  # Magic number for 16-bit terminfo format
++MAGIC32 = 0o1036  # Magic number for 32-bit terminfo format
++
++# Special values for absent/cancelled capabilities
++ABSENT_BOOLEAN = -1
++ABSENT_NUMERIC = -1
++CANCELLED_NUMERIC = -2
++ABSENT_STRING = None
++CANCELLED_STRING = None
++
++
++# Standard string capability names from ncurses Caps file
++# This matches the order used by ncurses when compiling terminfo
++# fmt: off
++_STRING_NAMES: tuple[str, ...] = (
++    "cbt", "bel", "cr", "csr", "tbc", "clear", "el", "ed", "hpa", "cmdch",
++    "cup", "cud1", "home", "civis", "cub1", "mrcup", "cnorm", "cuf1", "ll",
++    "cuu1", "cvvis", "dch1", "dl1", "dsl", "hd", "smacs", "blink", "bold",
++    "smcup", "smdc", "dim", "smir", "invis", "prot", "rev", "smso", "smul",
++    "ech", "rmacs", "sgr0", "rmcup", "rmdc", "rmir", "rmso", "rmul", "flash",
++    "ff", "fsl", "is1", "is2", "is3", "if", "ich1", "il1", "ip", "kbs", "ktbc",
++    "kclr", "kctab", "kdch1", "kdl1", "kcud1", "krmir", "kel", "ked", "kf0",
++    "kf1", "kf10", "kf2", "kf3", "kf4", "kf5", "kf6", "kf7", "kf8", "kf9",
++    "khome", "kich1", "kil1", "kcub1", "kll", "knp", "kpp", "kcuf1", "kind",
++    "kri", "khts", "kcuu1", "rmkx", "smkx", "lf0", "lf1", "lf10", "lf2", "lf3",
++    "lf4", "lf5", "lf6", "lf7", "lf8", "lf9", "rmm", "smm", "nel", "pad", "dch",
++    "dl", "cud", "ich", "indn", "il", "cub", "cuf", "rin", "cuu", "pfkey",
++    "pfloc", "pfx", "mc0", "mc4", "mc5", "rep", "rs1", "rs2", "rs3", "rf", "rc",
++    "vpa", "sc", "ind", "ri", "sgr", "hts", "wind", "ht", "tsl", "uc", "hu",
++    "iprog", "ka1", "ka3", "kb2", "kc1", "kc3", "mc5p", "rmp", "acsc", "pln",
++    "kcbt", "smxon", "rmxon", "smam", "rmam", "xonc", "xoffc", "enacs", "smln",
++    "rmln", "kbeg", "kcan", "kclo", "kcmd", "kcpy", "kcrt", "kend", "kent",
++    "kext", "kfnd", "khlp", "kmrk", "kmsg", "kmov", "knxt", "kopn", "kopt",
++    "kprv", "kprt", "krdo", "kref", "krfr", "krpl", "krst", "kres", "ksav",
++    "kspd", "kund", "kBEG", "kCAN", "kCMD", "kCPY", "kCRT", "kDC", "kDL",
++    "kslt", "kEND", "kEOL", "kEXT", "kFND", "kHLP", "kHOM", "kIC", "kLFT",
++    "kMSG", "kMOV", "kNXT", "kOPT", "kPRV", "kPRT", "kRDO", "kRPL", "kRIT",
++    "kRES", "kSAV", "kSPD", "kUND", "rfi", "kf11", "kf12", "kf13", "kf14",
++    "kf15", "kf16", "kf17", "kf18", "kf19", "kf20", "kf21", "kf22", "kf23",
++    "kf24", "kf25", "kf26", "kf27", "kf28", "kf29", "kf30", "kf31", "kf32",
++    "kf33", "kf34", "kf35", "kf36", "kf37", "kf38", "kf39", "kf40", "kf41",
++    "kf42", "kf43", "kf44", "kf45", "kf46", "kf47", "kf48", "kf49", "kf50",
++    "kf51", "kf52", "kf53", "kf54", "kf55", "kf56", "kf57", "kf58", "kf59",
++    "kf60", "kf61", "kf62", "kf63", "el1", "mgc", "smgl", "smgr", "fln", "sclk",
++    "dclk", "rmclk", "cwin", "wingo", "hup","dial", "qdial", "tone", "pulse",
++    "hook", "pause", "wait", "u0", "u1", "u2", "u3", "u4", "u5", "u6", "u7",
++    "u8", "u9", "op", "oc", "initc", "initp", "scp", "setf", "setb", "cpi",
++    "lpi", "chr", "cvr", "defc", "swidm", "sdrfq", "sitm", "slm", "smicm",
++    "snlq", "snrmq", "sshm", "ssubm", "ssupm", "sum", "rwidm", "ritm", "rlm",
++    "rmicm", "rshm", "rsubm", "rsupm", "rum", "mhpa", "mcud1", "mcub1", "mcuf1",
++    "mvpa", "mcuu1", "porder", "mcud", "mcub", "mcuf", "mcuu", "scs", "smgb",
++    "smgbp", "smglp", "smgrp", "smgt", "smgtp", "sbim", "scsd", "rbim", "rcsd",
++    "subcs", "supcs", "docr", "zerom", "csnm", "kmous", "minfo", "reqmp",
++    "getm", "setaf", "setab", "pfxl", "devt", "csin", "s0ds", "s1ds", "s2ds",
++    "s3ds", "smglr", "smgtb", "birep", "binel", "bicr", "colornm", "defbi",
++    "endbi", "setcolor", "slines", "dispc", "smpch", "rmpch", "smsc", "rmsc",
++    "pctrm", "scesc", "scesa", "ehhlm", "elhlm", "elohlm", "erhlm", "ethlm",
++    "evhlm", "sgr1", "slength", "OTi2", "OTrs", "OTnl", "OTbc", "OTko", "OTma",
++    "OTG2", "OTG3", "OTG1", "OTG4", "OTGR", "OTGL", "OTGU", "OTGD", "OTGH",
++    "OTGV", "OTGC","meml", "memu", "box1"
++)
++# fmt: on
++_STRING_CAPABILITY_NAMES = {name: i for i, name in enumerate(_STRING_NAMES)}
++
++
++def _get_terminfo_dirs() -> list[Path]:
++    """Get list of directories to search for terminfo files.
++
++    Based on ncurses behavior in:
++    - ncurses/tinfo/db_iterator.c:_nc_next_db()
++    - ncurses/tinfo/read_entry.c:_nc_read_entry()
++    """
++    dirs = []
++
++    terminfo = os.environ.get("TERMINFO")
++    if terminfo:
++        dirs.append(terminfo)
++
++    try:
++        home = Path.home()
++        dirs.append(str(home / ".terminfo"))
++    except RuntimeError:
++        pass
++
++    # Check TERMINFO_DIRS
++    terminfo_dirs = os.environ.get("TERMINFO_DIRS", "")
++    if terminfo_dirs:
++        for d in terminfo_dirs.split(":"):
++            if d:
++                dirs.append(d)
++
++    dirs.extend(
++        [
++            "/etc/terminfo",
++            "/lib/terminfo",
++            "/usr/lib/terminfo",
++            "/usr/share/terminfo",
++            "/usr/share/lib/terminfo",
++            "/usr/share/misc/terminfo",
++            "/usr/local/lib/terminfo",
++            "/usr/local/share/terminfo",
++        ]
++    )
++
++    return [Path(d) for d in dirs if Path(d).is_dir()]
++
++
++def _validate_terminal_name_or_raise(terminal_name: str) -> None:
++    if not isinstance(terminal_name, str):
++        raise TypeError("`terminal_name` must be a string")
++
++    if not terminal_name:
++        raise ValueError("`terminal_name` cannot be empty")
++
++    if "\x00" in terminal_name:
++        raise ValueError("NUL character found in `terminal_name`")
++
++    t = Path(terminal_name)
++    if len(t.parts) > 1:
++        raise ValueError("`terminal_name` cannot contain path separators")
++
++
++def _read_terminfo_file(terminal_name: str) -> bytes:
++    """Find and read terminfo file for given terminal name.
++
++    Terminfo files are stored in directories using the first character
++    of the terminal name as a subdirectory.
++    """
++    _validate_terminal_name_or_raise(terminal_name)
++    first_char = terminal_name[0].lower()
++    filename = terminal_name
++
++    for directory in _get_terminfo_dirs():
++        path = directory / first_char / filename
++        if path.is_file():
++            return path.read_bytes()
++
++        # Try with hex encoding of first char (for special chars)
++        hex_dir = "%02x" % ord(first_char)
++        path = directory / hex_dir / filename
++        if path.is_file():
++            return path.read_bytes()
++
++    raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), filename)
++
++
++# Hard-coded terminal capabilities for common terminals
++# This is a minimal subset needed by PyREPL
++_TERMINAL_CAPABILITIES = {
++    # ANSI/xterm-compatible terminals
++    "ansi": {
++        # Bell
++        "bel": b"\x07",
++        # Cursor movement
++        "cub": b"\x1b[%p1%dD",  # Move cursor left N columns
++        "cud": b"\x1b[%p1%dB",  # Move cursor down N rows
++        "cuf": b"\x1b[%p1%dC",  # Move cursor right N columns
++        "cuu": b"\x1b[%p1%dA",  # Move cursor up N rows
++        "cub1": b"\x08",  # Move cursor left 1 column
++        "cud1": b"\n",  # Move cursor down 1 row
++        "cuf1": b"\x1b[C",  # Move cursor right 1 column
++        "cuu1": b"\x1b[A",  # Move cursor up 1 row
++        "cup": b"\x1b[%i%p1%d;%p2%dH",  # Move cursor to row, column
++        "hpa": b"\x1b[%i%p1%dG",  # Move cursor to column
++        # Clear operations
++        "clear": b"\x1b[H\x1b[2J",  # Clear screen and home cursor
++        "el": b"\x1b[K",  # Clear to end of line
++        # Insert/delete
++        "dch": b"\x1b[%p1%dP",  # Delete N characters
++        "dch1": b"\x1b[P",  # Delete 1 character
++        "ich": b"\x1b[%p1%d@",  # Insert N characters
++        "ich1": b"",  # Insert 1 character
++        # Cursor visibility
++        "civis": b"\x1b[?25l",  # Make cursor invisible
++        "cnorm": b"\x1b[?12l\x1b[?25h",  # Make cursor normal (visible)
++        # Scrolling
++        "ind": b"\n",  # Scroll up one line
++        "ri": b"\x1bM",  # Scroll down one line
++        # Keypad mode
++        "smkx": b"\x1b[?1h\x1b=",  # Enable keypad mode
++        "rmkx": b"\x1b[?1l\x1b>",  # Disable keypad mode
++        # Padding (not used in modern terminals)
++        "pad": b"",
++        # Function keys and special keys
++        "kdch1": b"\x1b[3~",  # Delete key
++        "kcud1": b"\x1bOB",  # Down arrow
++        "kend": b"\x1bOF",  # End key
++        "kent": b"\x1bOM",  # Enter key
++        "khome": b"\x1bOH",  # Home key
++        "kich1": b"\x1b[2~",  # Insert key
++        "kcub1": b"\x1bOD",  # Left arrow
++        "knp": b"\x1b[6~",  # Page down
++        "kpp": b"\x1b[5~",  # Page up
++        "kcuf1": b"\x1bOC",  # Right arrow
++        "kcuu1": b"\x1bOA",  # Up arrow
++        # Function keys F1-F20
++        "kf1": b"\x1bOP",
++        "kf2": b"\x1bOQ",
++        "kf3": b"\x1bOR",
++        "kf4": b"\x1bOS",
++        "kf5": b"\x1b[15~",
++        "kf6": b"\x1b[17~",
++        "kf7": b"\x1b[18~",
++        "kf8": b"\x1b[19~",
++        "kf9": b"\x1b[20~",
++        "kf10": b"\x1b[21~",
++        "kf11": b"\x1b[23~",
++        "kf12": b"\x1b[24~",
++        "kf13": b"\x1b[1;2P",
++        "kf14": b"\x1b[1;2Q",
++        "kf15": b"\x1b[1;2R",
++        "kf16": b"\x1b[1;2S",
++        "kf17": b"\x1b[15;2~",
++        "kf18": b"\x1b[17;2~",
++        "kf19": b"\x1b[18;2~",
++        "kf20": b"\x1b[19;2~",
++    },
++    # Dumb terminal - minimal capabilities
++    "dumb": {
++        "bel": b"\x07",  # Bell
++        "cud1": b"\n",  # Move down 1 row (newline)
++        "ind": b"\n",  # Scroll up one line (newline)
++    },
++    # Linux console
++    "linux": {
++        # Bell
++        "bel": b"\x07",
++        # Cursor movement
++        "cub": b"\x1b[%p1%dD",  # Move cursor left N columns
++        "cud": b"\x1b[%p1%dB",  # Move cursor down N rows
++        "cuf": b"\x1b[%p1%dC",  # Move cursor right N columns
++        "cuu": b"\x1b[%p1%dA",  # Move cursor up N rows
++        "cub1": b"\x08",  # Move cursor left 1 column (backspace)
++        "cud1": b"\n",  # Move cursor down 1 row (newline)
++        "cuf1": b"\x1b[C",  # Move cursor right 1 column
++        "cuu1": b"\x1b[A",  # Move cursor up 1 row
++        "cup": b"\x1b[%i%p1%d;%p2%dH",  # Move cursor to row, column
++        "hpa": b"\x1b[%i%p1%dG",  # Move cursor to column
++        # Clear operations
++        "clear": b"\x1b[H\x1b[J",  # Clear screen and home cursor (different from ansi!)
++        "el": b"\x1b[K",  # Clear to end of line
++        # Insert/delete
++        "dch": b"\x1b[%p1%dP",  # Delete N characters
++        "dch1": b"\x1b[P",  # Delete 1 character
++        "ich": b"\x1b[%p1%d@",  # Insert N characters
++        "ich1": b"\x1b[@",  # Insert 1 character
++        # Cursor visibility
++        "civis": b"\x1b[?25l\x1b[?1c",  # Make cursor invisible
++        "cnorm": b"\x1b[?25h\x1b[?0c",  # Make cursor normal
++        # Scrolling
++        "ind": b"\n",  # Scroll up one line
++        "ri": b"\x1bM",  # Scroll down one line
++        # Keypad mode
++        "smkx": b"\x1b[?1h\x1b=",  # Enable keypad mode
++        "rmkx": b"\x1b[?1l\x1b>",  # Disable keypad mode
++        # Function keys and special keys
++        "kdch1": b"\x1b[3~",  # Delete key
++        "kcud1": b"\x1b[B",  # Down arrow
++        "kend": b"\x1b[4~",  # End key (different from ansi!)
++        "khome": b"\x1b[1~",  # Home key (different from ansi!)
++        "kich1": b"\x1b[2~",  # Insert key
++        "kcub1": b"\x1b[D",  # Left arrow
++        "knp": b"\x1b[6~",  # Page down
++        "kpp": b"\x1b[5~",  # Page up
++        "kcuf1": b"\x1b[C",  # Right arrow
++        "kcuu1": b"\x1b[A",  # Up arrow
++        # Function keys
++        "kf1": b"\x1b[[A",
++        "kf2": b"\x1b[[B",
++        "kf3": b"\x1b[[C",
++        "kf4": b"\x1b[[D",
++        "kf5": b"\x1b[[E",
++        "kf6": b"\x1b[17~",
++        "kf7": b"\x1b[18~",
++        "kf8": b"\x1b[19~",
++        "kf9": b"\x1b[20~",
++        "kf10": b"\x1b[21~",
++        "kf11": b"\x1b[23~",
++        "kf12": b"\x1b[24~",
++        "kf13": b"\x1b[25~",
++        "kf14": b"\x1b[26~",
++        "kf15": b"\x1b[28~",
++        "kf16": b"\x1b[29~",
++        "kf17": b"\x1b[31~",
++        "kf18": b"\x1b[32~",
++        "kf19": b"\x1b[33~",
++        "kf20": b"\x1b[34~",
++    },
++}
++
++# Map common TERM values to capability sets
++_TERM_ALIASES = {
++    "xterm": "ansi",
++    "xterm-color": "ansi",
++    "xterm-256color": "ansi",
++    "screen": "ansi",
++    "screen-256color": "ansi",
++    "tmux": "ansi",
++    "tmux-256color": "ansi",
++    "vt100": "ansi",
++    "vt220": "ansi",
++    "rxvt": "ansi",
++    "rxvt-unicode": "ansi",
++    "rxvt-unicode-256color": "ansi",
++    "unknown": "dumb",
++}
++
++
++@dataclass
++class TermInfo:
++    terminal_name: str | bytes | None
++    fallback: bool = True
++
++    _names: list[str] = field(default_factory=list)
++    _booleans: list[int] = field(default_factory=list)
++    _numbers: list[int] = field(default_factory=list)
++    _strings: list[bytes | None] = field(default_factory=list)
++    _capabilities: dict[str, bytes] = field(default_factory=dict)
++
++    def __post_init__(self) -> None:
++        """Initialize terminal capabilities for the given terminal type.
++
++        Based on ncurses implementation in:
++        - ncurses/tinfo/lib_setup.c:setupterm() and _nc_setupterm()
++        - ncurses/tinfo/lib_setup.c:TINFO_SETUP_TERM()
++
++        This version first attempts to read terminfo database files like ncurses,
++        then, if `fallback` is True, falls back to hardcoded capabilities for
++        common terminal types.
++        """
++        # If termstr is None or empty, try to get from environment
++        if not self.terminal_name:
++            self.terminal_name = os.environ.get("TERM") or "ANSI"
++
++        if isinstance(self.terminal_name, bytes):
++            self.terminal_name = self.terminal_name.decode("ascii")
++
++        try:
++            self._parse_terminfo_file(self.terminal_name)
++        except (OSError, ValueError):
++            if not self.fallback:
++                raise
++
++            term_type = _TERM_ALIASES.get(
++                self.terminal_name, self.terminal_name
++            )
++            if term_type not in _TERMINAL_CAPABILITIES:
++                term_type = "dumb"
++            self._capabilities = _TERMINAL_CAPABILITIES[term_type].copy()
++
++    def _parse_terminfo_file(self, terminal_name: str) -> None:
++        """Parse a terminfo file.
++
++        Based on ncurses implementation in:
++        - ncurses/tinfo/read_entry.c:_nc_read_termtype()
++        - ncurses/tinfo/read_entry.c:_nc_read_file_entry()
++        """
++        data = _read_terminfo_file(terminal_name)
++        too_short = f"TermInfo file for {terminal_name!r} too short"
++        offset = 12
++        if len(data) < offset:
++            raise ValueError(too_short)
++
++        magic, name_size, bool_count, num_count, str_count, str_size = (
++            struct.unpack("<Hhhhhh", data[:offset])
++        )
++
++        if magic == MAGIC16:
++            number_format = "<h"  # 16-bit signed
++            number_size = 2
++        elif magic == MAGIC32:
++            number_format = "<i"  # 32-bit signed
++            number_size = 4
++        else:
++            raise ValueError(
++                f"TermInfo file for {terminal_name!r} uses unknown magic"
++            )
++
++        # Read terminal names
++        if offset + name_size > len(data):
++            raise ValueError(too_short)
++        names = data[offset : offset + name_size - 1].decode(
++            "ascii", errors="ignore"
++        )
++        offset += name_size
++
++        # Read boolean capabilities
++        if offset + bool_count > len(data):
++            raise ValueError(too_short)
++        booleans = list(data[offset : offset + bool_count])
++        offset += bool_count
++
++        # Align to even byte boundary for numbers
++        if offset % 2:
++            offset += 1
++
++        # Read numeric capabilities
++        numbers = []
++        for i in range(num_count):
++            if offset + number_size > len(data):
++                raise ValueError(too_short)
++            num = struct.unpack(
++                number_format, data[offset : offset + number_size]
++            )[0]
++            numbers.append(num)
++            offset += number_size
++
++        # Read string offsets
++        string_offsets = []
++        for i in range(str_count):
++            if offset + 2 > len(data):
++                raise ValueError(too_short)
++            off = struct.unpack("<h", data[offset : offset + 2])[0]
++            string_offsets.append(off)
++            offset += 2
++
++        # Read string table
++        if offset + str_size > len(data):
++            raise ValueError(too_short)
++        string_table = data[offset : offset + str_size]
++
++        # Extract strings from string table
++        strings: list[bytes | None] = []
++        for off in string_offsets:
++            if off < 0:
++                strings.append(CANCELLED_STRING)
++            elif off < len(string_table):
++                # Find null terminator
++                end = off
++                while end < len(string_table) and string_table[end] != 0:
++                    end += 1
++                if end <= len(string_table):
++                    strings.append(string_table[off:end])
++                else:
++                    strings.append(ABSENT_STRING)
++            else:
++                strings.append(ABSENT_STRING)
++
++        self._names = names.split("|")
++        self._booleans = booleans
++        self._numbers = numbers
++        self._strings = strings
++
++    def get(self, cap: str) -> bytes | None:
++        """Get terminal capability string by name.
++
++        Based on ncurses implementation in:
++        - ncurses/tinfo/lib_ti.c:tigetstr()
++
++        The ncurses version searches through compiled terminfo data structures.
++        This version first checks parsed terminfo data, then falls back to
++        hardcoded capabilities.
++        """
++        if not isinstance(cap, str):
++            raise TypeError(f"`cap` must be a string, not {type(cap)}")
++
++        if self._capabilities:
++            # Fallbacks populated, use them
++            return self._capabilities.get(cap)
++
++        # Look up in standard capabilities first
++        if cap in _STRING_CAPABILITY_NAMES:
++            index = _STRING_CAPABILITY_NAMES[cap]
++            if index < len(self._strings):
++                return self._strings[index]
++
++        # Note: we don't support extended capabilities since PyREPL doesn't
++        # need them.
++        return None
++
++
++def tparm(cap_bytes: bytes, *params: int) -> bytes:
++    """Parameterize a terminal capability string.
++
++    Based on ncurses implementation in:
++    - ncurses/tinfo/lib_tparm.c:tparm()
++    - ncurses/tinfo/lib_tparm.c:tparam_internal()
++
++    The ncurses version implements a full stack-based interpreter for
++    terminfo parameter strings. This pure Python version implements only
++    the subset of parameter substitution operations needed by PyREPL:
++    - %i (increment parameters for 1-based indexing)
++    - %p[1-9]%d (parameter substitution)
++    - %p[1-9]%{n}%+%d (parameter plus constant)
++    """
++    if not isinstance(cap_bytes, bytes):
++        raise TypeError(f"`cap` must be bytes, not {type(cap_bytes)}")
++
++    result = cap_bytes
++
++    # %i - increment parameters (1-based instead of 0-based)
++    increment = b"%i" in result
++    if increment:
++        result = result.replace(b"%i", b"")
++
++    # Replace %p1%d, %p2%d, etc. with actual parameter values
++    for i in range(len(params)):
++        pattern = b"%%p%d%%d" % (i + 1)
++        if pattern in result:
++            value = params[i]
++            if increment:
++                value += 1
++            result = result.replace(pattern, str(value).encode("ascii"))
++
++    # Handle %p1%{1}%+%d (parameter plus constant)
++    # Used in some cursor positioning sequences
++    pattern_re = re.compile(rb"%p(\d)%\{(\d+)\}%\+%d")
++    matches = list(pattern_re.finditer(result))
++    for match in reversed(matches):  # reversed to maintain positions
++        param_idx = int(match.group(1))
++        constant = int(match.group(2))
++        value = params[param_idx] + constant
++        result = (
++            result[: match.start()]
++            + str(value).encode("ascii")
++            + result[match.end() :]
++        )
++
++    return result
+diff --git a/Lib/_pyrepl/unix_console.py b/Lib/_pyrepl/unix_console.py
+index 9a4575193af..901a49e7d8f 100644
+--- a/Lib/_pyrepl/unix_console.py
++++ b/Lib/_pyrepl/unix_console.py
+@@ -32,7 +32,7 @@
+ import platform
+ from fcntl import ioctl
+ 
+-from . import curses
++from . import terminfo
+ from .console import Console, Event
+ from .fancy_termios import tcgetattr, tcsetattr
+ from .trace import trace
+@@ -53,7 +53,7 @@ class InvalidTerminal(RuntimeError):
+     pass
+ 
+ 
+-_error = (termios.error, curses.error, InvalidTerminal)
++_error = (termios.error, InvalidTerminal)
+ 
+ SIGWINCH_EVENT = "repaint"
+ 
+@@ -150,7 +150,7 @@ def __init__(
+ 
+         self.pollob = poll()
+         self.pollob.register(self.input_fd, select.POLLIN)
+-        curses.setupterm(term or None, self.output_fd)
++        self.terminfo = terminfo.TermInfo(term or None)
+         self.term = term
+ 
+         @overload
+@@ -160,7 +160,7 @@ def _my_getstr(cap: str, optional: Literal[False] = False) -> bytes: ...
+         def _my_getstr(cap: str, optional: bool) -> bytes | None: ...
+ 
+         def _my_getstr(cap: str, optional: bool = False) -> bytes | None:
+-            r = curses.tigetstr(cap)
++            r = self.terminfo.get(cap)
+             if not optional and r is None:
+                 raise InvalidTerminal(
+                     f"terminal doesn't have the required {cap} capability"
+@@ -194,7 +194,7 @@ def _my_getstr(cap: str, optional: bool = False) -> bytes | None:
+ 
+         self.__setup_movement()
+ 
+-        self.event_queue = EventQueue(self.input_fd, self.encoding)
++        self.event_queue = EventQueue(self.input_fd, self.encoding, self.terminfo)
+         self.cursor_visible = 1
+ 
+         signal.signal(signal.SIGCONT, self._sigcont_handler)
+@@ -592,14 +592,14 @@ def __setup_movement(self):
+         if self._dch1:
+             self.dch1 = self._dch1
+         elif self._dch:
+-            self.dch1 = curses.tparm(self._dch, 1)
++            self.dch1 = terminfo.tparm(self._dch, 1)
+         else:
+             self.dch1 = None
+ 
+         if self._ich1:
+             self.ich1 = self._ich1
+         elif self._ich:
+-            self.ich1 = curses.tparm(self._ich, 1)
++            self.ich1 = terminfo.tparm(self._ich, 1)
+         else:
+             self.ich1 = None
+ 
+@@ -696,7 +696,7 @@ def __write(self, text):
+         self.__buffer.append((text, 0))
+ 
+     def __write_code(self, fmt, *args):
+-        self.__buffer.append((curses.tparm(fmt, *args), 1))
++        self.__buffer.append((terminfo.tparm(fmt, *args), 1))
+ 
+     def __maybe_write_code(self, fmt, *args):
+         if fmt:
+diff --git a/Lib/_pyrepl/unix_eventqueue.py b/Lib/_pyrepl/unix_eventqueue.py
+index 29b3e9dd5ef..2a9cca59e74 100644
+--- a/Lib/_pyrepl/unix_eventqueue.py
++++ b/Lib/_pyrepl/unix_eventqueue.py
+@@ -18,7 +18,7 @@
+ # CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+-from . import curses
++from .terminfo import TermInfo
+ from .trace import trace
+ from .base_eventqueue import BaseEventQueue
+ from termios import tcgetattr, VERASE
+@@ -54,22 +54,23 @@
+     b'\033Oc': 'ctrl right',
+ }
+ 
+-def get_terminal_keycodes() -> dict[bytes, str]:
++def get_terminal_keycodes(ti: TermInfo) -> dict[bytes, str]:
+     """
+     Generates a dictionary mapping terminal keycodes to human-readable names.
+     """
+     keycodes = {}
+     for key, terminal_code in TERMINAL_KEYNAMES.items():
+-        keycode = curses.tigetstr(terminal_code)
++        keycode = ti.get(terminal_code)
+         trace('key {key} tiname {terminal_code} keycode {keycode!r}', **locals())
+         if keycode:
+             keycodes[keycode] = key
+     keycodes.update(CTRL_ARROW_KEYCODES)
+     return keycodes
+ 
++
+ class EventQueue(BaseEventQueue):
+-    def __init__(self, fd: int, encoding: str) -> None:
+-        keycodes = get_terminal_keycodes()
++    def __init__(self, fd: int, encoding: str, ti: TermInfo) -> None:
++        keycodes = get_terminal_keycodes(ti)
+         if os.isatty(fd):
+             backspace = tcgetattr(fd)[6][VERASE]
+             keycodes[backspace] = "backspace"
+diff --git a/Lib/test/test_pyrepl/__init__.py b/Lib/test/test_pyrepl/__init__.py
+index 8359d984462..8ef472eb0cf 100644
+--- a/Lib/test/test_pyrepl/__init__.py
++++ b/Lib/test/test_pyrepl/__init__.py
+@@ -1,14 +1,14 @@
+ import os
+-import sys
+-from test.support import requires, load_package_tests
+-from test.support.import_helper import import_module
++from test.support import load_package_tests
++import unittest
+ 
+-if sys.platform != "win32":
+-    # On non-Windows platforms, testing pyrepl currently requires that the
+-    # 'curses' resource be given on the regrtest command line using the -u
+-    # option.  Additionally, we need to attempt to import curses and readline.
+-    requires("curses")
+-    curses = import_module("curses")
++
++try:
++    import termios
++except ImportError:
++    raise unittest.SkipTest("termios required")
++else:
++    del termios
+ 
+ 
+ def load_tests(*args):
+diff --git a/Lib/test/test_pyrepl/test_eventqueue.py b/Lib/test/test_pyrepl/test_eventqueue.py
+index 6ba2440426d..a7e28be2915 100644
+--- a/Lib/test/test_pyrepl/test_eventqueue.py
++++ b/Lib/test/test_pyrepl/test_eventqueue.py
+@@ -4,6 +4,8 @@
+ from unittest.mock import patch
+ from test import support
+ 
++from _pyrepl import terminfo
++
+ try:
+     from _pyrepl.console import Event
+     from _pyrepl import base_eventqueue
+@@ -173,17 +175,22 @@ def _push(keys):
+         self.assertEqual(eq.get(), _event("key", "a"))
+ 
+ 
++class EmptyTermInfo(terminfo.TermInfo):
++    def get(self, cap: str) -> bytes:
++        return b""
++
++
+ @unittest.skipIf(support.MS_WINDOWS, "No Unix event queue on Windows")
+ class TestUnixEventQueue(EventQueueTestBase, unittest.TestCase):
+     def setUp(self):
+-        self.enterContext(patch("_pyrepl.curses.tigetstr", lambda x: b""))
+         self.file = tempfile.TemporaryFile()
+ 
+     def tearDown(self) -> None:
+         self.file.close()
+ 
+     def make_eventqueue(self) -> base_eventqueue.BaseEventQueue:
+-        return unix_eventqueue.EventQueue(self.file.fileno(), "utf-8")
++        ti = EmptyTermInfo("ansi")
++        return unix_eventqueue.EventQueue(self.file.fileno(), "utf-8", ti)
+ 
+ 
+ @unittest.skipUnless(support.MS_WINDOWS, "No Windows event queue on Unix")
+diff --git a/Lib/test/test_pyrepl/test_pyrepl.py b/Lib/test/test_pyrepl/test_pyrepl.py
+index e80b525ac1f..759a0f2d7c8 100644
+--- a/Lib/test/test_pyrepl/test_pyrepl.py
++++ b/Lib/test/test_pyrepl/test_pyrepl.py
+@@ -9,10 +9,10 @@
+ import sys
+ import tempfile
+ from pkgutil import ModuleInfo
+-from unittest import TestCase, skipUnless, skipIf
++from unittest import TestCase, skipUnless, skipIf, SkipTest
+ from unittest.mock import patch
+ from test.support import force_not_colorized, make_clean_env, Py_DEBUG
+-from test.support import SHORT_TIMEOUT, STDLIB_DIR
++from test.support import has_subprocess_support, SHORT_TIMEOUT, STDLIB_DIR
+ from test.support.import_helper import import_module
+ from test.support.os_helper import EnvironmentVarGuard, unlink
+ 
+@@ -38,6 +38,10 @@
+ 
+ 
+ class ReplTestCase(TestCase):
++    def setUp(self):
++        if not has_subprocess_support:
++            raise SkipTest("test module requires subprocess")
++
+     def run_repl(
+         self,
+         repl_input: str | list[str],
+@@ -1346,6 +1350,7 @@ def setUp(self):
+         # Cleanup from PYTHON* variables to isolate from local
+         # user settings, see #121359.  Such variables should be
+         # added later in test methods to patched os.environ.
++        super().setUp()
+         patcher = patch('os.environ', new=make_clean_env())
+         self.addCleanup(patcher.stop)
+         patcher.start()
+diff --git a/Lib/test/test_pyrepl/test_terminfo.py b/Lib/test/test_pyrepl/test_terminfo.py
+new file mode 100644
+index 00000000000..562cf5c905b
+--- /dev/null
++++ b/Lib/test/test_pyrepl/test_terminfo.py
+@@ -0,0 +1,651 @@
++"""Tests comparing PyREPL's pure Python curses implementation with the standard curses module."""
++
++import json
++import os
++import subprocess
++import sys
++import unittest
++from test.support import requires, has_subprocess_support
++from textwrap import dedent
++
++# Only run these tests if curses is available
++requires("curses")
++
++try:
++    import _curses
++except ImportError:
++    try:
++        import curses as _curses
++    except ImportError:
++        _curses = None
++
++from _pyrepl import terminfo
++
++
++ABSENT_STRING = terminfo.ABSENT_STRING
++CANCELLED_STRING = terminfo.CANCELLED_STRING
++
++
++class TestCursesCompatibility(unittest.TestCase):
++    """Test that PyREPL's curses implementation matches the standard curses behavior.
++
++    Python's `curses` doesn't allow calling `setupterm()` again with a different
++    $TERM in the same process, so we subprocess all `curses` tests to get correctly
++    set up terminfo."""
++
++    @classmethod
++    def setUpClass(cls):
++        if _curses is None:
++            raise unittest.SkipTest(
++                "`curses` capability provided to regrtest but `_curses` not importable"
++            )
++
++        if not has_subprocess_support:
++            raise unittest.SkipTest("test module requires subprocess")
++
++        # we need to ensure there's a terminfo database on the system and that
++        # `infocmp` works
++        cls.infocmp("dumb")
++
++    def setUp(self):
++        self.original_term = os.environ.get("TERM", None)
++
++    def tearDown(self):
++        if self.original_term is not None:
++            os.environ["TERM"] = self.original_term
++        elif "TERM" in os.environ:
++            del os.environ["TERM"]
++
++    @classmethod
++    def infocmp(cls, term) -> list[str]:
++        all_caps = []
++        try:
++            result = subprocess.run(
++                ["infocmp", "-l1", term],
++                capture_output=True,
++                text=True,
++                check=True,
++            )
++        except Exception:
++            raise unittest.SkipTest("calling `infocmp` failed on the system")
++
++        for line in result.stdout.splitlines():
++            line = line.strip()
++            if line.startswith("#"):
++                if "terminfo" not in line and "termcap" in line:
++                    # PyREPL terminfo doesn't parse termcap databases
++                    raise unittest.SkipTest(
++                        "curses using termcap.db: no terminfo database on"
++                        " the system"
++                    )
++            elif "=" in line:
++                cap_name = line.split("=")[0]
++                all_caps.append(cap_name)
++
++        return all_caps
++
++    def test_setupterm_basic(self):
++        """Test basic setupterm functionality."""
++        # Test with explicit terminal type
++        test_terms = ["xterm", "xterm-256color", "vt100", "ansi"]
++
++        for term in test_terms:
++            with self.subTest(term=term):
++                ncurses_code = dedent(
++                    f"""
++                    import _curses
++                    import json
++                    try:
++                        _curses.setupterm({repr(term)}, 1)
++                        print(json.dumps({{"success": True}}))
++                    except Exception as e:
++                        print(json.dumps({{"success": False, "error": str(e)}}))
++                    """
++                )
++
++                result = subprocess.run(
++                    [sys.executable, "-c", ncurses_code],
++                    capture_output=True,
++                    text=True,
++                )
++                ncurses_data = json.loads(result.stdout)
++                std_success = ncurses_data["success"]
++
++                # Set up with PyREPL curses
++                try:
++                    terminfo.TermInfo(term, fallback=False)
++                    pyrepl_success = True
++                except Exception as e:
++                    pyrepl_success = False
++                    pyrepl_error = e
++
++                # Both should succeed or both should fail
++                if std_success:
++                    self.assertTrue(
++                        pyrepl_success,
++                        f"Standard curses succeeded but PyREPL failed for {term}",
++                    )
++                else:
++                    # If standard curses failed, PyREPL might still succeed with fallback
++                    # This is acceptable as PyREPL has hardcoded fallbacks
++                    pass
++
++    def test_setupterm_none(self):
++        """Test setupterm with None (uses TERM from environment)."""
++        # Test with current TERM
++        ncurses_code = dedent(
++            """
++            import _curses
++            import json
++            try:
++                _curses.setupterm(None, 1)
++                print(json.dumps({"success": True}))
++            except Exception as e:
++                print(json.dumps({"success": False, "error": str(e)}))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        ncurses_data = json.loads(result.stdout)
++        std_success = ncurses_data["success"]
++
++        try:
++            terminfo.TermInfo(None, fallback=False)
++            pyrepl_success = True
++        except Exception:
++            pyrepl_success = False
++
++        # Both should have same result
++        if std_success:
++            self.assertTrue(
++                pyrepl_success,
++                "Standard curses succeeded but PyREPL failed for None",
++            )
++
++    def test_tigetstr_common_capabilities(self):
++        """Test tigetstr for common terminal capabilities."""
++        # Test with a known terminal type
++        term = "xterm"
++
++        # Get ALL capabilities from infocmp
++        all_caps = self.infocmp(term)
++
++        ncurses_code = dedent(
++            f"""
++            import _curses
++            import json
++            _curses.setupterm({repr(term)}, 1)
++            results = {{}}
++            for cap in {repr(all_caps)}:
++                try:
++                    val = _curses.tigetstr(cap)
++                    if val is None:
++                        results[cap] = None
++                    elif val == -1:
++                        results[cap] = -1
++                    else:
++                        results[cap] = list(val)
++                except BaseException:
++                    results[cap] = "error"
++            print(json.dumps(results))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        self.assertEqual(
++            result.returncode, 0, f"Failed to run ncurses: {result.stderr}"
++        )
++
++        ncurses_data = json.loads(result.stdout)
++
++        ti = terminfo.TermInfo(term, fallback=False)
++
++        # Test every single capability
++        for cap in all_caps:
++            if cap not in ncurses_data or ncurses_data[cap] == "error":
++                continue
++
++            with self.subTest(capability=cap):
++                ncurses_val = ncurses_data[cap]
++                if isinstance(ncurses_val, list):
++                    ncurses_val = bytes(ncurses_val)
++
++                pyrepl_val = ti.get(cap)
++
++                self.assertEqual(
++                    pyrepl_val,
++                    ncurses_val,
++                    f"Capability {cap}: ncurses={repr(ncurses_val)}, "
++                    f"pyrepl={repr(pyrepl_val)}",
++                )
++
++    def test_tigetstr_input_types(self):
++        """Test tigetstr with different input types."""
++        term = "xterm"
++        cap = "cup"
++
++        # Test standard curses behavior with string in subprocess
++        ncurses_code = dedent(
++            f"""
++            import _curses
++            import json
++            _curses.setupterm({repr(term)}, 1)
++
++            # Test with string input
++            try:
++                std_str_result = _curses.tigetstr({repr(cap)})
++                std_accepts_str = True
++                if std_str_result is None:
++                    std_str_val = None
++                elif std_str_result == -1:
++                    std_str_val = -1
++                else:
++                    std_str_val = list(std_str_result)
++            except TypeError:
++                std_accepts_str = False
++                std_str_val = None
++
++            print(json.dumps({{
++                "accepts_str": std_accepts_str,
++                "str_result": std_str_val
++            }}))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        ncurses_data = json.loads(result.stdout)
++
++        # PyREPL setup
++        ti = terminfo.TermInfo(term, fallback=False)
++
++        # PyREPL behavior with string
++        try:
++            pyrepl_str_result = ti.get(cap)
++            pyrepl_accepts_str = True
++        except TypeError:
++            pyrepl_accepts_str = False
++
++        # PyREPL should also only accept strings for compatibility
++        with self.assertRaises(TypeError):
++            ti.get(cap.encode("ascii"))
++
++        # Both should accept string input
++        self.assertEqual(
++            pyrepl_accepts_str,
++            ncurses_data["accepts_str"],
++            "PyREPL and standard curses should have same string handling",
++        )
++        self.assertTrue(
++            pyrepl_accepts_str, "PyREPL should accept string input"
++        )
++
++    def test_tparm_basic(self):
++        """Test basic tparm functionality."""
++        term = "xterm"
++        ti = terminfo.TermInfo(term, fallback=False)
++
++        # Test cursor positioning (cup)
++        cup = ti.get("cup")
++        if cup and cup not in {ABSENT_STRING, CANCELLED_STRING}:
++            # Test various parameter combinations
++            test_cases = [
++                (0, 0),  # Top-left
++                (5, 10),  # Arbitrary position
++                (23, 79),  # Bottom-right of standard terminal
++                (999, 999),  # Large values
++            ]
++
++            # Get ncurses results in subprocess
++            ncurses_code = dedent(
++                f"""
++                import _curses
++                import json
++                _curses.setupterm({repr(term)}, 1)
++
++                # Get cup capability
++                cup = _curses.tigetstr('cup')
++                results = {{}}
++
++                for row, col in {repr(test_cases)}:
++                    try:
++                        result = _curses.tparm(cup, row, col)
++                        results[f"{{row}},{{col}}"] = list(result)
++                    except Exception as e:
++                        results[f"{{row}},{{col}}"] = {{"error": str(e)}}
++
++                print(json.dumps(results))
++                """
++            )
++
++            result = subprocess.run(
++                [sys.executable, "-c", ncurses_code],
++                capture_output=True,
++                text=True,
++            )
++            self.assertEqual(
++                result.returncode, 0, f"Failed to run ncurses: {result.stderr}"
++            )
++            ncurses_data = json.loads(result.stdout)
++
++            for row, col in test_cases:
++                with self.subTest(row=row, col=col):
++                    # Standard curses tparm from subprocess
++                    key = f"{row},{col}"
++                    if (
++                        isinstance(ncurses_data[key], dict)
++                        and "error" in ncurses_data[key]
++                    ):
++                        self.fail(
++                            f"ncurses tparm failed: {ncurses_data[key]['error']}"
++                        )
++                    std_result = bytes(ncurses_data[key])
++
++                    # PyREPL curses tparm
++                    pyrepl_result = terminfo.tparm(cup, row, col)
++
++                    # Results should be identical
++                    self.assertEqual(
++                        pyrepl_result,
++                        std_result,
++                        f"tparm(cup, {row}, {col}): "
++                        f"std={repr(std_result)}, pyrepl={repr(pyrepl_result)}",
++                    )
++        else:
++            raise unittest.SkipTest(
++                "test_tparm_basic() requires the `cup` capability"
++            )
++
++    def test_tparm_multiple_params(self):
++        """Test tparm with capabilities using multiple parameters."""
++        term = "xterm"
++        ti = terminfo.TermInfo(term, fallback=False)
++
++        # Test capabilities that take parameters
++        param_caps = {
++            "cub": 1,  # cursor_left with count
++            "cuf": 1,  # cursor_right with count
++            "cuu": 1,  # cursor_up with count
++            "cud": 1,  # cursor_down with count
++            "dch": 1,  # delete_character with count
++            "ich": 1,  # insert_character with count
++        }
++
++        # Get all capabilities from PyREPL first
++        pyrepl_caps = {}
++        for cap in param_caps:
++            cap_value = ti.get(cap)
++            if cap_value and cap_value not in {
++                ABSENT_STRING,
++                CANCELLED_STRING,
++            }:
++                pyrepl_caps[cap] = cap_value
++
++        if not pyrepl_caps:
++            self.skipTest("No parametrized capabilities found")
++
++        # Get ncurses results in subprocess
++        ncurses_code = dedent(
++            f"""
++            import _curses
++            import json
++            _curses.setupterm({repr(term)}, 1)
++
++            param_caps = {repr(param_caps)}
++            test_values = [1, 5, 10, 99]
++            results = {{}}
++
++            for cap in param_caps:
++                cap_value = _curses.tigetstr(cap)
++                if cap_value and cap_value != -1:
++                    for value in test_values:
++                        try:
++                            result = _curses.tparm(cap_value, value)
++                            results[f"{{cap}},{{value}}"] = list(result)
++                        except Exception as e:
++                            results[f"{{cap}},{{value}}"] = {{"error": str(e)}}
++
++            print(json.dumps(results))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        self.assertEqual(
++            result.returncode, 0, f"Failed to run ncurses: {result.stderr}"
++        )
++        ncurses_data = json.loads(result.stdout)
++
++        for cap, cap_value in pyrepl_caps.items():
++            with self.subTest(capability=cap):
++                # Test with different parameter values
++                for value in [1, 5, 10, 99]:
++                    key = f"{cap},{value}"
++                    if key in ncurses_data:
++                        if (
++                            isinstance(ncurses_data[key], dict)
++                            and "error" in ncurses_data[key]
++                        ):
++                            self.fail(
++                                f"ncurses tparm failed: {ncurses_data[key]['error']}"
++                            )
++                        std_result = bytes(ncurses_data[key])
++
++                        pyrepl_result = terminfo.tparm(cap_value, value)
++                        self.assertEqual(
++                            pyrepl_result,
++                            std_result,
++                            f"tparm({cap}, {value}): "
++                            f"std={repr(std_result)}, pyrepl={repr(pyrepl_result)}",
++                        )
++
++    def test_tparm_null_handling(self):
++        """Test tparm with None/null input."""
++        term = "xterm"
++
++        ncurses_code = dedent(
++            f"""
++            import _curses
++            import json
++            _curses.setupterm({repr(term)}, 1)
++
++            # Test with None
++            try:
++                _curses.tparm(None)
++                raises_typeerror = False
++            except TypeError:
++                raises_typeerror = True
++            except Exception as e:
++                raises_typeerror = False
++                error_type = type(e).__name__
++
++            print(json.dumps({{"raises_typeerror": raises_typeerror}}))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        ncurses_data = json.loads(result.stdout)
++
++        # PyREPL setup
++        ti = terminfo.TermInfo(term, fallback=False)
++
++        # Test with None - both should raise TypeError
++        if ncurses_data["raises_typeerror"]:
++            with self.assertRaises(TypeError):
++                terminfo.tparm(None)
++        else:
++            # If ncurses doesn't raise TypeError, PyREPL shouldn't either
++            try:
++                terminfo.tparm(None)
++            except TypeError:
++                self.fail("PyREPL raised TypeError but ncurses did not")
++
++    def test_special_terminals(self):
++        """Test with special terminal types."""
++        special_terms = [
++            "dumb",  # Minimal terminal
++            "unknown",  # Should fall back to defaults
++            "linux",  # Linux console
++            "screen",  # GNU Screen
++            "tmux",  # tmux
++        ]
++
++        # Get all string capabilities from ncurses
++        for term in special_terms:
++            with self.subTest(term=term):
++                all_caps = self.infocmp(term)
++                ncurses_code = dedent(
++                    f"""
++                    import _curses
++                    import json
++                    import sys
++
++                    try:
++                        _curses.setupterm({repr(term)}, 1)
++                        results = {{}}
++                        for cap in {repr(all_caps)}:
++                            try:
++                                val = _curses.tigetstr(cap)
++                                if val is None:
++                                    results[cap] = None
++                                elif val == -1:
++                                    results[cap] = -1
++                                else:
++                                    # Convert bytes to list of ints for JSON
++                                    results[cap] = list(val)
++                            except BaseException:
++                                results[cap] = "error"
++                        print(json.dumps(results))
++                    except Exception as e:
++                        print(json.dumps({{"error": str(e)}}))
++                    """
++                )
++
++                # Get ncurses results
++                result = subprocess.run(
++                    [sys.executable, "-c", ncurses_code],
++                    capture_output=True,
++                    text=True,
++                )
++                if result.returncode != 0:
++                    self.fail(
++                        f"Failed to get ncurses data for {term}: {result.stderr}"
++                    )
++
++                try:
++                    ncurses_data = json.loads(result.stdout)
++                except json.JSONDecodeError:
++                    self.fail(
++                        f"Failed to parse ncurses output for {term}: {result.stdout}"
++                    )
++
++                if "error" in ncurses_data and len(ncurses_data) == 1:
++                    # ncurses failed to setup this terminal
++                    # PyREPL should still work with fallback
++                    ti = terminfo.TermInfo(term, fallback=True)
++                    continue
++
++                ti = terminfo.TermInfo(term, fallback=False)
++
++                # Compare all capabilities
++                for cap in all_caps:
++                    if cap not in ncurses_data:
++                        continue
++
++                    with self.subTest(term=term, capability=cap):
++                        ncurses_val = ncurses_data[cap]
++                        if isinstance(ncurses_val, list):
++                            # Convert back to bytes
++                            ncurses_val = bytes(ncurses_val)
++
++                        pyrepl_val = ti.get(cap)
++
++                        # Both should return the same value
++                        self.assertEqual(
++                            pyrepl_val,
++                            ncurses_val,
++                            f"Capability {cap} for {term}: "
++                            f"ncurses={repr(ncurses_val)}, "
++                            f"pyrepl={repr(pyrepl_val)}",
++                        )
++
++    def test_terminfo_fallback(self):
++        """Test that PyREPL falls back gracefully when terminfo is not found."""
++        # Use a non-existent terminal type
++        fake_term = "nonexistent-terminal-type-12345"
++
++        # Check if standard curses can setup this terminal in subprocess
++        ncurses_code = dedent(
++            f"""
++            import _curses
++            import json
++            try:
++                _curses.setupterm({repr(fake_term)}, 1)
++                print(json.dumps({{"success": True}}))
++            except _curses.error:
++                print(json.dumps({{"success": False, "error": "curses.error"}}))
++            except Exception as e:
++                print(json.dumps({{"success": False, "error": str(e)}}))
++            """
++        )
++
++        result = subprocess.run(
++            [sys.executable, "-c", ncurses_code],
++            capture_output=True,
++            text=True,
++        )
++        ncurses_data = json.loads(result.stdout)
++
++        if ncurses_data["success"]:
++            # If it succeeded, skip this test as we can't test fallback
++            self.skipTest(
++                f"System unexpectedly has terminfo for '{fake_term}'"
++            )
++
++        # PyREPL should succeed with fallback
++        try:
++            ti = terminfo.TermInfo(fake_term, fallback=True)
++            pyrepl_ok = True
++        except Exception:
++            pyrepl_ok = False
++
++        self.assertTrue(
++            pyrepl_ok, "PyREPL should fall back for unknown terminals"
++        )
++
++        # Should still be able to get basic capabilities
++        bel = ti.get("bel")
++        self.assertIsNotNone(
++            bel, "PyREPL should provide basic capabilities after fallback"
++        )
++
++    def test_invalid_terminal_names(self):
++        cases = [
++            (42, TypeError),
++            ("", ValueError),
++            ("w\x00t", ValueError),
++            (f"..{os.sep}name", ValueError),
++        ]
++
++        for term, exc in cases:
++            with self.subTest(term=term):
++                with self.assertRaises(exc):
++                    terminfo._validate_terminal_name_or_raise(term)
+diff --git a/Lib/test/test_pyrepl/test_unix_console.py b/Lib/test/test_pyrepl/test_unix_console.py
+index 73c057d6512..56a1551bf76 100644
+--- a/Lib/test/test_pyrepl/test_unix_console.py
++++ b/Lib/test/test_pyrepl/test_unix_console.py
+@@ -15,9 +15,13 @@
+ except ImportError:
+     pass
+ 
++from _pyrepl.terminfo import _TERMINAL_CAPABILITIES
++
++TERM_CAPABILITIES = _TERMINAL_CAPABILITIES["ansi"]
++
+ 
+ def unix_console(events, **kwargs):
+-    console = UnixConsole()
++    console = UnixConsole(term="xterm")
+     console.get_event = MagicMock(side_effect=events)
+ 
+     height = kwargs.get("height", 25)
+@@ -49,41 +53,11 @@ def unix_console(events, **kwargs):
+ )
+ 
+ 
+-TERM_CAPABILITIES = {
+-    "bel": b"\x07",
+-    "civis": b"\x1b[?25l",
+-    "clear": b"\x1b[H\x1b[2J",
+-    "cnorm": b"\x1b[?12l\x1b[?25h",
+-    "cub": b"\x1b[%p1%dD",
+-    "cub1": b"\x08",
+-    "cud": b"\x1b[%p1%dB",
+-    "cud1": b"\n",
+-    "cuf": b"\x1b[%p1%dC",
+-    "cuf1": b"\x1b[C",
+-    "cup": b"\x1b[%i%p1%d;%p2%dH",
+-    "cuu": b"\x1b[%p1%dA",
+-    "cuu1": b"\x1b[A",
+-    "dch1": b"\x1b[P",
+-    "dch": b"\x1b[%p1%dP",
+-    "el": b"\x1b[K",
+-    "hpa": b"\x1b[%i%p1%dG",
+-    "ich": b"\x1b[%p1%d@",
+-    "ich1": None,
+-    "ind": b"\n",
+-    "pad": None,
+-    "ri": b"\x1bM",
+-    "rmkx": b"\x1b[?1l\x1b>",
+-    "smkx": b"\x1b[?1h\x1b=",
+-}
+-
+-
+ @unittest.skipIf(sys.platform == "win32", "No Unix event queue on Windows")
+-@patch("_pyrepl.curses.tigetstr", lambda s: TERM_CAPABILITIES.get(s))
+ @patch(
+-    "_pyrepl.curses.tparm",
++    "_pyrepl.terminfo.tparm",
+     lambda s, *args: s + b":" + b",".join(str(i).encode() for i in args),
+ )
+-@patch("_pyrepl.curses.setupterm", lambda a, b: None)
+ @patch(
+     "termios.tcgetattr",
+     lambda _: [
+@@ -321,7 +295,7 @@ def same_console(events):
+ 
+     def test_getheightwidth_with_invalid_environ(self, _os_write):
+         # gh-128636
+-        console = UnixConsole()
++        console = UnixConsole(term="xterm")
+         with os_helper.EnvironmentVarGuard() as env:
+             env["LINES"] = ""
+             self.assertIsInstance(console.getheightwidth(), tuple)
+diff --git a/Misc/NEWS.d/next/Build/2025-07-18-17-15-00.gh-issue-135621.9cyCNb.rst b/Misc/NEWS.d/next/Build/2025-07-18-17-15-00.gh-issue-135621.9cyCNb.rst
+new file mode 100644
+index 00000000000..fe7f962ccbb
+--- /dev/null
++++ b/Misc/NEWS.d/next/Build/2025-07-18-17-15-00.gh-issue-135621.9cyCNb.rst
+@@ -0,0 +1,2 @@
++PyREPL no longer depends on the :mod:`curses` standard library. Contributed
++by Łukasz Langa.
diff --git a/cpython/patches/1038-gh-135621-Simplify-TermInfo-GH-136916.patch b/cpython/patches/1038-gh-135621-Simplify-TermInfo-GH-136916.patch
new file mode 100644
index 00000000..7481226a
--- /dev/null
+++ b/cpython/patches/1038-gh-135621-Simplify-TermInfo-GH-136916.patch
@@ -0,0 +1,182 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Petr Viktorin <encukou@gmail.com>
+Date: Mon, 21 Jul 2025 13:06:42 +0200
+Subject: [PATCH] gh-135621: Simplify TermInfo (GH-136916)
+
+---
+ Lib/_pyrepl/terminfo.py | 106 ++++++++++++----------------------------
+ 1 file changed, 32 insertions(+), 74 deletions(-)
+
+diff --git a/Lib/_pyrepl/terminfo.py b/Lib/_pyrepl/terminfo.py
+index 063a285bb99..d02ef69cce0 100644
+--- a/Lib/_pyrepl/terminfo.py
++++ b/Lib/_pyrepl/terminfo.py
+@@ -71,7 +71,6 @@
+     "OTGV", "OTGC","meml", "memu", "box1"
+ )
+ # fmt: on
+-_STRING_CAPABILITY_NAMES = {name: i for i, name in enumerate(_STRING_NAMES)}
+ 
+ 
+ def _get_terminfo_dirs() -> list[Path]:
+@@ -322,10 +321,6 @@ class TermInfo:
+     terminal_name: str | bytes | None
+     fallback: bool = True
+ 
+-    _names: list[str] = field(default_factory=list)
+-    _booleans: list[int] = field(default_factory=list)
+-    _numbers: list[int] = field(default_factory=list)
+-    _strings: list[bytes | None] = field(default_factory=list)
+     _capabilities: dict[str, bytes] = field(default_factory=dict)
+ 
+     def __post_init__(self) -> None:
+@@ -362,9 +357,12 @@ def __post_init__(self) -> None:
+     def _parse_terminfo_file(self, terminal_name: str) -> None:
+         """Parse a terminfo file.
+ 
++        Populate the _capabilities dict for easy retrieval
++
+         Based on ncurses implementation in:
+         - ncurses/tinfo/read_entry.c:_nc_read_termtype()
+         - ncurses/tinfo/read_entry.c:_nc_read_file_entry()
++        - ncurses/tinfo/lib_ti.c:tigetstr()
+         """
+         data = _read_terminfo_file(terminal_name)
+         too_short = f"TermInfo file for {terminal_name!r} too short"
+@@ -377,53 +375,36 @@ def _parse_terminfo_file(self, terminal_name: str) -> None:
+         )
+ 
+         if magic == MAGIC16:
+-            number_format = "<h"  # 16-bit signed
+             number_size = 2
+         elif magic == MAGIC32:
+-            number_format = "<i"  # 32-bit signed
+             number_size = 4
+         else:
+             raise ValueError(
+                 f"TermInfo file for {terminal_name!r} uses unknown magic"
+             )
+ 
+-        # Read terminal names
+-        if offset + name_size > len(data):
+-            raise ValueError(too_short)
+-        names = data[offset : offset + name_size - 1].decode(
+-            "ascii", errors="ignore"
+-        )
++        # Skip data than PyREPL doesn't need:
++        # - names (`|`-separated ASCII strings)
++        # - boolean capabilities (bytes with value 0 or 1)
++        # - numbers (little-endian integers, `number_size` bytes each)
+         offset += name_size
+-
+-        # Read boolean capabilities
+-        if offset + bool_count > len(data):
+-            raise ValueError(too_short)
+-        booleans = list(data[offset : offset + bool_count])
+         offset += bool_count
+-
+-        # Align to even byte boundary for numbers
+         if offset % 2:
++            # Align to even byte boundary for numbers
+             offset += 1
+-
+-        # Read numeric capabilities
+-        numbers = []
+-        for i in range(num_count):
+-            if offset + number_size > len(data):
+-                raise ValueError(too_short)
+-            num = struct.unpack(
+-                number_format, data[offset : offset + number_size]
+-            )[0]
+-            numbers.append(num)
+-            offset += number_size
++        offset += num_count * number_size
++        if offset > len(data):
++            raise ValueError(too_short)
+ 
+         # Read string offsets
+-        string_offsets = []
+-        for i in range(str_count):
+-            if offset + 2 > len(data):
+-                raise ValueError(too_short)
+-            off = struct.unpack("<h", data[offset : offset + 2])[0]
+-            string_offsets.append(off)
+-            offset += 2
++        end_offset = offset + 2 * str_count
++        if offset > len(data):
++            raise ValueError(too_short)
++        string_offset_data = data[offset:end_offset]
++        string_offsets = [
++            off for [off] in struct.iter_unpack("<h", string_offset_data)
++        ]
++        offset = end_offset
+ 
+         # Read string table
+         if offset + str_size > len(data):
+@@ -431,53 +412,30 @@ def _parse_terminfo_file(self, terminal_name: str) -> None:
+         string_table = data[offset : offset + str_size]
+ 
+         # Extract strings from string table
+-        strings: list[bytes | None] = []
+-        for off in string_offsets:
++        capabilities = {}
++        for cap, off in zip(_STRING_NAMES, string_offsets):
+             if off < 0:
+-                strings.append(CANCELLED_STRING)
++                # CANCELLED_STRING; we do not store those
++                continue
+             elif off < len(string_table):
+                 # Find null terminator
+-                end = off
+-                while end < len(string_table) and string_table[end] != 0:
+-                    end += 1
+-                if end <= len(string_table):
+-                    strings.append(string_table[off:end])
+-                else:
+-                    strings.append(ABSENT_STRING)
+-            else:
+-                strings.append(ABSENT_STRING)
++                end = string_table.find(0, off)
++                if end >= 0:
++                    capabilities[cap] = string_table[off:end]
++            # in other cases this is ABSENT_STRING; we don't store those.
+ 
+-        self._names = names.split("|")
+-        self._booleans = booleans
+-        self._numbers = numbers
+-        self._strings = strings
++        # Note: we don't support extended capabilities since PyREPL doesn't
++        # need them.
++
++        self._capabilities = capabilities
+ 
+     def get(self, cap: str) -> bytes | None:
+         """Get terminal capability string by name.
+-
+-        Based on ncurses implementation in:
+-        - ncurses/tinfo/lib_ti.c:tigetstr()
+-
+-        The ncurses version searches through compiled terminfo data structures.
+-        This version first checks parsed terminfo data, then falls back to
+-        hardcoded capabilities.
+         """
+         if not isinstance(cap, str):
+             raise TypeError(f"`cap` must be a string, not {type(cap)}")
+ 
+-        if self._capabilities:
+-            # Fallbacks populated, use them
+-            return self._capabilities.get(cap)
+-
+-        # Look up in standard capabilities first
+-        if cap in _STRING_CAPABILITY_NAMES:
+-            index = _STRING_CAPABILITY_NAMES[cap]
+-            if index < len(self._strings):
+-                return self._strings[index]
+-
+-        # Note: we don't support extended capabilities since PyREPL doesn't
+-        # need them.
+-        return None
++        return self._capabilities.get(cap)
+ 
+ 
+ def tparm(cap_bytes: bytes, *params: int) -> bytes:
diff --git a/cpython/patches/1039-gh-134869-Fix-Ctrl-C-corrupts-REPL-autocomplete-1349.patch b/cpython/patches/1039-gh-134869-Fix-Ctrl-C-corrupts-REPL-autocomplete-1349.patch
new file mode 100644
index 00000000..61b44ef4
--- /dev/null
+++ b/cpython/patches/1039-gh-134869-Fix-Ctrl-C-corrupts-REPL-autocomplete-1349.patch
@@ -0,0 +1,30 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: ggqlq <124190229+ggqlq@users.noreply.github.com>
+Date: Tue, 19 Aug 2025 04:54:39 +0800
+Subject: [PATCH] gh-134869: Fix Ctrl+C corrupts REPL  autocomplete (#134929)
+
+---
+ Lib/_pyrepl/simple_interact.py                                   | 1 +
+ .../next/Library/2025-08-18-16-02-51.gh-issue-134869.GnAjnU.rst  | 1 +
+ 2 files changed, 2 insertions(+)
+ create mode 100644 Misc/NEWS.d/next/Library/2025-08-18-16-02-51.gh-issue-134869.GnAjnU.rst
+
+diff --git a/Lib/_pyrepl/simple_interact.py b/Lib/_pyrepl/simple_interact.py
+index 2d7fe280b0e..1b2763f11d8 100644
+--- a/Lib/_pyrepl/simple_interact.py
++++ b/Lib/_pyrepl/simple_interact.py
+@@ -160,6 +160,7 @@ def maybe_run_command(statement: str) -> bool:
+             input_n += 1
+         except KeyboardInterrupt:
+             r = _get_reader()
++            r.cmpltn_reset()
+             if r.input_trans is r.isearch_trans:
+                 r.do_cmd(("isearch-end", [""]))
+             r.pos = len(r.get_unicode())
+diff --git a/Misc/NEWS.d/next/Library/2025-08-18-16-02-51.gh-issue-134869.GnAjnU.rst b/Misc/NEWS.d/next/Library/2025-08-18-16-02-51.gh-issue-134869.GnAjnU.rst
+new file mode 100644
+index 00000000000..abb3579aa91
+--- /dev/null
++++ b/Misc/NEWS.d/next/Library/2025-08-18-16-02-51.gh-issue-134869.GnAjnU.rst
+@@ -0,0 +1 @@
++Fix an issue where pressing Ctrl+C during tab completion in the REPL would leave the autocompletion menu in a corrupted state.
diff --git a/cpython/patches/1040-hacks.patch b/cpython/patches/1040-hacks.patch
new file mode 100644
index 00000000..d2e03efb
--- /dev/null
+++ b/cpython/patches/1040-hacks.patch
@@ -0,0 +1,14 @@
+diff --git a/Python/emscripten_syscalls.c b/Python/emscripten_syscalls.c
+index 44044ca3fc1..2310127c3c0 100644
+--- a/Python/emscripten_syscalls.c
++++ b/Python/emscripten_syscalls.c
+@@ -82,7 +82,8 @@ EM_JS_MACROS(void, _emscripten_promising_main_js, (void), {
+             orig.sym = (...args) => {
+                 (async () => {
+                     const ret = await main(...args);
+-                    Module.onExit?.(ret);
++                    // TODO: this breaks Pyodide for some reason
++                    //Module.onExit?.(ret);
+                 })();
+                 _emscripten_exit_with_live_runtime();
+             };
