var y_=Object.defineProperty;var qe=(n,l)=>()=>(n&&(l=n(n=0)),l);var de=(n,l)=>{for(var b in l)y_(n,b,{get:l[b],enumerable:!0})};var t_={};de(t_,{filesystem:()=>F_,modules:()=>k_});var k_,F_,n_=qe(()=>{k_={"yosys.core.wasm":new URL("yosys.core-98005d95.wasm?hash=98005d95",import.meta.url),"yosys.core2.wasm":new URL("yosys.core2-0d6ad336.wasm?hash=0d6ad336",import.meta.url),"yosys.core3.wasm":new URL("yosys.core3-5cd4aa1c.wasm?hash=5cd4aa1c",import.meta.url),"yosys.core4.wasm":new URL("yosys.core4-0ce2f110.wasm?hash=0ce2f110",import.meta.url)},F_={share:{"abc9_map.v":`\`ifdef DFF
(* techmap_celltype = "$_DFF_[PN]_" *)
module $_DFF_x_(input C, D, output Q);
  parameter [0:0] _TECHMAP_WIREINIT_Q_ = 1'bx;
  parameter _TECHMAP_CELLTYPE_ = "";
  wire D_;
  generate if (_TECHMAP_CELLTYPE_ == "$_DFF_N_") begin
    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin
      $__DFF_N__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));
      $_DFF_N_ ff (.C(C), .D(D_), .Q(Q));
    end
    else
      (* abc9_keep *) $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  end
  else if (_TECHMAP_CELLTYPE_ == "$_DFF_P_") begin
    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin
      $__DFF_P__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));
      $_DFF_P_ ff (.C(C), .D(D_), .Q(Q));
    end
    else
      (* abc9_keep *) $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  end
  else if (_TECHMAP_CELLTYPE_ != "")
    $error("Unrecognised _TECHMAP_CELLTYPE_");
  endgenerate
endmodule
\`endif
`,"abc9_model.v":`(* abc9_box *)
module $__ABC9_DELAY (input I, output O);
  parameter DELAY = 0;
  specify
    (I => O) = DELAY;
  endspecify
endmodule

module $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);
parameter WIDTH = 0;
endmodule

(* abc9_flop, abc9_box, lib_whitebox *)
module $__DFF_N__$abc9_flop (input C, D, Q, output n1);
  assign n1 = D;
  specify
    $setup(D, posedge C, 0);
    (posedge C => (n1:D)) = 0;
  endspecify
endmodule

(* abc9_flop, abc9_box, lib_whitebox *)
module $__DFF_P__$abc9_flop (input C, D, Q, output n1);
  assign n1 = D;
  specify
    $setup(D, posedge C, 0);
    (posedge C => (n1:D)) = 0;
  endspecify
endmodule
`,"abc9_unmap.v":`(* techmap_celltype = "$__DFF_N__$abc9_flop $__DFF_P__$abc9_flop" *)
module $__DFF_x__$abc9_flop (input C, D, (* init = 1'b0 *) input Q, output n1);
  parameter _TECHMAP_CELLTYPE_ = "";
  generate if (_TECHMAP_CELLTYPE_ == "$__DFF_N__$abc9_flop")
    $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  else if (_TECHMAP_CELLTYPE_ == "$__DFF_P__$abc9_flop")
    $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  else if (_TECHMAP_CELLTYPE_ != "")
    $error("Unrecognised _TECHMAP_CELLTYPE_");
  endgenerate
endmodule

module $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);
parameter WIDTH = 0;
assign O = I;
endmodule
`,achronix:{speedster22i:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Achronix eFPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board/custom chip.

// > Input/Output buffers <
// Input buffer map
module \\$__inpad (input I, output O);
    PADIN _TECHMAP_REPLACE_ (.padout(O), .padin(I));
endmodule
// Output buffer map
module \\$__outpad (input I, output O);
    PADOUT _TECHMAP_REPLACE_ (.padout(O), .padin(I), .oe(1'b1));
endmodule
// > end buffers <

// > Look-Up table <
// > VT: I still think Achronix folks would have chosen a better \\
// >     logic architecture.
// LUT Map
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output 	     Y;
   generate
      if (WIDTH == 1) begin
	   // VT: This is not consistent and ACE will complain: assign Y = ~A[0];
         LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_
           (.dout(Y), .din0(A[0]), .din1(1'b0), .din2(1'b0), .din3(1'b0));
      end else
      if (WIDTH == 2) begin
              LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_
                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(1'b0), .din3(1'b0));
      end else
      if(WIDTH == 3) begin
	      LUT4 #(.lut_function({2{LUT}})) _TECHMAP_REPLACE_
                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(1'b0));
      end else
      if(WIDTH == 4) begin
             LUT4 #(.lut_function(LUT)) _TECHMAP_REPLACE_
               (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule
// > end LUT <

// > Flops <
// DFF flop
module  \\$_DFF_P_ (input D, C, output Q);
   DFF _TECHMAP_REPLACE_
     (.q(Q), .d(D), .ck(C));
endmodule

`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Achronix eFPGA technology sim models. User must first simulate the generated \\
// > netlist before going to test it on board/custom chip.
// > Changelog: 1) Removed unused VCC/GND modules
// >            2) Altera comments here (?). Removed.
// >            3) Reusing LUT sim model, removed wrong wires and parameters.

module PADIN (output padout, input padin);
   assign padout = padin;
endmodule

module PADOUT (output padout, input padin, input oe);
   assign padout  = padin;
   assign oe = oe;
endmodule

module LUT4 (output dout,
             input  din0, din1, din2, din3);

parameter [15:0] lut_function = 16'hFFFF;
reg combout_rt;
wire dataa_w;
wire datab_w;
wire datac_w;
wire datad_w;

assign dataa_w = din0;
assign datab_w = din1;
assign datac_w = din2;
assign datad_w = din3;

function lut_data;
input [15:0] mask;
input        dataa, datab, datac, datad;
reg [7:0]   s3;
reg [3:0]   s2;
reg [1:0]   s1;
  begin
       s3 = datad ? mask[15:8] : mask[7:0];
       s2 = datac ?   s3[7:4]  :   s3[3:0];
       s1 = datab ?   s2[3:2]  :   s2[1:0];
       lut_data = dataa ? s1[1] : s1[0];
  end
endfunction

always @(dataa_w or datab_w or datac_w or datad_w) begin
   combout_rt = lut_data(lut_function, dataa_w, datab_w,
                         datac_w, datad_w);
end
assign dout = combout_rt & 1'b1;
endmodule

module DFF (output reg q,
            input  d, ck);
   always @(posedge ck)
     q <= d;

endmodule



`}},"adff2dff.v":`(* techmap_celltype = "$adff" *)
module adff2dff (CLK, ARST, D, Q);
	parameter WIDTH = 1;
	parameter CLK_POLARITY = 1;
	parameter ARST_POLARITY = 1;
	parameter ARST_VALUE = 0;

	input CLK, ARST;
	(* force_downto *)
	input [WIDTH-1:0] D;
	(* force_downto *)
	output reg [WIDTH-1:0] Q;
	(* force_downto *)
	reg [WIDTH-1:0] NEXT_Q;

	wire [1023:0] _TECHMAP_DO_ = "proc;;";

	always @*
		if (ARST == ARST_POLARITY)
			NEXT_Q <= ARST_VALUE;
		else
			NEXT_Q <= D;

	if (CLK_POLARITY)
		always @(posedge CLK)
			Q <= NEXT_Q;
	else
		always @(negedge CLK)
			Q <= NEXT_Q;
endmodule
`,anlogic:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_anlogic_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH  = 1;
	parameter B_WIDTH  = 1;
	parameter Y_WIDTH  = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;
   
	wire CIx;
	(* force_downto *)
	wire [Y_WIDTH-1:0] COx;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = { COx, CIx };

    wire dummy;
    AL_MAP_ADDER #(
    	.ALUTYPE("ADD_CARRY"))
    adder_cin  (
        .a(CI),
		.b(1'b0),
		.c(1'b0),
        .o({CIx, dummy})
	);

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice
	    AL_MAP_ADDER #(
            .ALUTYPE("ADD")
        ) adder_i (
            .a(AA[i]),
            .b(BB[i]),
            .c(C[i]),
            .o({COx[i],Y[i]})
        );

		wire cout;
		AL_MAP_ADDER #(
			.ALUTYPE("ADD"))
		adder_cout  (
			.a(1'b0),
			.b(1'b0),
			.c(COx[i]),
			.o({cout, CO[i]})
		);
	  end: slice	  
	endgenerate

   /* End implementation */
   assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__ANLOGIC_BRAM_TDP_ {
	abits 13;
	widths 1 2 4 9 per_port;
	cost 64;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__ANLOGIC_BRAM_SDP_ {
	abits 13;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 64;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		clock anyedge;
		clken;
	}
}

ram block $__ANLOGIC_BRAM32K_ {
	abits 12;
	widths 8 16 per_port;
	byte 8;
	cost 192;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		# no reset - it doesn't really work without the pipeline
		# output registers
	}
}
`,"brams_map.v":`module $__ANLOGIC_BRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 9;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [12:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 9;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [12:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [255:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];
	end
endfunction

function [255:0] initp_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1) begin
		initp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];
	end
endfunction

wire [8:0] DOA;
wire [8:0] DOB;
// the replication is important \u2014 the BRAM behaves in... unexpected ways for
// width 1 and 2
wire [8:0] DIA = {9{PORT_A_WR_DATA}};
wire [8:0] DIB = {9{PORT_B_WR_DATA}};

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

EG_PHY_BRAM #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INITP_00(initp_slice('h00)),
	.INITP_01(initp_slice('h01)),
	.INITP_02(initp_slice('h02)),
	.INITP_03(initp_slice('h03)),
	.MODE("DP8K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_B_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CLKAMUX(PORT_A_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "SIG" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
) _TECHMAP_REPLACE_ (
	.clka(PORT_A_CLK),
	.wea(PORT_A_WR_EN),
	.cea(PORT_A_CLK_EN),
	.ocea(1'b1),
	.rsta(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.csa(3'b111),
	.addra(PORT_A_WIDTH == 9 ? {PORT_A_ADDR[12:1], 1'b1} : PORT_A_ADDR),
	.dia(DIA),
	.doa(DOA),

	.clkb(PORT_B_CLK),
	.web(PORT_B_WR_EN),
	.ceb(PORT_B_CLK_EN),
	.oceb(1'b1),
	.rstb(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.csb(3'b111),
	.addrb(PORT_B_WIDTH == 9 ? {PORT_B_ADDR[12:1], 1'b1} : PORT_B_ADDR),
	.dib(DIB),
	.dob(DOB),
);

endmodule


module $__ANLOGIC_BRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 18;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [12:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 18;
parameter PORT_W_WR_EN_WIDTH = 2;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [12:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [255:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];
	end
endfunction

function [255:0] initp_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1) begin
		initp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];
	end
endfunction

wire [17:0] DI = {18{PORT_W_WR_DATA}};
wire [17:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];

EG_PHY_BRAM #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INITP_00(initp_slice('h00)),
	.INITP_01(initp_slice('h01)),
	.INITP_02(initp_slice('h02)),
	.INITP_03(initp_slice('h03)),
	.MODE("PDPW8K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_W_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_R_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CLKAMUX(PORT_W_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "SIG" : "INV"),
) _TECHMAP_REPLACE_ (
	.clka(PORT_W_CLK),
	.wea(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),
	.cea(PORT_W_CLK_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.csa(3'b111),
	.addra(PORT_W_WIDTH == 18 ? {PORT_W_ADDR[12:2], PORT_W_WR_EN[1:0]} : (PORT_W_WIDTH == 9 ? {PORT_W_ADDR[12:1], PORT_W_WR_EN[0]} : PORT_W_ADDR)),
	.dia(DI[8:0]),
	.doa(DO[8:0]),

	.clkb(PORT_R_CLK),
	.web(1'b0),
	.ceb(PORT_R_CLK_EN),
	.oceb(1'b1),
	.rstb(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.csb(3'b111),
	.addrb(PORT_R_ADDR),
	.dib(DI[17:9]),
	.dob(DO[17:9]),
);

endmodule


module $__ANLOGIC_BRAM32K_ (...);

parameter INIT = 0;

parameter PORT_A_WIDTH = 16;
parameter PORT_A_WR_EN_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
input [11:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 16;
parameter PORT_B_WR_EN_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
input [11:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [255:0] init_slice;
	input integer idx;
	init_slice = INIT[256 * idx +: 256];
endfunction

wire [15:0] DOA;
wire [15:0] DOB;
wire [15:0] DIA = PORT_A_WR_DATA;
wire [15:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

wire BYTE_A, BYTEWE_A;
wire BYTE_B, BYTEWE_B;

generate

if (PORT_A_WIDTH == 8) begin
	assign BYTE_A = PORT_A_ADDR[0];
	assign BYTEWE_A = 1;
end else begin
	assign BYTE_A = PORT_A_WR_EN == 2;
	assign BYTEWE_A = ^PORT_A_WR_EN;
end

if (PORT_B_WIDTH == 8) begin
	assign BYTE_B = PORT_B_ADDR[0];
	assign BYTEWE_B = 1;
end else begin
	assign BYTE_B = PORT_B_WR_EN == 2;
	assign BYTEWE_B = ^PORT_B_WR_EN;
end

endgenerate

EG_PHY_BRAM32K #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INIT_20(init_slice('h20)),
	.INIT_21(init_slice('h21)),
	.INIT_22(init_slice('h22)),
	.INIT_23(init_slice('h23)),
	.INIT_24(init_slice('h24)),
	.INIT_25(init_slice('h25)),
	.INIT_26(init_slice('h26)),
	.INIT_27(init_slice('h27)),
	.INIT_28(init_slice('h28)),
	.INIT_29(init_slice('h29)),
	.INIT_2A(init_slice('h2a)),
	.INIT_2B(init_slice('h2b)),
	.INIT_2C(init_slice('h2c)),
	.INIT_2D(init_slice('h2d)),
	.INIT_2E(init_slice('h2e)),
	.INIT_2F(init_slice('h2f)),
	.INIT_30(init_slice('h30)),
	.INIT_31(init_slice('h31)),
	.INIT_32(init_slice('h32)),
	.INIT_33(init_slice('h33)),
	.INIT_34(init_slice('h34)),
	.INIT_35(init_slice('h35)),
	.INIT_36(init_slice('h36)),
	.INIT_37(init_slice('h37)),
	.INIT_38(init_slice('h38)),
	.INIT_39(init_slice('h39)),
	.INIT_3A(init_slice('h3a)),
	.INIT_3B(init_slice('h3b)),
	.INIT_3C(init_slice('h3c)),
	.INIT_3D(init_slice('h3d)),
	.INIT_3E(init_slice('h3e)),
	.INIT_3F(init_slice('h3f)),
	.INIT_40(init_slice('h40)),
	.INIT_41(init_slice('h41)),
	.INIT_42(init_slice('h42)),
	.INIT_43(init_slice('h43)),
	.INIT_44(init_slice('h44)),
	.INIT_45(init_slice('h45)),
	.INIT_46(init_slice('h46)),
	.INIT_47(init_slice('h47)),
	.INIT_48(init_slice('h48)),
	.INIT_49(init_slice('h49)),
	.INIT_4A(init_slice('h4a)),
	.INIT_4B(init_slice('h4b)),
	.INIT_4C(init_slice('h4c)),
	.INIT_4D(init_slice('h4d)),
	.INIT_4E(init_slice('h4e)),
	.INIT_4F(init_slice('h4f)),
	.INIT_50(init_slice('h50)),
	.INIT_51(init_slice('h51)),
	.INIT_52(init_slice('h52)),
	.INIT_53(init_slice('h53)),
	.INIT_54(init_slice('h54)),
	.INIT_55(init_slice('h55)),
	.INIT_56(init_slice('h56)),
	.INIT_57(init_slice('h57)),
	.INIT_58(init_slice('h58)),
	.INIT_59(init_slice('h59)),
	.INIT_5A(init_slice('h5a)),
	.INIT_5B(init_slice('h5b)),
	.INIT_5C(init_slice('h5c)),
	.INIT_5D(init_slice('h5d)),
	.INIT_5E(init_slice('h5e)),
	.INIT_5F(init_slice('h5f)),
	.INIT_60(init_slice('h60)),
	.INIT_61(init_slice('h61)),
	.INIT_62(init_slice('h62)),
	.INIT_63(init_slice('h63)),
	.INIT_64(init_slice('h64)),
	.INIT_65(init_slice('h65)),
	.INIT_66(init_slice('h66)),
	.INIT_67(init_slice('h67)),
	.INIT_68(init_slice('h68)),
	.INIT_69(init_slice('h69)),
	.INIT_6A(init_slice('h6a)),
	.INIT_6B(init_slice('h6b)),
	.INIT_6C(init_slice('h6c)),
	.INIT_6D(init_slice('h6d)),
	.INIT_6E(init_slice('h6e)),
	.INIT_6F(init_slice('h6f)),
	.INIT_70(init_slice('h70)),
	.INIT_71(init_slice('h71)),
	.INIT_72(init_slice('h72)),
	.INIT_73(init_slice('h73)),
	.INIT_74(init_slice('h74)),
	.INIT_75(init_slice('h75)),
	.INIT_76(init_slice('h76)),
	.INIT_77(init_slice('h77)),
	.INIT_78(init_slice('h78)),
	.INIT_79(init_slice('h79)),
	.INIT_7A(init_slice('h7a)),
	.INIT_7B(init_slice('h7b)),
	.INIT_7C(init_slice('h7c)),
	.INIT_7D(init_slice('h7d)),
	.INIT_7E(init_slice('h7e)),
	.INIT_7F(init_slice('h7f)),
	.MODE("DP16K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_B_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.CLKAMUX(PORT_A_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "SIG" : "INV"),
) _TECHMAP_REPLACE_ (
	.clka(PORT_A_CLK),
	.csa(PORT_A_CLK_EN),
	.wea(|PORT_A_WR_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.addra(PORT_A_ADDR[11:1]),
	.bytea(BYTE_A),
	.bytewea(BYTEWE_A),
	.dia(DIA),
	.doa(DOA),

	.clkb(PORT_B_CLK),
	.csb(PORT_B_CLK_EN),
	.web(|PORT_B_WR_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.addrb(PORT_B_ADDR[11:1]),
	.byteb(BYTE_B),
	.byteweb(BYTEWE_B),
	.dib(DIB),
	.dob(DOB),
);

endmodule
`,"cells_map.v":`module  \\$_DFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DLATCH_NN0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E) ,.ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NN1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NP0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NP1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      AL_MAP_LUT1 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]));
    end else
    if (WIDTH == 2) begin
      AL_MAP_LUT2 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]));
    end else
    if (WIDTH == 3) begin
      AL_MAP_LUT3 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]));
    end else
    if (WIDTH == 4) begin
      AL_MAP_LUT4 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]));
    end else
    if (WIDTH == 5) begin
      AL_MAP_LUT5 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]));
    end else
    if (WIDTH == 6) begin
      AL_MAP_LUT6 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]), .f(A[5]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`module AL_MAP_SEQ (
	output reg q,
	input ce,
	input clk,
	input sr,
	input d
);
	parameter DFFMODE = "FF"; //FF,LATCH
	parameter REGSET = "RESET"; //RESET/SET
	parameter SRMUX = "SR"; //SR/INV
	parameter SRMODE = "SYNC"; //SYNC/ASYNC

	wire srmux;
	generate
		case (SRMUX)
			"SR": assign srmux = sr;
			"INV": assign srmux = ~sr;
			default: assign srmux = sr;
		endcase
	endgenerate

	wire regset;
	generate
		case (REGSET)
			"RESET": assign regset = 1'b0;
			"SET": assign regset = 1'b1;
			default: assign regset = 1'b0;
		endcase
	endgenerate

	initial q = regset;

	generate
		if (DFFMODE == "FF")
		begin
			if (SRMODE == "ASYNC")
			begin
				always @(posedge clk, posedge srmux)
					if (srmux)
						q <= regset;
					else if (ce)
						q <= d;
			end
			else
			begin
				always @(posedge clk)
					if (srmux)
						q <= regset;
					else if (ce)
						q <= d;
			end
		end
		else
		begin
			// DFFMODE == "LATCH"
			if (SRMODE == "ASYNC")
			begin
				always @*
					if (srmux)
						q <= regset;
					else if (~clk & ce)
						q <= d;
			end
			else
			begin
				always @*
					if (~clk) begin
						if (srmux)
							q <= regset;
						else if (ce)
							q <= d;
					end
			end
		end
    endgenerate
endmodule

module AL_MAP_LUT1 (
	output o,
	input a
);
	parameter [1:0] INIT = 2'h0;
	parameter EQN = "(A)";

	assign o = a ? INIT[1] : INIT[0];	
endmodule

module AL_MAP_LUT2 (
	output o,
	input a,
	input b
);
	parameter [3:0] INIT = 4'h0;
	parameter EQN = "(A)";

	wire [1:0] s1 = b ? INIT[ 3:2] : INIT[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT3 (
	output o,
	input a,
	input b,
	input c
);
	parameter [7:0] INIT = 8'h0;
	parameter EQN = "(A)";

	wire [3:0] s2 = c ? INIT[ 7:4] : INIT[3:0];
	wire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT4 (
	output o,
	input a,
	input b,
	input c,
	input d
);
	parameter [15:0] INIT = 16'h0;
	parameter EQN = "(A)";

	wire [7:0] s3 = d ? INIT[15:8] : INIT[7:0];
	wire [3:0] s2 = c ?   s3[ 7:4] :   s3[3:0];
	wire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT5 (
	output o,
	input a,
	input b,
	input c,
	input d,
	input e
);
	parameter [31:0] INIT = 32'h0;
	parameter EQN = "(A)";
	assign o = INIT >> {e, d, c, b, a};
endmodule


module AL_MAP_LUT6 (
	output o,
	input a,
	input b,
	input c,
	input d,
	input e,
	input f
);
	parameter [63:0] INIT = 64'h0;
	parameter EQN = "(A)";
	assign o = INIT >> {f, e, d, c, b, a};
endmodule

module AL_MAP_ALU2B (
   input cin,
   input a0, b0, c0, d0,
   input a1, b1, c1, d1,
   output s0, s1, cout
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter FUNC0 = "NO";
	parameter FUNC1 = "NO";
endmodule

module AL_MAP_ADDER (
  input a,
  input b,
  input c,
  output [1:0] o
);
	parameter ALUTYPE = "ADD";

	generate
		case (ALUTYPE)
			"ADD": 		 assign o = a + b + c;
			"SUB": 		 assign o = a - b - c;
			"A_LE_B":    assign o = a - b - c;

			"ADD_CARRY":    assign o = {  a, 1'b0 };
			"SUB_CARRY":    assign o = { ~a, 1'b0 };
			"A_LE_B_CARRY": assign o = {  a, 1'b0 };
			default: assign o = a + b + c;
		endcase
	endgenerate	

endmodule
`,"eagle_bb.v":`// Anlogic Eagle - Blackbox cells
// FIXME: Create sim models

(* blackbox *)
module EG_LOGIC_BUF(
  output o,
  input i
);
endmodule

(* blackbox *)
module EG_LOGIC_BUFG(
  output o,
  input i
);
endmodule

(* blackbox *)
module EG_LOGIC_BUFIO(
  input clki,
  input rst,
  input coe,
  output clko,
  output clkdiv1,
  output clkdivx
);
  parameter GSR = "DISABLE";
  parameter DIV = 2;
  parameter STOPCLK = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_BUFGMUX(
  output o,
  input i0,
  input i1,
  input s
);
  parameter INIT_OUT = "0";
  parameter PRESELECT_I0 = "TRUE";
  parameter PRESELECT_I1 = "FALSE";
endmodule

(* blackbox *)
module EG_LOGIC_MBOOT(
  input rebootn,
  input [7:0] dynamic_addr  
);
  parameter ADDR_SOURCE_SEL = "STATIC";
  parameter STATIC_ADDR = 8'b00000000;
endmodule

(* blackbox *)
module EG_LOGIC_DNA(
  output dout,
  input  clk,
  input  din,
  input  shift_en
);
endmodule

(* blackbox *)
module EG_LOGIC_GCTRL(
  output done,
  output highz
);
endmodule

(* blackbox *)
module EG_LOGIC_GSRN(
  input gsrn,
  input sync_clk
);
  parameter GSRN_SYNC_SEL = "DISABLE";
  parameter USR_GSRN_EN = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_CCLK(
  output cclk,
  input  en
);
  parameter FREQ = "4.5";
endmodule

(* blackbox *)
module EG_LOGIC_IDELAY(
  output o,
  input i
);
  parameter INDEL = 0;
endmodule

(* blackbox *)
module EG_LOGIC_IDDR(
  output q1,
  output q0,
  input clk,
  input d,
  input rst
);
  parameter ASYNCRST = "ENABLE";
  parameter PIPEMODE = "PIPED";
endmodule

(* blackbox *)
module EG_LOGIC_ODDR(
  output q,
  input clk,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_IDDRx2(
  output q3,
  output q2,
  output q1,
  output q0,
  input pclk,
  input sclk,
  input d,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_ODELAY(
  output o,
  input i
);
  parameter OUTDEL = 0;
endmodule

(* blackbox *)
module EG_LOGIC_ODDRx2(
  output q,
  input pclk,
  input sclk,
  input d3,
  input d2,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_ODDRx2l(
  output q,
  input sclk,
  input d3,
  input d2,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_FIFO(
  input rst,
  input [DATA_WIDTH_W-1:0] di,
  output [DATA_WIDTH_R-1:0] do,
  input clkw,
  input we,
  input clkr,
  input re,
  input ore,
  input [2:0] csw,
  input [2:0] csr,
  output empty_flag,
  output aempty_flag,
  output full_flag,
  output afull_flag
);
  parameter DATA_WIDTH_W = 9;
  parameter DATA_WIDTH_R = DATA_WIDTH_W;
  parameter DATA_DEPTH_W = 1024;
  parameter DATA_DEPTH_R = DATA_WIDTH_W * DATA_DEPTH_W / DATA_WIDTH_R;
  parameter MODE = "FIFO8K";
  parameter REGMODE_W = "NOREG";
  parameter REGMODE_R = "NOREG";
  parameter E = 0;
  parameter AE = 6;
  parameter AF = DATA_DEPTH_W - 6;
  parameter F = DATA_DEPTH_W;
  parameter GSR = "DISABLE";
  parameter RESETMODE = "ASYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter ENDIAN = "LITTLE";
endmodule

(* blackbox *)
module EG_LOGIC_DRAM(
  input [DATA_WIDTH_W-1:0] di,
  input [ADDR_WIDTH_W-1:0] waddr,
  input wclk,
  input we,
  output [DATA_WIDTH_R-1:0] do,
  input [ADDR_WIDTH_R-1:0] raddr
);
  parameter DATA_WIDTH_W = 9;
  parameter ADDR_WIDTH_W = 10;
  parameter DATA_DEPTH_W = 2 ** ADDR_WIDTH_W;
  parameter DATA_WIDTH_R = 9;
  parameter ADDR_WIDTH_R = 10;
  parameter DATA_DEPTH_R = 2 ** ADDR_WIDTH_R;
  parameter INIT_FILE = "NONE";
endmodule

(* blackbox *)
module EG_LOGIC_DRAM16X4(
  input [3:0] di,
  input [3:0] waddr,
  input wclk,
  input we,
  input [3:0]raddr,
  output [3:0]do
);
  parameter INIT_D0=16'h0000;
  parameter INIT_D1=16'h0000;
  parameter INIT_D2=16'h0000;
  parameter INIT_D3=16'h0000;
endmodule

(* blackbox *)
module EG_LOGIC_MULT(
  output [OUTPUT_WIDTH-1:0] p,
  input [INPUT_WIDTH_A-1:0] a,
  input [INPUT_WIDTH_B-1:0] b,
  input cea,
  input ceb,
  input cepd,
  input clk,
  input rstan,
  input rstbn,
  input rstpdn
); 
  parameter INPUT_WIDTH_A = 18;
  parameter INPUT_WIDTH_B = 18;
  parameter OUTPUT_WIDTH = 36;
  parameter INPUTFORMAT = "SIGNED";
  parameter INPUTREGA = "ENABLE";
  parameter INPUTREGB = "ENABLE";
  parameter OUTPUTREG = "ENABLE";
  parameter SRMODE = "ASYNC";
  parameter IMPLEMENT = "AUTO";
endmodule

(* blackbox *)
module EG_LOGIC_SEQ_DIV(
  input clk,
  input rst,
  input start,
  input [NUMER_WIDTH-1:0] numer,
  input [DENOM_WIDTH-1:0] denom,
  output [NUMER_WIDTH-1:0] quotient,
  output [DENOM_WIDTH-1:0] remain,
  output done
);
	parameter NUMER_WIDTH = 16;
  parameter DENOM_WIDTH = 16;
endmodule

(* blackbox *)
module EG_PHY_BRAM(
  output [8:0] doa,
  output [8:0] dob,
  input [8:0] dia,
  input [8:0] dib,
  input [2:0] csa,
  input [2:0] csb,
  input cea,
  input ocea,
  input clka,
  input wea,
  input rsta,
  input ceb,
  input oceb,
  input clkb,
  input web,
  input rstb,
  input [12:0] addra,
  input [12:0] addrb
);
  parameter MODE = "DP8K";
  parameter DATA_WIDTH_A = "9";
  parameter DATA_WIDTH_B = "9";
  parameter READBACK = "OFF";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter GSR = "ENABLE";
  parameter RESETMODE = "SYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter CEAMUX = "SIG";
  parameter CEBMUX = "SIG";
  parameter OCEAMUX = "SIG";
  parameter OCEBMUX = "SIG";
  parameter RSTAMUX = "SIG";
  parameter RSTBMUX = "SIG";
  parameter CLKAMUX = "SIG";
  parameter CLKBMUX = "SIG";
  parameter WEAMUX = "SIG";
  parameter WEBMUX = "SIG";
  parameter CSA0 = "SIG" ;
  parameter CSA1 = "SIG" ;
  parameter CSA2 = "SIG" ;
  parameter CSB0 = "SIG" ;
  parameter CSB1 = "SIG" ;
  parameter CSB2 = "SIG" ;
  parameter INIT_FILE = "NONE";
  parameter INITP_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule

(* blackbox *)
module EG_PHY_BRAM32K(
  output [15:0] doa,
  output [15:0] dob,
  input [15:0] dia,
  input [15:0] dib,
  input [10:0] addra,
  input [10:0] addrb,
  input bytea,
  input bytewea,
  input byteb,
  input byteweb,
  input csa,
  input wea,
  input csb,
  input web,
  input clka,
  input rsta,
  input clkb,
  input rstb,
  input ocea,
  input oceb
);
  parameter MODE = "DP16K";
  parameter DATA_WIDTH_A = "16";
  parameter DATA_WIDTH_B = "16";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter SRMODE = "SYNC";
  parameter CSAMUX = "SIG";
  parameter CSBMUX = "SIG";
  parameter OCEAMUX = "SIG";
  parameter OCEBMUX = "SIG";
  parameter RSTAMUX = "SIG";
  parameter RSTBMUX = "SIG";
  parameter CLKAMUX = "SIG";
  parameter CLKBMUX = "SIG";
  parameter WEAMUX = "SIG";
  parameter WEBMUX = "SIG";
  parameter READBACK = "OFF";
  parameter INIT_FILE = "";
  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_40 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_41 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_42 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_43 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_44 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_45 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_46 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_47 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_48 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_49 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_50 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_51 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_52 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_53 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_54 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_55 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_56 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_57 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_58 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_59 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_60 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_61 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_62 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_63 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_64 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_65 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_66 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_67 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_68 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_69 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_70 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_71 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_72 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_73 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_74 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_75 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_76 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_77 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_78 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_79 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule

(* blackbox *)
module EG_PHY_FIFO(
  input [8:0] dia,
  input [8:0] dib,
  input [2:0] csr,
  input [2:0] csw,
  input we,
  input re,
  input clkw,
  input clkr,
  input rst,
  input rprst,
  input orea,
  input oreb,
  output [8:0] dob,
  output [8:0] doa,
  output empty_flag,
  output aempty_flag,
  output afull_flag,
  output full_flag
);
  parameter MODE = "FIFO8K";
  parameter DATA_WIDTH_A = "18";
  parameter DATA_WIDTH_B = "18";
  parameter READBACK = "OFF";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter [13:0] AE = 14'b00000001100000;
  parameter [13:0] AF = 14'b01111110010000;
  parameter [13:0] F = 14'b01111111110000;
  parameter [13:0] AEP1 = 14'b00000001110000;
  parameter [13:0] AFM1 = 14'b01111110000000;
  parameter [13:0] FM1  = 14'b01111111100000;   
  parameter [4:0] E = 5'b00000;
  parameter [5:0] EP1 = 6'b010000;
  parameter GSR = "ENABLE";
  parameter RESETMODE = "ASYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter CEA = "SIG";
  parameter CEB = "SIG";
  parameter OCEA = "SIG";
  parameter OCEB = "SIG";
  parameter RSTA = "SIG";
  parameter RSTB = "SIG";
  parameter CLKA = "SIG";
  parameter CLKB = "SIG";
  parameter WEA = "SIG";
  parameter WEB = "SIG";
  parameter CSA0 = "SIG";
  parameter CSA1 = "SIG";
  parameter CSA2 = "SIG";
  parameter CSB0 = "SIG";
  parameter CSB1 = "SIG";
  parameter CSB2 = "SIG";
endmodule

(* blackbox *)
module EG_PHY_MULT18(
  output [17:0] acout,
  output [17:0] bcout,
  output [35:0] p,
  input signeda,
  input signedb,
  input [17:0] a,
  input [17:0] b,
  input [17:0] acin,
  input [17:0] bcin,
  input cea,
  input ceb,
  input cepd,
  input clk,
  input rstan,
  input rstbn,
  input rstpdn,
  input sourcea,
  input sourceb  
); 
  parameter INPUTREGA = "ENABLE";
  parameter INPUTREGB = "ENABLE";
  parameter OUTPUTREG = "ENABLE";
  parameter SRMODE = "ASYNC";
  parameter MODE = "MULT18X18C";
  parameter CEAMUX = "SIG";
  parameter CEBMUX = "SIG";
  parameter CEPDMUX = "SIG";
  parameter RSTANMUX = "SIG";
  parameter RSTBNMUX = "SIG";
  parameter RSTPDNMUX = "SIG";
  parameter CLKMUX = "SIG";
  parameter SIGNEDAMUX = "SIG";
  parameter SIGNEDBMUX = "SIG";
  parameter SOURCEAMUX = "SIG";
  parameter SOURCEBMUX = "SIG";
endmodule

(* blackbox *)
module EG_PHY_GCLK(
  input clki,
  output clko
);    
endmodule

(* blackbox *)
module EG_PHY_IOCLK(
  input clki,
  input stop,
  output clko
);
  parameter STOPCLK = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_CLKDIV(
  output clkdiv1,
  output clkdivx,
  input clki,
  input rst,
  input rls
);    
  parameter GSR = "DISABLE";
  parameter DIV = 2;
endmodule

(* blackbox *)
module EG_PHY_CONFIG(
  output jrstn,
  output [1:0] jrti,
  output jshift,
  output jtck,
  output jtdi,
  output jupdate,
  output [1:0] jscanen,
  output jtms,
  input [1:0] jtdo,
  input [7:0] jtag8_ipa,
  input [7:0] jtag8_ipb,
  output done,
  output highz,
  output cclk,
  input	cclk_en,
  input gsrn_sync_clk,
  input usr_gsrn,
  output dna_dout,
  input	dna_clk,
  input	dna_din,
  input	dna_shift_en,
  input	mboot_rebootn,
  input [7:0]	mboot_dynamic_addr
);  
  parameter MBOOT_AUTO_SEL = "DISABLE";
  parameter ADDR_SOURCE_SEL = "STATIC";
  parameter STATIC_ADDR = 8'b0;
  parameter DONE_PERSISTN = "ENABLE";
  parameter INIT_PERSISTN = "ENABLE";
  parameter PROGRAMN_PERSISTN = "DISABLE";
  parameter JTAG_PERSISTN = "DISABLE";
  parameter GSRN_SYNC_SEL = "DISABLE";
  parameter FREQ = "2.5";
  parameter USR_GSRN_EN = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_OSC(
  input osc_dis,
  output osc_clk
);    
  parameter STDBY = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_PWRMNT(
    output pwr_dwn_n,
    input sel_pwr,
    input pwr_mnt_pd
);
  parameter MNT_LVL = 0;
endmodule

(* blackbox *)
module EG_PHY_DDR_8M_16(
  input clk,
  input clk_n,
  input ras_n,
  input cas_n,
  input we_n,
  input cs_n,
  input [11:0] addr,
  input [1:0] ba,
  inout [15:0] dq,
  input ldqs,
  input udqs,
  input ldm,
  input udm,
  input cke
);
endmodule

(* blackbox *)
module EG_PHY_SDRAM_2M_32(
  input clk,
  input ras_n,
  input cas_n,
  input we_n,
  input [10:0] addr,
  input [1:0] ba,
  inout [31:0] dq,
  input cs_n,
  input dm0,
  input dm1,
  input dm2,
  input dm3,
  input cke
);
endmodule

(* blackbox *)
module EG_PHY_PAD(
  input ipad,
  output opad,
  inout bpad,
  input rst,
  input ce,
  input isclk,
  input ipclk,
  input osclk,
  input opclk,
  input ts,
  input [3:0] do,
  output di,
  output [3:0] diq
);
  parameter DEDCLK = "DISABLE";
  parameter GSR = "ENABLE";
  parameter SRMODE = "SYNC";
  parameter TSMUX = "1";
  parameter INSCLKMUX = "0";
  parameter INPCLKMUX = "CLK";
  parameter INCEMUX = "CE";
  parameter INRSTMUX = "0";
  parameter IN_REGSET = "RESET";
  parameter IN_DFFMODE = "NONE";
  parameter IDDRMODE = "OFF";
  parameter IDDRPIPEMODE = "NONE";
  parameter INDELMUX = "NODEL";
  parameter INDEL = 0;
  parameter OUTSCLKMUX = "0";
  parameter OUTPCLKMUX = "CLK";
  parameter OUTCEMUX = "CE";
  parameter OUTRSTMUX = "0";
  parameter DO_REGSET = "RESET";
  parameter DO_DFFMODE = "NONE";
  parameter ODDRMODE = "OFF";
  parameter OUTDELMUX = "NODEL";
  parameter OUTDEL = 0;
  parameter TO_REGSET = "RESET";
  parameter TO_DFFMODE = "NONE";
  parameter MODE = "IN";
  parameter DRIVE = "NONE";
  parameter IOTYPE = "LVCMOS25";
endmodule

(* blackbox *)
module EG_PHY_MSLICE(
  input [1:0] a,
  input [1:0] b,
  input [1:0] c,
  input [1:0] d,
  input [1:0] mi,
  input clk,
  input ce,
  input sr,
  input fci,
  output [1:0] f,
  output [1:0] fx,
  output [1:0] q,
  output fco,
  input dpram_mode,
  input [1:0] dpram_di,
  input dpram_we,
  input dpram_wclk,
  input [3:0] dpram_waddr
);
  parameter INIT_LUT0 = 16'h0000;
  parameter INIT_LUT1 = 16'h0000;
  parameter MODE = "LOGIC";
  parameter ALUTYPE = "ADD";
  parameter MSFXMUX = "OFF";
  parameter GSR = "ENABLE";
  parameter TESTMODE = "OFF";
  parameter CEMUX = "CE";
  parameter SRMUX = "SR";
  parameter CLKMUX = "CLK";
  parameter SRMODE = "ASYNC";
  parameter DFFMODE = "FF";
  parameter REG0_SD = "MI";
  parameter REG1_SD = "MI";
  parameter REG0_REGSET = "SET";
  parameter REG1_REGSET = "SET";
endmodule

(* blackbox *)
module EG_PHY_LSLICE(
  input [1:0] a,
  input [1:0] b,
  input [1:0] c,
  input [1:0] d,
  input [1:0] e,
  input [1:0] mi,
  input clk,
  input ce,
  input sr,
  input fci,
  output [1:0] f,
  output [1:0] fx,
  output [1:0] q,
  output fco,
  output [3:0] dpram_di,
  output [3:0] dpram_waddr,
  output dpram_wclk,
  output dpram_we,
  output dpram_mode
);
  parameter INIT_LUTF0 = 16'h0000;
  parameter INIT_LUTG0 = 16'h0000;
  parameter INIT_LUTF1 = 16'h0000;
  parameter INIT_LUTG1 = 16'h0000;
  parameter MODE = "LOGIC";
  parameter GSR = "ENABLE";
  parameter TESTMODE = "OFF";
  parameter CEMUX = "1";
  parameter SRMUX = "SR";
  parameter CLKMUX = "CLK";
  parameter SRMODE = "ASYNC";
  parameter DFFMODE = "FF";
  parameter REG0_SD = "MI";
  parameter REG1_SD = "MI";
  parameter REG0_REGSET = "SET";
  parameter REG1_REGSET = "SET";
  parameter DEMUX0 = "D";
  parameter DEMUX1 = "D";
  parameter CMIMUX0 = "C";
  parameter CMIMUX1 = "C";
  parameter LSFMUX0 = "LUTF";
  parameter LSFXMUX0 = "LUTG";
  parameter LSFMUX1 = "LUTF";
  parameter LSFXMUX1 = "LUTG";
endmodule

(* blackbox *)
module EG_PHY_PLL(
  output [4:0] clkc,
  output extlock,
  input stdby,
  input refclk,
  input fbclk,
  input reset,
  output psdone,
  input psclk,
  input psdown,
  input psstep,
  input [2:0] psclksel,
  output [7:0] do,
  input dclk,
  input dcs,
  input dwe,
  input [7:0] di,
  input [5:0] daddr
);
  parameter DYNCFG = "DISABLE";
  parameter IF_ESCLKSTSW = "DISABLE";
  parameter REFCLK_SEL = "INTERNAL";
  parameter FIN = "100.0000";
  parameter REFCLK_DIV = 1;
  parameter FBCLK_DIV = 1;
  parameter CLKC0_DIV = 1;
  parameter CLKC1_DIV = 1;
  parameter CLKC2_DIV = 1;
  parameter CLKC3_DIV = 1;
  parameter CLKC4_DIV = 1;
  parameter CLKC0_ENABLE = "DISABLE";
  parameter CLKC1_ENABLE = "DISABLE";
  parameter CLKC2_ENABLE = "DISABLE";
  parameter CLKC3_ENABLE = "DISABLE";
  parameter CLKC4_ENABLE = "DISABLE";
  parameter CLKC0_DIV2_ENABLE = "DISABLE";
  parameter CLKC1_DIV2_ENABLE = "DISABLE";
  parameter CLKC2_DIV2_ENABLE = "DISABLE";
  parameter CLKC3_DIV2_ENABLE = "DISABLE";
  parameter CLKC4_DIV2_ENABLE = "DISABLE";
  parameter FEEDBK_MODE = "NORMAL";
  parameter FEEDBK_PATH = "VCO_PHASE_0";  
  parameter STDBY_ENABLE = "ENABLE";
  parameter CLKC0_FPHASE = 0;
  parameter CLKC1_FPHASE = 0;
  parameter CLKC2_FPHASE = 0;
  parameter CLKC3_FPHASE = 0;
  parameter CLKC4_FPHASE = 0;
  parameter CLKC0_CPHASE = 1;
  parameter CLKC1_CPHASE = 1;
  parameter CLKC2_CPHASE = 1;
  parameter CLKC3_CPHASE = 1;
  parameter CLKC4_CPHASE = 1;
  parameter GMC_GAIN = 7;
  parameter GMC_TEST = 14;
  parameter ICP_CURRENT = 14;
  parameter KVCO = 7;
  parameter LPF_CAPACITOR = 3;
  parameter LPF_RESISTOR = 1;
  parameter PLLRST_ENA = "ENABLE";
  parameter PLLMRST_ENA = "DISABLE";
  parameter PLLC2RST_ENA = "DISABLE";
  parameter PLLC34RST_ENA = "DISABLE";
  parameter PREDIV_MUXC0 = "VCO";
  parameter PREDIV_MUXC1 = "VCO";
  parameter PREDIV_MUXC2 = "VCO";
  parameter PREDIV_MUXC3 = "VCO";
  parameter PREDIV_MUXC4 = "VCO";
  parameter ODIV_MUXC0 = "DIV";
  parameter ODIV_MUXC1 = "DIV";
  parameter ODIV_MUXC2 = "DIV";
  parameter ODIV_MUXC3 = "DIV";
  parameter ODIV_MUXC4 = "DIV";
  parameter FREQ_LOCK_ACCURACY = 2;
  parameter PLL_LOCK_MODE = 0;
  parameter INTFB_WAKE = "DISABLE";
  parameter DPHASE_SOURCE = "DISABLE";
  parameter VCO_NORESET = "DISABLE";
  parameter STDBY_VCO_ENA = "DISABLE";
  parameter NORESET = "DISABLE";
  parameter SYNC_ENABLE = "ENABLE";
  parameter DERIVE_PLL_CLOCKS = "DISABLE";
  parameter GEN_BASIC_CLOCK = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_BRAM(
  output [DATA_WIDTH_A-1:0] doa,
  output [DATA_WIDTH_B-1:0] dob,
  input [DATA_WIDTH_A-1:0] dia,
  input [DATA_WIDTH_B-1:0] dib,
  input cea,
  input ocea,
  input clka,
  input wea,
  input rsta,
  input ceb,
  input oceb,
  input clkb,
  input web,
  input rstb,
  input [BYTE_A - 1 : 0] bea,
  input [BYTE_B - 1 : 0] beb,
  input [ADDR_WIDTH_A-1:0] addra,
  input [ADDR_WIDTH_B-1:0] addrb
);
  parameter DATA_WIDTH_A = 9;
  parameter DATA_WIDTH_B = DATA_WIDTH_A;
  parameter ADDR_WIDTH_A = 10;
  parameter ADDR_WIDTH_B = ADDR_WIDTH_A;
  parameter DATA_DEPTH_A = 2 ** ADDR_WIDTH_A;
  parameter DATA_DEPTH_B = 2 ** ADDR_WIDTH_B;
  parameter BYTE_ENABLE = 0;
  parameter BYTE_A = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_A / BYTE_ENABLE;
  parameter BYTE_B = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_B / BYTE_ENABLE;  
  parameter MODE = "DP";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter RESETMODE = "SYNC";
  parameter DEBUGGABLE = "NO";
  parameter PACKABLE = "NO";
  parameter FORCE_KEEP = "OFF";
  parameter INIT_FILE = "NONE";
  parameter FILL_ALL = "NONE";
  parameter IMPLEMENT = "9K";
endmodule     

(* blackbox *)
module EG_PHY_ADC(
  input clk,
  input pd,
  input [2:0] s,
  input soc,
  output eoc,
  output [11:0] dout
);
  parameter CH0 = "DISABLE";
  parameter CH1 = "DISABLE";
  parameter CH2 = "DISABLE";
  parameter CH3 = "DISABLE";
  parameter CH4 = "DISABLE";
  parameter CH5 = "DISABLE";
  parameter CH6 = "DISABLE";
  parameter CH7 = "DISABLE";
  parameter VREF = "DISABLE";
endmodule
`,"lutrams.txt":`ram distributed $__ANLOGIC_DRAM16X4_ {
	abits 4;
	width 4;
	cost 4;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__ANLOGIC_DRAM16X4_ (...);
	parameter INIT = 64'b0;

	input PORT_W_CLK;
	input [3:0] PORT_W_ADDR;
	input [3:0] PORT_W_WR_DATA;
	input PORT_W_WR_EN;

	input [3:0] PORT_R_ADDR;
	output [3:0] PORT_R_RD_DATA;

	function [15:0] init_slice;
		input integer idx;
		integer i;
		for (i = 0; i < 16; i = i + 1)
			init_slice[i] = INIT[i * 4 + idx];
	endfunction

	EG_LOGIC_DRAM16X4 #(
		.INIT_D0(init_slice(0)),
		.INIT_D1(init_slice(1)),
		.INIT_D2(init_slice(2)),
		.INIT_D3(init_slice(3))
	) _TECHMAP_REPLACE_ (
		.di(PORT_W_WR_DATA),
		.waddr(PORT_W_ADDR),
		.wclk(PORT_W_CLK),
		.we(PORT_W_WR_EN),
		.raddr(PORT_R_ADDR),
		.do(PORT_R_RD_DATA)
	);
endmodule
`},"cells.lib":`library(yosys_cells) {
	cell(DFF_N) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
		}
		pin(D) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_P) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
		}
		pin(D) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NN0) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			clear: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NN1) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			preset: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NP0) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			clear: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NP1) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			preset: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PN0) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			clear: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PN1) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			preset: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PP0) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			clear: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PP1) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			preset: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
}
`,choices:{"han-carlson.v":`(* techmap_celltype = "$lcu" *)
module _80_lcu_han_carlson (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		i = 0;
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);
		if (i < $clog2(WIDTH)) begin

			// First layer: BK
			for (j = WIDTH - 1; j >= 0; j = j - 1) begin
				if (j % 2 == 1) begin
					g[j] = g[j] | p[j] & g[j - 1];
					p[j] = p[j] & p[j - 1];
				end
			end

			// Inner (log(WIDTH) - 1) layers: KS
			for (i = 1; i < $clog2(WIDTH); i = i + 1) begin
				for (j = WIDTH - 1; j >= 2**i; j = j - 1) begin
					if (j % 2 == 1) begin
						g[j] = g[j] | p[j] & g[j - 2**i];
						p[j] = p[j] & p[j - 2**i];
					end
				end
			end

			// Last layer: BK
			if (i < ($clog2(WIDTH) + 1)) begin
				for (j = WIDTH - 1; j >= 0; j = j - 1) begin
					if ((j % 2 == 0) && (j > 0)) begin
						g[j] = g[j] | p[j] & g[j - 1];
						p[j] = p[j] & p[j - 1];
					end
				end
			end

		end
	end

	assign CO = g;
endmodule
`,"kogge-stone.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Martin Povi\u0161er <povik@cutebit.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$lcu" *)
module _80_lcu_kogge_stone (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);

		for (i = 0; i < $clog2(WIDTH); i = i + 1) begin
			// iterate in reverse so we don't confuse a result from this stage and the previous
			for (j = WIDTH - 1; j >= 2**i; j = j - 1) begin
				g[j] = g[j] | p[j] & g[j - 2**i];
				p[j] = p[j] & p[j - 2**i];
			end
		end
	end

	assign CO = g;
endmodule
`,"sklansky.v":`(* techmap_celltype = "$lcu" *)
module _80_lcu_sklansky (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);

		for (i = 0; i < $clog2(WIDTH); i = i + 1) begin
			// iterate in reverse so we don't confuse a result from this stage and the previous
			for (j = WIDTH - 1; j >= 0; j = j - 1) begin
				if (j & 2**i) begin
					g[j] = g[j] | p[j] & g[(j & ~(2**i - 1)) - 1];
					p[j] = p[j] & p[(j & ~(2**i - 1)) - 1];
				end
			end
		end
	end

	assign CO = g;
endmodule
`},"cmp2lcu.v":`// This pass performs an optimisation that decomposes wide arithmetic
//   comparisons into LUT-size chunks (as guided by the \`LUT_WIDTH
//   macro) connected to a single lookahead-carry-unit $lcu cell,
//   which is typically mapped to dedicated (and fast) FPGA
//   carry-chains.
(* techmap_celltype = "$lt $le $gt $ge" *)
module _80_lcu_cmp_ (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

generate
    if (_TECHMAP_CELLTYPE_ == "" || \`LUT_WIDTH < 2)
        wire _TECHMAP_FAIL_ = 1;
    else if (_TECHMAP_CELLTYPE_ == "$lt") begin
        // Transform $lt into $gt by swapping A and B
        $gt #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));
    end
    else if (_TECHMAP_CELLTYPE_ == "$le") begin
        // Transform $le into $ge by swapping A and B
        $ge #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));
    end
    else begin
        // Perform sign extension on A and B
        localparam WIDTH = A_WIDTH > B_WIDTH ? A_WIDTH : B_WIDTH;
        (* force_downto *)
        wire [WIDTH-1:0] AA = {{(WIDTH-A_WIDTH){A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};
        (* force_downto *)
        wire [WIDTH-1:0] BB = {{(WIDTH-B_WIDTH){B_SIGNED ? B[B_WIDTH-1] : 1'b0}}, B};
        // For $ge operation, start with the assumption that A and B are
        //   equal (propagating this equality if A and B turn out to be so)
        localparam CI = _TECHMAP_CELLTYPE_ == "$ge";
        $__CMP2LCU #(.AB_WIDTH(WIDTH), .AB_SIGNED(A_SIGNED && B_SIGNED), .LCU_WIDTH(1), .BUDGET(\`LUT_WIDTH), .CI(CI))
            _TECHMAP_REPLACE_ (.A(AA), .B(BB), .P(1'b1), .G(1'b0), .Y(Y));
    end
endgenerate
endmodule

module $__CMP2LCU (A, B, P, G, Y);

parameter AB_WIDTH = 0;
parameter AB_SIGNED = 0;
parameter LCU_WIDTH = 1;
parameter BUDGET = 0;
parameter CI = 0;

(* force_downto *)
input [AB_WIDTH-1:0] A; // A from original $gt/$ge
(* force_downto *)
input [AB_WIDTH-1:0] B; // B from original $gt/$ge
(* force_downto *)
input [LCU_WIDTH-1:0] P; // P of $lcu
(* force_downto *)
input [LCU_WIDTH-1:0] G; // G of $lcu
output Y;

parameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;
parameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
parameter [LCU_WIDTH-1:0] _TECHMAP_CONSTMSK_P_ = 0;

generate
    if (AB_WIDTH == 0) begin
        (* force_downto *)
        wire [LCU_WIDTH-1:0] CO;
        $lcu #(.WIDTH(LCU_WIDTH)) _TECHMAP_REPLACE_ (.P(P), .G(G), .CI(CI), .CO(CO));
        assign Y = CO[LCU_WIDTH-1];
    end
    else begin
        localparam COST =
            _TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] && _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]
            ? 0
            : (_TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] || _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]
                ? 1
                : 2);

        if (BUDGET < COST)
             $__CMP2LCU #(.AB_WIDTH(AB_WIDTH), .AB_SIGNED(AB_SIGNED), .LCU_WIDTH(LCU_WIDTH+1), .BUDGET(\`LUT_WIDTH), .CI(CI))
                _TECHMAP_REPLACE_ (.A(A), .B(B), .P({P, 1'b1}), .G({G, 1'b0}), .Y(Y));
        else begin
            wire PP, GG;
            // Bit-wise equality (xnor) of A and B
            assign PP = A[AB_WIDTH-1] ^~ B[AB_WIDTH-1];
            if (AB_SIGNED)
                assign GG = ~A[AB_WIDTH-1] & B[AB_WIDTH-1];
            else if (_TECHMAP_CONSTMSK_P_[LCU_WIDTH-1]) // First compare for LUT if P (and G) is constant
                assign GG = A[AB_WIDTH-1] & ~B[AB_WIDTH-1];
            else
                // Priority "encoder" that checks A[i] == 1'b1 && B[i] == 1'b0
                //   from MSB down, deferring to less significant bits if the
                //   MSBs are equal
                assign GG = P[0] & (A[AB_WIDTH-1] & ~B[AB_WIDTH-1]);
            (* force_downto *)
            wire [LCU_WIDTH-1:0] P_, G_;
            if (LCU_WIDTH == 1) begin
                // Propagate only if all pairs are equal
                //   (inconclusive evidence to say A >= B)
                assign P_ = P[0] & PP;
                // Generate if any comparisons call for it
                assign G_ = G[0] | GG;
            end
            else begin
                // Propagate only if all pairs are equal
                //   (inconclusive evidence to say A >= B)
                assign P_ = {P[LCU_WIDTH-1:1], P[0] & PP};
                // Generate if any comparisons call for it
                assign G_ = {G[LCU_WIDTH-1:1], G[0] | GG};
            end
            if (AB_WIDTH == 1)
               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))
                    _TECHMAP_REPLACE_ (.A(), .B(), .P(P_), .G(G_), .Y(Y));
            else
               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))
                    _TECHMAP_REPLACE_ (.A(A[AB_WIDTH-2:0]), .B(B[AB_WIDTH-2:0]), .P(P_), .G(G_), .Y(Y));
        end
    end
endgenerate
endmodule
`,"cmp2lut.v":`// Certain arithmetic operations between a signal of width n and a constant can be directly mapped
// to a single k-LUT (where n <= k). This is preferable to normal alumacc techmapping process
// because for many targets, arithmetic techmapping creates hard logic (such as carry cells) which often
// cannot be optimized further.
//
// TODO: Currently, only comparisons with 1-bit output are mapped. Potentially, all arithmetic cells
// with n <= k inputs should be techmapped in this way, because this shortens the critical path
// from n to 1 by avoiding carry chains.

(* techmap_celltype = "$lt $le $gt $ge" *)
module _90_lut_cmp_ (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

parameter _TECHMAP_CONSTMSK_A_ = 0;
parameter _TECHMAP_CONSTVAL_A_ = 0;
parameter _TECHMAP_CONSTMSK_B_ = 0;
parameter _TECHMAP_CONSTVAL_B_ = 0;

function automatic [(1 << \`LUT_WIDTH)-1:0] gen_lut;
	input integer width;
	input integer operation;
	input integer swap;
	input integer sign;
	input integer operand;
	integer n, i_var, i_cst, lhs, rhs, o_bit;
	begin
		gen_lut = width'b0;
		for (n = 0; n < (1 << width); n++) begin
			if (sign)
				i_var = n[width-1:0];
			else
				i_var = n;
			i_cst = operand;
			if (swap) begin
				lhs = i_cst;
				rhs = i_var;
			end else begin
				lhs = i_var;
				rhs = i_cst;
			end
			if (operation == 0)
				o_bit = (lhs <  rhs);
			if (operation == 1)
				o_bit = (lhs <= rhs);
			if (operation == 2)
				o_bit = (lhs >  rhs);
			if (operation == 3)
				o_bit = (lhs >= rhs);
			gen_lut = gen_lut | (o_bit << n);
		end
	end
endfunction

generate
	localparam operation =
		_TECHMAP_CELLTYPE_ == "$lt" ? 0 :
		_TECHMAP_CELLTYPE_ == "$le" ? 1 :
		_TECHMAP_CELLTYPE_ == "$gt" ? 2 :
		_TECHMAP_CELLTYPE_ == "$ge" ? 3 :
		-1;

	if (A_WIDTH > \`LUT_WIDTH || B_WIDTH > \`LUT_WIDTH || Y_WIDTH != 1)
		wire _TECHMAP_FAIL_ = 1;
	else if (&_TECHMAP_CONSTMSK_B_)
		\\$lut #(
			.WIDTH(A_WIDTH),
			.LUT({ gen_lut(A_WIDTH, operation, 0, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_B_) })
		) _TECHMAP_REPLACE_ (
			.A(A),
			.Y(Y)
		);
	else if (&_TECHMAP_CONSTMSK_A_)
		\\$lut #(
			.WIDTH(B_WIDTH),
			.LUT({ gen_lut(B_WIDTH, operation, 1, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_A_) })
		) _TECHMAP_REPLACE_ (
			.A(B),
			.Y(Y)
		);
	else
		wire _TECHMAP_FAIL_ = 1;
endgenerate

endmodule
`,"cmp2softlogic.v":`module constgtge(C, A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
output Y;
input C;

wire [A_WIDTH:0] ch;
genvar n;
generate
	if (B_WIDTH > A_WIDTH) begin
		// Fail
	end else begin
		assign ch[0] = C;
		for (n = 0; n < A_WIDTH; n = n + 1) begin
			if (n < B_WIDTH) begin
				assign ch[n + 1] = B[n] ? (ch[n] && A[n]) : (ch[n] || A[n]);
			end else begin
				assign ch[n + 1] = ch[n] || A[n];
			end
		end
		assign Y = ch[A_WIDTH];
	end
endgenerate
endmodule

module constltle(C, A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
output Y;
input C;

wire [A_WIDTH:0] ch;
genvar n;
generate
	if (B_WIDTH > A_WIDTH) begin
		// Fail
	end else begin
		assign ch[0] = C;
		for (n = 0; n < A_WIDTH; n = n + 1) begin
			if (n < B_WIDTH) begin
				assign ch[n + 1] = !B[n] ? (ch[n] && !A[n]) : (ch[n] || !A[n]);
			end else begin
				assign ch[n + 1] = ch[n] && !A[n];
			end
		end
		assign Y = ch[A_WIDTH];
	end
endgenerate
endmodule

(* techmap_celltype = "$ge $gt $le $lt" *)
module _map_const_cmp_(A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;
parameter A_SIGNED = 0;
parameter B_SIGNED = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

parameter _TECHMAP_CONSTMSK_A_ = 0;
parameter _TECHMAP_CONSTVAL_A_ = 0;
parameter _TECHMAP_CONSTMSK_B_ = 0;
parameter _TECHMAP_CONSTVAL_B_ = 0;

wire [1023:0] _TECHMAP_DO_ = "opt -fast;";

wire [A_WIDTH:0] ch;

genvar n;
generate
	if (Y_WIDTH != 1 || A_SIGNED || B_SIGNED)
		wire _TECHMAP_FAIL_ = 1;
	else if (&_TECHMAP_CONSTMSK_A_) begin
		if (A_WIDTH > B_WIDTH)
			wire _TECHMAP_FAIL_ = 1;
		else if (_TECHMAP_CELLTYPE_ == "$lt" || _TECHMAP_CELLTYPE_ == "$le")
			constgtge #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))
				_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$lt"));
		else
			constltle #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))
				_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$gt"));
	end else if (&_TECHMAP_CONSTMSK_B_) begin
		if (B_WIDTH > A_WIDTH)
			wire _TECHMAP_FAIL_ = 1;
		else if (_TECHMAP_CELLTYPE_ == "$lt" || _TECHMAP_CELLTYPE_ == "$le")
			constltle #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))
				_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$le"));
		else
			constgtge #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))
				_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$ge"));
	end else
		wire _TECHMAP_FAIL_ = 1;
endgenerate

endmodule
`,coolrunner2:{"cells_counter_map.v":`module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

    input wire CE;
    input wire CLK;
    output wire OUT;
    (* force_downto *)
    output wire[WIDTH-1:0] POUT;
    input wire RST;
    input wire UP;

    parameter COUNT_TO = 1;
    parameter RESET_MODE = "RISING";
    parameter RESET_TO_MAX = 0;
    parameter HAS_POUT = 0;
    parameter HAS_CE = 0;
    parameter WIDTH = 8;
    parameter DIRECTION = "DOWN";

    if (DIRECTION == "UP") begin
        if (WIDTH < 2) begin
            initial begin
                $display("ERROR: \\$__COUNT_ must be at least 2 bits wide (bug in extract_counter pass?).");
                $finish;
            end
        end

        // FIXME: Max width?

        assign OUT = POUT == COUNT_TO;

        if (HAS_CE) begin
            genvar i;
            for (i = 0; i < WIDTH; i++) begin: countbits
                // each bit = (cur & !reset) ^ (all prev & !reset)
                wire xor_to_mc_bitn;
                FDCP #(
                    .INIT(0)
                ) bitn_ff (
                    .C(CLK),
                    .CLR(0),
                    .D(xor_to_mc_bitn),
                    .PRE(0),
                    .Q(POUT[i])
                );
                wire orterm_to_xor_bitn;
                wire pterm0_to_or_bitn;
                wire pterm1_to_or_bitn;
                MACROCELL_XOR #(
                    .INVERT_OUT(0)
                ) bitn_xor (
                    .IN_ORTERM(orterm_to_xor_bitn),
                    .IN_PTC(pterm1_to_or_bitn),
                    .OUT(xor_to_mc_bitn)
                );
                ORTERM #(
                    .WIDTH(1)
                ) bitn_or (
                    .IN(pterm0_to_or_bitn),
                    .OUT(orterm_to_xor_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(1)
                ) bitn_pterm0 (
                    .IN(POUT[i]),
                    .IN_B(OUT),
                    .OUT(pterm0_to_or_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(i + 1)
                ) bitn_pterm1 (
                    .IN({POUT[i-1:0], CE}),
                    .IN_B(OUT),
                    .OUT(pterm1_to_or_bitn)
                );
            end
        end else begin
            // Bit0 is special; toggle unless reset
            // cur  reset           out
            // 0    0               1
            // 0    1               0
            // 1    0               0
            // 1    1               0
            wire xor_to_mc_bit0;
            FDCP #(
                .INIT(0)
            ) bit0_ff (
                .C(CLK),
                .CLR(0),
                .D(xor_to_mc_bit0),
                .PRE(0),
                .Q(POUT[0])
            );
            wire pterm_to_xor_bit0;
            MACROCELL_XOR #(
                .INVERT_OUT(0)
            ) bit0_xor (
                .IN_PTC(pterm_to_xor_bit0),
                .OUT(xor_to_mc_bit0)
            );
            ANDTERM #(
                .COMP_INP(2),
                .TRUE_INP(0)
            ) bit0_pterm (
                .IN(),
                .IN_B({POUT[0], OUT}),
                .OUT(pterm_to_xor_bit0)
            );

            genvar i;
            for (i = 1; i < WIDTH; i++) begin: countbits
                // each bit = (cur & !reset) ^ (all prev & !reset)
                wire xor_to_mc_bitn;
                FDCP #(
                    .INIT(0)
                ) bitn_ff (
                    .C(CLK),
                    .CLR(0),
                    .D(xor_to_mc_bitn),
                    .PRE(0),
                    .Q(POUT[i])
                );
                wire orterm_to_xor_bitn;
                wire pterm0_to_or_bitn;
                wire pterm1_to_or_bitn;
                MACROCELL_XOR #(
                    .INVERT_OUT(0)
                ) bitn_xor (
                    .IN_ORTERM(orterm_to_xor_bitn),
                    .IN_PTC(pterm1_to_or_bitn),
                    .OUT(xor_to_mc_bitn)
                );
                ORTERM #(
                    .WIDTH(1)
                ) bitn_or (
                    .IN(pterm0_to_or_bitn),
                    .OUT(orterm_to_xor_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(1)
                ) bitn_pterm0 (
                    .IN(POUT[i]),
                    .IN_B(OUT),
                    .OUT(pterm0_to_or_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(i)
                ) bitn_pterm1 (
                    .IN(POUT[i-1:0]),
                    .IN_B(OUT),
                    .OUT(pterm1_to_or_bitn)
                );
            end
        end
    end

    // FIXME: down counters

endmodule
`,"cells_latch.v":`module $_DLATCH_P_(input E, input D, output Q);
    LDCP _TECHMAP_REPLACE_ (
        .D(D),
        .G(E),
        .Q(Q),
        .PRE(1'b0),
        .CLR(1'b0)
        );
endmodule

module $_DLATCH_N_(input E, input D, output Q);
    LDCP_N _TECHMAP_REPLACE_ (
        .D(D),
        .G(E),
        .Q(Q),
        .PRE(1'b0),
        .CLR(1'b0)
        );
endmodule
`,"cells_sim.v":`module IBUF(input I, output O);
    assign O = I;
endmodule

module IOBUFE(input I, input E, output O, inout IO);
    assign O = IO;
    assign IO = E ? I : 1'bz;
endmodule

module ANDTERM(IN, IN_B, OUT);
    parameter TRUE_INP = 0;
    parameter COMP_INP = 0;

    input [TRUE_INP-1:0] IN;
    input [COMP_INP-1:0] IN_B;
    output reg OUT;

    integer i;

    always @(*) begin
        OUT = 1;
        for (i = 0; i < TRUE_INP; i=i+1)
            OUT = OUT & IN[i];
        for (i = 0; i < COMP_INP; i=i+1)
            OUT = OUT & ~IN_B[i];
    end
endmodule

module ORTERM(IN, OUT);
    parameter WIDTH = 0;

    input [WIDTH-1:0] IN;
    output reg OUT;

    integer i;

    always @(*) begin
        OUT = 0;
        for (i = 0; i < WIDTH; i=i+1) begin
            OUT = OUT | IN[i];
        end
    end
endmodule

module MACROCELL_XOR(IN_PTC, IN_ORTERM, OUT);
    parameter INVERT_OUT = 0;

    input IN_PTC;
    input IN_ORTERM;
    output wire OUT;

    wire xor_intermed;

    assign OUT = INVERT_OUT ? ~xor_intermed : xor_intermed;
    assign xor_intermed = IN_ORTERM ^ IN_PTC;
endmodule

module FDCP (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module FDCP_N (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module LDCP (G, PRE, CLR, D, Q);
    parameter INIT = 0;

    input G, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @* begin
        if (CLR == 1)
            Q <= 0;
        else if (G == 1)
            Q <= D;
        else if (PRE == 1)
            Q <= 1;
    end
endmodule

module LDCP_N (G, PRE, CLR, D, Q);
    parameter INIT = 0;

    input G, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @* begin
        if (CLR == 1)
            Q <= 0;
        else if (G == 0)
            Q <= D;
        else if (PRE == 1)
            Q <= 1;
    end
endmodule

module BUFG(I, O);
    input I;
    output O;

    assign O = I;
endmodule

module BUFGSR(I, O);
    parameter INVERT = 0;

    input I;
    output O;

    assign O = INVERT ? ~I : I;
endmodule

module BUFGTS(I, O);
    parameter INVERT = 0;

    input I;
    output O;

    assign O = INVERT ? ~I : I;
endmodule

module FDDCP (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module FTCP (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FTCP_N (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FTDCP (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FDCPE (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule

module FDCPE_N (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule

module FDDCPE (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule
`,"tff_extract.v":`module FTCP (C, PRE, CLR, T, Q);
	input C, PRE, CLR, T;
	output wire Q;

	wire xorout;

	$_XOR_ xorgate (
		.A(T),
		.B(Q),
		.Y(xorout),
	);

	$_DFFSR_PPP_ dff (
		.C(C),
		.D(xorout),
		.Q(Q),
		.S(PRE),
		.R(CLR),
	);
endmodule

module FTCP_N (C, PRE, CLR, T, Q);
	input C, PRE, CLR, T;
	output wire Q;

	wire xorout;

	$_XOR_ xorgate (
		.A(T),
		.B(Q),
		.Y(xorout),
	);

	$_DFFSR_NPP_ dff (
		.C(C),
		.D(xorout),
		.Q(Q),
		.S(PRE),
		.R(CLR),
	);
endmodule
`,"xc2_dff.lib":`library(xc2_dff) {
  cell(FDCP) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: C;
                      next_state: D;
                      clear: "CLR";
                      preset: "PRE"; }
    pin(C) { direction: input;
             clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
             function: "IQ"; }
    pin(CLR) { direction: input; }
    pin(PRE) { direction: input; }
  }

  cell(FDCP_N) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: "!C";
                      next_state: D;
                      clear: "CLR";
                      preset: "PRE"; }
    pin(C) { direction: input;
             clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
             function: "IQ"; }
    pin(CLR) { direction: input; }
    pin(PRE) { direction: input; }
  }
}
`},"dff2ff.v":`(* techmap_celltype = "$dff" *)
module dff2ff (CLK, D, Q);
	parameter WIDTH = 1;
	parameter CLK_POLARITY = 1;

	input CLK;
	(* force_downto *)
	input [WIDTH-1:0] D;
	(* force_downto *)
	output reg [WIDTH-1:0] Q;

	wire [1023:0] _TECHMAP_DO_ = "proc;;";

	always @($global_clock)
		Q <= D;
endmodule
`,ecp5:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ecp5_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2C #(
			.INIT0(16'b1001011010101010),
			.INIT1(16'b1001011010101010),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
	   ) ccu2c_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__ECP5_DP16KD_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		wrbe_separate;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__ECP5_PDPW16KD_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 36;
		clock anyedge;
		clken;
	}
}
`,"brams_map.v":`module $__ECP5_DP16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_A_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "CLKB" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),
	.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.ADA13(PORT_A_ADDR[13]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DIA9(DIA[9]),
	.DIA10(DIA[10]),
	.DIA11(DIA[11]),
	.DIA12(DIA[12]),
	.DIA13(DIA[13]),
	.DIA14(DIA[14]),
	.DIA15(DIA[15]),
	.DIA16(DIA[16]),
	.DIA17(DIA[17]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),
	.DOA9(DOA[9]),
	.DOA10(DOA[10]),
	.DOA11(DOA[11]),
	.DOA12(DOA[12]),
	.DOA13(DOA[13]),
	.DOA14(DOA[14]),
	.DOA15(DOA[15]),
	.DOA16(DOA[16]),
	.DOA17(DOA[17]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),
	.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.ADB13(PORT_B_ADDR[13]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DIB9(DIB[9]),
	.DIB10(DIB[10]),
	.DIB11(DIB[11]),
	.DIB12(DIB[12]),
	.DIB13(DIB[13]),
	.DIB14(DIB[14]),
	.DIB15(DIB[15]),
	.DIB16(DIB[16]),
	.DIB17(DIB[17]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
	.DOB9(DOB[9]),
	.DOB10(DOB[10]),
	.DOB11(DOB[11]),
	.DOB12(DOB[12]),
	.DOB13(DOB[13]),
	.DOB14(DOB[14]),
	.DOB15(DOB[15]),
	.DOB16(DOB[16]),
	.DOB17(DOB[17]),
);

endmodule


module $__ECP5_PDPW16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 36;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_W_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "CLKB" : "INV"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),
	.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.ADA13(PORT_W_ADDR[13]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIA9(DI[9]),
	.DIA10(DI[10]),
	.DIA11(DI[11]),
	.DIA12(DI[12]),
	.DIA13(DI[13]),
	.DIA14(DI[14]),
	.DIA15(DI[15]),
	.DIA16(DI[16]),
	.DIA17(DI[17]),
	.DIB0(DI[18]),
	.DIB1(DI[19]),
	.DIB2(DI[20]),
	.DIB3(DI[21]),
	.DIB4(DI[22]),
	.DIB5(DI[23]),
	.DIB6(DI[24]),
	.DIB7(DI[25]),
	.DIB8(DI[26]),
	.DIB9(DI[27]),
	.DIB10(DI[28]),
	.DIB11(DI[29]),
	.DIB12(DI[30]),
	.DIB13(DI[31]),
	.DIB14(DI[32]),
	.DIB15(DI[33]),
	.DIB16(DI[34]),
	.DIB17(DI[35]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.ADB13(PORT_R_ADDR[13]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOA9(DO[9]),
	.DOA10(DO[10]),
	.DOA11(DO[11]),
	.DOA12(DO[12]),
	.DOA13(DO[13]),
	.DOA14(DO[14]),
	.DOA15(DO[15]),
	.DOA16(DO[16]),
	.DOA17(DO[17]),
	.DOB0(DO[18]),
	.DOB1(DO[19]),
	.DOB2(DO[20]),
	.DOB3(DO[21]),
	.DOB4(DO[22]),
	.DOB5(DO[23]),
	.DOB6(DO[24]),
	.DOB7(DO[25]),
	.DOB8(DO[26]),
	.DOB9(DO[27]),
	.DOB10(DO[28]),
	.DOB11(DO[29]),
	.DOB12(DO[30]),
	.DOB13(DO[31]),
	.DOB14(DO[32]),
	.DOB15(DO[33]),
	.DOB16(DO[34]),
	.DOB17(DO[35]),
);

endmodule
`,"cells_bb.v":`// ECP5 Blackbox cells
// FIXME: Create sim models

(* blackbox *)
module MULT18X18D(
	input A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17,
	input B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17,
	input C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17,
	input SIGNEDA, SIGNEDB, SOURCEA, SOURCEB,
	input CLK0, CLK1, CLK2, CLK3,
	input CE0, CE1, CE2, CE3,
	input RST0, RST1, RST2, RST3,
	input SRIA0, SRIA1, SRIA2, SRIA3, SRIA4, SRIA5, SRIA6, SRIA7, SRIA8, SRIA9, SRIA10, SRIA11, SRIA12, SRIA13, SRIA14, SRIA15, SRIA16, SRIA17,
	input SRIB0, SRIB1, SRIB2, SRIB3, SRIB4, SRIB5, SRIB6, SRIB7, SRIB8, SRIB9, SRIB10, SRIB11, SRIB12, SRIB13, SRIB14, SRIB15, SRIB16, SRIB17,
	output SROA0, SROA1, SROA2, SROA3, SROA4, SROA5, SROA6, SROA7, SROA8, SROA9, SROA10, SROA11, SROA12, SROA13, SROA14, SROA15, SROA16, SROA17,
	output SROB0, SROB1, SROB2, SROB3, SROB4, SROB5, SROB6, SROB7, SROB8, SROB9, SROB10, SROB11, SROB12, SROB13, SROB14, SROB15, SROB16, SROB17,
	output ROA0, ROA1, ROA2, ROA3, ROA4, ROA5, ROA6, ROA7, ROA8, ROA9, ROA10, ROA11, ROA12, ROA13, ROA14, ROA15, ROA16, ROA17,
	output ROB0, ROB1, ROB2, ROB3, ROB4, ROB5, ROB6, ROB7, ROB8, ROB9, ROB10, ROB11, ROB12, ROB13, ROB14, ROB15, ROB16, ROB17,
	output ROC0, ROC1, ROC2, ROC3, ROC4, ROC5, ROC6, ROC7, ROC8, ROC9, ROC10, ROC11, ROC12, ROC13, ROC14, ROC15, ROC16, ROC17,
	output P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, P23, P24, P25, P26, P27, P28, P29, P30, P31, P32, P33, P34, P35,
	output SIGNEDP
);
	parameter REG_INPUTA_CLK = "NONE";
	parameter REG_INPUTA_CE = "CE0";
	parameter REG_INPUTA_RST = "RST0";
	parameter REG_INPUTB_CLK = "NONE";
	parameter REG_INPUTB_CE = "CE0";
	parameter REG_INPUTB_RST = "RST0";
	parameter REG_INPUTC_CLK = "NONE";
	parameter REG_INPUTC_CE = "CE0";
	parameter REG_INPUTC_RST = "RST0";
	parameter REG_PIPELINE_CLK = "NONE";
	parameter REG_PIPELINE_CE = "CE0";
	parameter REG_PIPELINE_RST = "RST0";
	parameter REG_OUTPUT_CLK = "NONE";
	parameter REG_OUTPUT_CE = "CE0";
	parameter REG_OUTPUT_RST = "RST0";
	parameter [127:0] CLK0_DIV = "ENABLED";
	parameter [127:0] CLK1_DIV = "ENABLED";
	parameter [127:0] CLK2_DIV = "ENABLED";
	parameter [127:0] CLK3_DIV = "ENABLED";
	parameter HIGHSPEED_CLK = "NONE";
	parameter [127:0] GSR = "ENABLED";
	parameter CAS_MATCH_REG = "FALSE";
	parameter [127:0] SOURCEB_MODE = "B_SHIFT";
	parameter [127:0] MULT_BYPASS = "DISABLED";
	parameter [127:0] RESETMODE = "SYNC";
endmodule

(* blackbox *)
module ALU54B(
	input CLK0, CLK1, CLK2, CLK3,
	input CE0, CE1, CE2, CE3,
	input RST0, RST1, RST2, RST3,
	input SIGNEDIA, SIGNEDIB, SIGNEDCIN,
	input A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35,
	input B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32, B33, B34, B35,
	input C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, C37, C38, C39, C40, C41, C42, C43, C44, C45, C46, C47, C48, C49, C50, C51, C52, C53,
	input CFB0, CFB1, CFB2, CFB3, CFB4, CFB5, CFB6, CFB7, CFB8, CFB9, CFB10, CFB11, CFB12, CFB13, CFB14, CFB15, CFB16, CFB17, CFB18, CFB19, CFB20, CFB21, CFB22, CFB23, CFB24, CFB25, CFB26, CFB27, CFB28, CFB29, CFB30, CFB31, CFB32, CFB33, CFB34, CFB35, CFB36, CFB37, CFB38, CFB39, CFB40, CFB41, CFB42, CFB43, CFB44, CFB45, CFB46, CFB47, CFB48, CFB49, CFB50, CFB51, CFB52, CFB53,
	input MA0, MA1, MA2, MA3, MA4, MA5, MA6, MA7, MA8, MA9, MA10, MA11, MA12, MA13, MA14, MA15, MA16, MA17, MA18, MA19, MA20, MA21, MA22, MA23, MA24, MA25, MA26, MA27, MA28, MA29, MA30, MA31, MA32, MA33, MA34, MA35,
	input MB0, MB1, MB2, MB3, MB4, MB5, MB6, MB7, MB8, MB9, MB10, MB11, MB12, MB13, MB14, MB15, MB16, MB17, MB18, MB19, MB20, MB21, MB22, MB23, MB24, MB25, MB26, MB27, MB28, MB29, MB30, MB31, MB32, MB33, MB34, MB35,
	input CIN0, CIN1, CIN2, CIN3, CIN4, CIN5, CIN6, CIN7, CIN8, CIN9, CIN10, CIN11, CIN12, CIN13, CIN14, CIN15, CIN16, CIN17, CIN18, CIN19, CIN20, CIN21, CIN22, CIN23, CIN24, CIN25, CIN26, CIN27, CIN28, CIN29, CIN30, CIN31, CIN32, CIN33, CIN34, CIN35, CIN36, CIN37, CIN38, CIN39, CIN40, CIN41, CIN42, CIN43, CIN44, CIN45, CIN46, CIN47, CIN48, CIN49, CIN50, CIN51, CIN52, CIN53,
	input OP0, OP1, OP2, OP3, OP4, OP5, OP6, OP7, OP8, OP9, OP10,
	output R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31, R32, R33, R34, R35, R36, R37, R38, R39, R40, R41, R42, R43, R44, R45, R46, R47, R48, R49, R50, R51, R52, R53,
	output CO0, CO1, CO2, CO3, CO4, CO5, CO6, CO7, CO8, CO9, CO10, CO11, CO12, CO13, CO14, CO15, CO16, CO17, CO18, CO19, CO20, CO21, CO22, CO23, CO24, CO25, CO26, CO27, CO28, CO29, CO30, CO31, CO32, CO33, CO34, CO35, CO36, CO37, CO38, CO39, CO40, CO41, CO42, CO43, CO44, CO45, CO46, CO47, CO48, CO49, CO50, CO51, CO52, CO53,
	output EQZ, EQZM, EQOM, EQPAT, EQPATB,
	output OVER, UNDER, OVERUNDER,
	output SIGNEDR
);
	parameter REG_INPUTC0_CLK = "NONE";
	parameter REG_INPUTC0_CE = "CE0";
	parameter REG_INPUTC0_RST = "RST0";
	parameter REG_INPUTC1_CLK = "NONE";
	parameter REG_INPUTC1_CE = "CE0";
	parameter REG_INPUTC1_RST = "RST0";
	parameter REG_OPCODEOP0_0_CLK = "NONE";
	parameter REG_OPCODEOP0_0_CE = "CE0";
	parameter REG_OPCODEOP0_0_RST = "RST0";
	parameter REG_OPCODEOP1_0_CLK = "NONE";
	parameter REG_OPCODEOP0_1_CLK = "NONE";
	parameter REG_OPCODEOP0_1_CE = "CE0";
	parameter REG_OPCODEOP0_1_RST = "RST0";
	parameter REG_OPCODEOP1_1_CLK = "NONE";
	parameter REG_OPCODEIN_0_CLK = "NONE";
	parameter REG_OPCODEIN_0_CE = "CE0";
	parameter REG_OPCODEIN_0_RST = "RST0";
	parameter REG_OPCODEIN_1_CLK = "NONE";
	parameter REG_OPCODEIN_1_CE = "CE0";
	parameter REG_OPCODEIN_1_RST = "RST0";
	parameter REG_OUTPUT0_CLK = "NONE";
	parameter REG_OUTPUT0_CE = "CE0";
	parameter REG_OUTPUT0_RST = "RST0";
	parameter REG_OUTPUT1_CLK = "NONE";
	parameter REG_OUTPUT1_CE = "CE0";
	parameter REG_OUTPUT1_RST = "RST0";
	parameter REG_FLAG_CLK = "NONE";
	parameter REG_FLAG_CE = "CE0";
	parameter REG_FLAG_RST = "RST0";
	parameter REG_INPUTCFB_CLK = "NONE";
	parameter REG_INPUTCFB_CE = "CE0";
	parameter REG_INPUTCFB_RST = "RST0";
	parameter [127:0] MCPAT_SOURCE = "STATIC";
	parameter [127:0] MASKPAT_SOURCE = "STATIC";
	parameter MASK01 = "0x00000000000000";
	parameter [127:0] CLK0_DIV = "ENABLED";
	parameter [127:0] CLK1_DIV = "ENABLED";
	parameter [127:0] CLK2_DIV = "ENABLED";
	parameter [127:0] CLK3_DIV = "ENABLED";
	parameter MCPAT = "0x00000000000000";
	parameter MASKPAT = "0x00000000000000";
	parameter RNDPAT = "0x00000000000000";
	parameter [127:0] GSR = "ENABLED";
	parameter [127:0] RESETMODE = "SYNC";
	parameter MULT9_MODE = "DISABLED";
	parameter FORCE_ZERO_BARREL_SHIFT = "DISABLED";
	parameter LEGACY = "DISABLED";
endmodule

(* blackbox *)
module EHXPLLL (
	input CLKI, CLKFB,
	input PHASESEL1, PHASESEL0, PHASEDIR, PHASESTEP, PHASELOADREG,
	input STDBY, PLLWAKESYNC,
	input RST, ENCLKOP, ENCLKOS, ENCLKOS2, ENCLKOS3,
	output CLKOP, CLKOS, CLKOS2, CLKOS3,
	output LOCK, INTLOCK,
	output REFCLK, CLKINTFB
);
	parameter CLKI_DIV = 1;
	parameter CLKFB_DIV = 1;
	parameter CLKOP_DIV = 8;
	parameter CLKOS_DIV = 8;
	parameter CLKOS2_DIV = 8;
	parameter CLKOS3_DIV = 8;
	parameter CLKOP_ENABLE = "ENABLED";
	parameter CLKOS_ENABLE = "DISABLED";
	parameter CLKOS2_ENABLE = "DISABLED";
	parameter CLKOS3_ENABLE = "DISABLED";
	parameter CLKOP_CPHASE = 0;
	parameter CLKOS_CPHASE = 0;
	parameter CLKOS2_CPHASE = 0;
	parameter CLKOS3_CPHASE = 0;
	parameter CLKOP_FPHASE = 0;
	parameter CLKOS_FPHASE = 0;
	parameter CLKOS2_FPHASE = 0;
	parameter CLKOS3_FPHASE = 0;
	parameter FEEDBK_PATH = "CLKOP";
	parameter CLKOP_TRIM_POL = "RISING";
	parameter CLKOP_TRIM_DELAY = 0;
	parameter CLKOS_TRIM_POL = "RISING";
	parameter CLKOS_TRIM_DELAY = 0;
	parameter OUTDIVIDER_MUXA = "DIVA";
	parameter OUTDIVIDER_MUXB = "DIVB";
	parameter OUTDIVIDER_MUXC = "DIVC";
	parameter OUTDIVIDER_MUXD = "DIVD";
	parameter PLL_LOCK_MODE = 0;
	parameter PLL_LOCK_DELAY = 200;
	parameter STDBY_ENABLE = "DISABLED";
	parameter REFIN_RESET = "DISABLED";
	parameter SYNC_ENABLE = "DISABLED";
	parameter INT_LOCK_STICKY = "ENABLED";
	parameter DPHASE_SOURCE = "DISABLED";
	parameter PLLRST_ENA = "DISABLED";
	parameter INTFB_WAKE = "DISABLED";
endmodule

(* blackbox *)
module DTR(
	input STARTPULSE,
	output DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0
);
endmodule

(* blackbox *)
module OSCG(
	output OSC
);
parameter DIV = 128;
endmodule

(* blackbox *) (* keep *)
module USRMCLK(
	input USRMCLKI, USRMCLKTS,
	output USRMCLKO
);
endmodule

(* blackbox *) (* keep *)
module JTAGG(
	(* iopad_external_pin *)
	input TCK, 
	(* iopad_external_pin *)
	input TMS, 
	(* iopad_external_pin *)
	input TDI,
	input JTDO2, JTDO1,
	(* iopad_external_pin *)
	output TDO,
	output JTDI, JTCK, JRTI2, JRTI1,
	output JSHIFT, JUPDATE, JRSTN, JCE2, JCE1
);
parameter ER1 = "ENABLED";
parameter ER2 = "ENABLED";
endmodule

(* blackbox *)
module DELAYF(
	input A, LOADN, MOVE, DIRECTION,
	output Z, CFLAG
);
	parameter DEL_MODE = "USER_DEFINED";
	parameter DEL_VALUE = 0;
endmodule

(* blackbox *)
module DELAYG(
	input A,
	output Z
);
	parameter DEL_MODE = "USER_DEFINED";
	parameter DEL_VALUE = 0;
endmodule

(* blackbox *)
module IDDRX1F(
	input D, SCLK, RST,
	output Q0, Q1
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDRX2F(
	input D, SCLK, ECLK, RST, ALIGNWD,
	output Q0, Q1, Q2, Q3
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDR71B(
	input D, SCLK, ECLK, RST, ALIGNWD,
	output Q0, Q1, Q2, Q3, Q4, Q5, Q6
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDRX2DQA(
	input D, DQSR90, ECLK, SCLK, RST,
	input RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,
	output Q0, Q1, Q2, Q3, QWL
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX1F(
	input SCLK, RST, D0, D1,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2F(
	input SCLK, ECLK, RST, D0, D1, D2, D3,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDR71B(
	input SCLK, ECLK, RST, D0, D1, D2, D3, D4, D5, D6,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module OSHX2A(
	input D0, D1, RST, ECLK, SCLK,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2DQA(
	input D0, D1, D2, D3, RST, ECLK, SCLK, DQSW270,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2DQSB(
	input D0, D1, D2, D3, RST, ECLK, SCLK, DQSW,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module TSHX2DQA(
	input T0, T1, SCLK, ECLK, DQSW270, RST,
	output Q
);
	parameter GSR = "ENABLED";
	parameter REGSET = "SET";
endmodule

(* blackbox *)
module TSHX2DQSA(
	input T0, T1, SCLK, ECLK, DQSW, RST,
	output Q
);
	parameter GSR = "ENABLED";
	parameter REGSET = "SET";
endmodule

(* blackbox *)
module DQSBUFM(
	input DQSI, READ1, READ0, READCLKSEL2, READCLKSEL1, READCLKSEL0, DDRDEL,
	input ECLK, SCLK,
	input DYNDELAY7, DYNDELAY6, DYNDELAY5, DYNDELAY4,
	input DYNDELAY3, DYNDELAY2, DYNDELAY1, DYNDELAY0, 
	input RST, RDLOADN, RDMOVE, RDDIRECTION, WRLOADN, WRMOVE, WRDIRECTION, PAUSE,
	output DQSR90, DQSW, DQSW270,
	output RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,
	output DATAVALID, BURSTDET, RDCFLAG, WRCFLAG
);
	parameter DQS_LI_DEL_ADJ = "FACTORYONLY";
	parameter DQS_LI_DEL_VAL = 0;
	parameter DQS_LO_DEL_ADJ = "FACTORYONLY";
	parameter DQS_LO_DEL_VAL = 0;
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module DDRDLLA(
	input CLK, RST, UDDCNTLN, FREEZE,
	output LOCK, DDRDEL, DCNTL7, DCNTL6, DCNTL5, DCNTL4, DCNTL3, DCNTL2, DCNTL1, DCNTL0
);
	parameter FORCE_MAX_DELAY = "NO";
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module DLLDELD(
	input A, DDRDEL, LOADN, MOVE, DIRECTION,
	output Z, CFLAG
);
	parameter DEL_ADJ = "PLUS";
	parameter DEL_VAL = 0;
endmodule

(* blackbox *)
module CLKDIVF(
	input CLKI, RST, ALIGNWD,
	output CDIVX
);
	parameter GSR = "DISABLED";
	parameter DIV = "2.0";
endmodule

(* blackbox *)
module ECLKSYNCB(
	input ECLKI, STOP,
	output ECLKO
);
endmodule

(* blackbox *)
module ECLKBRIDGECS(
	input CLK0, CLK1, SEL,
	output ECSOUT
);
endmodule

(* blackbox *)
module DCCA(
	input CLKI, CE,
	output CLKO
);
endmodule

(* blackbox *)
module DCSC(
	input CLK1, CLK0,
	input SEL1, SEL0,
	input MODESEL,
	output DCSOUT
);
	parameter DCSMODE = "POS";
endmodule

(* blackbox *) (* keep *)
module DCUA(
	(* iopad_external_pin *)
	input CH0_HDINP,
	(* iopad_external_pin *)
	input CH1_HDINP,
	(* iopad_external_pin *)
	input CH0_HDINN,
	(* iopad_external_pin *)
	input CH1_HDINN,
	input D_TXBIT_CLKP_FROM_ND, D_TXBIT_CLKN_FROM_ND, D_SYNC_ND, D_TXPLL_LOL_FROM_ND,
	input CH0_RX_REFCLK, CH1_RX_REFCLK, CH0_FF_RXI_CLK, CH1_FF_RXI_CLK, CH0_FF_TXI_CLK, CH1_FF_TXI_CLK, CH0_FF_EBRD_CLK, CH1_FF_EBRD_CLK,
	input CH0_FF_TX_D_0, CH1_FF_TX_D_0, CH0_FF_TX_D_1, CH1_FF_TX_D_1, CH0_FF_TX_D_2, CH1_FF_TX_D_2, CH0_FF_TX_D_3, CH1_FF_TX_D_3,
	input CH0_FF_TX_D_4, CH1_FF_TX_D_4, CH0_FF_TX_D_5, CH1_FF_TX_D_5, CH0_FF_TX_D_6, CH1_FF_TX_D_6, CH0_FF_TX_D_7, CH1_FF_TX_D_7,
	input CH0_FF_TX_D_8, CH1_FF_TX_D_8, CH0_FF_TX_D_9, CH1_FF_TX_D_9, CH0_FF_TX_D_10, CH1_FF_TX_D_10, CH0_FF_TX_D_11, CH1_FF_TX_D_11,
	input CH0_FF_TX_D_12, CH1_FF_TX_D_12, CH0_FF_TX_D_13, CH1_FF_TX_D_13, CH0_FF_TX_D_14, CH1_FF_TX_D_14, CH0_FF_TX_D_15, CH1_FF_TX_D_15,
	input CH0_FF_TX_D_16, CH1_FF_TX_D_16, CH0_FF_TX_D_17, CH1_FF_TX_D_17, CH0_FF_TX_D_18, CH1_FF_TX_D_18, CH0_FF_TX_D_19, CH1_FF_TX_D_19,
	input CH0_FF_TX_D_20, CH1_FF_TX_D_20, CH0_FF_TX_D_21, CH1_FF_TX_D_21, CH0_FF_TX_D_22, CH1_FF_TX_D_22, CH0_FF_TX_D_23, CH1_FF_TX_D_23,
	input CH0_FFC_EI_EN, CH1_FFC_EI_EN, CH0_FFC_PCIE_DET_EN, CH1_FFC_PCIE_DET_EN, CH0_FFC_PCIE_CT, CH1_FFC_PCIE_CT, CH0_FFC_SB_INV_RX, CH1_FFC_SB_INV_RX,
	input CH0_FFC_ENABLE_CGALIGN, CH1_FFC_ENABLE_CGALIGN, CH0_FFC_SIGNAL_DETECT, CH1_FFC_SIGNAL_DETECT, CH0_FFC_FB_LOOPBACK, CH1_FFC_FB_LOOPBACK, CH0_FFC_SB_PFIFO_LP, CH1_FFC_SB_PFIFO_LP,
	input CH0_FFC_PFIFO_CLR, CH1_FFC_PFIFO_CLR, CH0_FFC_RATE_MODE_RX, CH1_FFC_RATE_MODE_RX, CH0_FFC_RATE_MODE_TX, CH1_FFC_RATE_MODE_TX, CH0_FFC_DIV11_MODE_RX, CH1_FFC_DIV11_MODE_RX, CH0_FFC_RX_GEAR_MODE, CH1_FFC_RX_GEAR_MODE, CH0_FFC_TX_GEAR_MODE, CH1_FFC_TX_GEAR_MODE,
	input CH0_FFC_DIV11_MODE_TX, CH1_FFC_DIV11_MODE_TX, CH0_FFC_LDR_CORE2TX_EN, CH1_FFC_LDR_CORE2TX_EN, CH0_FFC_LANE_TX_RST, CH1_FFC_LANE_TX_RST, CH0_FFC_LANE_RX_RST, CH1_FFC_LANE_RX_RST,
	input CH0_FFC_RRST, CH1_FFC_RRST, CH0_FFC_TXPWDNB, CH1_FFC_TXPWDNB, CH0_FFC_RXPWDNB, CH1_FFC_RXPWDNB, CH0_LDR_CORE2TX, CH1_LDR_CORE2TX,
	input D_SCIWDATA0, D_SCIWDATA1, D_SCIWDATA2, D_SCIWDATA3, D_SCIWDATA4, D_SCIWDATA5, D_SCIWDATA6, D_SCIWDATA7,
	input D_SCIADDR0, D_SCIADDR1, D_SCIADDR2, D_SCIADDR3, D_SCIADDR4, D_SCIADDR5, D_SCIENAUX, D_SCISELAUX,
	input CH0_SCIEN, CH1_SCIEN, CH0_SCISEL, CH1_SCISEL, D_SCIRD, D_SCIWSTN, D_CYAWSTN, D_FFC_SYNC_TOGGLE,
	input D_FFC_DUAL_RST, D_FFC_MACRO_RST, D_FFC_MACROPDB, D_FFC_TRST, CH0_FFC_CDR_EN_BITSLIP, CH1_FFC_CDR_EN_BITSLIP, D_SCAN_ENABLE, D_SCAN_IN_0,
	input D_SCAN_IN_1, D_SCAN_IN_2, D_SCAN_IN_3, D_SCAN_IN_4, D_SCAN_IN_5, D_SCAN_IN_6, D_SCAN_IN_7, D_SCAN_MODE,
	input D_SCAN_RESET, D_CIN0, D_CIN1, D_CIN2, D_CIN3, D_CIN4, D_CIN5, D_CIN6,D_CIN7, D_CIN8, D_CIN9, D_CIN10, D_CIN11,
	output CH0_HDOUTP, CH1_HDOUTP, CH0_HDOUTN, CH1_HDOUTN, D_TXBIT_CLKP_TO_ND, D_TXBIT_CLKN_TO_ND, D_SYNC_PULSE2ND, D_TXPLL_LOL_TO_ND,
	output CH0_FF_RX_F_CLK, CH1_FF_RX_F_CLK, CH0_FF_RX_H_CLK, CH1_FF_RX_H_CLK, CH0_FF_TX_F_CLK, CH1_FF_TX_F_CLK, CH0_FF_TX_H_CLK, CH1_FF_TX_H_CLK,
	output CH0_FF_RX_PCLK, CH1_FF_RX_PCLK, CH0_FF_TX_PCLK, CH1_FF_TX_PCLK, CH0_FF_RX_D_0, CH1_FF_RX_D_0, CH0_FF_RX_D_1, CH1_FF_RX_D_1,
	output CH0_FF_RX_D_2, CH1_FF_RX_D_2, CH0_FF_RX_D_3, CH1_FF_RX_D_3, CH0_FF_RX_D_4, CH1_FF_RX_D_4, CH0_FF_RX_D_5, CH1_FF_RX_D_5,
	output CH0_FF_RX_D_6, CH1_FF_RX_D_6, CH0_FF_RX_D_7, CH1_FF_RX_D_7, CH0_FF_RX_D_8, CH1_FF_RX_D_8, CH0_FF_RX_D_9, CH1_FF_RX_D_9,
	output CH0_FF_RX_D_10, CH1_FF_RX_D_10, CH0_FF_RX_D_11, CH1_FF_RX_D_11, CH0_FF_RX_D_12, CH1_FF_RX_D_12, CH0_FF_RX_D_13, CH1_FF_RX_D_13,
	output CH0_FF_RX_D_14, CH1_FF_RX_D_14, CH0_FF_RX_D_15, CH1_FF_RX_D_15, CH0_FF_RX_D_16, CH1_FF_RX_D_16, CH0_FF_RX_D_17, CH1_FF_RX_D_17,
	output CH0_FF_RX_D_18, CH1_FF_RX_D_18, CH0_FF_RX_D_19, CH1_FF_RX_D_19, CH0_FF_RX_D_20, CH1_FF_RX_D_20, CH0_FF_RX_D_21, CH1_FF_RX_D_21,
	output CH0_FF_RX_D_22, CH1_FF_RX_D_22, CH0_FF_RX_D_23, CH1_FF_RX_D_23, CH0_FFS_PCIE_DONE, CH1_FFS_PCIE_DONE, CH0_FFS_PCIE_CON, CH1_FFS_PCIE_CON,
	output CH0_FFS_RLOS, CH1_FFS_RLOS, CH0_FFS_LS_SYNC_STATUS, CH1_FFS_LS_SYNC_STATUS, CH0_FFS_CC_UNDERRUN, CH1_FFS_CC_UNDERRUN, CH0_FFS_CC_OVERRUN, CH1_FFS_CC_OVERRUN,
	output CH0_FFS_RXFBFIFO_ERROR, CH1_FFS_RXFBFIFO_ERROR, CH0_FFS_TXFBFIFO_ERROR, CH1_FFS_TXFBFIFO_ERROR, CH0_FFS_RLOL, CH1_FFS_RLOL, CH0_FFS_SKP_ADDED, CH1_FFS_SKP_ADDED,
	output CH0_FFS_SKP_DELETED, CH1_FFS_SKP_DELETED, CH0_LDR_RX2CORE, CH1_LDR_RX2CORE, D_SCIRDATA0, D_SCIRDATA1, D_SCIRDATA2, D_SCIRDATA3,
	output D_SCIRDATA4, D_SCIRDATA5, D_SCIRDATA6, D_SCIRDATA7, D_SCIINT, D_SCAN_OUT_0, D_SCAN_OUT_1, D_SCAN_OUT_2, D_SCAN_OUT_3, D_SCAN_OUT_4, D_SCAN_OUT_5, D_SCAN_OUT_6, D_SCAN_OUT_7,
	output D_COUT0, D_COUT1, D_COUT2, D_COUT3, D_COUT4, D_COUT5, D_COUT6, D_COUT7, D_COUT8, D_COUT9, D_COUT10, D_COUT11, D_COUT12, D_COUT13, D_COUT14, D_COUT15, D_COUT16, D_COUT17, D_COUT18, D_COUT19,

	input  D_REFCLKI,
	output D_FFS_PLOL
);
	parameter CH0_AUTO_CALIB_EN = "0b0";
	parameter CH0_AUTO_FACQ_EN = "0b0";
	parameter CH0_BAND_THRESHOLD = "0b000000";
	parameter CH0_CALIB_CK_MODE = "0b0";
	parameter CH0_CC_MATCH_1 = "0b0000000000";
	parameter CH0_CC_MATCH_2 = "0b0000000000";
	parameter CH0_CC_MATCH_3 = "0b0000000000";
	parameter CH0_CC_MATCH_4 = "0b0000000000";
	parameter CH0_CDR_CNT4SEL = "0b00";
	parameter CH0_CDR_CNT8SEL = "0b00";
	parameter CH0_CTC_BYPASS = "0b0";
	parameter CH0_DCOATDCFG = "0b00";
	parameter CH0_DCOATDDLY = "0b00";
	parameter CH0_DCOBYPSATD = "0b0";
	parameter CH0_DCOCALDIV = "0b000";
	parameter CH0_DCOCTLGI = "0b000";
	parameter CH0_DCODISBDAVOID = "0b0";
	parameter CH0_DCOFLTDAC = "0b00";
	parameter CH0_DCOFTNRG = "0b000";
	parameter CH0_DCOIOSTUNE = "0b000";
	parameter CH0_DCOITUNE = "0b00";
	parameter CH0_DCOITUNE4LSB = "0b000";
	parameter CH0_DCOIUPDNX2 = "0b0";
	parameter CH0_DCONUOFLSB = "0b000";
	parameter CH0_DCOSCALEI = "0b00";
	parameter CH0_DCOSTARTVAL = "0b000";
	parameter CH0_DCOSTEP = "0b00";
	parameter CH0_DEC_BYPASS = "0b0";
	parameter CH0_ENABLE_CG_ALIGN = "0b0";
	parameter CH0_ENC_BYPASS = "0b0";
	parameter CH0_FF_RX_F_CLK_DIS = "0b0";
	parameter CH0_FF_RX_H_CLK_EN = "0b0";
	parameter CH0_FF_TX_F_CLK_DIS = "0b0";
	parameter CH0_FF_TX_H_CLK_EN = "0b0";
	parameter CH0_GE_AN_ENABLE = "0b0";
	parameter CH0_INVERT_RX = "0b0";
	parameter CH0_INVERT_TX = "0b0";
	parameter CH0_LDR_CORE2TX_SEL = "0b0";
	parameter CH0_LDR_RX2CORE_SEL = "0b0";
	parameter CH0_LEQ_OFFSET_SEL = "0b0";
	parameter CH0_LEQ_OFFSET_TRIM = "0b000";
	parameter CH0_LSM_DISABLE = "0b0";
	parameter CH0_MATCH_2_ENABLE = "0b0";
	parameter CH0_MATCH_4_ENABLE = "0b0";
	parameter CH0_MIN_IPG_CNT = "0b00";
	parameter CH0_PCIE_EI_EN = "0b0";
	parameter CH0_PCIE_MODE = "0b0";
	parameter CH0_PCS_DET_TIME_SEL = "0b00";
	parameter CH0_PDEN_SEL = "0b0";
	parameter CH0_PRBS_ENABLE = "0b0";
	parameter CH0_PRBS_LOCK = "0b0";
	parameter CH0_PRBS_SELECTION = "0b0";
	parameter CH0_RATE_MODE_RX = "0b0";
	parameter CH0_RATE_MODE_TX = "0b0";
	parameter CH0_RCV_DCC_EN = "0b0";
	parameter CH0_REG_BAND_OFFSET = "0b0000";
	parameter CH0_REG_BAND_SEL = "0b000000";
	parameter CH0_REG_IDAC_EN = "0b0";
	parameter CH0_REG_IDAC_SEL = "0b0000000000";
	parameter CH0_REQ_EN = "0b0";
	parameter CH0_REQ_LVL_SET = "0b00";
	parameter CH0_RIO_MODE = "0b0";
	parameter CH0_RLOS_SEL = "0b0";
	parameter CH0_RPWDNB = "0b0";
	parameter CH0_RTERM_RX = "0b00000";
	parameter CH0_RTERM_TX = "0b00000";
	parameter CH0_RXIN_CM = "0b00";
	parameter CH0_RXTERM_CM = "0b00";
	parameter CH0_RX_DCO_CK_DIV = "0b000";
	parameter CH0_RX_DIV11_SEL = "0b0";
	parameter CH0_RX_GEAR_BYPASS = "0b0";
	parameter CH0_RX_GEAR_MODE = "0b0";
	parameter CH0_RX_LOS_CEQ = "0b00";
	parameter CH0_RX_LOS_EN = "0b0";
	parameter CH0_RX_LOS_HYST_EN = "0b0";
	parameter CH0_RX_LOS_LVL = "0b000";
	parameter CH0_RX_RATE_SEL = "0b0000";
	parameter CH0_RX_SB_BYPASS = "0b0";
	parameter CH0_SB_BYPASS = "0b0";
	parameter CH0_SEL_SD_RX_CLK = "0b0";
	parameter CH0_TDRV_DAT_SEL = "0b00";
	parameter CH0_TDRV_POST_EN = "0b0";
	parameter CH0_TDRV_PRE_EN = "0b0";
	parameter CH0_TDRV_SLICE0_CUR = "0b000";
	parameter CH0_TDRV_SLICE0_SEL = "0b00";
	parameter CH0_TDRV_SLICE1_CUR = "0b000";
	parameter CH0_TDRV_SLICE1_SEL = "0b00";
	parameter CH0_TDRV_SLICE2_CUR = "0b00";
	parameter CH0_TDRV_SLICE2_SEL = "0b00";
	parameter CH0_TDRV_SLICE3_CUR = "0b00";
	parameter CH0_TDRV_SLICE3_SEL = "0b00";
	parameter CH0_TDRV_SLICE4_CUR = "0b00";
	parameter CH0_TDRV_SLICE4_SEL = "0b00";
	parameter CH0_TDRV_SLICE5_CUR = "0b00";
	parameter CH0_TDRV_SLICE5_SEL = "0b00";
	parameter CH0_TPWDNB = "0b0";
	parameter CH0_TX_CM_SEL = "0b00";
	parameter CH0_TX_DIV11_SEL = "0b0";
	parameter CH0_TX_GEAR_BYPASS = "0b0";
	parameter CH0_TX_GEAR_MODE = "0b0";
	parameter CH0_TX_POST_SIGN = "0b0";
	parameter CH0_TX_PRE_SIGN = "0b0";
	parameter CH0_UC_MODE = "0b0";
	parameter CH0_UDF_COMMA_A = "0b0000000000";
	parameter CH0_UDF_COMMA_B = "0b0000000000";
	parameter CH0_UDF_COMMA_MASK = "0b0000000000";
	parameter CH0_WA_BYPASS = "0b0";
	parameter CH0_WA_MODE = "0b0";
	parameter CH1_AUTO_CALIB_EN = "0b0";
	parameter CH1_AUTO_FACQ_EN = "0b0";
	parameter CH1_BAND_THRESHOLD = "0b000000";
	parameter CH1_CALIB_CK_MODE = "0b0";
	parameter CH1_CC_MATCH_1 = "0b0000000000";
	parameter CH1_CC_MATCH_2 = "0b0000000000";
	parameter CH1_CC_MATCH_3 = "0b0000000000";
	parameter CH1_CC_MATCH_4 = "0b0000000000";
	parameter CH1_CDR_CNT4SEL = "0b00";
	parameter CH1_CDR_CNT8SEL = "0b00";
	parameter CH1_CTC_BYPASS = "0b0";
	parameter CH1_DCOATDCFG = "0b00";
	parameter CH1_DCOATDDLY = "0b00";
	parameter CH1_DCOBYPSATD = "0b0";
	parameter CH1_DCOCALDIV = "0b000";
	parameter CH1_DCOCTLGI = "0b000";
	parameter CH1_DCODISBDAVOID = "0b0";
	parameter CH1_DCOFLTDAC = "0b00";
	parameter CH1_DCOFTNRG = "0b000";
	parameter CH1_DCOIOSTUNE = "0b000";
	parameter CH1_DCOITUNE = "0b00";
	parameter CH1_DCOITUNE4LSB = "0b000";
	parameter CH1_DCOIUPDNX2 = "0b0";
	parameter CH1_DCONUOFLSB = "0b000";
	parameter CH1_DCOSCALEI = "0b00";
	parameter CH1_DCOSTARTVAL = "0b000";
	parameter CH1_DCOSTEP = "0b00";
	parameter CH1_DEC_BYPASS = "0b0";
	parameter CH1_ENABLE_CG_ALIGN = "0b0";
	parameter CH1_ENC_BYPASS = "0b0";
	parameter CH1_FF_RX_F_CLK_DIS = "0b0";
	parameter CH1_FF_RX_H_CLK_EN = "0b0";
	parameter CH1_FF_TX_F_CLK_DIS = "0b0";
	parameter CH1_FF_TX_H_CLK_EN = "0b0";
	parameter CH1_GE_AN_ENABLE = "0b0";
	parameter CH1_INVERT_RX = "0b0";
	parameter CH1_INVERT_TX = "0b0";
	parameter CH1_LDR_CORE2TX_SEL = "0b0";
	parameter CH1_LDR_RX2CORE_SEL = "0b0";
	parameter CH1_LEQ_OFFSET_SEL = "0b0";
	parameter CH1_LEQ_OFFSET_TRIM = "0b000";
	parameter CH1_LSM_DISABLE = "0b0";
	parameter CH1_MATCH_2_ENABLE = "0b0";
	parameter CH1_MATCH_4_ENABLE = "0b0";
	parameter CH1_MIN_IPG_CNT = "0b00";
	parameter CH1_PCIE_EI_EN = "0b0";
	parameter CH1_PCIE_MODE = "0b0";
	parameter CH1_PCS_DET_TIME_SEL = "0b00";
	parameter CH1_PDEN_SEL = "0b0";
	parameter CH1_PRBS_ENABLE = "0b0";
	parameter CH1_PRBS_LOCK = "0b0";
	parameter CH1_PRBS_SELECTION = "0b0";
	parameter CH1_RATE_MODE_RX = "0b0";
	parameter CH1_RATE_MODE_TX = "0b0";
	parameter CH1_RCV_DCC_EN = "0b0";
	parameter CH1_REG_BAND_OFFSET = "0b0000";
	parameter CH1_REG_BAND_SEL = "0b000000";
	parameter CH1_REG_IDAC_EN = "0b0";
	parameter CH1_REG_IDAC_SEL = "0b0000000000";
	parameter CH1_REQ_EN = "0b0";
	parameter CH1_REQ_LVL_SET = "0b00";
	parameter CH1_RIO_MODE = "0b0";
	parameter CH1_RLOS_SEL = "0b0";
	parameter CH1_RPWDNB = "0b0";
	parameter CH1_RTERM_RX = "0b00000";
	parameter CH1_RTERM_TX = "0b00000";
	parameter CH1_RXIN_CM = "0b00";
	parameter CH1_RXTERM_CM = "0b00";
	parameter CH1_RX_DCO_CK_DIV = "0b000";
	parameter CH1_RX_DIV11_SEL = "0b0";
	parameter CH1_RX_GEAR_BYPASS = "0b0";
	parameter CH1_RX_GEAR_MODE = "0b0";
	parameter CH1_RX_LOS_CEQ = "0b00";
	parameter CH1_RX_LOS_EN = "0b0";
	parameter CH1_RX_LOS_HYST_EN = "0b0";
	parameter CH1_RX_LOS_LVL = "0b000";
	parameter CH1_RX_RATE_SEL = "0b0000";
	parameter CH1_RX_SB_BYPASS = "0b0";
	parameter CH1_SB_BYPASS = "0b0";
	parameter CH1_SEL_SD_RX_CLK = "0b0";
	parameter CH1_TDRV_DAT_SEL = "0b00";
	parameter CH1_TDRV_POST_EN = "0b0";
	parameter CH1_TDRV_PRE_EN = "0b0";
	parameter CH1_TDRV_SLICE0_CUR = "0b000";
	parameter CH1_TDRV_SLICE0_SEL = "0b00";
	parameter CH1_TDRV_SLICE1_CUR = "0b000";
	parameter CH1_TDRV_SLICE1_SEL = "0b00";
	parameter CH1_TDRV_SLICE2_CUR = "0b00";
	parameter CH1_TDRV_SLICE2_SEL = "0b00";
	parameter CH1_TDRV_SLICE3_CUR = "0b00";
	parameter CH1_TDRV_SLICE3_SEL = "0b00";
	parameter CH1_TDRV_SLICE4_CUR = "0b00";
	parameter CH1_TDRV_SLICE4_SEL = "0b00";
	parameter CH1_TDRV_SLICE5_CUR = "0b00";
	parameter CH1_TDRV_SLICE5_SEL = "0b00";
	parameter CH1_TPWDNB = "0b0";
	parameter CH1_TX_CM_SEL = "0b00";
	parameter CH1_TX_DIV11_SEL = "0b0";
	parameter CH1_TX_GEAR_BYPASS = "0b0";
	parameter CH1_TX_GEAR_MODE = "0b0";
	parameter CH1_TX_POST_SIGN = "0b0";
	parameter CH1_TX_PRE_SIGN = "0b0";
	parameter CH1_UC_MODE = "0b0";
	parameter CH1_UDF_COMMA_A = "0b0000000000";
	parameter CH1_UDF_COMMA_B = "0b0000000000";
	parameter CH1_UDF_COMMA_MASK = "0b0000000000";
	parameter CH1_WA_BYPASS = "0b0";
	parameter CH1_WA_MODE = "0b0";
	parameter D_BITCLK_FROM_ND_EN = "0b0";
	parameter D_BITCLK_LOCAL_EN = "0b0";
	parameter D_BITCLK_ND_EN = "0b0";
	parameter D_BUS8BIT_SEL = "0b0";
	parameter D_CDR_LOL_SET = "0b00";
	parameter D_CMUSETBIASI = "0b00";
	parameter D_CMUSETI4CPP = "0b0000";
	parameter D_CMUSETI4CPZ = "0b0000";
	parameter D_CMUSETI4VCO = "0b00";
	parameter D_CMUSETICP4P = "0b00";
	parameter D_CMUSETICP4Z = "0b000";
	parameter D_CMUSETINITVCT = "0b00";
	parameter D_CMUSETISCL4VCO = "0b000";
	parameter D_CMUSETP1GM = "0b000";
	parameter D_CMUSETP2AGM = "0b000";
	parameter D_CMUSETZGM = "0b000";
	parameter D_DCO_CALIB_TIME_SEL = "0b00";
	parameter D_HIGH_MARK = "0b0000";
	parameter D_IB_PWDNB = "0b0";
	parameter D_ISETLOS = "0b00000000";
	parameter D_LOW_MARK = "0b0000";
	parameter D_MACROPDB = "0b0";
	parameter D_PD_ISET = "0b00";
	parameter D_PLL_LOL_SET = "0b00";
	parameter D_REFCK_MODE = "0b000";
	parameter D_REQ_ISET = "0b000";
	parameter D_RG_EN = "0b0";
	parameter D_RG_SET = "0b00";
	parameter D_SETICONST_AUX = "0b00";
	parameter D_SETICONST_CH = "0b00";
	parameter D_SETIRPOLY_AUX = "0b00";
	parameter D_SETIRPOLY_CH = "0b00";
	parameter D_SETPLLRC = "0b000000";
	parameter D_SYNC_LOCAL_EN = "0b0";
	parameter D_SYNC_ND_EN = "0b0";
	parameter D_TXPLL_PWDNB = "0b0";
	parameter D_TX_VCO_CK_DIV = "0b000";
	parameter D_XGE_MODE = "0b0";

// These parameters don't do anything but are
// needed for compatibility with Diamond
	parameter D_TX_MAX_RATE = "2.5";
	parameter D_RX_MAX_RATE = "2.5";
	parameter CH0_TXAMPLITUDE = "0d1300";
	parameter CH1_TXAMPLITUDE = "0d1300";
	parameter CH0_PROTOCOL = "8B10B";
	parameter CH1_PROTOCOL = "8B10B";
	parameter CH0_CDR_MAX_RATE = "2.5";
	parameter CH1_CDR_MAX_RATE = "2.5";
	parameter CH0_TXDEPRE = "DISABLED";
	parameter CH1_TXDEPRE = "DISABLED";
	parameter CH0_TXDEPOST = "DISABLED";
	parameter CH1_TXDEPOST = "DISABLED";
endmodule

(* blackbox *)
module EXTREFB (
	(* iopad_external_pin *)
	input REFCLKP,
	(* iopad_external_pin *)
	input REFCLKN,
	output REFCLKO
);
	parameter REFCK_PWDNB = "0b0";
	parameter REFCK_RTERM = "0b0";
	parameter REFCK_DCBIAS_EN = "0b0";
endmodule

(* blackbox *)
module PCSCLKDIV (
	input CLKI, RST, SEL2, SEL1, SEL0,
	output CDIV1, CDIVX
);
	parameter GSR = "DISABLED";
endmodule

// Note: this module is not marked keep as we want it swept away in synth (sim use only)
(* blackbox *)
module PUR (
	input PUR
);
	parameter RST_PULSE = 1;
endmodule

(* blackbox, keep *)
module GSR (
	input GSR
);
endmodule

(* blackbox, keep *)
module SGSR (
	input GSR, CLK
);
endmodule


(* blackbox *)
module PDPW16KD (
	input DI35, DI34, DI33, DI32, DI31, DI30, DI29, DI28, DI27, DI26, DI25, DI24, DI23, DI22, DI21, DI20, DI19, DI18,
	input DI17, DI16, DI15, DI14, DI13, DI12, DI11, DI10, DI9, DI8, DI7, DI6, DI5, DI4, DI3, DI2, DI1, DI0,
	input ADW8, ADW7, ADW6, ADW5, ADW4, ADW3, ADW2, ADW1, ADW0,
	input BE3,  BE2,  BE1, BE0, CEW, CLKW, CSW2, CSW1, CSW0,
	input ADR13, ADR12, ADR11, ADR10, ADR9, ADR8, ADR7, ADR6, ADR5, ADR4, ADR3, ADR2, ADR1, ADR0,
	input CER, OCER, CLKR, CSR2, CSR1, CSR0, RST,
	output DO35, DO34, DO33, DO32, DO31, DO30, DO29, DO28, DO27, DO26, DO25, DO24, DO23, DO22, DO21, DO20, DO19, DO18,
	output DO17, DO16, DO15, DO14, DO13, DO12, DO11, DO10, DO9, DO8, DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0
);
	parameter DATA_WIDTH_W = 36;
	parameter DATA_WIDTH_R = 36;
	parameter GSR = "ENABLED";

	parameter REGMODE = "NOREG";

	parameter RESETMODE = "SYNC";
	parameter ASYNC_RESET_RELEASE = "SYNC";

	parameter CSDECODE_W = "0b000";
	parameter CSDECODE_R = "0b000";

	parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INIT_DATA = "STATIC";
	parameter CLKWMUX = "CLKW";
	parameter CLKRMUX = "CLKR";

endmodule
`,"cells_ff.vh":`// Diamond flip-flops
module FD1P3AX(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3AY(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1S3AX(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3AY(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3BX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule
module FD1S3DX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3IX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3JX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule

// TODO: Diamond latches
// module FL1P3AY(); endmodule
// module FL1P3AZ(); endmodule
// module FL1P3BX(); endmodule
// module FL1P3DX(); endmodule
// module FL1P3IY(); endmodule
// module FL1P3JY(); endmodule
// module FL1S3AX(); endmodule
// module FL1S3AY(); endmodule

// Diamond I/O registers
module IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

module OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

// TODO: Diamond I/O latches
// module IFS1S1B(input PD, D, SCLK, output Q); endmodule
// module IFS1S1D(input CD, D, SCLK, output Q); endmodule
// module IFS1S1I(input PD, D, SCLK, output Q); endmodule
// module IFS1S1J(input CD, D, SCLK, output Q); endmodule
`,"cells_io.vh":`// Diamond I/O buffers
module IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule
module OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule
module BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule
module OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule
`,"cells_map.v":`module  \\$_DFF_N_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_P_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module \\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

module \\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`ifndef NO_LUT
module \\$lut (A, Y);
    parameter WIDTH = 0;
    parameter LUT = 0;

    (* force_downto *)
    input [WIDTH-1:0] A;
    output Y;

    generate
        if (WIDTH == 1) begin
            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));
        end else
        if (WIDTH == 2) begin
            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));
        end else
        if (WIDTH == 3) begin
            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));
        end else
        if (WIDTH == 4) begin
            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
        \`ifndef NO_PFUMUX
        end else
        if (WIDTH == 5) begin
            wire f0, f1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));
        end else
        if (WIDTH == 6) begin
            wire f0, f1, f2, f3, g0, g1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));
        end else
        if (WIDTH == 7) begin
            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));
            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));
            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));
            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));
            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));
        \`endif
        end else begin
            wire _TECHMAP_FAIL_ = 1;
        end
    endgenerate
endmodule
\`endif
`,"cells_sim.v":`// ---------------------------------------

(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
    parameter [15:0] INIT = 16'h0000;
    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
    specify
        (A => Z) = 141;
        (B => Z) = 275;
        (C => Z) = 379;
        (D => Z) = 379;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
// LUT5 = 2x LUT4 + PFUMX
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);
    specify
        (M0 => Z) = 151;
        (D => Z) = 239;
        (C => Z) = 373;
        (B => Z) = 477;
        (A => Z) = 477;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 6-input LUTs and is not intended to be instantiated
// LUT6 = 2x LUT5 + MUX2
(* abc9_lut=4 *)
module \\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);
    specify
        (M1 => Z) = 148;
        (M0 => Z) = 292;
        (D => Z) = 380;
        (C => Z) = 514;
        (B => Z) = 618;
        (A => Z) = 618;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 7-input LUTs and is not intended to be instantiated
// LUT7 = 2x LUT6 + MUX2
(* abc9_lut=8 *)
module \\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);
    specify
        (M2 => Z) = 148;
        (M1 => Z) = 289;
        (M0 => Z) = 433;
        (D => Z) = 521;
        (C => Z) = 655;
        (B => Z) = 759;
        (A => Z) = 759;
    endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module L6MUX21 (input D0, D1, SD, output Z);
	assign Z = SD ? D1 : D0;
	specify
		(D0 => Z) = 140;
		(D1 => Z) = 141;
		(SD => Z) = 148;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module CCU2C(
	(* abc9_carry *)
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	(* abc9_carry *)
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);

	specify
		(A0 => S0) = 379;
		(B0 => S0) = 379;
		(C0 => S0) = 275;
		(D0 => S0) = 141;
		(CIN => S0) = 257;
		(A0 => S1) = 630;
		(B0 => S1) = 630;
		(C0 => S1) = 526;
		(D0 => S1) = 392;
		(A1 => S1) = 379;
		(B1 => S1) = 379;
		(C1 => S1) = 275;
		(D1 => S1) = 141;
		(CIN => S1) = 273;
		(A0 => COUT) = 516;
		(B0 => COUT) = 516;
		(C0 => COUT) = 412;
		(D0 => COUT) = 278;
		(A1 => COUT) = 516;
		(B1 => COUT) = 516;
		(C1 => COUT) = 412;
		(D1 => COUT) = 278;
		(CIN => COUT) = 43;
	endspecify
endmodule

// ---------------------------------------

module TRELLIS_RAM16X2 (
	input DI0, DI1,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	input RAD0, RAD1, RAD2, RAD3,
	output DO0, DO1
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter INITVAL_0 = 16'h0000;
	parameter INITVAL_1 = 16'h0000;

	reg [1:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= {INITVAL_1[i], INITVAL_0[i]};
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase


	always @(posedge muxwck)
		if (muxwre)
			mem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};

	assign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module PFUMX (input ALUT, BLUT, C0, output Z);
	assign Z = C0 ? ALUT : BLUT;
	specify
		(ALUT => Z) = 98;
		(BLUT => Z) = 98;
		(C0 => Z) = 151;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module TRELLIS_DPR16X4 (
	input  [3:0] DI,
	input  [3:0] WAD,
	input        WRE,
	input        WCK,
	input  [3:0] RAD,
	output [3:0] DO
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter [63:0] INITVAL = 64'h0000000000000000;

	reg [3:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= INITVAL[4*i +: 4];
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase

	always @(posedge muxwck)
		if (muxwre)
			mem[WAD] <= DI;

	assign DO = mem[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* abc9_box, lib_whitebox *)
module DPR16X4C (
		input [3:0] DI,
		input WCK, WRE,
		input [3:0] RAD,
		input [3:0] WAD,
		output [3:0] DO
);
	// For legacy Lattice compatibility, INITIVAL is a hex
	// string rather than a numeric parameter
	parameter INITVAL = "0x0000000000000000";

	function [63:0] convert_initval;
		input [143:0] hex_initval;
		reg done;
		reg [63:0] temp;
		reg [7:0] char;
		integer i;
		begin
			done = 1'b0;
			temp = 0;
			for (i = 0; i < 16; i = i + 1) begin
				if (!done) begin
					char = hex_initval[8*i +: 8];
					if (char == "x") begin
						done = 1'b1;
					end else begin
						if (char >= "0" && char <= "9")
							temp[4*i +: 4] = char - "0";
						else if (char >= "A" && char <= "F")
							temp[4*i +: 4] = 10 + char - "A";
						else if (char >= "a" && char <= "f")
							temp[4*i +: 4] = 10 + char - "a";
					end
				end
			end
			convert_initval = temp;
		end
	endfunction

	localparam conv_initval = convert_initval(INITVAL);

	reg [3:0] ram[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i = i + 1) begin
			ram[i] <= conv_initval[4*i +: 4];
		end
	end

	always @(posedge WCK)
		if (WRE)
			ram[WAD] <= DI;

	assign DO = ram[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* lib_whitebox *)
module LUT2(input A, B, output Z);
    parameter [3:0] INIT = 4'h0;
    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
endmodule

// ---------------------------------------

\`ifdef YOSYS
(* abc9_flop=(SRMODE != "ASYNC"), abc9_box=(SRMODE == "ASYNC"), lib_whitebox *)
\`endif
module TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (SRMODE == "ASYNC") begin
			always @(posedge muxclk, posedge muxlsr)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end else begin
			always @(posedge muxclk)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end
	endgenerate

	specify
		$setup(DI, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(CE, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(LSR, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(DI, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(CE, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(LSR, posedge CLK &&& CLKMUX != "INV", 0);
\`ifndef YOSYS
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX == "INV") (negedge CLK => (Q : srval)) = 0;
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX != "INV") (posedge CLK => (Q : srval)) = 0;
\`else
		if (SRMODE == "ASYNC" && muxlsr) (LSR => Q) = 0; 	// Technically, this should be an edge sensitive path
									// but for facilitating a bypass box, let's pretend it's
									// a simple path
\`endif
		if (!muxlsr && muxce && CLKMUX == "INV") (negedge CLK => (Q : DI)) = 0;
		if (!muxlsr && muxce && CLKMUX != "INV") (posedge CLK => (Q : DI)) = 0;
	endspecify
endmodule

// ---------------------------------------
(* keep *)
module TRELLIS_IO(
	(* iopad_external_pin *)
	inout B,
	input I,
	input T,
	output O
);
	parameter DIR = "INPUT";
	reg T_pd;
	always @(*) if (T === 1'bz) T_pd = 1'b0; else T_pd = T;

	generate
		if (DIR == "INPUT") begin
			assign B = 1'bz;
			assign O = B;
		end else if (DIR == "OUTPUT") begin
			assign B = T_pd ? 1'bz : I;
			assign O = 1'bx;
		end else if (DIR == "BIDIR") begin
			assign B = T_pd ? 1'bz : I;
			assign O = B;
		end else begin
			ERROR_UNKNOWN_IO_MODE error();
		end
	endgenerate

endmodule

// ---------------------------------------

module INV(input A, output Z);
	assign Z = !A;
endmodule

// ---------------------------------------

module TRELLIS_COMB(
	input A, B, C, D, M,
	input FCI, F1, FXA, FXB,
	input WD,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	output F, FCO, OFX
);
	parameter MODE = "LOGIC";
	parameter INITVAL = 16'h0;
	parameter CCU2_INJECT1 = "NO";
	parameter WREMUX = "WRE";
	parameter IS_Z1 = 1'b0;

	generate
		if (MODE == "LOGIC") begin: mode_logic
			LUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));
		end else if (MODE == "CCU2") begin: mode_ccu2
			wire l4o, l2o;
			LUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));
			LUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));
			wire gated_cin_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : FCI;
			assign F = l4o ^ gated_cin_0;
			wire gated_lut2_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : l2o;
			wire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);
		end else if (MODE == "DPRAM") begin: mode_dpram
			reg [15:0] ram = INITVAL;
			always @(posedge WCK)
				if (WRE)
					ram[{WAD3, WAD2, WAD1, WAD0}] <= WD;
			assign F = ram[{A, C, B, D}];
		end else begin
			$error("unsupported COMB mode %s", MODE);
		end

 		if (IS_Z1)
			L6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));
		else
			PFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));
	endgenerate

endmodule

(* blackbox *)
module DP16KD(
  input DIA17, DIA16, DIA15, DIA14, DIA13, DIA12, DIA11, DIA10, DIA9, DIA8, DIA7, DIA6, DIA5, DIA4, DIA3, DIA2, DIA1, DIA0,
  input ADA13, ADA12, ADA11, ADA10, ADA9, ADA8, ADA7, ADA6, ADA5, ADA4, ADA3, ADA2, ADA1, ADA0,
  input CEA, OCEA, CLKA, WEA, RSTA,
  input CSA2, CSA1, CSA0,
  output DOA17, DOA16, DOA15, DOA14, DOA13, DOA12, DOA11, DOA10, DOA9, DOA8, DOA7, DOA6, DOA5, DOA4, DOA3, DOA2, DOA1, DOA0,

  input DIB17, DIB16, DIB15, DIB14, DIB13, DIB12, DIB11, DIB10, DIB9, DIB8, DIB7, DIB6, DIB5, DIB4, DIB3, DIB2, DIB1, DIB0,
  input ADB13, ADB12, ADB11, ADB10, ADB9, ADB8, ADB7, ADB6, ADB5, ADB4, ADB3, ADB2, ADB1, ADB0,
  input CEB, OCEB, CLKB, WEB, RSTB,
  input CSB2, CSB1, CSB0,
  output DOB17, DOB16, DOB15, DOB14, DOB13, DOB12, DOB11, DOB10, DOB9, DOB8, DOB7, DOB6, DOB5, DOB4, DOB3, DOB2, DOB1, DOB0
);
	parameter DATA_WIDTH_A = 18;
	parameter DATA_WIDTH_B = 18;

	parameter REGMODE_A = "NOREG";
	parameter REGMODE_B = "NOREG";

	parameter RESETMODE = "SYNC";
	parameter ASYNC_RESET_RELEASE = "SYNC";

	parameter CSDECODE_A = "0b000";
	parameter CSDECODE_B = "0b000";

	parameter WRITEMODE_A = "NORMAL";
	parameter WRITEMODE_B = "NORMAL";

	parameter DIA17MUX = "DIA17";
	parameter DIA16MUX = "DIA16";
	parameter DIA15MUX = "DIA15";
	parameter DIA14MUX = "DIA14";
	parameter DIA13MUX = "DIA13";
	parameter DIA12MUX = "DIA12";
	parameter DIA11MUX = "DIA11";
	parameter DIA10MUX = "DIA10";
	parameter DIA9MUX = "DIA9";
	parameter DIA8MUX = "DIA8";
	parameter DIA7MUX = "DIA7";
	parameter DIA6MUX = "DIA6";
	parameter DIA5MUX = "DIA5";
	parameter DIA4MUX = "DIA4";
	parameter DIA3MUX = "DIA3";
	parameter DIA2MUX = "DIA2";
	parameter DIA1MUX = "DIA1";
	parameter DIA0MUX = "DIA0";
	parameter ADA13MUX = "ADA13";
	parameter ADA12MUX = "ADA12";
	parameter ADA11MUX = "ADA11";
	parameter ADA10MUX = "ADA10";
	parameter ADA9MUX = "ADA9";
	parameter ADA8MUX = "ADA8";
	parameter ADA7MUX = "ADA7";
	parameter ADA6MUX = "ADA6";
	parameter ADA5MUX = "ADA5";
	parameter ADA4MUX = "ADA4";
	parameter ADA3MUX = "ADA3";
	parameter ADA2MUX = "ADA2";
	parameter ADA1MUX = "ADA1";
	parameter ADA0MUX = "ADA0";
	parameter CEAMUX = "CEA";
	parameter OCEAMUX = "OCEA";
	parameter CLKAMUX = "CLKA";
	parameter WEAMUX = "WEA";
	parameter RSTAMUX = "RSTA";
	parameter CSA2MUX = "CSA2";
	parameter CSA1MUX = "CSA1";
	parameter CSA0MUX = "CSA0";
	parameter DOA17MUX = "DOA17";
	parameter DOA16MUX = "DOA16";
	parameter DOA15MUX = "DOA15";
	parameter DOA14MUX = "DOA14";
	parameter DOA13MUX = "DOA13";
	parameter DOA12MUX = "DOA12";
	parameter DOA11MUX = "DOA11";
	parameter DOA10MUX = "DOA10";
	parameter DOA9MUX = "DOA9";
	parameter DOA8MUX = "DOA8";
	parameter DOA7MUX = "DOA7";
	parameter DOA6MUX = "DOA6";
	parameter DOA5MUX = "DOA5";
	parameter DOA4MUX = "DOA4";
	parameter DOA3MUX = "DOA3";
	parameter DOA2MUX = "DOA2";
	parameter DOA1MUX = "DOA1";
	parameter DOA0MUX = "DOA0";
	parameter DIB17MUX = "DIB17";
	parameter DIB16MUX = "DIB16";
	parameter DIB15MUX = "DIB15";
	parameter DIB14MUX = "DIB14";
	parameter DIB13MUX = "DIB13";
	parameter DIB12MUX = "DIB12";
	parameter DIB11MUX = "DIB11";
	parameter DIB10MUX = "DIB10";
	parameter DIB9MUX = "DIB9";
	parameter DIB8MUX = "DIB8";
	parameter DIB7MUX = "DIB7";
	parameter DIB6MUX = "DIB6";
	parameter DIB5MUX = "DIB5";
	parameter DIB4MUX = "DIB4";
	parameter DIB3MUX = "DIB3";
	parameter DIB2MUX = "DIB2";
	parameter DIB1MUX = "DIB1";
	parameter DIB0MUX = "DIB0";
	parameter ADB13MUX = "ADB13";
	parameter ADB12MUX = "ADB12";
	parameter ADB11MUX = "ADB11";
	parameter ADB10MUX = "ADB10";
	parameter ADB9MUX = "ADB9";
	parameter ADB8MUX = "ADB8";
	parameter ADB7MUX = "ADB7";
	parameter ADB6MUX = "ADB6";
	parameter ADB5MUX = "ADB5";
	parameter ADB4MUX = "ADB4";
	parameter ADB3MUX = "ADB3";
	parameter ADB2MUX = "ADB2";
	parameter ADB1MUX = "ADB1";
	parameter ADB0MUX = "ADB0";
	parameter CEBMUX = "CEB";
	parameter OCEBMUX = "OCEB";
	parameter CLKBMUX = "CLKB";
	parameter WEBMUX = "WEB";
	parameter RSTBMUX = "RSTB";
	parameter CSB2MUX = "CSB2";
	parameter CSB1MUX = "CSB1";
	parameter CSB0MUX = "CSB0";
	parameter DOB17MUX = "DOB17";
	parameter DOB16MUX = "DOB16";
	parameter DOB15MUX = "DOB15";
	parameter DOB14MUX = "DOB14";
	parameter DOB13MUX = "DOB13";
	parameter DOB12MUX = "DOB12";
	parameter DOB11MUX = "DOB11";
	parameter DOB10MUX = "DOB10";
	parameter DOB9MUX = "DOB9";
	parameter DOB8MUX = "DOB8";
	parameter DOB7MUX = "DOB7";
	parameter DOB6MUX = "DOB6";
	parameter DOB5MUX = "DOB5";
	parameter DOB4MUX = "DOB4";
	parameter DOB3MUX = "DOB3";
	parameter DOB2MUX = "DOB2";
	parameter DOB1MUX = "DOB1";
	parameter DOB0MUX = "DOB0";

	parameter WID = 0;

	parameter GSR = "ENABLED";

	parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INIT_DATA = "STATIC";
endmodule

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18D _TECHMAP_REPLACE_ (
		.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),
		.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),
		.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),

		.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lutrams.txt":`ram distributed $__TRELLIS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init any;
	prune_rom;
	port sw "W" {
		clock anyedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__TRELLIS_DPR16X4_(...);

parameter INIT = 64'bx;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input [3:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

localparam WCKMUX = PORT_W_CLK_POL ? "WCK" : "INV";

TRELLIS_DPR16X4 #(
	.INITVAL(INIT),
	.WCKMUX(WCKMUX),
	.WREMUX("WRE")
) _TECHMAP_REPLACE_ (
	.RAD(PORT_R_ADDR),
	.DO(PORT_R_RD_DATA),

	.WAD(PORT_W_ADDR),
	.DI(PORT_W_WR_DATA),
	.WCK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);

endmodule
`},efinix:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_efinix_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH  = 1;
	parameter B_WIDTH  = 1;
	parameter Y_WIDTH  = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;
   
    wire CIx;
    (* force_downto *)
    wire [Y_WIDTH-1:0] COx;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = { COx, CIx };

    EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))
    adder_cin  (
        .I0(CI),
        .I1(1'b1),
        .CI(1'b0),
        .CO(CIx)
	);

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice
		EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))
		adder_i (
			.I0(AA[i]),
			.I1(BB[i]),
			.CI(C[i]),
			.O(Y[i]),
			.CO(COx[i])
		);
		EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))				
		adder_cout  (
			.I0(1'b0),
			.I1(1'b0),
			.CI(COx[i]),
			.O(CO[i])
		);
	  end: slice	  
	endgenerate

   /* End implementation */
   assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__EFINIX_5K_ {
	abits 12;
	widths 1 2 5 10 20 per_port;
	cost 32;
	init no_undef;
	port sr "R" {
		clock anyedge;
		rden;
	}
	port sw "W" {
		clock anyedge;
		option "WRITE_MODE" "READ_FIRST" {
			wrtrans "R" old;
		}
		option "WRITE_MODE" "WRITE_FIRST" {
			wrtrans "R" new;
		}
	}
}
`,"brams_map.v":`module $__EFINIX_5K_ (...);
	parameter INIT = 0;
	parameter OPTION_WRITE_MODE = "READ_FIRST";

	parameter PORT_R_WIDTH = 20;
	parameter PORT_R_CLK_POL = 1;
	parameter PORT_W_WIDTH = 20;
	parameter PORT_W_CLK_POL = 1;

	input PORT_R_CLK;
	input PORT_R_RD_EN;
	input [11:0] PORT_R_ADDR;
	output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

	input PORT_W_CLK;
	input PORT_W_WR_EN;
	input [11:0] PORT_W_ADDR;
	input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

	localparam IS_5BIT = PORT_R_WIDTH >= 5 && PORT_W_WIDTH >= 5;

	localparam RADDR_WIDTH =
		PORT_R_WIDTH == 1 ? 12 :
		PORT_R_WIDTH == 2 ? 11 :
		PORT_R_WIDTH == 5 ? 10 :
		PORT_R_WIDTH == 10 ? 9 :
		8;

	localparam WADDR_WIDTH =
		PORT_W_WIDTH == 1 ? 12 :
		PORT_W_WIDTH == 2 ? 11 :
		PORT_W_WIDTH == 5 ? 10 :
		PORT_W_WIDTH == 10 ? 9 :
		8;

	localparam READ_WIDTH = 
		PORT_R_WIDTH == 1 ? 1 :
		PORT_R_WIDTH == 2 ? 2 :
		PORT_R_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :
		PORT_R_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :
		(IS_5BIT ? 20 : 16);

	localparam WRITE_WIDTH = 
		PORT_W_WIDTH == 1 ? 1 :
		PORT_W_WIDTH == 2 ? 2 :
		PORT_W_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :
		PORT_W_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :
		(IS_5BIT ? 20 : 16);

	wire [RADDR_WIDTH-1:0] RADDR = PORT_R_ADDR[11:12-RADDR_WIDTH];
	wire [WADDR_WIDTH-1:0] WADDR = PORT_W_ADDR[11:12-WADDR_WIDTH];

	wire [WRITE_WIDTH-1:0] WDATA;
	wire [READ_WIDTH-1:0] RDATA;

	generate
		case (WRITE_WIDTH)
		1:	assign WDATA = PORT_W_WR_DATA;
		2:	assign WDATA = PORT_W_WR_DATA;
		4:	assign WDATA = PORT_W_WR_DATA[3:0];
		5:	assign WDATA = PORT_W_WR_DATA;
		8:	assign WDATA = {
			PORT_W_WR_DATA[8:5],
			PORT_W_WR_DATA[3:0]
		};
		10:	assign WDATA = PORT_W_WR_DATA;
		16:	assign WDATA = {
			PORT_W_WR_DATA[18:15],
			PORT_W_WR_DATA[13:10],
			PORT_W_WR_DATA[8:5],
			PORT_W_WR_DATA[3:0]
		};
		20:	assign WDATA = PORT_W_WR_DATA;
		endcase
		case (READ_WIDTH)
		1:	assign PORT_R_RD_DATA = RDATA;
		2:	assign PORT_R_RD_DATA = RDATA;
		4:	assign PORT_R_RD_DATA[3:0] = RDATA;
		5:	assign PORT_R_RD_DATA = RDATA;
		8:	assign {
			PORT_R_RD_DATA[8:5],
			PORT_R_RD_DATA[3:0]
		} = RDATA;
		10:	assign PORT_R_RD_DATA = RDATA;
		16:	assign {
			PORT_R_RD_DATA[18:15],
			PORT_R_RD_DATA[13:10],
			PORT_R_RD_DATA[8:5],
			PORT_R_RD_DATA[3:0]
		} = RDATA;
		20:	assign PORT_R_RD_DATA = RDATA;
		endcase
	endgenerate

	function [255:0] init_slice;
		input integer idx;
		integer i;
		if (IS_5BIT)
			init_slice = INIT[idx * 256 +: 256];
		else if (idx > 16)
			init_slice = 0;
		else
			for (i = 0; i < 64; i = i + 1)
				init_slice[i*4+:4] = INIT[(idx * 64 + i) * 5+:4];
	endfunction

	EFX_RAM_5K #(
		.READ_WIDTH(READ_WIDTH),
		.WRITE_WIDTH(WRITE_WIDTH),
		.OUTPUT_REG(1'b0),
		.RCLK_POLARITY(PORT_R_CLK_POL),
		.RE_POLARITY(1'b1),
		.WCLK_POLARITY(PORT_W_CLK_POL),
		.WE_POLARITY(1'b1),
		.WCLKE_POLARITY(1'b1),
		.WRITE_MODE(OPTION_WRITE_MODE),
		.INIT_0(init_slice('h00)),
		.INIT_1(init_slice('h01)),
		.INIT_2(init_slice('h02)),
		.INIT_3(init_slice('h03)),
		.INIT_4(init_slice('h04)),
		.INIT_5(init_slice('h05)),
		.INIT_6(init_slice('h06)),
		.INIT_7(init_slice('h07)),
		.INIT_8(init_slice('h08)),
		.INIT_9(init_slice('h09)),
		.INIT_A(init_slice('h0a)),
		.INIT_B(init_slice('h0b)),
		.INIT_C(init_slice('h0c)),
		.INIT_D(init_slice('h0d)),
		.INIT_E(init_slice('h0e)),
		.INIT_F(init_slice('h0f)),
		.INIT_10(init_slice('h10)),
		.INIT_11(init_slice('h11)),
		.INIT_12(init_slice('h12)),
		.INIT_13(init_slice('h13)),
	) _TECHMAP_REPLACE_ (
		.WDATA(WDATA),
		.WADDR(WADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
		.WCLKE(1'b1),
		.RDATA(RDATA),
		.RADDR(RADDR),
		.RE(PORT_R_RD_EN),
		.RCLK(PORT_R_CLK)
	);

endmodule
`,"cells_map.v":`(* techmap_celltype = "$_DFFE_[PN][PN][01][PN]_" *)
module  \\$_DFFE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b0),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b1)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

(* techmap_celltype = "$_SDFFE_[PN][PN][01][PN]_" *)
module  \\$_SDFFE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b1),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b1)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

(* techmap_celltype = "$_SDFFCE_[PN][PN][01][PN]_" *)
module  \\$_SDFFCE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b1),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b0)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(1'b0), .I2(1'b0), .I3(1'b0));
    end else
    if (WIDTH == 2) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(1'b0), .I3(1'b0));
    end else
    if (WIDTH == 3) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(1'b0));
    end else
    if (WIDTH == 4) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`module EFX_LUT4(
   output O, 
   input I0,
   input I1,
   input I2,
   input I3
);
	parameter LUTMASK = 16'h0000;

	wire [7:0] s3 = I3 ? LUTMASK[15:8] : LUTMASK[7:0];
	wire [3:0] s2 = I2 ?      s3[ 7:4] :      s3[3:0];
	wire [1:0] s1 = I1 ?      s2[ 3:2] :      s2[1:0];
	assign O = I0 ? s1[1] : s1[0];	   
endmodule

module EFX_ADD(
   output O,
   output CO,
   input I0,
   input I1,
   input CI
);
   parameter I0_POLARITY   = 1;
   parameter I1_POLARITY   = 1;

   wire i0;
   wire i1;

   assign i0 = I0_POLARITY ? I0 : ~I0;
   assign i1 = I1_POLARITY ? I1 : ~I1;

   assign {CO, O} = i0 + i1 + CI;
endmodule

module EFX_FF(
   output reg Q,
   input D,
   input CE,
   (* clkbuf_sink *)
   input CLK,
   input SR
);
   parameter CLK_POLARITY = 1;
   parameter CE_POLARITY = 1;
   parameter SR_POLARITY = 1;
   parameter SR_SYNC = 0;
   parameter SR_VALUE = 0;
   parameter SR_SYNC_PRIORITY = 0;
   parameter D_POLARITY = 1;

   wire clk;
   wire ce;
   wire sr;
   wire d;
   wire prio;
   wire sync;
   wire async;

   assign clk = CLK_POLARITY ? CLK : ~CLK;
   assign ce = CE_POLARITY ? CE : ~CE;
   assign sr = SR_POLARITY ? SR : ~SR;
   assign d = D_POLARITY ? D : ~D;

	initial Q = 1'b0;

   generate
   	if (SR_SYNC == 1) 
      begin
         if (SR_SYNC_PRIORITY == 1) 
         begin
            always @(posedge clk)
               if (sr)
                  Q <= SR_VALUE;
               else if (ce)
                  Q <= d;
         end
         else
         begin
            always @(posedge clk)
               if (ce)
               begin
                  if (sr)
                     Q <= SR_VALUE;
                  else
                     Q <= d;
               end
         end
      end
      else
      begin
         always @(posedge clk or posedge sr)
            if (sr)
               Q <= SR_VALUE;
            else if (ce)
               Q <= d;
         
      end
   endgenerate
endmodule

module EFX_GBUFCE(
   input CE,
   input I,
   (* clkbuf_driver *)
   output O
);
   parameter CE_POLARITY = 1'b1;

   wire ce;
   assign ce = CE_POLARITY ? CE : ~CE;
   
   assign O = I & ce;
   
endmodule

module EFX_RAM_5K
# (
   parameter READ_WIDTH = 20,
   parameter WRITE_WIDTH = 20,
   localparam READ_ADDR_WIDTH = 
			    (READ_WIDTH == 16) ? 8 :  // 256x16
			    (READ_WIDTH == 8)  ? 9 :  // 512x8
			    (READ_WIDTH == 4)  ? 10 : // 1024x4
			    (READ_WIDTH == 2)  ? 11 : // 2048x2
			    (READ_WIDTH == 1)  ? 12 : // 4096x1
			    (READ_WIDTH == 20) ? 8 :  // 256x20
			    (READ_WIDTH == 10) ? 9 :  // 512x10
			    (READ_WIDTH == 5)  ? 10 : -1, // 1024x5
   
   localparam WRITE_ADDR_WIDTH = 
			    (WRITE_WIDTH == 16) ? 8 :  // 256x16
			    (WRITE_WIDTH == 8)  ? 9 :  // 512x8
			    (WRITE_WIDTH == 4)  ? 10 : // 1024x4
			    (WRITE_WIDTH == 2)  ? 11 : // 2048x2
			    (WRITE_WIDTH == 1)  ? 12 : // 4096x1
			    (WRITE_WIDTH == 20) ? 8 :  // 256x20
			    (WRITE_WIDTH == 10) ? 9 :  // 512x10
			    (WRITE_WIDTH == 5)  ? 10 : -1 // 1024x5
)
(
   input [WRITE_WIDTH-1:0] WDATA,
   input [WRITE_ADDR_WIDTH-1:0] WADDR,
   input WE, 
   (* clkbuf_sink *)
   input WCLK,
   input WCLKE, 
   output [READ_WIDTH-1:0] RDATA, 
   input [READ_ADDR_WIDTH-1:0] RADDR,
   input RE, 
   (* clkbuf_sink *)
   input RCLK
);
   parameter OUTPUT_REG = 1'b0;
   parameter RCLK_POLARITY  = 1'b1;
   parameter RE_POLARITY    = 1'b1;
   parameter WCLK_POLARITY  = 1'b1;
   parameter WE_POLARITY    = 1'b1;
   parameter WCLKE_POLARITY = 1'b1;
   parameter WRITE_MODE = "READ_FIRST";
   parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule
`,"gbuf_map.v":`module \\$__EFX_GBUF (input I, output O);
  EFX_GBUFCE #(.CE_POLARITY(1'b1)) _TECHMAP_REPLACE_ (.I(I), .O(O), .CE(1'b1));
endmodule
`},fabulous:{"arith_map.v":`\`default_nettype none

\`ifdef ARITH_ha
(* techmap_celltype = "$alu" *)
module _80_fabulous_ha_alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

parameter _TECHMAP_CONSTMSK_CI_ = 0;
parameter _TECHMAP_CONSTVAL_CI_ = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
input CI, BI;
(* force_downto *)
output [Y_WIDTH-1:0] X, Y, CO;

(* force_downto *)
wire [Y_WIDTH-1:0] A_buf, B_buf;
\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

(* force_downto *)
wire [Y_WIDTH-1:0] AA = A_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
wire [Y_WIDTH:0] CARRY;


LUT4_HA #(
	.INIT(16'b0),
	.I0MUX(1'b1)
) carry_statrt (
	.I0(), .I1(CI), .I2(CI), .I3(),
	.Ci(),
	.Co(CARRY[0])
);

// Carry chain
genvar i;
generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
	LUT4_HA #(
		.INIT(16'b1001_0110_1001_0110), // full adder sum over (I2, I1, I0)
		.I0MUX(1'b1)
	) lut_i (
		.I0(), .I1(AA[i]), .I2(BB[i]), .I3(),
		.Ci(CARRY[i]),
		.O(Y[i]),
		.Co(CARRY[i+1])
	);

	assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
end endgenerate

assign X = AA ^ BB;

endmodule
\`endif

`,"cells_map.v":`module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));

    end else
    if (WIDTH == 2) begin
      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));

    end else
    if (WIDTH == 3) begin
      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));
    end else
    if (WIDTH == 4) begin
      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else
    if (WIDTH == 5) begin
      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]));
    end else
    if (WIDTH == 6) begin
      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]), .I5(A[5]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule

module  \\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule
`,"ff_map.v":`module  \\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q); LUTFF_E  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E)); endmodule

module  \\$_SDFF_PP0_ (input D, C, R, output Q); LUTFF_SR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .R(R)); endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); LUTFF_SS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .S(R)); endmodule

module  \\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); LUTFF_ESR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .R(R)); endmodule
module  \\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); LUTFF_ESS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .S(R)); endmodule
`,"io_map.v":`module \\$__FABULOUS_IBUF (input PAD, output O);
	IO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .O(O), .T(1'b1));
endmodule

module \\$__FABULOUS_OBUF (output PAD, input I);
	IO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .I(I), .T(1'b0));
endmodule

`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"prims.v":`module LUT1(output O, input I0);
  parameter [1:0] INIT = 0;
  assign O = I0 ? INIT[1] : INIT[0];
endmodule

module LUT2(output O, input I0, I1);
  parameter [3:0] INIT = 0;
  wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT3(output O, input I0, I1, I2);
  parameter [7:0] INIT = 0;
  wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT4(output O, input I0, I1, I2, I3);
  parameter [15:0] INIT = 0;
  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT4_HA(output O, Co, input I0, I1, I2, I3, Ci);
  parameter [15:0] INIT = 0;
  parameter I0MUX = 1'b1;

  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];

  wire I0_sel = I0MUX ? Ci : I0;
  assign O = I0_sel ? s1[1] : s1[0];

  assign Co = (Ci & I1) | (Ci & I2) | (I1 & I2);
endmodule

module LUT5(output O, input I0, I1, I2, I3, I4);
  parameter [31:0] INIT = 0;
  wire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];
  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT6(output O, input I0, I1, I2, I3, I4, I5);
  parameter [63:0] INIT = 0;
  wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];
  wire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];
  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT55_FCY (output O, Co, input I0, I1, I2, I3, I4, Ci);
  parameter [63:0] INIT = 0;

  wire comb1, comb2;

  LUT5 #(.INIT(INIT[31: 0])) l5_1 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb1));
  LUT5 #(.INIT(INIT[63:32])) l5_2 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb2));

  assign O = comb1 ^ Ci;
  assign Co = comb1 ? Ci : comb2;
endmodule


module LUTFF(input CLK, D, output reg O);
  initial O = 1'b0;
  always @ (posedge CLK) begin
    O <= D;
  end
endmodule

module FABULOUS_MUX2(input I0, I1, S0, output O);
  assign O = S0 ? I1 : I0;
endmodule

module FABULOUS_MUX4(input I0, I1, I2, I3, S0, S1, output O);
  wire A0 = S0 ? I1 : I0;
  wire A1 = S0 ? I3 : I2;
  assign O = S1 ? A1 : A0;
endmodule

module FABULOUS_MUX8(input I0, I1, I2, I3, I4, I5, I6, I7, S0, S1, S2, output O);
  wire A0 = S0 ? I1 : I0;
  wire A1 = S0 ? I3 : I2;
  wire A2 = S0 ? I5 : I4;
  wire A3 = S0 ? I7 : I6;
  wire B0 = S1 ? A1 : A0;
  wire B1 = S1 ? A3 : A2;
  assign O = S2 ? B1 : B0;
endmodule

module FABULOUS_LC #(
  parameter K = 4,
  parameter [2**K-1:0] INIT = 0,
  parameter DFF_ENABLE = 1'b0
) (
  input CLK,
  input [K-1:0] I,
  output O,
  output Q
);
  wire f_wire;
  
  //LUT #(.K(K), .INIT(INIT)) lut_i(.I(I), .Q(f_wire));
  generate
    if (K == 1) begin
      LUT1 #(.INIT(INIT)) lut1 (.O(f_wire), .I0(I[0]));
    end else
    if (K == 2) begin
      LUT2 #(.INIT(INIT)) lut2 (.O(f_wire), .I0(I[0]), .I1(I[1]));
    end else
    if (K == 3) begin
      LUT3 #(.INIT(INIT)) lut3 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]));
    end else
    if (K == 4) begin
      LUT4 #(.INIT(INIT)) lut4 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]), .I3(I[3]));
    end
  endgenerate
        
  LUTFF dff_i(.CLK(CLK), .D(f_wire), .Q(Q));

  assign O = f_wire;
endmodule

(* blackbox *)
module Global_Clock (output CLK);
\`ifndef SYNTHESIS
  initial CLK = 0;
  always #10 CLK = ~CLK;
\`endif
endmodule

(* blackbox, keep *)
module InPass4_frame_config (input CLK, output O0, O1, O2, O3);

endmodule


(* blackbox, keep *)
module OutPass4_frame_config (input CLK, I0, I1, I2, I3);

endmodule

(* keep *)
module IO_1_bidirectional_frame_config_pass (input CLK, T, I, output Q, O, (* iopad_external_pin *) inout PAD);
  assign PAD = T ? 1'bz : I;
  assign O = PAD;
  reg Q_q;
  always @(posedge CLK) Q_q <= O;
  assign Q = Q_q;
endmodule


module MULADD (A7, A6, A5, A4, A3, A2, A1, A0, B7, B6, B5, B4, B3, B2, B1, B0, C19, C18, C17, C16, C15, C14, C13, C12, C11, C10, C9, C8, C7, C6, C5, C4, C3, C2, C1, C0, Q19, Q18, Q17, Q16, Q15, Q14, Q13, Q12, Q11, Q10, Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, clr, CLK);
  parameter A_reg = 1'b0;
  parameter B_reg = 1'b0;
  parameter C_reg = 1'b0;
  parameter ACC = 1'b0;
  parameter signExtension = 1'b0;
  parameter ACCout = 1'b0;

  //parameter NoConfigBits = 6;// has to be adjusted manually (we don't use an arithmetic parser for the value)
  // IMPORTANT: this has to be in a dedicated line
  input A7;// operand A
  input A6;
  input A5;
  input A4;
  input A3;
  input A2;
  input A1;
  input A0;
  input B7;// operand B
  input B6;
  input B5;
  input B4;
  input B3;
  input B2;
  input B1;
  input B0;
  input C19;// operand C
  input C18;
  input C17;
  input C16;
  input C15;
  input C14;
  input C13;
  input C12;
  input C11;
  input C10;
  input C9;
  input C8;
  input C7;
  input C6;
  input C5;
  input C4;
  input C3;
  input C2;
  input C1;
  input C0;
  output Q19;// result
  output Q18;
  output Q17;
  output Q16;
  output Q15;
  output Q14;
  output Q13;
  output Q12;
  output Q11;
  output Q10;
  output Q9;
  output Q8;
  output Q7;
  output Q6;
  output Q5;
  output Q4;
  output Q3;
  output Q2;
  output Q1;
  output Q0;

  input clr;
  input CLK; // EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)
  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label


  wire [7:0] A;   // port A read data 
  wire [7:0] B;   // port B read data 
  wire [19:0] C;    // port B read data 
  reg [7:0] A_q;    // port A read data register
  reg [7:0] B_q;    // port B read data register
  reg [19:0] C_q;   // port B read data register
  wire [7:0] OPA;   // port A 
  wire [7:0] OPB;   // port B 
  wire [19:0] OPC;    // port B  
  reg [19:0] ACC_data ;    // accumulator register
  wire [19:0] sum;// port B read data register
  wire [19:0] sum_in;// port B read data register
  wire [15:0] product;
  wire [19:0] product_extended;

  assign A = {A7,A6,A5,A4,A3,A2,A1,A0};
  assign B = {B7,B6,B5,B4,B3,B2,B1,B0};
  assign C = {C19,C18,C17,C16,C15,C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1,C0};

  assign OPA = A_reg ? A_q : A;
  assign OPB = B_reg ? B_q : B;
  assign OPC = C_reg ? C_q : C;

  assign sum_in = ACC ? ACC_data : OPC;// we can

  assign product = OPA * OPB;

// The sign extension was not tested
  assign product_extended = signExtension ? {product[15],product[15],product[15],product[15],product} : {4'b0000,product};

  assign sum = product_extended + sum_in;

  assign Q19  = ACCout ? ACC_data[19] : sum[19];
  assign Q18  = ACCout ? ACC_data[18] : sum[18];
  assign Q17  = ACCout ? ACC_data[17] : sum[17];
  assign Q16  = ACCout ? ACC_data[16] : sum[16];
  assign Q15  = ACCout ? ACC_data[15] : sum[15];
  assign Q14  = ACCout ? ACC_data[14] : sum[14];
  assign Q13  = ACCout ? ACC_data[13] : sum[13];
  assign Q12  = ACCout ? ACC_data[12] : sum[12];
  assign Q11  = ACCout ? ACC_data[11] : sum[11];
  assign Q10  = ACCout ? ACC_data[10] : sum[10];
  assign Q9 = ACCout ? ACC_data[9] : sum[9];
  assign Q8 = ACCout ? ACC_data[8] : sum[8];
  assign Q7 = ACCout ? ACC_data[7] : sum[7];
  assign Q6 = ACCout ? ACC_data[6] : sum[6];
  assign Q5 = ACCout ? ACC_data[5] : sum[5];
  assign Q4 = ACCout ? ACC_data[4] : sum[4];
  assign Q3 = ACCout ? ACC_data[3] : sum[3];
  assign Q2 = ACCout ? ACC_data[2] : sum[2];
  assign Q1 = ACCout ? ACC_data[1] : sum[1];
  assign Q0 = ACCout ? ACC_data[0] : sum[0];

  always @ (posedge CLK)
  begin
    A_q <= A;
    B_q <= B;
    C_q <= C;
    if (clr == 1'b1) begin
      ACC_data <= 20'b00000000000000000000;
    end else begin
      ACC_data <= sum;
    end
  end

endmodule

module RegFile_32x4 (D0, D1, D2, D3, W_ADR0, W_ADR1, W_ADR2, W_ADR3, W_ADR4, W_en, AD0, AD1, AD2, AD3, A_ADR0, A_ADR1, A_ADR2, A_ADR3, A_ADR4, BD0, BD1, BD2, BD3, B_ADR0, B_ADR1, B_ADR2, B_ADR3, B_ADR4, CLK);
  //parameter NoConfigBits = 2;// has to be adjusted manually (we don't use an arithmetic parser for the value)
  parameter AD_reg = 1'b0;
  parameter BD_reg = 1'b0;
  // IMPORTANT: this has to be in a dedicated line
  input D0; // Register File write port
  input D1;
  input D2;
  input D3;
  input W_ADR0;
  input W_ADR1;
  input W_ADR2;
  input W_ADR3;
  input W_ADR4;
  input W_en;
  
  output AD0;// Register File read port A
  output AD1;
  output AD2;
  output AD3;
  input A_ADR0;
  input A_ADR1;
  input A_ADR2;
  input A_ADR3;
  input A_ADR4;

  output BD0;//Register File read port B
  output BD1;
  output BD2;
  output BD3;
  input B_ADR0;
  input B_ADR1;
  input B_ADR2;
  input B_ADR3;
  input B_ADR4;

  input CLK;// EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)
  
  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label
  

  //type memtype is array (31 downto 0) of std_logic_vector(3 downto 0); // 32 entries of 4 bit
  //signal mem : memtype := (others => (others => '0'));
  reg [3:0] mem [31:0];

  wire [4:0] W_ADR;// write address
  wire [4:0] A_ADR;// port A read address
  wire [4:0] B_ADR;// port B read address

  wire [3:0] D;   // write data
  wire [3:0] AD;    // port A read data
  wire [3:0] BD;    // port B read data

  reg [3:0] AD_q;   // port A read data register
  reg [3:0] BD_q;   // port B read data register
  
  integer i;

  assign W_ADR = {W_ADR4,W_ADR3,W_ADR2,W_ADR1,W_ADR0};
  assign A_ADR = {A_ADR4,A_ADR3,A_ADR2,A_ADR1,A_ADR0};
  assign B_ADR = {B_ADR4,B_ADR3,B_ADR2,B_ADR1,B_ADR0};

  assign D = {D3,D2,D1,D0};
  
  initial begin
    for (i=0; i<32; i=i+1) begin
      mem[i] = 4'b0000;
    end
  end

  always @ (posedge CLK) begin : P_write
    if (W_en == 1'b1) begin
      mem[W_ADR] <= D ;
    end
  end

  assign AD = mem[A_ADR];
  assign BD = mem[B_ADR];

  always @ (posedge CLK) begin
    AD_q <= AD;
    BD_q <= BD;
  end

  assign AD0 = AD_reg ? AD_q[0] : AD[0];
  assign AD1 = AD_reg ? AD_q[1] : AD[1];
  assign AD2 = AD_reg ? AD_q[2] : AD[2];
  assign AD3 = AD_reg ? AD_q[3] : AD[3];

  assign BD0 = BD_reg ? BD_q[0] : BD[0];
  assign BD1 = BD_reg ? BD_q[1] : BD[1];
  assign BD2 = BD_reg ? BD_q[2] : BD[2];
  assign BD3 = BD_reg ? BD_q[3] : BD[3];

endmodule

\`ifdef EQUIV
\`define COMPLEX_DFF
\`endif

\`ifdef COMPLEX_DFF
module LUTFF_E (
  output reg O,
  input CLK, E, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E)
      O <= D;
endmodule

module LUTFF_SR (
  output reg O,
  input CLK, R, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (R)
      O <= 0;
    else
      O <= D;
endmodule

module LUTFF_SS (
  output reg O,
  input CLK, S, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (S)
      O <= 1;
    else
      O <= D;
endmodule

module LUTFF_ESR (
  output reg O,
  input CLK, E, R, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E) begin
      if (R)
        O <= 0;
      else
        O <= D;
    end
endmodule

module LUTFF_ESS (
  output reg O,
  input CLK, E, S, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E) begin
      if (S)
        O <= 1;
      else
        O <= D;
    end
endmodule
\`endif // COMPLEX_DFF
`,"ram_regfile.txt":`# Yosys doesn't support configurable sync/async ports.
# So we define three RAMs for 2xasync, 1xsync 1xasync and 2xsync

ram distributed $__REGFILE_AA_ {
    abits 5;
    width 4;
    cost 6;
    port sw "W" {
        clock posedge "CLK";
    }
    port ar "A" {
    }
    port ar "B" {
    }
}

ram distributed $__REGFILE_SA_ {
    abits 5;
    width 4;
    cost 5;
    port sw "W" {
        clock posedge "CLK";
        wrtrans all old;
    }
    port sr "A" {
        clock posedge "CLK";
    }
    port ar "B" {
    }
}

ram distributed $__REGFILE_SS_ {
    abits 5;
    width 4;
    cost 4;
    port sw "W" {
        clock posedge "CLK";
        wrtrans all old;
    }
    port sr "A" {
        clock posedge "CLK";
    }
    port sr "B" {
        clock posedge "CLK";
    }
}
`,"regfile_map.v":`(* techmap_celltype = "$__REGFILE_[AS][AS]_" *)
module \\$__REGFILE_XX_ (...);

parameter _TECHMAP_CELLTYPE_ = "";
localparam [0:0] B_SYNC = _TECHMAP_CELLTYPE_[15:8] == "S";
localparam [0:0] A_SYNC = _TECHMAP_CELLTYPE_[23:16] == "S";

localparam WIDTH = 4;
localparam ABITS = 5;

input [WIDTH-1:0] PORT_W_WR_DATA;
input [ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;

output [WIDTH-1:0] PORT_A_RD_DATA;
input [ABITS-1:0] PORT_A_ADDR;

output [WIDTH-1:0] PORT_B_RD_DATA;
input [ABITS-1:0] PORT_B_ADDR;

// Unused - we have a shared clock - but keep techmap happy
input PORT_W_CLK;
input PORT_A_CLK;
input PORT_B_CLK;

input CLK_CLK;

RegFile_32x4 #(
	.AD_reg(A_SYNC),
	.BD_reg(B_SYNC)
) _TECHMAP_REPLACE_ (
	.D0(PORT_W_WR_DATA[0]), .D1(PORT_W_WR_DATA[1]), .D2(PORT_W_WR_DATA[2]), .D3(PORT_W_WR_DATA[3]),
	.W_ADR0(PORT_W_ADDR[0]), .W_ADR1(PORT_W_ADDR[1]), .W_ADR2(PORT_W_ADDR[2]), .W_ADR3(PORT_W_ADDR[3]), .W_ADR4(PORT_W_ADDR[4]),
	.W_en(PORT_W_WR_EN),
	.AD0(PORT_A_RD_DATA[0]), .AD1(PORT_A_RD_DATA[1]), .AD2(PORT_A_RD_DATA[2]), .AD3(PORT_A_RD_DATA[3]),
	.A_ADR0(PORT_A_ADDR[0]), .A_ADR1(PORT_A_ADDR[1]), .A_ADR2(PORT_A_ADDR[2]), .A_ADR3(PORT_A_ADDR[3]), .A_ADR4(PORT_A_ADDR[4]),
	.BD0(PORT_B_RD_DATA[0]), .BD1(PORT_B_RD_DATA[1]), .BD2(PORT_B_RD_DATA[2]), .BD3(PORT_B_RD_DATA[3]),
	.B_ADR0(PORT_B_ADDR[0]), .B_ADR1(PORT_B_ADDR[1]), .B_ADR2(PORT_B_ADDR[2]), .B_ADR3(PORT_B_ADDR[3]), .B_ADR4(PORT_B_ADDR[4]),
	.CLK(CLK_CLK)
);

endmodule
`},"gate2lut.v":`(* techmap_celltype = "$_NOT_" *)
module _90_lut_not (A, Y);
    input A;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b01)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_OR_" *)
module _90_lut_or (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b1110)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_AND_" *)
module _90_lut_and (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b1000)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_XOR_" *)
module _90_lut_xor (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b0110)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_MUX_" *)
module _90_lut_mux (A, B, S, Y);
    input A, B, S;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {S, B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        //     A 1010 1010
        //     B 1100 1100
        //     S 1111 0000
        .LUT(8'b 1100_1010)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule
`,gatemate:{"arith_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* techmap_celltype = "$alu" *)\r
module _80_gatemate_alu(A, B, CI, BI, X, Y, CO);\r
	parameter A_SIGNED = 0;\r
	parameter B_SIGNED = 0;\r
	parameter A_WIDTH = 1;\r
	parameter B_WIDTH = 1;\r
	parameter Y_WIDTH = 1;\r
\r
	(* force_downto *)\r
	input [A_WIDTH-1:0] A;\r
	(* force_downto *)\r
	input [B_WIDTH-1:0] B;\r
	(* force_downto *)\r
	output [Y_WIDTH-1:0] X, Y;\r
\r
	input CI, BI;\r
	(* force_downto *)\r
	output [Y_WIDTH-1:0] CO;\r
\r
	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\r
\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] A_buf, B_buf;\r
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\r
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\r
\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] AA = A_buf;\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] C = {CO, CI};\r
\r
	genvar i;\r
	generate\r
		for (i = 0; i < Y_WIDTH; i = i + 1)\r
		begin: slice\r
			CC_ADDF addf_i (\r
				.A(AA[i]),\r
				.B(BB[i]),\r
				.CI(C[i]),\r
				.CO(CO[i]),\r
				.S(Y[i])\r
			);\r
		end\r
	endgenerate\r
\r
	assign X = AA ^ BB;\r
\r
endmodule\r
`,"brams.txt":`ram block $__CC_BRAM_TDP_ {
	option "MODE" "20K" {
		abits 14;
		widths 1 2 5 10 20 per_port;
		cost 129;
	}
	option "MODE" "40K" {
		abits 15;
		widths 1 2 5 10 20 40 per_port;
		cost 257;
	}
	option "MODE" "CASCADE" {
		abits 16;
		# hack to enforce same INIT layout as in the other modes
		widths 1 2 5 per_port;
		cost 513;
	}
	byte 1;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		option "MODE" "20K" {
			width mix;
		}
		option "MODE" "40K" {
			width mix;
		}
		option "MODE" "CASCADE" {
			width mix 1;
		}
		portoption "WR_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WR_MODE" "WRITE_THROUGH" {
			rdwr new;
		}
		wrbe_separate;
		optional_rw;
	}
}

ram block $__CC_BRAM_SDP_ {
	option "MODE" "20K" {
		abits 14;
		widths 1 2 5 10 20 40 per_port;
		cost 129;
	}
	option "MODE" "40K" {
		abits 15;
		widths 1 2 5 10 20 40 80 per_port;
		cost 257;
	}
	byte 1;
	init no_undef;
	port sr "R" {
		option "MODE" "20K" {
			width 40;
		}
		option "MODE" "40K" {
			width 80;
		}
		clock anyedge;
		clken;
		optional;
	}
	port sw "W" {
		option "MODE" "20K" {
			width 40;
		}
		option "MODE" "40K" {
			width 80;
		}
		clock anyedge;
		clken;
		wrbe_separate;
		optional;
	}
}
`,"brams_init_20.vh":`.INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
`,"brams_init_40.vh":`\`ifdef INIT_LOWER
.INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_40(permute_init(INIT[ 64*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_41(permute_init(INIT[ 65*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_42(permute_init(INIT[ 66*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_43(permute_init(INIT[ 67*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_44(permute_init(INIT[ 68*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_45(permute_init(INIT[ 69*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_46(permute_init(INIT[ 70*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_47(permute_init(INIT[ 71*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_48(permute_init(INIT[ 72*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_49(permute_init(INIT[ 73*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4A(permute_init(INIT[ 74*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4B(permute_init(INIT[ 75*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4C(permute_init(INIT[ 76*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4D(permute_init(INIT[ 77*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4E(permute_init(INIT[ 78*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4F(permute_init(INIT[ 79*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_50(permute_init(INIT[ 80*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_51(permute_init(INIT[ 81*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_52(permute_init(INIT[ 82*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_53(permute_init(INIT[ 83*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_54(permute_init(INIT[ 84*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_55(permute_init(INIT[ 85*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_56(permute_init(INIT[ 86*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_57(permute_init(INIT[ 87*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_58(permute_init(INIT[ 88*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_59(permute_init(INIT[ 89*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5A(permute_init(INIT[ 90*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5B(permute_init(INIT[ 91*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5C(permute_init(INIT[ 92*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5D(permute_init(INIT[ 93*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5E(permute_init(INIT[ 94*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5F(permute_init(INIT[ 95*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_60(permute_init(INIT[ 96*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_61(permute_init(INIT[ 97*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_62(permute_init(INIT[ 98*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_63(permute_init(INIT[ 99*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_64(permute_init(INIT[100*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_65(permute_init(INIT[101*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_66(permute_init(INIT[102*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_67(permute_init(INIT[103*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_68(permute_init(INIT[104*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_69(permute_init(INIT[105*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6A(permute_init(INIT[106*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6B(permute_init(INIT[107*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6C(permute_init(INIT[108*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6D(permute_init(INIT[109*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6E(permute_init(INIT[110*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6F(permute_init(INIT[111*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_70(permute_init(INIT[112*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_71(permute_init(INIT[113*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_72(permute_init(INIT[114*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_73(permute_init(INIT[115*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_74(permute_init(INIT[116*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_75(permute_init(INIT[117*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_76(permute_init(INIT[118*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_77(permute_init(INIT[119*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_78(permute_init(INIT[120*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_79(permute_init(INIT[121*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7A(permute_init(INIT[122*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7B(permute_init(INIT[123*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7C(permute_init(INIT[124*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7D(permute_init(INIT[125*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7E(permute_init(INIT[126*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7F(permute_init(INIT[127*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
\`endif
\`ifdef INIT_UPPER
.INIT_00(permute_init(INIT[128*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[129*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[130*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[131*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[132*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[133*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[134*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[135*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[136*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[137*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[138*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[139*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[140*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[141*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[142*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[143*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[144*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[145*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[146*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[147*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[148*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[149*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[150*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[151*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[152*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[153*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[154*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[155*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[156*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[157*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[158*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[159*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[160*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[161*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[162*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[163*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[164*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[165*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[166*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[167*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[168*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[169*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[170*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[171*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[172*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[173*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[174*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[175*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[176*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[177*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[178*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[179*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[180*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[181*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[182*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[183*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[184*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[185*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[186*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[187*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[188*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[189*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[190*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[191*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_40(permute_init(INIT[192*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_41(permute_init(INIT[193*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_42(permute_init(INIT[194*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_43(permute_init(INIT[195*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_44(permute_init(INIT[196*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_45(permute_init(INIT[197*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_46(permute_init(INIT[198*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_47(permute_init(INIT[199*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_48(permute_init(INIT[200*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_49(permute_init(INIT[201*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4A(permute_init(INIT[202*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4B(permute_init(INIT[203*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4C(permute_init(INIT[204*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4D(permute_init(INIT[205*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4E(permute_init(INIT[206*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4F(permute_init(INIT[207*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_50(permute_init(INIT[208*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_51(permute_init(INIT[209*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_52(permute_init(INIT[210*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_53(permute_init(INIT[211*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_54(permute_init(INIT[212*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_55(permute_init(INIT[213*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_56(permute_init(INIT[214*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_57(permute_init(INIT[215*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_58(permute_init(INIT[216*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_59(permute_init(INIT[217*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5A(permute_init(INIT[218*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5B(permute_init(INIT[219*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5C(permute_init(INIT[220*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5D(permute_init(INIT[221*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5E(permute_init(INIT[222*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5F(permute_init(INIT[223*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_60(permute_init(INIT[224*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_61(permute_init(INIT[225*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_62(permute_init(INIT[226*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_63(permute_init(INIT[227*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_64(permute_init(INIT[228*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_65(permute_init(INIT[229*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_66(permute_init(INIT[230*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_67(permute_init(INIT[231*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_68(permute_init(INIT[232*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_69(permute_init(INIT[233*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6A(permute_init(INIT[234*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6B(permute_init(INIT[235*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6C(permute_init(INIT[236*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6D(permute_init(INIT[237*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6E(permute_init(INIT[238*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6F(permute_init(INIT[239*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_70(permute_init(INIT[240*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_71(permute_init(INIT[241*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_72(permute_init(INIT[242*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_73(permute_init(INIT[243*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_74(permute_init(INIT[244*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_75(permute_init(INIT[245*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_76(permute_init(INIT[246*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_77(permute_init(INIT[247*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_78(permute_init(INIT[248*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_79(permute_init(INIT[249*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7A(permute_init(INIT[250*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7B(permute_init(INIT[251*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7C(permute_init(INIT[252*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7D(permute_init(INIT[253*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7E(permute_init(INIT[254*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7F(permute_init(INIT[255*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
\`endif
`,"brams_map.v":`module $__CC_BRAM_TDP_(...);\r
\r
parameter INIT = 0;\r
parameter OPTION_MODE = "20K";\r
\r
parameter PORT_A_CLK_POL = 1;\r
parameter PORT_A_RD_USED = 1;\r
parameter PORT_A_WR_USED = 1;\r
parameter PORT_A_RD_WIDTH = 1;\r
parameter PORT_A_WR_WIDTH = 1;\r
parameter PORT_A_WR_BE_WIDTH = 1;\r
parameter PORT_A_OPTION_WR_MODE = "NO_CHANGE";\r
\r
parameter PORT_B_CLK_POL = 1;\r
parameter PORT_B_RD_USED = 1;\r
parameter PORT_B_WR_USED = 1;\r
parameter PORT_B_RD_WIDTH = 1;\r
parameter PORT_B_WR_WIDTH = 1;\r
parameter PORT_B_WR_BE_WIDTH = 1;\r
parameter PORT_B_OPTION_WR_MODE = "NO_CHANGE";\r
\r
input PORT_A_CLK;\r
input PORT_A_CLK_EN;\r
input PORT_A_WR_EN;\r
input [15:0] PORT_A_ADDR;\r
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\r
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\r
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\r
\r
input PORT_B_CLK;\r
input PORT_B_CLK_EN;\r
input PORT_B_WR_EN;\r
input [15:0] PORT_B_ADDR;\r
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\r
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\r
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\r
\r
generate\r
	if (OPTION_MODE == "20K") begin\r
		CC_BRAM_20K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM({{(20-PORT_A_WR_BE_WIDTH){1'bx}}, PORT_A_WR_BE}),\r
			.A_DI({{(20-PORT_A_WR_WIDTH){1'bx}}, PORT_A_WR_DATA}),\r
			.A_ADDR({PORT_A_ADDR[13:5], 1'b0, PORT_A_ADDR[4:0], 1'b0}),\r
			.A_DO(PORT_A_RD_DATA),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM({{(20-PORT_B_WR_BE_WIDTH){1'bx}}, PORT_B_WR_BE}),\r
			.B_DI({{(20-PORT_B_WR_WIDTH){1'bx}}, PORT_B_WR_DATA}),\r
			.B_ADDR({PORT_B_ADDR[13:5], 1'b0, PORT_B_ADDR[4:0], 1'b0}),\r
			.B_DO(PORT_B_RD_DATA),\r
		);\r
	end else if (OPTION_MODE == "40K") begin\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM({{(40-PORT_A_WR_BE_WIDTH){1'bx}}, PORT_A_WR_BE}),\r
			.A_DI({{(40-PORT_A_WR_WIDTH){1'bx}}, PORT_A_WR_DATA}),\r
			.A_ADDR({PORT_A_ADDR[14:0], 1'b0}),\r
			.A_DO(PORT_A_RD_DATA),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM({{(40-PORT_B_WR_BE_WIDTH){1'bx}}, PORT_B_WR_BE}),\r
			.B_DI({{(40-PORT_B_WR_WIDTH){1'bx}}, PORT_B_WR_DATA}),\r
			.B_ADDR({PORT_B_ADDR[14:0], 1'b0}),\r
			.B_DO(PORT_B_RD_DATA),\r
		);\r
	end else begin\r
		wire CAS_A, CAS_B;\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
			.CAS("LOWER"),\r
		) lower (\r
			.A_CO(CAS_A),\r
			.B_CO(CAS_B),\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM({{(40-PORT_A_WR_BE_WIDTH){1'bx}}, PORT_A_WR_BE}),\r
			.A_DI({{(40-PORT_A_WR_WIDTH){1'bx}}, PORT_A_WR_DATA}),\r
			.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM({{(40-PORT_B_WR_BE_WIDTH){1'bx}}, PORT_B_WR_BE}),\r
			.B_DI({{(40-PORT_B_WR_WIDTH){1'bx}}, PORT_B_WR_DATA}),\r
			.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\r
		);\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h80*320+:320]),\r
			.INIT_01(INIT['h81*320+:320]),\r
			.INIT_02(INIT['h82*320+:320]),\r
			.INIT_03(INIT['h83*320+:320]),\r
			.INIT_04(INIT['h84*320+:320]),\r
			.INIT_05(INIT['h85*320+:320]),\r
			.INIT_06(INIT['h86*320+:320]),\r
			.INIT_07(INIT['h87*320+:320]),\r
			.INIT_08(INIT['h88*320+:320]),\r
			.INIT_09(INIT['h89*320+:320]),\r
			.INIT_0A(INIT['h8a*320+:320]),\r
			.INIT_0B(INIT['h8b*320+:320]),\r
			.INIT_0C(INIT['h8c*320+:320]),\r
			.INIT_0D(INIT['h8d*320+:320]),\r
			.INIT_0E(INIT['h8e*320+:320]),\r
			.INIT_0F(INIT['h8f*320+:320]),\r
			.INIT_10(INIT['h90*320+:320]),\r
			.INIT_11(INIT['h91*320+:320]),\r
			.INIT_12(INIT['h92*320+:320]),\r
			.INIT_13(INIT['h93*320+:320]),\r
			.INIT_14(INIT['h94*320+:320]),\r
			.INIT_15(INIT['h95*320+:320]),\r
			.INIT_16(INIT['h96*320+:320]),\r
			.INIT_17(INIT['h97*320+:320]),\r
			.INIT_18(INIT['h98*320+:320]),\r
			.INIT_19(INIT['h99*320+:320]),\r
			.INIT_1A(INIT['h9a*320+:320]),\r
			.INIT_1B(INIT['h9b*320+:320]),\r
			.INIT_1C(INIT['h9c*320+:320]),\r
			.INIT_1D(INIT['h9d*320+:320]),\r
			.INIT_1E(INIT['h9e*320+:320]),\r
			.INIT_1F(INIT['h9f*320+:320]),\r
			.INIT_20(INIT['ha0*320+:320]),\r
			.INIT_21(INIT['ha1*320+:320]),\r
			.INIT_22(INIT['ha2*320+:320]),\r
			.INIT_23(INIT['ha3*320+:320]),\r
			.INIT_24(INIT['ha4*320+:320]),\r
			.INIT_25(INIT['ha5*320+:320]),\r
			.INIT_26(INIT['ha6*320+:320]),\r
			.INIT_27(INIT['ha7*320+:320]),\r
			.INIT_28(INIT['ha8*320+:320]),\r
			.INIT_29(INIT['ha9*320+:320]),\r
			.INIT_2A(INIT['haa*320+:320]),\r
			.INIT_2B(INIT['hab*320+:320]),\r
			.INIT_2C(INIT['hac*320+:320]),\r
			.INIT_2D(INIT['had*320+:320]),\r
			.INIT_2E(INIT['hae*320+:320]),\r
			.INIT_2F(INIT['haf*320+:320]),\r
			.INIT_30(INIT['hb0*320+:320]),\r
			.INIT_31(INIT['hb1*320+:320]),\r
			.INIT_32(INIT['hb2*320+:320]),\r
			.INIT_33(INIT['hb3*320+:320]),\r
			.INIT_34(INIT['hb4*320+:320]),\r
			.INIT_35(INIT['hb5*320+:320]),\r
			.INIT_36(INIT['hb6*320+:320]),\r
			.INIT_37(INIT['hb7*320+:320]),\r
			.INIT_38(INIT['hb8*320+:320]),\r
			.INIT_39(INIT['hb9*320+:320]),\r
			.INIT_3A(INIT['hba*320+:320]),\r
			.INIT_3B(INIT['hbb*320+:320]),\r
			.INIT_3C(INIT['hbc*320+:320]),\r
			.INIT_3D(INIT['hbd*320+:320]),\r
			.INIT_3E(INIT['hbe*320+:320]),\r
			.INIT_3F(INIT['hbf*320+:320]),\r
			.INIT_40(INIT['hc0*320+:320]),\r
			.INIT_41(INIT['hc1*320+:320]),\r
			.INIT_42(INIT['hc2*320+:320]),\r
			.INIT_43(INIT['hc3*320+:320]),\r
			.INIT_44(INIT['hc4*320+:320]),\r
			.INIT_45(INIT['hc5*320+:320]),\r
			.INIT_46(INIT['hc6*320+:320]),\r
			.INIT_47(INIT['hc7*320+:320]),\r
			.INIT_48(INIT['hc8*320+:320]),\r
			.INIT_49(INIT['hc9*320+:320]),\r
			.INIT_4A(INIT['hca*320+:320]),\r
			.INIT_4B(INIT['hcb*320+:320]),\r
			.INIT_4C(INIT['hcc*320+:320]),\r
			.INIT_4D(INIT['hcd*320+:320]),\r
			.INIT_4E(INIT['hce*320+:320]),\r
			.INIT_4F(INIT['hcf*320+:320]),\r
			.INIT_50(INIT['hd0*320+:320]),\r
			.INIT_51(INIT['hd1*320+:320]),\r
			.INIT_52(INIT['hd2*320+:320]),\r
			.INIT_53(INIT['hd3*320+:320]),\r
			.INIT_54(INIT['hd4*320+:320]),\r
			.INIT_55(INIT['hd5*320+:320]),\r
			.INIT_56(INIT['hd6*320+:320]),\r
			.INIT_57(INIT['hd7*320+:320]),\r
			.INIT_58(INIT['hd8*320+:320]),\r
			.INIT_59(INIT['hd9*320+:320]),\r
			.INIT_5A(INIT['hda*320+:320]),\r
			.INIT_5B(INIT['hdb*320+:320]),\r
			.INIT_5C(INIT['hdc*320+:320]),\r
			.INIT_5D(INIT['hdd*320+:320]),\r
			.INIT_5E(INIT['hde*320+:320]),\r
			.INIT_5F(INIT['hdf*320+:320]),\r
			.INIT_60(INIT['he0*320+:320]),\r
			.INIT_61(INIT['he1*320+:320]),\r
			.INIT_62(INIT['he2*320+:320]),\r
			.INIT_63(INIT['he3*320+:320]),\r
			.INIT_64(INIT['he4*320+:320]),\r
			.INIT_65(INIT['he5*320+:320]),\r
			.INIT_66(INIT['he6*320+:320]),\r
			.INIT_67(INIT['he7*320+:320]),\r
			.INIT_68(INIT['he8*320+:320]),\r
			.INIT_69(INIT['he9*320+:320]),\r
			.INIT_6A(INIT['hea*320+:320]),\r
			.INIT_6B(INIT['heb*320+:320]),\r
			.INIT_6C(INIT['hec*320+:320]),\r
			.INIT_6D(INIT['hed*320+:320]),\r
			.INIT_6E(INIT['hee*320+:320]),\r
			.INIT_6F(INIT['hef*320+:320]),\r
			.INIT_70(INIT['hf0*320+:320]),\r
			.INIT_71(INIT['hf1*320+:320]),\r
			.INIT_72(INIT['hf2*320+:320]),\r
			.INIT_73(INIT['hf3*320+:320]),\r
			.INIT_74(INIT['hf4*320+:320]),\r
			.INIT_75(INIT['hf5*320+:320]),\r
			.INIT_76(INIT['hf6*320+:320]),\r
			.INIT_77(INIT['hf7*320+:320]),\r
			.INIT_78(INIT['hf8*320+:320]),\r
			.INIT_79(INIT['hf9*320+:320]),\r
			.INIT_7A(INIT['hfa*320+:320]),\r
			.INIT_7B(INIT['hfb*320+:320]),\r
			.INIT_7C(INIT['hfc*320+:320]),\r
			.INIT_7D(INIT['hfd*320+:320]),\r
			.INIT_7E(INIT['hfe*320+:320]),\r
			.INIT_7F(INIT['hff*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
			.CAS("UPPER"),\r
		) upper (\r
			.A_CI(CAS_A),\r
			.B_CI(CAS_B),\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM({{(40-PORT_A_WR_BE_WIDTH){1'bx}}, PORT_A_WR_BE}),\r
			.A_DI({{(40-PORT_A_WR_WIDTH){1'bx}}, PORT_A_WR_DATA}),\r
			.A_DO(PORT_A_RD_DATA),\r
			.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM({{(40-PORT_B_WR_BE_WIDTH){1'bx}}, PORT_B_WR_BE}),\r
			.B_DI({{(40-PORT_B_WR_WIDTH){1'bx}}, PORT_B_WR_DATA}),\r
			.B_DO(PORT_B_RD_DATA),\r
			.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\r
		);\r
	end\r
endgenerate\r
\r
endmodule\r
\r
\r
module $__CC_BRAM_SDP_(...);\r
\r
parameter INIT = 0;\r
parameter OPTION_MODE = "20K";\r
parameter OPTION_WR_MODE = "NO_CHANGE";\r
\r
parameter PORT_W_CLK_POL = 1;\r
parameter PORT_W_USED = 1;\r
parameter PORT_W_WIDTH = 40;\r
parameter PORT_W_WR_BE_WIDTH = 40;\r
\r
parameter PORT_R_CLK_POL = 1;\r
parameter PORT_R_USED = 1;\r
parameter PORT_R_WIDTH = 40;\r
\r
input PORT_W_CLK;\r
input PORT_W_CLK_EN;\r
input PORT_W_WR_EN;\r
input [15:0] PORT_W_ADDR;\r
input [PORT_W_WR_BE_WIDTH-1:0] PORT_W_WR_BE;\r
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\r
\r
input PORT_R_CLK;\r
input PORT_R_CLK_EN;\r
input [15:0] PORT_R_ADDR;\r
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\r
\r
generate\r
	if (OPTION_MODE == "20K") begin\r
		CC_BRAM_20K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.A_RD_WIDTH(0),\r
			.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\r
			.B_WR_WIDTH(0),\r
			.RAM_MODE("SDP"),\r
			.A_WR_MODE(OPTION_WR_MODE),\r
			.B_WR_MODE(OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_W_CLK_POL),\r
			.B_CLK_INV(!PORT_R_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_W_CLK),\r
			.A_EN(PORT_W_CLK_EN),\r
			.A_WE(PORT_W_WR_EN),\r
			.A_BM(PORT_W_WR_BE[19:0]),\r
			.B_BM({{(40-PORT_W_WIDTH){1'bx}}, PORT_W_WR_BE[39:20]}),\r
			.A_DI(PORT_W_WR_DATA[19:0]),\r
			.B_DI({{(40-PORT_W_WIDTH){1'bx}}, PORT_W_WR_DATA[39:20]}),\r
			.A_ADDR({PORT_W_ADDR[13:5], 1'b0, PORT_W_ADDR[4:0], 1'b0}),\r
			.B_CLK(PORT_R_CLK),\r
			.B_EN(PORT_R_CLK_EN),\r
			.B_WE(1'b0),\r
			.B_ADDR({PORT_R_ADDR[13:5], 1'b0, PORT_R_ADDR[4:0], 1'b0}),\r
			.A_DO(PORT_R_RD_DATA[19:0]),\r
			.B_DO(PORT_R_RD_DATA[39:20]),\r
		);\r
	end else if (OPTION_MODE == "40K") begin\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(0),\r
			.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\r
			.B_WR_WIDTH(0),\r
			.RAM_MODE("SDP"),\r
			.A_WR_MODE(OPTION_WR_MODE),\r
			.B_WR_MODE(OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_W_CLK_POL),\r
			.B_CLK_INV(!PORT_R_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_W_CLK),\r
			.A_EN(PORT_W_CLK_EN),\r
			.A_WE(PORT_W_WR_EN),\r
			.A_BM(PORT_W_WR_BE[39:0]),\r
			.B_BM({{(80-PORT_W_WIDTH){1'bx}}, PORT_W_WR_BE[79:40]}),\r
			.A_DI(PORT_W_WR_DATA[39:0]),\r
			.B_DI({{(80-PORT_W_WIDTH){1'bx}}, PORT_W_WR_DATA[79:40]}),\r
			.A_ADDR({PORT_W_ADDR[14:0], 1'b0}),\r
			.B_CLK(PORT_R_CLK),\r
			.B_EN(PORT_R_CLK_EN),\r
			.B_WE(1'b0),\r
			.B_ADDR({PORT_R_ADDR[14:0], 1'b0}),\r
			.A_DO(PORT_R_RD_DATA[39:0]),\r
			.B_DO(PORT_R_RD_DATA[79:40]),\r
		);\r
	end\r
endgenerate\r
\r
endmodule\r
`,"cells_bb.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* blackbox *)\r
module CC_PLL #(\r
	parameter REF_CLK = "", // e.g. "10.0"\r
	parameter OUT_CLK = "", // e.g. "50.0"\r
	parameter PERF_MD = "", // LOWPOWER, ECONOMY, SPEED\r
	parameter LOCK_REQ = 1,\r
	parameter CLK270_DOUB = 0,\r
	parameter CLK180_DOUB = 0,\r
	parameter LOW_JITTER = 1,\r
	parameter CI_FILTER_CONST = 2,\r
	parameter CP_FILTER_CONST = 4\r
)(\r
	input  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\r
	input  USR_LOCKED_STDY_RST,\r
	output USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\r
	output CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\r
);\r
endmodule\r
\r
(* blackbox *)\r
module CC_PLL_ADV #(\r
	parameter [95:0] PLL_CFG_A = 96'bx,\r
	parameter [95:0] PLL_CFG_B = 96'bx\r
)(\r
	input  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\r
	input  USR_LOCKED_STDY_RST, USR_SEL_A_B,\r
	output USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\r
	output CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_SERDES #(\r
	parameter  [4:0] RX_BUF_RESET_TIME = 3,\r
	parameter  [4:0] RX_PCS_RESET_TIME = 3,\r
	parameter  [4:0] RX_RESET_TIMER_PRESC = 0,\r
	parameter  [0:0] RX_RESET_DONE_GATE = 0,\r
	parameter  [4:0] RX_CDR_RESET_TIME = 3,\r
	parameter  [4:0] RX_EQA_RESET_TIME = 3,\r
	parameter  [4:0] RX_PMA_RESET_TIME = 3,\r
	parameter  [0:0] RX_WAIT_CDR_LOCK = 1,\r
	parameter  [0:0] RX_CALIB_EN = 0,\r
	parameter  [0:0] RX_CALIB_OVR = 0,\r
	parameter  [3:0] RX_CALIB_VAL = 0,\r
	parameter  [2:0] RX_RTERM_VCMSEL = 4,\r
	parameter  [0:0] RX_RTERM_PD = 0,\r
	parameter  [7:0] RX_EQA_CKP_LF = 8'hA3,\r
	parameter  [7:0] RX_EQA_CKP_HF = 8'hA3,\r
	parameter  [7:0] RX_EQA_CKP_OFFSET = 8'h01,\r
	parameter  [0:0] RX_EN_EQA = 0,\r
	parameter  [3:0] RX_EQA_LOCK_CFG = 0,\r
	parameter  [4:0] RX_TH_MON1 = 8,\r
	parameter  [3:0] RX_EN_EQA_EXT_VALUE = 0,\r
	parameter  [4:0] RX_TH_MON2 = 8,\r
	parameter  [4:0] RX_TAPW = 8,\r
	parameter  [4:0] RX_AFE_OFFSET = 8,\r
	parameter [15:0] RX_EQA_CONFIG = 16'h01C0,\r
	parameter  [4:0] RX_AFE_PEAK = 16,\r
	parameter  [3:0] RX_AFE_GAIN = 8,\r
	parameter  [2:0] RX_AFE_VCMSEL = 4,\r
	parameter  [7:0] RX_CDR_CKP = 8'hF8,\r
	parameter  [7:0] RX_CDR_CKI = 0,\r
	parameter  [8:0] RX_CDR_TRANS_TH = 128,\r
	parameter  [5:0] RX_CDR_LOCK_CFG = 8'h0B,\r
	parameter [14:0] RX_CDR_FREQ_ACC = 0,\r
	parameter [15:0] RX_CDR_PHASE_ACC = 0,\r
	parameter  [1:0] RX_CDR_SET_ACC_CONFIG = 0,\r
	parameter  [0:0] RX_CDR_FORCE_LOCK = 0,\r
	parameter  [9:0] RX_ALIGN_MCOMMA_VALUE = 10'h283,\r
	parameter  [0:0] RX_MCOMMA_ALIGN_OVR = 0,\r
	parameter  [0:0] RX_MCOMMA_ALIGN = 0,\r
	parameter  [9:0] RX_ALIGN_PCOMMA_VALUE = 10'h17C,\r
	parameter  [0:0] RX_PCOMMA_ALIGN_OVR = 0,\r
	parameter  [0:0] RX_PCOMMA_ALIGN = 0,\r
	parameter  [1:0] RX_ALIGN_COMMA_WORD = 0,\r
	parameter  [9:0] RX_ALIGN_COMMA_ENABLE = 10'h3FF,\r
	parameter  [1:0] RX_SLIDE_MODE = 0,\r
	parameter  [0:0] RX_COMMA_DETECT_EN_OVR = 0,\r
	parameter  [0:0] RX_COMMA_DETECT_EN = 0,\r
	parameter  [1:0] RX_SLIDE = 0,\r
	parameter  [0:0] RX_EYE_MEAS_EN = 0,\r
	parameter [14:0] RX_EYE_MEAS_CFG = 0,\r
	parameter  [5:0] RX_MON_PH_OFFSET = 0,\r
	parameter  [3:0] RX_EI_BIAS = 0,\r
	parameter  [3:0] RX_EI_BW_SEL = 4,\r
	parameter  [0:0] RX_EN_EI_DETECTOR_OVR = 0,\r
	parameter  [0:0] RX_EN_EI_DETECTOR = 0,\r
	parameter  [0:0] RX_DATA_SEL = 0,\r
	parameter  [0:0] RX_BUF_BYPASS = 0,\r
	parameter  [0:0] RX_CLKCOR_USE = 0,\r
	parameter  [5:0] RX_CLKCOR_MIN_LAT = 32,\r
	parameter  [5:0] RX_CLKCOR_MAX_LAT = 39,\r
	parameter  [9:0] RX_CLKCOR_SEQ_1_0 = 10'h1F7,\r
	parameter  [9:0] RX_CLKCOR_SEQ_1_1 = 10'h1F7,\r
	parameter  [9:0] RX_CLKCOR_SEQ_1_2 = 10'h1F7,\r
	parameter  [9:0] RX_CLKCOR_SEQ_1_3 = 10'h1F7,\r
	parameter  [0:0] RX_PMA_LOOPBACK = 0,\r
	parameter  [0:0] RX_PCS_LOOPBACK = 0,\r
	parameter  [1:0] RX_DATAPATH_SEL = 3,\r
	parameter  [0:0] RX_PRBS_OVR = 0,\r
	parameter  [2:0] RX_PRBS_SEL = 0,\r
	parameter  [0:0] RX_LOOPBACK_OVR = 0,\r
	parameter  [0:0] RX_PRBS_CNT_RESET = 0,\r
	parameter  [0:0] RX_POWER_DOWN_OVR = 0,\r
	parameter  [0:0] RX_POWER_DOWN_N = 0,\r
	parameter  [0:0] RX_RESET_OVR = 0,\r
	parameter  [0:0] RX_RESET = 0,\r
	parameter  [0:0] RX_PMA_RESET_OVR = 0,\r
	parameter  [0:0] RX_PMA_RESET = 0,\r
	parameter  [0:0] RX_EQA_RESET_OVR = 0,\r
	parameter  [0:0] RX_EQA_RESET = 0,\r
	parameter  [0:0] RX_CDR_RESET_OVR = 0,\r
	parameter  [0:0] RX_CDR_RESET = 0,\r
	parameter  [0:0] RX_PCS_RESET_OVR = 0,\r
	parameter  [0:0] RX_PCS_RESET = 0,\r
	parameter  [0:0] RX_BUF_RESET_OVR = 0,\r
	parameter  [0:0] RX_BUF_RESET = 0,\r
	parameter  [0:0] RX_POLARITY_OVR = 0,\r
	parameter  [0:0] RX_POLARITY = 0,\r
	parameter  [0:0] RX_8B10B_EN_OVR = 0,\r
	parameter  [0:0] RX_8B10B_EN = 0,\r
	parameter  [7:0] RX_8B10B_BYPASS = 0,\r
	parameter  [0:0] RX_BYTE_REALIGN = 0,\r
	parameter  [0:0] RX_DBG_EN = 0,\r
	parameter  [1:0] RX_DBG_SEL = 0,\r
	parameter  [0:0] RX_DBG_MODE = 0,\r
	parameter  [5:0] RX_DBG_SRAM_DELAY = 6'h05,\r
	parameter  [9:0] RX_DBG_ADDR = 0,\r
	parameter  [0:0] RX_DBG_RE = 0,\r
	parameter  [0:0] RX_DBG_WE = 0,\r
	parameter [19:0] RX_DBG_DATA = 0,\r
	parameter  [4:0] TX_SEL_PRE = 0,\r
	parameter  [4:0] TX_SEL_POST = 0,\r
	parameter  [4:0] TX_AMP = 15,\r
	parameter  [4:0] TX_BRANCH_EN_PRE = 0,\r
	parameter  [5:0] TX_BRANCH_EN_MAIN = 6'h3F,\r
	parameter  [4:0] TX_BRANCH_EN_POST = 0,\r
	parameter  [2:0] TX_TAIL_CASCODE = 4,\r
	parameter  [6:0] TX_DC_ENABLE = 63,\r
	parameter  [4:0] TX_DC_OFFSET = 0,\r
	parameter  [4:0] TX_CM_RAISE = 0,\r
	parameter  [4:0] TX_CM_THRESHOLD_0 = 14,\r
	parameter  [4:0] TX_CM_THRESHOLD_1 = 16,\r
	parameter  [4:0] TX_SEL_PRE_EI = 0,\r
	parameter  [4:0] TX_SEL_POST_EI = 0,\r
	parameter  [4:0] TX_AMP_EI = 15,\r
	parameter  [4:0] TX_BRANCH_EN_PRE_EI = 0,\r
	parameter  [5:0] TX_BRANCH_EN_MAIN_EI = 6'h3F,\r
	parameter  [4:0] TX_BRANCH_EN_POST_EI = 0,\r
	parameter  [2:0] TX_TAIL_CASCODE_EI = 4,\r
	parameter  [6:0] TX_DC_ENABLE_EI = 63,\r
	parameter  [4:0] TX_DC_OFFSET_EI = 0,\r
	parameter  [4:0] TX_CM_RAISE_EI = 0,\r
	parameter  [4:0] TX_CM_THRESHOLD_0_EI = 14,\r
	parameter  [4:0] TX_CM_THRESHOLD_1_EI = 16,\r
	parameter  [4:0] TX_SEL_PRE_RXDET = 0,\r
	parameter  [4:0] TX_SEL_POST_RXDET = 0,\r
	parameter  [4:0] TX_AMP_RXDET = 15,\r
	parameter  [4:0] TX_BRANCH_EN_PRE_RXDET = 0,\r
	parameter  [5:0] TX_BRANCH_EN_MAIN_RXDET = 6'h3F,\r
	parameter  [4:0] TX_BRANCH_EN_POST_RXDET = 0,\r
	parameter  [2:0] TX_TAIL_CASCODE_RXDET = 4,\r
	parameter  [6:0] TX_DC_ENABLE_RXDET = 63,\r
	parameter  [4:0] TX_DC_OFFSET_RXDET = 0,\r
	parameter  [4:0] TX_CM_RAISE_RXDET = 0,\r
	parameter  [4:0] TX_CM_THRESHOLD_0_RXDET = 14,\r
	parameter  [4:0] TX_CM_THRESHOLD_1_RXDET = 16,\r
	parameter  [0:0] TX_CALIB_EN = 0,\r
	parameter  [0:0] TX_CALIB_OVR = 0,\r
	parameter  [3:0] TX_CALIB_VAL = 0,\r
	parameter  [7:0] TX_CM_REG_KI = 8'h80,\r
	parameter  [0:0] TX_CM_SAR_EN = 0,\r
	parameter  [0:0] TX_CM_REG_EN = 1,\r
	parameter  [4:0] TX_PMA_RESET_TIME = 3,\r
	parameter  [4:0] TX_PCS_RESET_TIME = 3,\r
	parameter  [0:0] TX_PCS_RESET_OVR = 0,\r
	parameter  [0:0] TX_PCS_RESET = 0,\r
	parameter  [0:0] TX_PMA_RESET_OVR = 0,\r
	parameter  [0:0] TX_PMA_RESET = 0,\r
	parameter  [0:0] TX_RESET_OVR = 0,\r
	parameter  [0:0] TX_RESET = 0,\r
	parameter  [1:0] TX_PMA_LOOPBACK = 0,\r
	parameter  [0:0] TX_PCS_LOOPBACK = 0,\r
	parameter  [1:0] TX_DATAPATH_SEL = 3,\r
	parameter  [0:0] TX_PRBS_OVR = 0,\r
	parameter  [2:0] TX_PRBS_SEL = 0,\r
	parameter  [0:0] TX_PRBS_FORCE_ERR = 0,\r
	parameter  [0:0] TX_LOOPBACK_OVR = 0,\r
	parameter  [0:0] TX_POWER_DOWN_OVR = 0,\r
	parameter  [0:0] TX_POWER_DOWN_N = 0,\r
	parameter  [0:0] TX_ELEC_IDLE_OVR = 0,\r
	parameter  [0:0] TX_ELEC_IDLE = 0,\r
	parameter  [0:0] TX_DETECT_RX_OVR = 0,\r
	parameter  [0:0] TX_DETECT_RX = 0,\r
	parameter  [0:0] TX_POLARITY_OVR = 0,\r
	parameter  [0:0] TX_POLARITY = 0,\r
	parameter  [0:0] TX_8B10B_EN_OVR = 0,\r
	parameter  [0:0] TX_8B10B_EN = 0,\r
	parameter  [0:0] TX_DATA_OVR = 0,\r
	parameter  [2:0] TX_DATA_CNT = 0,\r
	parameter  [0:0] TX_DATA_VALID = 0,\r
	parameter  [0:0] PLL_EN_ADPLL_CTRL = 0,\r
	parameter  [0:0] PLL_CONFIG_SEL = 0,\r
	parameter  [0:0] PLL_SET_OP_LOCK = 0,\r
	parameter  [0:0] PLL_ENFORCE_LOCK = 0,\r
	parameter  [0:0] PLL_DISABLE_LOCK = 0,\r
	parameter  [0:0] PLL_LOCK_WINDOW = 1,\r
	parameter  [0:0] PLL_FAST_LOCK = 1,\r
	parameter  [0:0] PLL_SYNC_BYPASS = 0,\r
	parameter  [0:0] PLL_PFD_SELECT = 0,\r
	parameter  [0:0] PLL_REF_BYPASS = 0,\r
	parameter  [0:0] PLL_REF_SEL = 0,\r
	parameter  [0:0] PLL_REF_RTERM = 1,\r
	parameter  [5:0] PLL_FCNTRL = 58,\r
	parameter  [5:0] PLL_MAIN_DIVSEL = 27,\r
	parameter  [1:0] PLL_OUT_DIVSEL = 0,\r
	parameter  [4:0] PLL_CI = 3,\r
	parameter  [9:0] PLL_CP = 80,\r
	parameter  [3:0] PLL_AO = 0,\r
	parameter  [2:0] PLL_SCAP = 0,\r
	parameter  [1:0] PLL_FILTER_SHIFT = 2,\r
	parameter  [2:0] PLL_SAR_LIMIT = 2,\r
	parameter [10:0] PLL_FT = 512,\r
	parameter  [0:0] PLL_OPEN_LOOP = 0,\r
	parameter  [0:0] PLL_SCAP_AUTO_CAL = 1,\r
	parameter  [2:0] PLL_BISC_MODE = 4,\r
	parameter  [3:0] PLL_BISC_TIMER_MAX = 15,\r
	parameter  [0:0] PLL_BISC_OPT_DET_IND = 0,\r
	parameter  [0:0] PLL_BISC_PFD_SEL = 0,\r
	parameter  [0:0] PLL_BISC_DLY_DIR = 0,\r
	parameter  [2:0] PLL_BISC_COR_DLY = 1,\r
	parameter  [0:0] PLL_BISC_CAL_SIGN = 0,\r
	parameter  [0:0] PLL_BISC_CAL_AUTO = 1,\r
	parameter  [4:0] PLL_BISC_CP_MIN = 4,\r
	parameter  [4:0] PLL_BISC_CP_MAX = 18,\r
	parameter  [4:0] PLL_BISC_CP_START = 12,\r
	parameter  [4:0] PLL_BISC_DLY_PFD_MON_REF = 0,\r
	parameter  [4:0] PLL_BISC_DLY_PFD_MON_DIV = 2,\r
	parameter  [0:0] SERDES_ENABLE = 0,\r
	parameter  [0:0] SERDES_AUTO_INIT = 0,\r
	parameter  [0:0] SERDES_TESTMODE = 0\r
)(\r
	input [63:0] TX_DATA_I,\r
	input TX_RESET_I,\r
	input TX_PCS_RESET_I,\r
	input TX_PMA_RESET_I,\r
	input PLL_RESET_I,\r
	input TX_POWER_DOWN_N_I,\r
	input TX_POLARITY_I,\r
	input [2:0] TX_PRBS_SEL_I,\r
	input TX_PRBS_FORCE_ERR_I,\r
	input TX_8B10B_EN_I,\r
	input [7:0] TX_8B10B_BYPASS_I,\r
	input [7:0] TX_CHAR_IS_K_I,\r
	input [7:0] TX_CHAR_DISPMODE_I,\r
	input [7:0] TX_CHAR_DISPVAL_I,\r
	input TX_ELEC_IDLE_I,\r
	input TX_DETECT_RX_I,\r
	input [2:0] LOOPBACK_I,\r
	input TX_CLK_I,\r
	input RX_CLK_I,\r
	input RX_RESET_I,\r
	input RX_PMA_RESET_I,\r
	input RX_EQA_RESET_I,\r
	input RX_CDR_RESET_I,\r
	input RX_PCS_RESET_I,\r
	input RX_BUF_RESET_I,\r
	input RX_POWER_DOWN_N_I,\r
	input RX_POLARITY_I,\r
	input [2:0] RX_PRBS_SEL_I,\r
	input RX_PRBS_CNT_RESET_I,\r
	input RX_8B10B_EN_I,\r
	input [7:0] RX_8B10B_BYPASS_I,\r
	input RX_EN_EI_DETECTOR_I,\r
	input RX_COMMA_DETECT_EN_I,\r
	input RX_SLIDE_I,\r
	input RX_MCOMMA_ALIGN_I,\r
	input RX_PCOMMA_ALIGN_I,\r
	input REGFILE_CLK_I,\r
	input REGFILE_WE_I,\r
	input REGFILE_EN_I,\r
	input [7:0] REGFILE_ADDR_I,\r
	input [15:0] REGFILE_DI_I,\r
	input [15:0] REGFILE_MASK_I,\r
	output [63:0] RX_DATA_O,\r
	output [7:0] RX_NOT_IN_TABLE_O,\r
	output [7:0] RX_CHAR_IS_COMMA_O,\r
	output [7:0] RX_CHAR_IS_K_O,\r
	output [7:0] RX_DISP_ERR_O,\r
	output TX_DETECT_RX_DONE_O,\r
	output TX_DETECT_RX_PRESENT_O,\r
	output TX_BUF_ERR_O,\r
	output TX_RESET_DONE_O,\r
	output RX_PRBS_ERR_O,\r
	output RX_BUF_ERR_O,\r
	output RX_BYTE_IS_ALIGNED_O,\r
	output RX_BYTE_REALIGN_O,\r
	output RX_RESET_DONE_O,\r
	output RX_EI_EN_O,\r
	output RX_CLK_O,\r
	output PLL_CLK_O,\r
	output [15:0] REGFILE_DO_O,\r
	output REGFILE_RDY_O\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_CFG_CTRL(\r
	input [7:0] DATA,\r
	input CLK,\r
	input EN,\r
	input RECFG,\r
	input VALID\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_USR_RSTN (\r
	output USR_RSTN\r
);\r
endmodule\r
`,"cells_sim.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
\`timescale 1ps/1ps\r
\r
module CC_IBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	parameter [0:0] SCHMITT_TRIGGER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx\r
)(\r
	(* iopad_external_pin *)\r
	input  I,\r
	output Y\r
);\r
	assign Y = I;\r
\r
endmodule\r
\r
\r
module CC_OBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A,\r
	(* iopad_external_pin *)\r
	output O\r
);\r
	assign O = A;\r
\r
endmodule\r
\r
\r
module CC_TOBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	output O\r
);\r
	assign O = T ? 1'bz : A;\r
\r
endmodule\r
\r
\r
module CC_IOBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	parameter [0:0] SCHMITT_TRIGGER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	output Y,\r
	(* iopad_external_pin *)\r
	inout  IO\r
);\r
	assign IO = T ? 1'bz : A;\r
	assign Y = IO;\r
\r
endmodule\r
\r
\r
module CC_LVDS_IBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_RTERM = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx\r
)(\r
	(* iopad_external_pin *)\r
	input  I_P, I_N,\r
	output Y\r
);\r
	assign Y = I_P;\r
\r
endmodule\r
\r
\r
module CC_LVDS_OBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A,\r
	(* iopad_external_pin *)\r
	output O_P, O_N\r
);\r
	assign O_P = A;\r
	assign O_N = ~A;\r
\r
endmodule\r
\r
\r
module CC_LVDS_TOBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	output O_P, O_N\r
);\r
	assign O_P = T ? 1'bz :  A;\r
	assign O_N = T ? 1'bz : ~A;\r
\r
endmodule\r
\r
\r
module CC_LVDS_IOBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_RTERM = 1'bx,\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	inout  IO_P, IO_N,\r
	output Y\r
);\r
	assign IO_P = T ? 1'bz :  A;\r
	assign IO_N = T ? 1'bz : ~A;\r
	assign Y = IO_P;\r
\r
endmodule\r
\r
\r
module CC_IDDR #(\r
	parameter [0:0] CLK_INV = 1'b0\r
)(\r
	input D,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	output reg Q0, Q1\r
);\r
	wire clk;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
\r
	always @(posedge clk)\r
	begin\r
		Q0 <= D;\r
	end\r
\r
	always @(negedge clk)\r
	begin\r
		Q1 <= D;\r
	end\r
\r
endmodule\r
\r
\r
module CC_ODDR #(\r
	parameter [0:0] CLK_INV = 1'b0\r
)(\r
	input D0,\r
	input D1,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	(* clkbuf_sink *)\r
	input DDR,\r
	output Q\r
);\r
	wire clk;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
\r
	reg q0, q1;\r
	assign Q = (DDR) ? q0 : q1;\r
\r
	always @(posedge clk)\r
	begin\r
		q0 <= D0;\r
	end\r
\r
	always @(negedge clk)\r
	begin\r
		q1 <= D1;\r
	end\r
\r
endmodule\r
\r
\r
module CC_DFF #(\r
	parameter [0:0] CLK_INV = 1'b0,\r
	parameter [0:0] EN_INV  = 1'b0,\r
	parameter [0:0] SR_INV  = 1'b0,\r
	parameter [0:0] SR_VAL  = 1'b0,\r
	parameter [0:0] INIT    = 1'bx\r
)(\r
	input D,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	input EN,\r
	input SR,\r
	output reg Q\r
);\r
	wire clk, en, sr;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
	assign en  = (EN_INV)  ?  ~EN :  EN;\r
	assign sr  = (SR_INV)  ?  ~SR :  SR;\r
\r
	initial Q = INIT;\r
\r
	always @(posedge clk or posedge sr)\r
	begin\r
		if (sr) begin\r
			Q <= SR_VAL;\r
		end\r
		else if (en) begin\r
			Q <= D;\r
		end\r
	end\r
\r
endmodule\r
\r
\r
module CC_DLT #(\r
	parameter [0:0] G_INV  = 1'b0,\r
	parameter [0:0] SR_INV = 1'b0,\r
	parameter [0:0] SR_VAL = 1'b0,\r
	parameter [0:0] INIT   = 1'bx\r
)(\r
	input D,\r
	input G,\r
	input SR,\r
	output reg Q\r
);\r
	wire en, sr;\r
	assign en  = (G_INV) ? ~G : G;\r
	assign sr  = (SR_INV) ? ~SR : SR;\r
\r
	initial Q = INIT;\r
\r
	always @(*)\r
	begin\r
		if (sr) begin\r
			Q = SR_VAL;\r
		end\r
		else if (en) begin\r
			Q = D;\r
		end\r
	end\r
\r
endmodule\r
\r
\r
module CC_LUT1 (\r
	output O,\r
	input  I0\r
);\r
	parameter [1:0] INIT = 0;\r
\r
	assign O = I0 ? INIT[1] : INIT[0];\r
\r
endmodule\r
\r
\r
module CC_LUT2 (\r
	output O,\r
	input  I0, I1\r
);\r
	parameter [3:0] INIT = 0;\r
\r
	wire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_LUT3 (\r
	output O,\r
	input  I0, I1, I2\r
);\r
	parameter [7:0] INIT = 0;\r
\r
	wire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];\r
	wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_LUT4 (\r
	output O,\r
	input  I0, I1, I2, I3\r
);\r
	parameter [15:0] INIT = 0;\r
\r
	wire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];\r
	wire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];\r
	wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_MX2 (\r
	input  D0, D1,\r
	input  S0,\r
	output Y\r
);\r
	assign Y = S0 ? D1 : D0;\r
\r
endmodule\r
\r
\r
module CC_MX4 (\r
	input  D0, D1, D2, D3,\r
	input  S0, S1,\r
	output Y\r
);\r
	assign Y = S1 ? (S0 ? D3 : D2) :\r
					(S0 ? D1 : D0);\r
\r
endmodule\r
\r
\r
module CC_MX8 (\r
	input  D0, D1, D2, D3,\r
	input  D4, D5, D6, D7,\r
	input  S0, S1, S2,\r
	output Y\r
);\r
	assign Y = S2 ? (S1 ? (S0 ? D7 : D6) :\r
						  (S0 ? D5 : D4)) :\r
					(S1 ? (S0 ? D3 : D2) :\r
						  (S0 ? D1 : D0));\r
\r
endmodule\r
\r
\r
module CC_ADDF (\r
	input  A, B, CI,\r
	output CO, S\r
);\r
	assign {CO, S} = A + B + CI;\r
\r
endmodule\r
\r
\r
module CC_MULT #(\r
	parameter A_WIDTH = 0,\r
	parameter B_WIDTH = 0,\r
	parameter P_WIDTH = 0\r
)(\r
	input signed [A_WIDTH-1:0] A,\r
	input signed [B_WIDTH-1:0] B,\r
	output reg signed [P_WIDTH-1:0] P\r
);\r
	always @(*)\r
	begin\r
		P = A * B;\r
	end\r
endmodule\r
\r
\r
module CC_BUFG (\r
	input  I,\r
	(* clkbuf_driver *)\r
	output O\r
);\r
	assign O = I;\r
\r
endmodule\r
\r
\r
module CC_BRAM_20K (\r
	output [19:0] A_DO,\r
	output [19:0] B_DO,\r
	output ECC_1B_ERR,\r
	output ECC_2B_ERR,\r
	(* clkbuf_sink *)\r
	input A_CLK,\r
	(* clkbuf_sink *)\r
	input B_CLK,\r
	input A_EN,\r
	input B_EN,\r
	input A_WE,\r
	input B_WE,\r
	input [15:0] A_ADDR,\r
	input [15:0] B_ADDR,\r
	input [19:0] A_DI,\r
	input [19:0] B_DI,\r
	input [19:0] A_BM,\r
	input [19:0] B_BM\r
);\r
	// Location format: D(0..N-1)(0..N-1)X(0..3)Y(0..7)Z(0..1) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
\r
	// Port Widths\r
	parameter A_RD_WIDTH = 0;\r
	parameter B_RD_WIDTH = 0;\r
	parameter A_WR_WIDTH = 0;\r
	parameter B_WR_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "SDP";\r
	parameter A_WR_MODE = "NO_CHANGE";\r
	parameter B_WR_MODE = "NO_CHANGE";\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter ECC_EN = 1'b0;\r
\r
	// RAM Contents\r
	parameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
\r
	localparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\r
	localparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\r
\r
	integer i, k;\r
\r
	// 512 x 40 bit\r
	reg [20479:0] memory = 20480'b0;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_WR_MODE != "WRITE_THROUGH") && (A_WR_MODE != "NO_CHANGE")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (A_WR_MODE == "WRITE_THROUGH")) begin\r
			$display("ERROR: %s is not supported in %s mode.", A_WR_MODE, RAM_MODE);\r
			$finish();\r
		end\r
		if (ECC_EN != 1'b0) begin\r
			$display("WARNING: ECC feature not supported in simulation.");\r
		end\r
		if ((ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (WIDTH_MODE_A != 40)) begin\r
			$display("ERROR: Illegal ECC Port configuration. Must be SDP 40 bit, but is %s %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A == 40) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 40 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B == 40) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 40 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\r
			(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\r
			(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, WIDTH_MODE_B);\r
			$finish();\r
		end\r
		// RAM initialization\r
		memory[320*0+319:320*0]   = INIT_00;\r
		memory[320*1+319:320*1]   = INIT_01;\r
		memory[320*2+319:320*2]   = INIT_02;\r
		memory[320*3+319:320*3]   = INIT_03;\r
		memory[320*4+319:320*4]   = INIT_04;\r
		memory[320*5+319:320*5]   = INIT_05;\r
		memory[320*6+319:320*6]   = INIT_06;\r
		memory[320*7+319:320*7]   = INIT_07;\r
		memory[320*8+319:320*8]   = INIT_08;\r
		memory[320*9+319:320*9]   = INIT_09;\r
		memory[320*10+319:320*10] = INIT_0A;\r
		memory[320*11+319:320*11] = INIT_0B;\r
		memory[320*12+319:320*12] = INIT_0C;\r
		memory[320*13+319:320*13] = INIT_0D;\r
		memory[320*14+319:320*14] = INIT_0E;\r
		memory[320*15+319:320*15] = INIT_0F;\r
		memory[320*16+319:320*16] = INIT_10;\r
		memory[320*17+319:320*17] = INIT_11;\r
		memory[320*18+319:320*18] = INIT_12;\r
		memory[320*19+319:320*19] = INIT_13;\r
		memory[320*20+319:320*20] = INIT_14;\r
		memory[320*21+319:320*21] = INIT_15;\r
		memory[320*22+319:320*22] = INIT_16;\r
		memory[320*23+319:320*23] = INIT_17;\r
		memory[320*24+319:320*24] = INIT_18;\r
		memory[320*25+319:320*25] = INIT_19;\r
		memory[320*26+319:320*26] = INIT_1A;\r
		memory[320*27+319:320*27] = INIT_1B;\r
		memory[320*28+319:320*28] = INIT_1C;\r
		memory[320*29+319:320*29] = INIT_1D;\r
		memory[320*30+319:320*30] = INIT_1E;\r
		memory[320*31+319:320*31] = INIT_1F;\r
		memory[320*32+319:320*32] = INIT_20;\r
		memory[320*33+319:320*33] = INIT_21;\r
		memory[320*34+319:320*34] = INIT_22;\r
		memory[320*35+319:320*35] = INIT_23;\r
		memory[320*36+319:320*36] = INIT_24;\r
		memory[320*37+319:320*37] = INIT_25;\r
		memory[320*38+319:320*38] = INIT_26;\r
		memory[320*39+319:320*39] = INIT_27;\r
		memory[320*40+319:320*40] = INIT_28;\r
		memory[320*41+319:320*41] = INIT_29;\r
		memory[320*42+319:320*42] = INIT_2A;\r
		memory[320*43+319:320*43] = INIT_2B;\r
		memory[320*44+319:320*44] = INIT_2C;\r
		memory[320*45+319:320*45] = INIT_2D;\r
		memory[320*46+319:320*46] = INIT_2E;\r
		memory[320*47+319:320*47] = INIT_2F;\r
		memory[320*48+319:320*48] = INIT_30;\r
		memory[320*49+319:320*49] = INIT_31;\r
		memory[320*50+319:320*50] = INIT_32;\r
		memory[320*51+319:320*51] = INIT_33;\r
		memory[320*52+319:320*52] = INIT_34;\r
		memory[320*53+319:320*53] = INIT_35;\r
		memory[320*54+319:320*54] = INIT_36;\r
		memory[320*55+319:320*55] = INIT_37;\r
		memory[320*56+319:320*56] = INIT_38;\r
		memory[320*57+319:320*57] = INIT_39;\r
		memory[320*58+319:320*58] = INIT_3A;\r
		memory[320*59+319:320*59] = INIT_3B;\r
		memory[320*60+319:320*60] = INIT_3C;\r
		memory[320*61+319:320*61] = INIT_3D;\r
		memory[320*62+319:320*62] = INIT_3E;\r
		memory[320*63+319:320*63] = INIT_3F;\r
	end\r
\r
	// Signal inversion\r
	wire clka = A_CLK_INV ^ A_CLK;\r
	wire clkb = B_CLK_INV ^ B_CLK;\r
	wire ena  = A_EN_INV ^ A_EN;\r
	wire enb  = B_EN_INV ^ B_EN;\r
	wire wea  = A_WE_INV ^ A_WE;\r
	wire web  = B_WE_INV ^ B_WE;\r
\r
	// Internal signals\r
	wire [15:0] addra;\r
	wire [15:0] addrb;\r
	reg  [19:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [19:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// Port A (write)\r
			if (A_WR_WIDTH == 40) begin\r
				assign addra = A_ADDR[15:7]*40;\r
			end\r
			// Port B (read)\r
			if (B_RD_WIDTH == 40) begin\r
				assign addrb = B_ADDR[15:7]*40;\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// Port A\r
			if (WIDTH_MODE_A <= 1) begin\r
				wire [15:0] tmpa = {2'b0, A_ADDR[15:7], A_ADDR[5:1]};\r
				assign addra = tmpa + (tmpa/4);\r
			end\r
			else if (WIDTH_MODE_A <= 2) begin\r
				wire [15:0] tmpa = {3'b0, A_ADDR[15:7], A_ADDR[5:2]};\r
				assign addra = tmpa*2 + (tmpa/2);\r
			end\r
			else if (WIDTH_MODE_A <= 5) begin\r
				assign addra = {4'b0, A_ADDR[15:7], A_ADDR[5:3]}*5;\r
			end\r
			else if (WIDTH_MODE_A <= 10) begin\r
				assign addra = {5'b0, A_ADDR[15:7], A_ADDR[5:4]}*10;\r
			end\r
			else if (WIDTH_MODE_A <= 20) begin\r
				assign addra = {6'b0, A_ADDR[15:7], A_ADDR[5]}*20;\r
			end\r
			// Port B\r
			if (WIDTH_MODE_B <= 1) begin\r
				wire [15:0] tmpb = {2'b0, B_ADDR[15:7], B_ADDR[5:1]};\r
				assign addrb = tmpb + (tmpb/4);\r
			end\r
			else if (WIDTH_MODE_B <= 2) begin\r
				wire [15:0] tmpb = {3'b0, B_ADDR[15:7], B_ADDR[5:2]};\r
				assign addrb = tmpb*2 + (tmpb/2);\r
			end\r
			else if (WIDTH_MODE_B <= 5) begin\r
				assign addrb = {4'b0, B_ADDR[15:7], B_ADDR[5:3]}*5;\r
			end\r
			else if (WIDTH_MODE_B <= 10) begin\r
				assign addrb = {5'b0, B_ADDR[15:7], B_ADDR[5:4]}*10;\r
			end\r
			else if (WIDTH_MODE_B <= 20) begin\r
				assign addrb = {6'b0, B_ADDR[15:7], B_ADDR[5]}*20;\r
			end\r
		end\r
	endgenerate\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// SDP write port\r
			always @(posedge clka)\r
			begin\r
				for (k=0; k < A_WR_WIDTH; k=k+1) begin\r
					if (k < 20) begin\r
						if (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ena && wea && B_BM[k-20]) memory[addra+k] <= B_DI[k-20];\r
					end\r
				end\r
			end\r
			// SDP read port\r
			always @(posedge clkb)\r
			begin\r
				for (k=0; k < B_RD_WIDTH; k=k+1) begin\r
					if (k < 20) begin\r
						if (enb) A_DO_out[k] <= memory[addrb+k];\r
					end\r
					else begin // use both ports\r
						if (enb) B_DO_out[k-20] <= memory[addrb+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// TDP port A\r
			always @(posedge clka)\r
			begin\r
				for (i=0; i < WIDTH_MODE_A; i=i+1) begin\r
					if (ena && wea && A_BM[i]) memory[addra+i] <= A_DI[i];\r
\r
					if (A_WR_MODE == "NO_CHANGE") begin\r
						if (ena && !wea) A_DO_out[i] <= memory[addra+i];\r
					end\r
					else if (A_WR_MODE == "WRITE_THROUGH") begin\r
						if (ena) begin\r
							if (wea && A_BM[i]) begin\r
								A_DO_out[i] <= A_DI[i];\r
							end\r
							else begin\r
								A_DO_out[i] <= memory[addra+i];\r
							end\r
						end\r
					end\r
				end\r
			end\r
			// TDP port B\r
			always @(posedge clkb)\r
			begin\r
				for (i=0; i < WIDTH_MODE_B; i=i+1) begin\r
					if (enb && web && B_BM[i]) memory[addrb+i] <= B_DI[i];\r
\r
					if (B_WR_MODE == "NO_CHANGE") begin\r
						if (enb && !web) B_DO_out[i] <= memory[addrb+i];\r
					end\r
					else if (B_WR_MODE == "WRITE_THROUGH") begin\r
						if (enb) begin\r
							if (web && B_BM[i]) begin\r
								B_DO_out[i] <= B_DI[i];\r
							end\r
							else begin\r
								B_DO_out[i] <= memory[addrb+i];\r
							end\r
						end\r
					end\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge clka) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge clkb) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
\r
module CC_BRAM_40K (\r
	output [39:0] A_DO,\r
	output [39:0] B_DO,\r
	output A_ECC_1B_ERR,\r
	output B_ECC_1B_ERR,\r
	output A_ECC_2B_ERR,\r
	output B_ECC_2B_ERR,\r
	output reg A_CO = 0,\r
	output reg B_CO = 0,\r
	(* clkbuf_sink *)\r
	input A_CLK,\r
	(* clkbuf_sink *)\r
	input B_CLK,\r
	input A_EN,\r
	input B_EN,\r
	input A_WE,\r
	input B_WE,\r
	input [15:0] A_ADDR,\r
	input [15:0] B_ADDR,\r
	input [39:0] A_DI,\r
	input [39:0] B_DI,\r
	input [39:0] A_BM,\r
	input [39:0] B_BM,\r
	input A_CI,\r
	input B_CI\r
);\r
	// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
	parameter CAS = "NONE"; // NONE, UPPER, LOWER\r
\r
	// Port Widths\r
	parameter A_RD_WIDTH = 0;\r
	parameter B_RD_WIDTH = 0;\r
	parameter A_WR_WIDTH = 0;\r
	parameter B_WR_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "SDP";\r
	parameter A_WR_MODE = "NO_CHANGE";\r
	parameter B_WR_MODE = "NO_CHANGE";\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter A_ECC_EN  = 1'b0;\r
	parameter B_ECC_EN  = 1'b0;\r
\r
	parameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_40 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_41 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_42 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_43 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_44 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_45 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_46 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_47 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_48 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_49 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_50 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_51 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_52 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_53 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_54 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_55 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_56 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_57 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_58 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_59 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_60 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_61 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_62 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_63 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_64 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_65 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_66 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_67 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_68 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_69 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_70 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_71 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_72 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_73 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_74 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_75 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_76 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_77 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_78 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_79 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
\r
	localparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\r
	localparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\r
\r
	integer i, k;\r
\r
	// 512 x 80 bit\r
	reg [40959:0] memory = 40960'b0;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_WR_MODE != "WRITE_THROUGH") && (A_WR_MODE != "NO_CHANGE")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (A_WR_MODE == "WRITE_THROUGH")) begin\r
			$display("ERROR: %s is not supported in %s mode.", A_WR_MODE, RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_ECC_EN != 1'b0) || (B_ECC_EN != 1'b0)) begin\r
			$display("WARNING: ECC feature not supported in simulation.");\r
		end\r
		if ((A_ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (WIDTH_MODE_A != 40)) begin\r
			$display("ERROR: Illegal ECC Port A configuration. Must be SDP 40 bit, but is %s %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A != 80) && (WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\r
			(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B != 80) && (WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\r
			(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, WIDTH_MODE_B);\r
			$finish();\r
		end\r
		if ((CAS != "NONE") && ((WIDTH_MODE_A > 1) || (WIDTH_MODE_B > 1))) begin\r
			$display("ERROR: Cascade feature only supported in 1 bit data width mode.");\r
			$finish();\r
		end\r
		if ((CAS != "NONE") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Cascade feature only supported in TDP mode.");\r
			$finish();\r
		end\r
		// RAM initialization\r
		memory[320*0+319:320*0]     = INIT_00;\r
		memory[320*1+319:320*1]     = INIT_01;\r
		memory[320*2+319:320*2]     = INIT_02;\r
		memory[320*3+319:320*3]     = INIT_03;\r
		memory[320*4+319:320*4]     = INIT_04;\r
		memory[320*5+319:320*5]     = INIT_05;\r
		memory[320*6+319:320*6]     = INIT_06;\r
		memory[320*7+319:320*7]     = INIT_07;\r
		memory[320*8+319:320*8]     = INIT_08;\r
		memory[320*9+319:320*9]     = INIT_09;\r
		memory[320*10+319:320*10]   = INIT_0A;\r
		memory[320*11+319:320*11]   = INIT_0B;\r
		memory[320*12+319:320*12]   = INIT_0C;\r
		memory[320*13+319:320*13]   = INIT_0D;\r
		memory[320*14+319:320*14]   = INIT_0E;\r
		memory[320*15+319:320*15]   = INIT_0F;\r
		memory[320*16+319:320*16]   = INIT_10;\r
		memory[320*17+319:320*17]   = INIT_11;\r
		memory[320*18+319:320*18]   = INIT_12;\r
		memory[320*19+319:320*19]   = INIT_13;\r
		memory[320*20+319:320*20]   = INIT_14;\r
		memory[320*21+319:320*21]   = INIT_15;\r
		memory[320*22+319:320*22]   = INIT_16;\r
		memory[320*23+319:320*23]   = INIT_17;\r
		memory[320*24+319:320*24]   = INIT_18;\r
		memory[320*25+319:320*25]   = INIT_19;\r
		memory[320*26+319:320*26]   = INIT_1A;\r
		memory[320*27+319:320*27]   = INIT_1B;\r
		memory[320*28+319:320*28]   = INIT_1C;\r
		memory[320*29+319:320*29]   = INIT_1D;\r
		memory[320*30+319:320*30]   = INIT_1E;\r
		memory[320*31+319:320*31]   = INIT_1F;\r
		memory[320*32+319:320*32]   = INIT_20;\r
		memory[320*33+319:320*33]   = INIT_21;\r
		memory[320*34+319:320*34]   = INIT_22;\r
		memory[320*35+319:320*35]   = INIT_23;\r
		memory[320*36+319:320*36]   = INIT_24;\r
		memory[320*37+319:320*37]   = INIT_25;\r
		memory[320*38+319:320*38]   = INIT_26;\r
		memory[320*39+319:320*39]   = INIT_27;\r
		memory[320*40+319:320*40]   = INIT_28;\r
		memory[320*41+319:320*41]   = INIT_29;\r
		memory[320*42+319:320*42]   = INIT_2A;\r
		memory[320*43+319:320*43]   = INIT_2B;\r
		memory[320*44+319:320*44]   = INIT_2C;\r
		memory[320*45+319:320*45]   = INIT_2D;\r
		memory[320*46+319:320*46]   = INIT_2E;\r
		memory[320*47+319:320*47]   = INIT_2F;\r
		memory[320*48+319:320*48]   = INIT_30;\r
		memory[320*49+319:320*49]   = INIT_31;\r
		memory[320*50+319:320*50]   = INIT_32;\r
		memory[320*51+319:320*51]   = INIT_33;\r
		memory[320*52+319:320*52]   = INIT_34;\r
		memory[320*53+319:320*53]   = INIT_35;\r
		memory[320*54+319:320*54]   = INIT_36;\r
		memory[320*55+319:320*55]   = INIT_37;\r
		memory[320*56+319:320*56]   = INIT_38;\r
		memory[320*57+319:320*57]   = INIT_39;\r
		memory[320*58+319:320*58]   = INIT_3A;\r
		memory[320*59+319:320*59]   = INIT_3B;\r
		memory[320*60+319:320*60]   = INIT_3C;\r
		memory[320*61+319:320*61]   = INIT_3D;\r
		memory[320*62+319:320*62]   = INIT_3E;\r
		memory[320*63+319:320*63]   = INIT_3F;\r
		memory[320*64+319:320*64]   = INIT_40;\r
		memory[320*65+319:320*65]   = INIT_41;\r
		memory[320*66+319:320*66]   = INIT_42;\r
		memory[320*67+319:320*67]   = INIT_43;\r
		memory[320*68+319:320*68]   = INIT_44;\r
		memory[320*69+319:320*69]   = INIT_45;\r
		memory[320*70+319:320*70]   = INIT_46;\r
		memory[320*71+319:320*71]   = INIT_47;\r
		memory[320*72+319:320*72]   = INIT_48;\r
		memory[320*73+319:320*73]   = INIT_49;\r
		memory[320*74+319:320*74]   = INIT_4A;\r
		memory[320*75+319:320*75]   = INIT_4B;\r
		memory[320*76+319:320*76]   = INIT_4C;\r
		memory[320*77+319:320*77]   = INIT_4D;\r
		memory[320*78+319:320*78]   = INIT_4E;\r
		memory[320*79+319:320*79]   = INIT_4F;\r
		memory[320*80+319:320*80]   = INIT_50;\r
		memory[320*81+319:320*81]   = INIT_51;\r
		memory[320*82+319:320*82]   = INIT_52;\r
		memory[320*83+319:320*83]   = INIT_53;\r
		memory[320*84+319:320*84]   = INIT_54;\r
		memory[320*85+319:320*85]   = INIT_55;\r
		memory[320*86+319:320*86]   = INIT_56;\r
		memory[320*87+319:320*87]   = INIT_57;\r
		memory[320*88+319:320*88]   = INIT_58;\r
		memory[320*89+319:320*89]   = INIT_59;\r
		memory[320*90+319:320*90]   = INIT_5A;\r
		memory[320*91+319:320*91]   = INIT_5B;\r
		memory[320*92+319:320*92]   = INIT_5C;\r
		memory[320*93+319:320*93]   = INIT_5D;\r
		memory[320*94+319:320*94]   = INIT_5E;\r
		memory[320*95+319:320*95]   = INIT_5F;\r
		memory[320*96+319:320*96]   = INIT_60;\r
		memory[320*97+319:320*97]   = INIT_61;\r
		memory[320*98+319:320*98]   = INIT_62;\r
		memory[320*99+319:320*99]   = INIT_63;\r
		memory[320*100+319:320*100] = INIT_64;\r
		memory[320*101+319:320*101] = INIT_65;\r
		memory[320*102+319:320*102] = INIT_66;\r
		memory[320*103+319:320*103] = INIT_67;\r
		memory[320*104+319:320*104] = INIT_68;\r
		memory[320*105+319:320*105] = INIT_69;\r
		memory[320*106+319:320*106] = INIT_6A;\r
		memory[320*107+319:320*107] = INIT_6B;\r
		memory[320*108+319:320*108] = INIT_6C;\r
		memory[320*109+319:320*109] = INIT_6D;\r
		memory[320*110+319:320*110] = INIT_6E;\r
		memory[320*111+319:320*111] = INIT_6F;\r
		memory[320*112+319:320*112] = INIT_70;\r
		memory[320*113+319:320*113] = INIT_71;\r
		memory[320*114+319:320*114] = INIT_72;\r
		memory[320*115+319:320*115] = INIT_73;\r
		memory[320*116+319:320*116] = INIT_74;\r
		memory[320*117+319:320*117] = INIT_75;\r
		memory[320*118+319:320*118] = INIT_76;\r
		memory[320*119+319:320*119] = INIT_77;\r
		memory[320*120+319:320*120] = INIT_78;\r
		memory[320*121+319:320*121] = INIT_79;\r
		memory[320*122+319:320*122] = INIT_7A;\r
		memory[320*123+319:320*123] = INIT_7B;\r
		memory[320*124+319:320*124] = INIT_7C;\r
		memory[320*125+319:320*125] = INIT_7D;\r
		memory[320*126+319:320*126] = INIT_7E;\r
		memory[320*127+319:320*127] = INIT_7F;\r
	end\r
\r
	// Signal inversion\r
	wire clka = A_CLK_INV ^ A_CLK;\r
	wire clkb = B_CLK_INV ^ B_CLK;\r
	wire ena  = A_EN_INV ^ A_EN;\r
	wire enb  = B_EN_INV ^ B_EN;\r
	wire wea  = A_WE_INV ^ A_WE;\r
	wire web  = B_WE_INV ^ B_WE;\r
\r
	// Internal signals\r
	wire [15:0] addra;\r
	wire [15:0] addrb;\r
	reg  [39:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [39:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// Port A (write)\r
			 if (A_WR_WIDTH == 80) begin\r
				assign addra = A_ADDR[15:7]*80;\r
			end\r
			// Port B (read)\r
			if (B_RD_WIDTH == 80) begin\r
				assign addrb = B_ADDR[15:7]*80;\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// Port A\r
			if (WIDTH_MODE_A <= 1) begin\r
				wire [15:0] tmpa = {1'b0, A_ADDR[15:1]};\r
				assign addra = tmpa + (tmpa/4);\r
			end\r
			else if (WIDTH_MODE_A <= 2) begin\r
				wire [15:0] tmpa = {2'b0, A_ADDR[15:2]};\r
				assign addra = tmpa*2 + (tmpa/2);\r
			end\r
			else if (WIDTH_MODE_A <= 5) begin\r
				assign addra = {3'b0, A_ADDR[15:3]}*5;\r
			end\r
			else if (WIDTH_MODE_A <= 10) begin\r
				assign addra = {4'b0, A_ADDR[15:4]}*10;\r
			end\r
			else if (WIDTH_MODE_A <= 20) begin\r
				assign addra = {5'b0, A_ADDR[15:5]}*20;\r
			end\r
			else if (WIDTH_MODE_A <= 40) begin\r
				assign addra = {6'b0, A_ADDR[15:6]}*40;\r
			end\r
			// Port B\r
			if (WIDTH_MODE_B <= 1) begin\r
				wire [15:0] tmpb = {1'b0, B_ADDR[15:1]};\r
				assign addrb = tmpb + (tmpb/4);\r
			end\r
			else if (WIDTH_MODE_B <= 2) begin\r
				wire [15:0] tmpb = {2'b0, B_ADDR[15:2]};\r
				assign addrb = tmpb*2 + (tmpb/2);\r
			end\r
			else if (WIDTH_MODE_B <= 5) begin\r
				assign addrb = {3'b0, B_ADDR[15:3]}*5;\r
			end\r
			else if (WIDTH_MODE_B <= 10) begin\r
				assign addrb = {4'b0, B_ADDR[15:4]}*10;\r
			end\r
			else if (WIDTH_MODE_B <= 20) begin\r
				assign addrb = {5'b0, B_ADDR[15:5]}*20;\r
			end\r
			else if (WIDTH_MODE_B <= 40) begin\r
				assign addrb = {6'b0, B_ADDR[15:6]}*40;\r
			end\r
		end\r
	endgenerate\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// SDP write port\r
			always @(posedge clka)\r
			begin\r
				for (k=0; k < A_WR_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ena && wea && B_BM[k-40]) memory[addra+k] <= B_DI[k-40];\r
					end\r
				end\r
			end\r
			// SDP read port\r
			always @(posedge clkb)\r
			begin\r
				for (k=0; k < B_RD_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (enb) A_DO_out[k] <= memory[addrb+k];\r
					end\r
					else begin // use both ports\r
						if (enb) B_DO_out[k-40] <= memory[addrb+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// {A,B}_ADDR[0]=0 selects lower, {A,B}_ADDR[0]=1 selects upper cascade memory\r
			wire upper_sel_a = ((CAS == "UPPER") && (A_ADDR[0] == 1));\r
			wire lower_sel_a = ((CAS == "LOWER") && (A_ADDR[0] == 0));\r
			wire upper_sel_b = ((CAS == "UPPER") && (B_ADDR[0] == 1));\r
			wire lower_sel_b = ((CAS == "LOWER") && (B_ADDR[0] == 0));\r
\r
			reg dumm;\r
\r
			// Cascade output port A\r
			always @(*)\r
			begin\r
				if ((A_WR_MODE == "NO_CHANGE") && lower_sel_a) begin\r
					A_CO = memory[addra];\r
				end\r
				else if ((A_WR_MODE == "WRITE_THROUGH") && lower_sel_a) begin\r
					A_CO = ((wea && A_BM[0]) ? (A_DI[0]) : (memory[addra]));\r
				end\r
			end\r
\r
			// Cascade output port B\r
			always @(*)\r
			begin\r
				if ((B_WR_MODE == "NO_CHANGE") && lower_sel_b) begin\r
					B_CO = memory[addrb];\r
				end\r
				else if ((B_WR_MODE == "WRITE_THROUGH") && lower_sel_b) begin\r
					B_CO = ((web && B_BM[0]) ? (B_DI[0]) : (memory[addrb]));\r
				end\r
			end\r
\r
			// TDP port A\r
			always @(posedge clka)\r
			begin\r
				for (i=0; i < WIDTH_MODE_A; i=i+1) begin\r
					if (upper_sel_a || lower_sel_a || (CAS == "NONE")) begin\r
						if (ena && wea && A_BM[i])\r
							memory[addra+i] <= A_DI[i];\r
					end\r
\r
					if (A_WR_MODE == "NO_CHANGE") begin\r
						if (ena && !wea) begin\r
							if (CAS == "UPPER") begin\r
								A_DO_out[i] <= ((A_ADDR[0] == 1) ? (memory[addra+i]) : (A_CI));\r
							end\r
							else if (CAS == "NONE") begin\r
								A_DO_out[i] <= memory[addra+i];\r
							end\r
						end\r
					end\r
					else if (A_WR_MODE == "WRITE_THROUGH") begin\r
						if (ena) begin\r
							if (CAS == "UPPER") begin\r
								if (A_ADDR[0] == 1) begin\r
									A_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\r
								end else begin\r
									A_DO_out[i] <= A_CI;\r
								end\r
							end\r
							else if (CAS == "NONE") begin\r
								A_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\r
							end\r
						end\r
					end\r
				end\r
			end\r
			// TDP port B\r
			always @(posedge clkb)\r
			begin\r
				for (i=0; i < WIDTH_MODE_B; i=i+1) begin\r
					if (upper_sel_b || lower_sel_b || (CAS == "NONE")) begin\r
						if (enb && web && B_BM[i])\r
							memory[addrb+i] <= B_DI[i];\r
					end\r
\r
					if (B_WR_MODE == "NO_CHANGE") begin\r
						if (enb && !web) begin\r
							if (CAS == "UPPER") begin\r
								B_DO_out[i] <= ((B_ADDR[0] == 1) ? (memory[addrb+i]) : (B_CI));\r
							end\r
							else if (CAS == "NONE") begin\r
								B_DO_out[i] <= memory[addrb+i];\r
							end\r
						end\r
					end\r
					else if (B_WR_MODE == "WRITE_THROUGH") begin\r
						if (enb) begin\r
							if (CAS == "UPPER") begin\r
								if (B_ADDR[0] == 1) begin\r
									B_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\r
								end else begin\r
									B_DO_out[i] <= B_CI;\r
								end\r
							end\r
							else if (CAS == "NONE") begin\r
								B_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\r
							end\r
						end\r
					end\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge clka) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge clkb) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
module CC_FIFO_40K (\r
	output A_ECC_1B_ERR,\r
	output B_ECC_1B_ERR,\r
	output A_ECC_2B_ERR,\r
	output B_ECC_2B_ERR,\r
	// FIFO pop port\r
	output [39:0] A_DO,\r
	output [39:0] B_DO,\r
	(* clkbuf_sink *)\r
	input  A_CLK,\r
	input  A_EN,\r
	// FIFO push port\r
	input  [39:0] A_DI,\r
	input  [39:0] B_DI,\r
	input  [39:0] A_BM,\r
	input  [39:0] B_BM,\r
	(* clkbuf_sink *)\r
	input  B_CLK,\r
	input  B_EN,\r
	input  B_WE,\r
	// FIFO control\r
	input  F_RST_N,\r
	input  [14:0] F_ALMOST_FULL_OFFSET,\r
	input  [14:0] F_ALMOST_EMPTY_OFFSET,\r
	// FIFO status signals\r
	output F_FULL,\r
	output F_EMPTY,\r
	output F_ALMOST_FULL,\r
	output F_ALMOST_EMPTY,\r
	output F_RD_ERROR,\r
	output F_WR_ERROR,\r
	output [15:0] F_RD_PTR,\r
	output [15:0] F_WR_PTR\r
);\r
	// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
\r
	// Offset configuration\r
	parameter DYN_STAT_SELECT = 1'b0;\r
	parameter [14:0] ALMOST_FULL_OFFSET = 15'b0;\r
	parameter [14:0] ALMOST_EMPTY_OFFSET = 15'b0;\r
\r
	// Port Widths\r
	parameter A_WIDTH = 0;\r
	parameter B_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "TDP"; // "TDP" or "SDP"\r
	parameter FIFO_MODE = "SYNC"; // "ASYNC" or "SYNC"\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter A_ECC_EN  = 1'b0;\r
	parameter B_ECC_EN  = 1'b0;\r
\r
	integer i, k;\r
\r
	// 512 x 80 bit\r
	reg [40959:0] memory = 40960'b0;\r
\r
	reg [15:0] counter_max;\r
	reg [15:0] sram_depth;\r
	localparam tp = (A_WIDTH ==  1) ? 15 :\r
					(A_WIDTH ==  2) ? 14 :\r
					(A_WIDTH ==  5) ? 13 :\r
					(A_WIDTH == 10) ? 12 :\r
					(A_WIDTH == 20) ? 11 :\r
					(A_WIDTH == 40) ? 10 : 9;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((FIFO_MODE != "ASYNC") && (FIFO_MODE != "SYNC")) begin\r
			$display("ERROR: Illegal FIFO MODE %d.", FIFO_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (DYN_STAT_SELECT == 1)) begin\r
			$display("ERROR: Dynamic offset configuration is not supported in %s mode.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && ((A_WIDTH != 80) || (B_WIDTH != 80))) begin\r
			$display("ERROR: SDP is ony supported in 80 bit mode.");\r
			$finish();\r
		end\r
		if ((A_WIDTH == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((B_WIDTH == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((A_WIDTH != 80) && (A_WIDTH != 40) && (A_WIDTH != 20) && (A_WIDTH != 10) &&\r
			(A_WIDTH != 5)  && (A_WIDTH != 2)  && (A_WIDTH != 1) && (A_WIDTH != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, A_WIDTH);\r
			$finish();\r
		end\r
		if ((B_WIDTH != 80) && (B_WIDTH != 40) && (B_WIDTH != 20) && (B_WIDTH != 10) &&\r
			(B_WIDTH != 5)  && (B_WIDTH != 2)  && (B_WIDTH != 1) && (B_WIDTH != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, B_WIDTH);\r
			$finish();\r
		end\r
		if (A_WIDTH != B_WIDTH) begin\r
			$display("ERROR: The values of A_WIDTH and B_WIDTH must be equal.");\r
		end\r
		if ((A_ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (A_WIDTH != 40)) begin\r
			$display("ERROR: Illegal ECC Port A configuration. ECC mode requires TDP >=40 bit or SDP 80 bit, but is %s %d.", RAM_MODE, A_WIDTH);\r
			$finish();\r
		end\r
		// Set local parameters\r
		if (A_WIDTH == 1) begin // A_WIDTH=B_WIDTH\r
			counter_max = 2 * 32*1024 - 1;\r
			sram_depth  =     32*1024;\r
		end\r
		else if (A_WIDTH == 2) begin\r
			counter_max = 2 * 16*1024 - 1;\r
			sram_depth  =     16*1024;\r
		end\r
		else if (A_WIDTH == 5) begin\r
			counter_max = 2 * 8*1024 - 1;\r
			sram_depth  =     8*1024;\r
		end\r
		else if (A_WIDTH == 10) begin\r
			counter_max = 2 * 4*1024 - 1;\r
			sram_depth  =     4*1024;\r
		end\r
		else if (A_WIDTH == 20) begin\r
			counter_max = 2 * 2*1024 - 1;\r
			sram_depth  =     2*1024;\r
		end\r
		else if (A_WIDTH == 40) begin\r
			counter_max = 2 * 1*1024 - 1;\r
			sram_depth  =     1*1024;\r
		end\r
		else begin // 80 bit SDP\r
			counter_max = 2 * 512 - 1;\r
			sram_depth  =     512;\r
		end\r
	end\r
\r
	// Internal signals\r
	wire fifo_rdclk = A_CLK ^ A_CLK_INV;\r
	wire fifo_wrclk = (FIFO_MODE == "ASYNC") ? (B_CLK ^ B_CLK_INV) : (A_CLK ^ A_CLK_INV);\r
	wire [15:0] almost_full_offset  = DYN_STAT_SELECT ? F_ALMOST_FULL_OFFSET  : ALMOST_FULL_OFFSET;\r
	wire [15:0] almost_empty_offset = DYN_STAT_SELECT ? F_ALMOST_EMPTY_OFFSET : ALMOST_EMPTY_OFFSET;\r
	reg  [39:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [39:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	// Status signals\r
	reg fifo_full;\r
	reg fifo_empty;\r
	reg fifo_almost_full;\r
	reg fifo_almost_empty;\r
	assign F_FULL         = fifo_full;\r
	assign F_EMPTY        = fifo_empty;\r
	assign F_ALMOST_FULL  = fifo_almost_full;\r
	assign F_ALMOST_EMPTY = fifo_almost_empty;\r
	assign F_WR_ERROR     = (F_FULL && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\r
	assign F_RD_ERROR     = (F_EMPTY && (A_EN ^ A_EN_INV));\r
	wire ram_we = (~F_FULL  && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\r
	wire ram_en = (~F_EMPTY && (A_EN ^ A_EN_INV));\r
\r
	// Reset synchronizers\r
	reg  [1:0] aclk_reset_q, bclk_reset_q;\r
	wire fifo_sync_rstn    = aclk_reset_q;\r
	wire fifo_async_wrrstn = bclk_reset_q;\r
	wire fifo_async_rdrstn = aclk_reset_q;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			aclk_reset_q <= 2'b0;\r
		end\r
		else begin\r
			aclk_reset_q[1] <= aclk_reset_q[0];\r
			aclk_reset_q[0] <= 1'b1;\r
		end\r
	end\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			bclk_reset_q <= 2'b0;\r
		end\r
		else begin\r
			bclk_reset_q[1] <= bclk_reset_q[0];\r
			bclk_reset_q[0] <= 1'b1;\r
		end\r
	end\r
\r
	// Push/pop pointers\r
	reg  [15:0] rd_pointer, rd_pointer_int;\r
	reg  [15:0] wr_pointer, wr_pointer_int;\r
	reg  [15:0] rd_pointer_cmp, wr_pointer_cmp;\r
	wire [15:0] rd_pointer_nxt;\r
	wire [15:0] wr_pointer_nxt;\r
	reg  [15:0] fifo_rdaddr, rdaddr;\r
	reg  [15:0] fifo_wraddr, wraddr;\r
	assign F_RD_PTR = fifo_rdaddr;\r
	assign F_WR_PTR = fifo_wraddr;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			rd_pointer <= 0;\r
			rd_pointer_int <= 0;\r
		end\r
		else if (ram_en) begin\r
			rd_pointer <= rd_pointer_nxt;\r
			rd_pointer_int <= rd_pointer_nxt[15:1] ^ rd_pointer_nxt[14:0];\r
		end\r
	end\r
\r
	assign rd_pointer_nxt = (rd_pointer == counter_max) ? (0) : (rd_pointer + 1'b1);\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			wr_pointer <= 0;\r
			wr_pointer_int <= 0;\r
		end\r
		else if (ram_we) begin\r
			wr_pointer <= wr_pointer_nxt;\r
			wr_pointer_int <= wr_pointer_nxt[15:1] ^ wr_pointer_nxt[14:0];\r
		end\r
	end\r
\r
	assign wr_pointer_nxt = (wr_pointer == counter_max) ? (0) : (wr_pointer + 1'b1);\r
\r
	// Address synchronizers\r
	reg [15:0] rd_pointer_sync, wr_pointer_sync;\r
	reg [15:0] rd_pointer_sync_0, rd_pointer_sync_1;\r
	reg [15:0] wr_pointer_sync_0, wr_pointer_sync_1;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			wr_pointer_sync_0 <= 0;\r
			wr_pointer_sync_1 <= 0;\r
		end\r
		else begin\r
			wr_pointer_sync_0 <= wraddr;\r
			wr_pointer_sync_1 <= wr_pointer_sync_0;\r
		end\r
	 end\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	 begin\r
		if (F_RST_N == 1'b0) begin\r
			rd_pointer_sync_0 <= 0;\r
			rd_pointer_sync_1 <= 0;\r
		end\r
		else begin\r
			rd_pointer_sync_0 <= rdaddr;\r
			rd_pointer_sync_1 <= rd_pointer_sync_0;\r
		end\r
	 end\r
\r
	always @(*) begin\r
		fifo_wraddr = {wr_pointer[tp-1:0], {(15-tp){1'b0}}};\r
		fifo_rdaddr = {rd_pointer[tp-1:0], {(15-tp){1'b0}}};\r
\r
		rdaddr = {rd_pointer[tp], rd_pointer_int[tp-1:0]};\r
		wraddr = {{(15-tp){1'b0}}, wr_pointer[tp], wr_pointer_int[tp:0]};\r
\r
		if (FIFO_MODE == "ASYNC")\r
			fifo_full = (wraddr[tp-2:0] == rd_pointer_sync_1[tp-2:0] ) && (wraddr[tp] != rd_pointer_sync_1[tp] ) && ( wraddr[tp-1] != rd_pointer_sync_1[tp-1] );\r
		else\r
			fifo_full = (wr_pointer[tp-1:0] == rd_pointer[tp-1:0]) && (wr_pointer[tp] ^ rd_pointer[tp]);\r
\r
		if (FIFO_MODE == "ASYNC")\r
			fifo_empty = (wr_pointer_sync_1[tp:0] == rdaddr[tp:0]);\r
		else\r
			fifo_empty = (wr_pointer[tp:0] == rd_pointer[tp:0]);\r
\r
		rd_pointer_cmp = (FIFO_MODE == "ASYNC") ? rd_pointer_sync : rd_pointer;\r
		if (wr_pointer[tp] == rd_pointer_cmp[tp])\r
			fifo_almost_full = ((wr_pointer[tp-1:0] - rd_pointer_cmp[tp-1:0]) >= (sram_depth - almost_full_offset));\r
		else\r
			fifo_almost_full = ((rd_pointer_cmp[tp-1:0] - wr_pointer[tp-1:0]) <= almost_full_offset);\r
\r
		wr_pointer_cmp = (FIFO_MODE == "ASYNC") ? wr_pointer_sync : wr_pointer;\r
		if (wr_pointer_cmp[tp] == rd_pointer[tp])\r
			fifo_almost_empty = ((wr_pointer_cmp[tp-1:0] - rd_pointer[tp-1:0]) <= almost_empty_offset);\r
		else\r
			fifo_almost_empty = ((rd_pointer[tp-1:0] - wr_pointer_cmp[tp-1:0]) >= (sram_depth - almost_empty_offset));\r
	end\r
\r
	generate\r
		always @(*) begin\r
			wr_pointer_sync = 0;\r
			rd_pointer_sync = 0;\r
			for (i=tp; i >= 0; i=i-1) begin\r
				if (i == tp) begin\r
					wr_pointer_sync[i] = wr_pointer_sync_1[i];\r
					rd_pointer_sync[i] = rd_pointer_sync_1[i];\r
				end\r
				else begin\r
					wr_pointer_sync[i] = wr_pointer_sync_1[i] ^ wr_pointer_sync[i+1];\r
					rd_pointer_sync[i] = rd_pointer_sync_1[i] ^ rd_pointer_sync[i+1];\r
				end\r
			end\r
		end\r
		if (RAM_MODE == "SDP") begin\r
			// SDP push ports A+B\r
			always @(posedge fifo_wrclk)\r
			begin\r
				for (k=0; k < A_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ram_we && A_BM[k]) memory[fifo_wraddr+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ram_we && B_BM[k-40]) memory[fifo_wraddr+k] <= B_DI[k-40];\r
					end\r
				end\r
			end\r
			// SDP pop ports A+B\r
			always @(posedge fifo_rdclk)\r
			begin\r
				for (k=0; k < B_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ram_en) A_DO_out[k] <= memory[fifo_rdaddr+k];\r
					end\r
					else begin // use both ports\r
						if (ram_en) B_DO_out[k-40] <= memory[fifo_rdaddr+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// TDP pop port A\r
			always @(posedge fifo_rdclk)\r
			begin\r
				for (i=0; i < A_WIDTH; i=i+1) begin\r
					if (ram_en) begin\r
						A_DO_out[i] <= memory[fifo_rdaddr+i];\r
					end\r
				end\r
			end\r
			// TDP push port B\r
			always @(posedge fifo_wrclk)\r
			begin\r
				for (i=0; i < B_WIDTH; i=i+1) begin\r
					if (ram_we && B_BM[i])\r
						memory[fifo_wraddr+i] <= B_DI[i];\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge fifo_rdclk) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge fifo_rdclk) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
// Models of the LUT2 tree primitives\r
module CC_L2T4(\r
	output O,\r
	input I0, I1, I2, I3\r
);\r
	parameter [3:0] INIT_L00 = 4'b0000;\r
	parameter [3:0] INIT_L01 = 4'b0000;\r
	parameter [3:0] INIT_L10 = 4'b0000;\r
\r
	wire [1:0] l00_s1 = I1 ? INIT_L00[3:2] : INIT_L00[1:0];\r
	wire l00 = I0 ? l00_s1[1] : l00_s1[0];\r
\r
	wire [1:0] l01_s1 = I3 ? INIT_L01[3:2] : INIT_L01[1:0];\r
	wire l01 = I2 ? l01_s1[1] : l01_s1[0];\r
\r
	wire [1:0] l10_s1 = l01 ? INIT_L10[3:2] : INIT_L10[1:0];\r
	assign O = l00 ? l10_s1[1] : l10_s1[0];\r
\r
endmodule\r
\r
\r
module CC_L2T5(\r
	output O,\r
	input I0, I1, I2, I3, I4\r
);\r
	parameter [3:0] INIT_L02 = 4'b0000;\r
	parameter [3:0] INIT_L03 = 4'b0000;\r
	parameter [3:0] INIT_L11 = 4'b0000;\r
	parameter [3:0] INIT_L20 = 4'b0000;\r
\r
	wire [1:0] l02_s1 = I1 ? INIT_L02[3:2] : INIT_L02[1:0];\r
	wire l02 = I0 ? l02_s1[1] : l02_s1[0];\r
\r
	wire [1:0] l03_s1 = I3 ? INIT_L03[3:2] : INIT_L03[1:0];\r
	wire l03 = I2 ? l03_s1[1] : l03_s1[0];\r
\r
	wire [1:0] l11_s1 = l03 ? INIT_L11[3:2] : INIT_L11[1:0];\r
	wire l11 = l02 ? l11_s1[1] : l11_s1[0];\r
\r
	wire [1:0] l20_s1 = l11 ? INIT_L20[3:2] : INIT_L20[1:0];\r
	assign O = I4 ? l20_s1[1] : l20_s1[0];\r
\r
endmodule\r
`,"inv_map.v":`// Any inverters not folded into LUTs are mapped to a LUT of their own
module \\$__CC_NOT (input A, output Y);
	CC_LUT1 #(.INIT(2'b01)) _TECHMAP_REPLACE_ (.I0(A), .O(Y));
endmodule
`,"lut_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
module \\$lut (A, Y);\r
	parameter WIDTH = 0;\r
	parameter LUT = 0;\r
\r
	(* force_downto *)\r
	input [WIDTH-1:0] A;\r
	output Y;\r
\r
	generate\r
		if (WIDTH == 1) begin\r
			CC_LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));\r
		end\r
		else if (WIDTH == 2) begin\r
			CC_LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));\r
		end\r
		else if (WIDTH == 3) begin\r
			CC_LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));\r
		end\r
		else if (WIDTH == 4) begin\r
			CC_LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\r
		end\r
		else begin\r
			wire _TECHMAP_FAIL_ = 1;\r
		end\r
	endgenerate\r
endmodule\r
`,"lut_tree_cells.genlib":`GATE $__ZERO 0 Y=CONST0;
GATE $__ONE 0 Y=CONST1;

GATE $__CC_BUF 5 Y=A;
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC_NOT 0 Y=!A;
PIN * INV 1 9999 10 5 10 5

GATE $__CC_MUX 5 Y=((A*!C)+(B*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_A 10 Y=(A*B);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_A_O 12 Y=(E+(A*B));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_A_X 12 Y=((E*(!A+!B))+(!E*(A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_O 10 Y=(A+B);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_O_A 12 Y=(E*(A+B));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_O_X 12 Y=((E*(!A*!B))+(!E*(A+B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_X 10 Y=((A*!B)+(!A*B));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_X_A 12 Y=(E*((A*!B)+(!A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_X_O 12 Y=(E+((A*!B)+(!A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AA 10 Y=((A*B)*C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AA_O 12 Y=(E+((A*B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AA_X 12 Y=((E*((!A+!B)+!C))+(!E*((A*B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_OO 10 Y=((A+B)+C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OO_A 12 Y=(E*((A+B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OO_X 12 Y=((E*((!A*!B)*!C))+(!E*((A+B)+C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_XX 10 Y=((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XX_A 12 Y=(E*((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XX_O 12 Y=(E+((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AO 10 Y=((A*B)+C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_A 12 Y=(E*((A*B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_O 12 Y=(E+((A*B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_X 12 Y=((E*((!A+!B)*!C))+(!E*((A*B)+C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_OA 10 Y=((A+B)*C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_A 12 Y=(E*((A+B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_O 12 Y=(E+((A+B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_X 12 Y=((E*((!A*!B)+!C))+(!E*((A+B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AX 10 Y=(((A*B)*!C)+((!A+!B)*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_A 12 Y=(E*(((A*B)*!C)+((!A+!B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_O 12 Y=(E+(((A*B)*!C)+((!A+!B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_X 12 Y=((E*(((!A+!B)+C)*((A*B)+!C)))+(!E*(((A*B)*!C)+((!A+!B)*C))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_XA 10 Y=(((A*!B)+(!A*B))*C);
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_A 12 Y=(E*(((A*!B)+(!A*B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_O 12 Y=(E+(((A*!B)+(!A*B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_X 12 Y=((E*(((!A+B)*(A+!B))+!C))+(!E*(((A*!B)+(!A*B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAA 10 Y=((A*B)*(C*D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_A 12 Y=(E*((A*B)*(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_O 12 Y=(E+((A*B)*(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_X 12 Y=((E*((!A+!B)+(!C+!D)))+(!E*((A*B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AXA 10 Y=(((A*B)*(!C+!D))+((!A+!B)*(C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_A 12 Y=(E*(((A*B)*(!C+!D))+((!A+!B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_O 12 Y=(E+(((A*B)*(!C+!D))+((!A+!B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_X 12 Y=((E*(((!A+!B)+(C*D))*((A*B)+(!C+!D))))+(!E*(((A*B)*(!C+!D))+((!A+!B)*(C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XAX 10 Y=(((A*!B)+(!A*B))*((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_A 12 Y=(E*(((A*!B)+(!A*B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_O 12 Y=(E+(((A*!B)+(!A*B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_X 12 Y=((E*(((!A+B)*(A+!B))+((!C+D)*(C+!D))))+(!E*(((A*!B)+(!A*B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAX 10 Y=((A*B)*((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_A 12 Y=(E*((A*B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_O 12 Y=(E+((A*B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_X 12 Y=((E*((!A+!B)+((!C+D)*(C+!D))))+(!E*((A*B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AXX 10 Y=(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_A 12 Y=(E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_O 12 Y=(E+(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_X 12 Y=((E*(((!A+!B)+((C*!D)+(!C*D)))*((A*B)+((!C+D)*(C+!D)))))+(!E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XXX 10 Y=((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_A 12 Y=(E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_O 12 Y=(E+((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_X 12 Y=((E*((((!A+B)*(A+!B))+((C*!D)+(!C*D)))*(((A*!B)+(!A*B))+((!C+D)*(C+!D)))))+(!E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAO 10 Y=((A*B)*(C+D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_A 12 Y=(E*((A*B)*(C+D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_O 12 Y=(E+((A*B)*(C+D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_X 12 Y=((E*((!A+!B)+(!C*!D)))+(!E*((A*B)*(C+D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AOA 10 Y=((A*B)+(C*D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_A 12 Y=(E*((A*B)+(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_O 12 Y=(E+((A*B)+(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_X 12 Y=((E*((!A+!B)*(!C+!D)))+(!E*((A*B)+(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AOX 10 Y=((A*B)+((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_A 12 Y=(E*((A*B)+((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_O 12 Y=(E+((A*B)+((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_X 12 Y=((E*((!A+!B)*((!C+D)*(C+!D))))+(!E*((A*B)+((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5
`,"lut_tree_map.v":`
module \\$__ZERO (output Y); assign Y = 1'b0; endmodule
module \\$__ONE (output Y); assign Y = 1'b1; endmodule

module \\$__CC_BUF (input A, output Y); assign Y = A; endmodule

module \\$__CC_MUX (input A, B, C, output Y);
    CC_MX2 _TECHMAP_REPLACE_ (
        .D0(A), .D1(B), .S0(C),
        .Y(Y)
    );
endmodule


module \\$__CC2_A (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_A_O (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_A_X (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC2_O (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_O_A (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_O_X (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC2_X (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_X_A (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_X_O (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_AA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_OO (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_OO_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OO_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_XX (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_XX_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XX_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_AO (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_OA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_AX (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_XA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AXA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XAX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AXX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XXX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAO (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AOA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AOX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule
`,"mul_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$mul $__mul" *)
module \\$__MULMXN (A, B, Y);

	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	localparam A_ADJWIDTH = A_WIDTH + (A_SIGNED ? 0 : 1);
	localparam B_ADJWIDTH = B_WIDTH + (B_SIGNED ? 0 : 1);

	generate
		if (A_SIGNED) begin: blkA
			wire signed [A_ADJWIDTH-1:0] Aext = $signed(A);
		end
		else begin: blkA
			wire [A_ADJWIDTH-1:0] Aext = A;
		end
		if (B_SIGNED) begin: blkB
			wire signed [B_ADJWIDTH-1:0] Bext = $signed(B);
		end
		else begin: blkB
			wire [B_ADJWIDTH-1:0] Bext = B;
		end

		if (A_WIDTH >= B_WIDTH) begin
			CC_MULT #(
				.A_WIDTH(A_ADJWIDTH),
				.B_WIDTH(B_ADJWIDTH),
				.P_WIDTH(Y_WIDTH),
			) _TECHMAP_REPLACE_ (
				.A(blkA.Aext),
				.B(blkB.Bext),
				.P(Y)
			);
		end
		else begin // swap A,B
			CC_MULT #(
				.A_WIDTH(B_ADJWIDTH),
				.B_WIDTH(A_ADJWIDTH),
				.P_WIDTH(Y_WIDTH),
			) _TECHMAP_REPLACE_ (
				.A(blkB.Bext),
				.B(blkA.Aext),
				.P(Y)
			);
		end
	endgenerate

endmodule
`,"mux_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\r
	input  A, B, C, D, E, F, G, H, S, T, U;\r
	output Y;\r
\r
	CC_MX8 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .D2(C), .D3(D),\r
		.D4(E), .D5(F), .D6(G), .D7(H),\r
		.S0(S), .S1(T), .S2(U),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
\r
module \\$_MUX4_ (A, B, C, D, S, T, Y);\r
	input  A, B, C, D, S, T;\r
	output Y;\r
\r
	CC_MX4 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .D2(C), .D3(D),\r
		.S0(S), .S1(T),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
\r
/*\r
module \\$_MUX_ (A, B, S, Y);\r
	input  A, B, S;\r
	output Y;\r
\r
	CC_MX2 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .S0(S),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
*/\r
`,"reg_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* techmap_celltype = "$_DFFE_[NP][NP][01][NP]_" *)\r
module \\$_DFFE_xxxx_ (input D, C, R, E, output Q);\r
\r
	parameter _TECHMAP_CELLTYPE_ = "";\r
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\r
\r
	CC_DFF #(\r
		.CLK_INV(_TECHMAP_CELLTYPE_[39:32] == "N"),\r
		.EN_INV(_TECHMAP_CELLTYPE_[15:8] == "N"),\r
		.SR_INV(_TECHMAP_CELLTYPE_[31:24] == "N"),\r
		.SR_VAL(_TECHMAP_CELLTYPE_[23:16] == "1"),\r
		.INIT(_TECHMAP_WIREINIT_Q_)\r
	) _TECHMAP_REPLACE_ (.D(D), .EN(E), .CLK(C), .SR(R), .Q(Q));\r
\r
	wire _TECHMAP_REMOVEINIT_Q_ = 1;\r
endmodule\r
\r
(* techmap_celltype = "$_DLATCH_[NP][NP][01]_" *)\r
module \\$_DLATCH_xxx_ (input E, R, D, output Q);\r
\r
	parameter _TECHMAP_CELLTYPE_ = "";\r
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\r
\r
	CC_DLT #(\r
		.G_INV(_TECHMAP_CELLTYPE_[31:24] == "N"),\r
		.SR_INV(_TECHMAP_CELLTYPE_[23:16] == "N"),\r
		.SR_VAL(_TECHMAP_CELLTYPE_[15:8] == "1"),\r
		.INIT(_TECHMAP_WIREINIT_Q_)\r
	) _TECHMAP_REPLACE_ (.D(D), .G(E), .SR(R), .Q(Q));\r
\r
	wire _TECHMAP_REMOVEINIT_Q_ = 1;\r
endmodule\r
`},gowin:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_gw1n_alu(A, B, CI, BI, X, Y, CO);
   parameter A_SIGNED = 0;
   parameter B_SIGNED = 0;
   parameter A_WIDTH = 1;
   parameter B_WIDTH = 1;
   parameter Y_WIDTH = 1;

   (* force_downto *)
   input [A_WIDTH-1:0] A;
   (* force_downto *)
   input [B_WIDTH-1:0] B;
   (* force_downto *)
   output [Y_WIDTH-1:0] X, Y;

   input 		CI, BI;
   (* force_downto *)
   output [Y_WIDTH-1:0] CO;

   wire 		_TECHMAP_FAIL_ = Y_WIDTH <= 2;

   (* force_downto *)
   wire [Y_WIDTH-1:0] 	A_buf, B_buf;
   \\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
   \\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

   (* force_downto *)
   wire [Y_WIDTH-1:0] 	AA = A_buf;
   (* force_downto *)
   wire [Y_WIDTH-1:0] 	BB = B_buf;
   (* force_downto *)
   wire [Y_WIDTH-1:0] 	C = {CO, CI};

   genvar 		i;
   generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
      ALU #(.ALU_MODE(2)) // ADDSUB I3 ? add : sub
      alu(.I0(AA[i]),
	  .I1(BB[i]),
	  .I3(~BI),
	  .CIN(C[i]),
	  .COUT(CO[i]),
	  .SUM(Y[i])
	  );
   end endgenerate
   assign X = AA ^ BB ^ {Y_WIDTH{BI}};
endmodule

`,"brams.txt":`ram block $__GOWIN_SP_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	cost 128;
	init no_undef;
	port srsw "A" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		portoption "WRITE_MODE" 0 {
			rdwr no_change;
		}
		portoption "WRITE_MODE" 1 {
			rdwr new;
		}
		portoption "WRITE_MODE" 2 {
			rdwr old;
		}
	}
}

ram block $__GOWIN_DP_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		portoption "WRITE_MODE" 0 {
			rdwr no_change;
		}
		portoption "WRITE_MODE" 1 {
			rdwr new;
		}
		portoption "WRITE_MODE" 2 {
			rdwr old;
		}
	}
}

ram block $__GOWIN_SDP_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	cost 128;
	init no_undef;
	port sr "R" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		clock posedge;
		clken;
	}
}
`,"brams_map.v":`\`define DEF_FUNCS \\
	function [255:0] init_slice_x8; \\
		input integer idx; \\
		integer i; \\
		for (i = 0; i < 32; i = i + 1) begin \\
			init_slice_x8[i*8+:8] = INIT[(idx * 32 + i) * 9+:8]; \\
		end \\
	endfunction \\
	function [287:0] init_slice_x9; \\
		input integer idx; \\
		init_slice_x9 = INIT[idx * 288+:288]; \\
	endfunction \\

\`define x8_width(width) (width / 9 * 8 + width % 9)
\`define x8_rd_data(data) {1'bx, data[31:24], 1'bx, data[23:16], 1'bx, data[15:8], 1'bx, data[7:0]}
\`define x8_wr_data(data) {data[34:27], data[25:18], data[16:9], data[7:0]}
\`define addrbe_always(width, addr) (width < 18 ? addr :  width == 18 ? {addr[13:4], 4'b0011} : {addr[13:5], 5'b01111})


\`define INIT(func) \\
	.INIT_RAM_00(func('h00)), \\
	.INIT_RAM_01(func('h01)), \\
	.INIT_RAM_02(func('h02)), \\
	.INIT_RAM_03(func('h03)), \\
	.INIT_RAM_04(func('h04)), \\
	.INIT_RAM_05(func('h05)), \\
	.INIT_RAM_06(func('h06)), \\
	.INIT_RAM_07(func('h07)), \\
	.INIT_RAM_08(func('h08)), \\
	.INIT_RAM_09(func('h09)), \\
	.INIT_RAM_0A(func('h0a)), \\
	.INIT_RAM_0B(func('h0b)), \\
	.INIT_RAM_0C(func('h0c)), \\
	.INIT_RAM_0D(func('h0d)), \\
	.INIT_RAM_0E(func('h0e)), \\
	.INIT_RAM_0F(func('h0f)), \\
	.INIT_RAM_10(func('h10)), \\
	.INIT_RAM_11(func('h11)), \\
	.INIT_RAM_12(func('h12)), \\
	.INIT_RAM_13(func('h13)), \\
	.INIT_RAM_14(func('h14)), \\
	.INIT_RAM_15(func('h15)), \\
	.INIT_RAM_16(func('h16)), \\
	.INIT_RAM_17(func('h17)), \\
	.INIT_RAM_18(func('h18)), \\
	.INIT_RAM_19(func('h19)), \\
	.INIT_RAM_1A(func('h1a)), \\
	.INIT_RAM_1B(func('h1b)), \\
	.INIT_RAM_1C(func('h1c)), \\
	.INIT_RAM_1D(func('h1d)), \\
	.INIT_RAM_1E(func('h1e)), \\
	.INIT_RAM_1F(func('h1f)), \\
	.INIT_RAM_20(func('h20)), \\
	.INIT_RAM_21(func('h21)), \\
	.INIT_RAM_22(func('h22)), \\
	.INIT_RAM_23(func('h23)), \\
	.INIT_RAM_24(func('h24)), \\
	.INIT_RAM_25(func('h25)), \\
	.INIT_RAM_26(func('h26)), \\
	.INIT_RAM_27(func('h27)), \\
	.INIT_RAM_28(func('h28)), \\
	.INIT_RAM_29(func('h29)), \\
	.INIT_RAM_2A(func('h2a)), \\
	.INIT_RAM_2B(func('h2b)), \\
	.INIT_RAM_2C(func('h2c)), \\
	.INIT_RAM_2D(func('h2d)), \\
	.INIT_RAM_2E(func('h2e)), \\
	.INIT_RAM_2F(func('h2f)), \\
	.INIT_RAM_30(func('h30)), \\
	.INIT_RAM_31(func('h31)), \\
	.INIT_RAM_32(func('h32)), \\
	.INIT_RAM_33(func('h33)), \\
	.INIT_RAM_34(func('h34)), \\
	.INIT_RAM_35(func('h35)), \\
	.INIT_RAM_36(func('h36)), \\
	.INIT_RAM_37(func('h37)), \\
	.INIT_RAM_38(func('h38)), \\
	.INIT_RAM_39(func('h39)), \\
	.INIT_RAM_3A(func('h3a)), \\
	.INIT_RAM_3B(func('h3b)), \\
	.INIT_RAM_3C(func('h3c)), \\
	.INIT_RAM_3D(func('h3d)), \\
	.INIT_RAM_3E(func('h3e)), \\
	.INIT_RAM_3F(func('h3f)),

module $__GOWIN_SP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_A_WIDTH = 36;
parameter PORT_A_OPTION_WRITE_MODE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

\`DEF_FUNCS

wire RST = OPTION_RESET_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire [13:0] AD = \`addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);

generate

if (PORT_A_WIDTH < 9) begin

	wire [31:0] DI = \`x8_wr_data(PORT_A_WR_DATA);
	wire [31:0] DO;

	assign PORT_A_RD_DATA = \`x8_rd_data(DO);

	SP #(
		\`INIT(init_slice_x8)
		.READ_MODE(1'b0),
		.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),
		.BIT_WIDTH(\`x8_width(PORT_A_WIDTH)),
		.BLK_SEL(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSEL(3'b000),
		.CLK(PORT_A_CLK),
		.CE(PORT_A_CLK_EN),
		.WRE(PORT_A_WR_EN),
		.RESET(RST),
		.OCE(1'b1),
		.AD(AD),
		.DI(DI),
		.DO(DO),
	);

end else begin

	wire [35:0] DI = PORT_A_WR_DATA;
	wire [35:0] DO;

	assign PORT_A_RD_DATA = DO;

	SPX9 #(
		\`INIT(init_slice_x9)
		.READ_MODE(1'b0),
		.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),
		.BIT_WIDTH(PORT_A_WIDTH),
		.BLK_SEL(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSEL(3'b000),
		.CLK(PORT_A_CLK),
		.CE(PORT_A_CLK_EN),
		.WRE(PORT_A_WR_EN),
		.RESET(RST),
		.OCE(1'b1),
		.AD(AD),
		.DI(DI),
		.DO(DO),
	);

end

endgenerate

endmodule


module $__GOWIN_DP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_OPTION_WRITE_MODE = 0;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_OPTION_WRITE_MODE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_A_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_B_RD_DATA;

\`DEF_FUNCS

wire RSTA = OPTION_RESET_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire RSTB = OPTION_RESET_MODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST;
wire [13:0] ADA = \`addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);
wire [13:0] ADB = \`addrbe_always(PORT_B_WIDTH, PORT_B_ADDR);

generate

if (PORT_A_WIDTH < 9 || PORT_B_WIDTH < 9) begin

	wire [15:0] DIA = \`x8_wr_data(PORT_A_WR_DATA);
	wire [15:0] DIB = \`x8_wr_data(PORT_B_WR_DATA);
	wire [15:0] DOA;
	wire [15:0] DOB;

	assign PORT_A_RD_DATA = \`x8_rd_data(DOA);
	assign PORT_B_RD_DATA = \`x8_rd_data(DOB);

	DPB #(
		\`INIT(init_slice_x8)
		.READ_MODE0(1'b0),
		.READ_MODE1(1'b0),
		.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),
		.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),
		.BIT_WIDTH_0(\`x8_width(PORT_A_WIDTH)),
		.BIT_WIDTH_1(\`x8_width(PORT_B_WIDTH)),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_A_CLK),
		.CEA(PORT_A_CLK_EN),
		.WREA(PORT_A_WR_EN),
		.RESETA(RSTA),
		.OCEA(1'b1),
		.ADA(ADA),
		.DIA(DIA),
		.DOA(DOA),

		.CLKB(PORT_B_CLK),
		.CEB(PORT_B_CLK_EN),
		.WREB(PORT_B_WR_EN),
		.RESETB(RSTB),
		.OCEB(1'b1),
		.ADB(ADB),
		.DIB(DIB),
		.DOB(DOB),
	);

end else begin

	wire [17:0] DIA = PORT_A_WR_DATA;
	wire [17:0] DIB = PORT_B_WR_DATA;
	wire [17:0] DOA;
	wire [17:0] DOB;

	assign PORT_A_RD_DATA = DOA;
	assign PORT_B_RD_DATA = DOB;

	DPX9B #(
		\`INIT(init_slice_x9)
		.READ_MODE0(1'b0),
		.READ_MODE1(1'b0),
		.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),
		.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),
		.BIT_WIDTH_0(PORT_A_WIDTH),
		.BIT_WIDTH_1(PORT_B_WIDTH),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_A_CLK),
		.CEA(PORT_A_CLK_EN),
		.WREA(PORT_A_WR_EN),
		.RESETA(RSTA),
		.OCEA(1'b1),
		.ADA(ADA),
		.DIA(DIA),
		.DOA(DOA),

		.CLKB(PORT_B_CLK),
		.CEB(PORT_B_CLK_EN),
		.WREB(PORT_B_WR_EN),
		.RESETB(RSTB),
		.OCEB(1'b1),
		.ADB(ADB),
		.DIB(DIB),
		.DOB(DOB),
	);

end

endgenerate

endmodule


module $__GOWIN_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_R_WIDTH = 18;
parameter PORT_W_WIDTH = 18;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input PORT_W_WR_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

\`DEF_FUNCS

wire RST = OPTION_RESET_MODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST;
wire [13:0] ADW = \`addrbe_always(PORT_W_WIDTH, PORT_W_ADDR);
wire WRE = PORT_W_CLK_EN & PORT_W_WR_EN;

generate

if (PORT_W_WIDTH < 9 || PORT_R_WIDTH < 9) begin

	wire [31:0] DI = \`x8_wr_data(PORT_W_WR_DATA);
	wire [31:0] DO;

	assign PORT_R_RD_DATA = \`x8_rd_data(DO);

	SDPB #(
		\`INIT(init_slice_x8)
		.READ_MODE(1'b0),
		.BIT_WIDTH_0(\`x8_width(PORT_W_WIDTH)),
		.BIT_WIDTH_1(\`x8_width(PORT_R_WIDTH)),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_W_CLK),
		.CEA(WRE),
		.RESETA(1'b0),
		.ADA(ADW),
		.DI(DI),

		.CLKB(PORT_R_CLK),
		.CEB(PORT_R_CLK_EN),
		.RESETB(RST),
		.OCE(1'b1),
		.ADB(PORT_R_ADDR),
		.DO(DO),
	);

end else begin

	wire [35:0] DI = PORT_W_WR_DATA;
	wire [35:0] DO;

	assign PORT_R_RD_DATA = DO;

	SDPX9B #(
		\`INIT(init_slice_x9)
		.READ_MODE(1'b0),
		.BIT_WIDTH_0(PORT_W_WIDTH),
		.BIT_WIDTH_1(PORT_R_WIDTH),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_W_CLK),
		.CEA(WRE),
		.RESETA(1'b0),
		.ADA(ADW),
		.DI(DI),

		.CLKB(PORT_R_CLK),
		.CEB(PORT_R_CLK_EN),
		.RESETB(RST),
		.OCE(1'b1),
		.ADB(PORT_R_ADDR),
		.DO(DO),
	);

end

endgenerate

endmodule
`,"cells_map.v":`\`default_nettype none
//All DFF* have INIT, but the hardware is always initialised to the reset
//value regardless. The parameter is ignored.

// DFFN			 D Flip-Flop with Negative-Edge Clock
module	\\$_DFF_N_ (input D, C, output Q);
	DFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFF			 D Flip-Flop
module	\\$_DFF_P_ (input D, C, output Q);
	DFF _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFE			 D Flip-Flop with Clock Enable
module	\\$_DFFE_PP_ (input D, C, E, output Q);
	DFFE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNE		 D Flip-Flop with Negative-Edge Clock and Clock Enable
module	\\$_DFFE_NP_ (input D, C, E, output Q);
	DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFR			 D Flip-Flop with Synchronous Reset
module	\\$_SDFF_PP0_ (input D, C, R, output Q);
	DFFR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNR		 D Flip-Flop with Negative-Edge Clock and Synchronous Reset
module	\\$_SDFF_NP0_ (input D, C, R, output Q);
	DFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFRE		 D Flip-Flop with Clock Enable and Synchronous Reset
module	\\$_SDFFE_PP0P_ (input D, C, R, E, output Q);
	DFFRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNRE		 D Flip-Flop with Negative-Edge Clock,Clock Enable, and Synchronous Reset
module	\\$_SDFFE_NP0P_ (input D, C, R, E, output Q);
	DFFNRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFS			 D Flip-Flop with Synchronous Set
module	\\$_SDFF_PP1_ (input D, C, R, output Q);
	DFFS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNS		 D Flip-Flop with Negative-Edge Clock and Synchronous Set
module	\\$_SDFF_NP1_ (input D, C, R, output Q);
	DFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFSE		 D Flip-Flop with Clock Enable and Synchronous Set
module	\\$_SDFFE_PP1P_ (input D, C, R, E, output Q);
	DFFSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNSE		 D Flip-Flop with Negative-Edge Clock,Clock Enable,and Synchronous Set
module	\\$_SDFFE_NP1P_ (input D, C, R, E, output Q);
	DFFNSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFP			 D Flip-Flop with Asynchronous Preset
module	\\$_DFF_PP1_ (input D, C, R, output Q);
	DFFP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNP		 D Flip-Flop with Negative-Edge Clock and Asynchronous Preset
module	\\$_DFF_NP1_ (input D, C, R, output Q);
	DFFNP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFC			 D Flip-Flop with Asynchronous Clear
module	\\$_DFF_PP0_ (input D, C, R, output Q);
	DFFC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNC		 D Flip-Flop with Negative-Edge Clock and Asynchronous Clear
module	\\$_DFF_NP0_ (input D, C, R, output Q);
	DFFNC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFPE		 D Flip-Flop with Clock Enable and Asynchronous Preset
module	\\$_DFFE_PP1P_ (input D, C, R, E, output Q);
	DFFPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNPE		 D Flip-Flop with Negative-Edge Clock,Clock Enable, and Asynchronous Preset
module	\\$_DFFE_NP1P_ (input D, C, R, E, output Q);
	DFFNPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFCE		 D Flip-Flop with Clock Enable and Asynchronous Clear
module	\\$_DFFE_PP0P_ (input D, C, R, E, output Q);
	DFFCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNCE		 D Flip-Flop with Negative-Edge Clock,Clock Enable and Asynchronous Clear
module	\\$_DFFE_NP0P_ (input D, C, R, E, output Q);
	DFFNCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	(* force_downto *)
	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
			LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]));
		end else
		if (WIDTH == 2) begin
			LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]));
		end else
		if (WIDTH == 3) begin
			LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]), .I2(A[2]));
		end else
		if (WIDTH == 4) begin
			LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
		end else
		if (WIDTH == 5) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));
			\\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));
			MUX2_LUT5 mux5(.I0(f0), .I1(f1), .S0(A[4]), .O(Y));
		end else
		if (WIDTH == 6) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));
			\\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));
			MUX2_LUT6 mux6(.I0(f0), .I1(f1), .S0(A[5]), .O(Y));
		end else
		if (WIDTH == 7) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));
			\\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));
			MUX2_LUT7 mux7(.I0(f0), .I1(f1), .S0(A[6]), .O(Y));
		end else
		if (WIDTH == 8) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[127: 0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));
			\\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));
			MUX2_LUT8 mux8(.I0(f0), .I1(f1), .S0(A[7]), .O(Y));
		end else begin
			wire _TECHMAP_FAIL_ = 1;
		end
	endgenerate
endmodule
`,"cells_sim.v":`(* abc9_lut=1 *)
module LUT1(output F, input I0);
	parameter [1:0] INIT = 0;
	specify
		(I0 => F) = (555, 902);
	endspecify
	assign F = I0 ? INIT[1] : INIT[0];
endmodule

(* abc9_lut=1 *)
module LUT2(output F, input I0, I1);
	parameter [3:0] INIT = 0;
	specify
		(I0 => F) = (867, 1184);
		(I1 => F) = (555, 902);
	endspecify
	wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=1 *)
module LUT3(output F, input I0, I1, I2);
	parameter [7:0] INIT = 0;
	specify
		(I0 => F) = (1054, 1486);
		(I1 => F) = (867, 1184);
		(I2 => F) = (555, 902);
	endspecify	
	wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=1 *)
module LUT4(output F, input I0, I1, I2, I3);
	parameter [15:0] INIT = 0;
	specify
		(I0 => F) = (1054, 1486);
		(I1 => F) = (1053, 1583);
		(I2 => F) = (867, 1184);
		(I3 => F) = (555, 902);
	endspecify	
	wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=2 *)
module __APICULA_LUT5(output F, input I0, I1, I2, I3, M0);
	specify
		(I0 => F) = (1187, 1638);
		(I1 => F) = (1184, 1638);
		(I2 => F) = (995, 1371);
		(I3 => F) = (808, 1116);
		(M0 => F) = (486, 680);
	endspecify	
endmodule

(* abc9_lut=4 *)
module __APICULA_LUT6(output F, input I0, I1, I2, I3, M0, M1);
	specify
		(I0 => F) = (1187 + 136, 1638 + 255);
		(I1 => F) = (1184 + 136, 1638 + 255);
		(I2 => F) = (995 + 136, 1371 + 255);
		(I3 => F) = (808 + 136, 1116 + 255);
		(M0 => F) = (486 + 136, 680 + 255);
		(M1 => F) = (478, 723);
	endspecify	
endmodule

(* abc9_lut=8 *)
module __APICULA_LUT7(output F, input I0, I1, I2, I3, M0, M1, M2);
	specify
		(I0 => F) = (1187 + 136 + 136, 1638 + 255 + 255);
		(I1 => F) = (1184 + 136 + 136, 1638 + 255 + 255);
		(I2 => F) = (995 + 136 + 136, 1371 + 255 + 255);
		(I3 => F) = (808 + 136 + 136, 1116 + 255 + 255);
		(M0 => F) = (486 + 136 + 136, 680 + 255 + 255);
		(M1 => F) = (478 + 136, 723 + 255);
		(M2 => F) = (478, 723);
	endspecify	
endmodule

(* abc9_lut=16 *)
module __APICULA_LUT8(output F, input I0, I1, I2, I3, M0, M1, M2, M3);
		specify
		(I0 => F) = (1187 + 136 + 136 + 136, 1638 + 255 + 255 + 255);
		(I1 => F) = (1184 + 136 + 136 + 136, 1638 + 255 + 255 + 255);
		(I2 => F) = (995 + 136 + 136 + 136, 1371 + 255 + 255 + 255);
		(I3 => F) = (808 + 136 + 136 + 136, 1116 + 255 + 255 + 255);
		(M0 => F) = (486 + 136 + 136 + 136, 680 + 255 + 255 + 255);
		(M1 => F) = (478 + 136 + 136, 723 + 255 + 255);
		(M2 => F) = (478 + 136, 723 + 255);
		(M3 => F) = (478, 723);
		endspecify	
	endmodule

module MUX2 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (141, 160);
		(I1 => O) = (141, 160);
		(S0 => O) = (486, 680);
	endspecify

  assign O = S0 ? I1 : I0;
endmodule

module MUX2_LUT5 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (141, 160);
		(I1 => O) = (141, 160);
		(S0 => O) = (486, 680);
	endspecify

  MUX2 mux2_lut5 (O, I0, I1, S0);
endmodule

module MUX2_LUT6 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut6 (O, I0, I1, S0);
endmodule

module MUX2_LUT7 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut7 (O, I0, I1, S0);
endmodule

module MUX2_LUT8 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut8 (O, I0, I1, S0);
endmodule

(* abc9_flop, lib_whitebox *)
module DFF (output reg Q, input CLK, D);
	parameter [0:0] INIT = 1'b0;
	initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
	endspecify

	always @(posedge CLK)
		Q <= D;
endmodule

(* abc9_flop, lib_whitebox *)
module DFFE (output reg Q, input D, CLK, CE);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (CE)
      Q <= D;
  end
endmodule // DFFE (positive clock edge; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFS (output reg Q, input D, CLK, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
		$setup(SET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else
      Q <= D;	
  end
endmodule // DFFS (positive clock edge; synchronous set)

(* abc9_flop, lib_whitebox *)
module DFFSE (output reg Q, input D, CLK, CE, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
		$setup(SET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
end
endmodule // DFFSE (positive clock edge; synchronous set takes precedence over clock enable)

(* abc9_flop, lib_whitebox *)
module DFFR (output reg Q, input D, CLK, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
		$setup(RESET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFR (positive clock edge; synchronous reset)

(* abc9_flop, lib_whitebox *)
module DFFRE (output reg Q, input D, CLK, CE, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
		$setup(RESET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFRE (positive clock edge; synchronous reset takes precedence over clock enable)

(* abc9_box, lib_whitebox *)
module DFFP (output reg Q, input D, CLK, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, posedge CLK, 576);
	endspecify

  always @(posedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else
      Q <= D;
  end
endmodule // DFFP (positive clock edge; asynchronous preset)

(* abc9_box, lib_whitebox *)
module DFFPE (output reg Q, input D, CLK, CE, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
  end
endmodule // DFFPE (positive clock edge; asynchronous preset; clock enable)

(* abc9_box, lib_whitebox *)
module DFFC (output reg Q, input D, CLK, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, posedge CLK, 576);
	endspecify

  always @(posedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFC (positive clock edge; asynchronous clear)

(* abc9_box, lib_whitebox *)
module DFFCE (output reg Q, input D, CLK, CE, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFCE (positive clock edge; asynchronous clear; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFN (output reg Q, input CLK, D);
	parameter [0:0] INIT = 1'b0;
	initial Q = INIT;

  specify
    (negedge CLK => (Q : D)) = (480, 660);
    $setup(D, negedge CLK, 576);
  endspecify

	always @(negedge CLK)
		Q <= D;
endmodule

(* abc9_flop, lib_whitebox *)
module DFFNE (output reg Q, input D, CLK, CE);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (CE)
      Q <= D;
  end
endmodule // DFFNE (negative clock edge; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFNS (output reg Q, input D, CLK, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;
  
	specify
		(negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK, 576);
		$setup(SET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else
      Q <= D;	
  end
endmodule // DFFNS (negative clock edge; synchronous set)

(* abc9_flop, lib_whitebox *)
module DFFNSE (output reg Q, input D, CLK, CE, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
		$setup(SET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
end
endmodule // DFFNSE (negative clock edge; synchronous set takes precedence over clock enable)

(* abc9_flop, lib_whitebox *)
module DFFNR (output reg Q, input D, CLK, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK, 576);
		$setup(RESET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFNR (negative clock edge; synchronous reset)

(* abc9_flop, lib_whitebox *)
module DFFNRE (output reg Q, input D, CLK, CE, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
		$setup(RESET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNRE (negative clock edge; synchronous reset takes precedence over clock enable)

(* abc9_box, lib_whitebox *)
module DFFNP (output reg Q, input D, CLK, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, negedge CLK, 576);
	endspecify

  always @(negedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else
      Q <= D;
  end
endmodule // DFFNP (negative clock edge; asynchronous preset)

(* abc9_box, lib_whitebox *)
module DFFNPE (output reg Q, input D, CLK, CE, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;
  
	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNPE (negative clock edge; asynchronous preset; clock enable)

(* abc9_box, lib_whitebox *)
module DFFNC (output reg Q, input D, CLK, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, negedge CLK, 576);
	endspecify

  always @(negedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFNC (negative clock edge; asynchronous clear)

(* abc9_box, lib_whitebox *)
module DFFNCE (output reg Q, input D, CLK, CE, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNCE (negative clock edge; asynchronous clear; clock enable)

// TODO add more DFF sim cells

module VCC(output V);
	assign V = 1;
endmodule

module GND(output G);
	assign G = 0;
endmodule

module IBUF(output O, input I);

	specify
		(I => O) = 0;
	endspecify

	assign O = I;
endmodule

module OBUF(output O, input I);

	specify
		(I => O) = 0;
	endspecify

	assign O = I;
endmodule

module TBUF (O, I, OEN);
  input I, OEN;
  output O;
  assign O = OEN ? 1'bz : I;
endmodule

module IOBUF (O, IO, I, OEN);
  input I,OEN;
  output O;
  inout IO;
  assign IO = OEN ? 1'bz : I;
  assign I = IO;
endmodule

module ELVDS_OBUF (I, O, OB);
  input I;
  output O;
  output OB;
  assign O = I;
  assign OB = ~I;
endmodule

module TLVDS_OBUF (I, O, OB);
  input I;
  output O;
  output OB;
  assign O = I;
  assign OB = ~I;
endmodule

module OSER4(D3, D2, D1, D0, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);
	output Q1;
	output Q0;

	input D3;
	input D2;
	input D1;
	input D0;
	input TX1;
	input TX0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
	parameter TXCLK_POL = 0;
	parameter HWL = "false";
endmodule

module OSER4_MEM (Q0, Q1, D0, D1, D2, D3, TX0, TX1, PCLK, FCLK, TCLK, RESET)  ;
    parameter GSREN = "";
    parameter LSREN = "";
    parameter HWL = "";
    parameter TCLK_SOURCE = "";
    parameter TXCLK_POL = "";

    input D0, D1, D2, D3;
    input TX0, TX1;
    input PCLK, FCLK, TCLK, RESET;
    output  Q0,  Q1;

    parameter ID = "";
endmodule

module OSER8(D7, D6, D5, D4, D3, D2, D1, D0, TX3, TX2, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);
	output Q1;
	output Q0;

	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input TX3;
	input TX2;
	input TX1;
	input TX0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
	parameter TXCLK_POL = 0;
	parameter HWL = "false";
endmodule

module OSER10(D9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);
	output Q;

	input D9;
	input D8;
	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module OVIDEO(D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);
	output Q;

	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module OSER16(D15, D14, D13, D12, D11, D10, 
D9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK,
RESET, Q);
	output Q;

	input D15;
	input D14;
	input D13;
	input D12;
	input D11;
	input D10;
	input D9;
	input D8;
	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES4(Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES4_MEM (Q0, Q1, Q2, Q3, D, WADDR,
RADDR, CALIB, PCLK, FCLK, ICLK, RESET)  ;
parameter GSREN = "";
parameter LSREN = "";

input D, ICLK, FCLK, PCLK;
input [2:0] WADDR;
input [2:0] RADDR;
input CALIB, RESET;

output Q0,Q1,Q2,Q3;

parameter ID = "";
endmodule

module IDES8(Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES10(Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q9;
	output Q8;
	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IVIDEO(Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES16(Q15, Q14, Q13, Q12, Q11, Q10, 
Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q15;
	output Q14;
	output Q13;
	output Q12;
	output Q11;
	output Q10;
	output Q9;
	output Q8;
	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDDR(D, CLK, Q0, Q1);
	input D;
	input CLK;
	output Q0;
	output Q1;
	parameter Q0_INIT = 1'b0;
	parameter Q1_INIT = 1'b0;
endmodule

module IDDRC(D, CLK, CLEAR, Q0, Q1);
	input D;
	input CLK;
	input CLEAR;
	output Q0;
	output Q1;
	parameter Q0_INIT = 1'b0;
	parameter Q1_INIT = 1'b0;
endmodule

module DQS(DQSR90, DQSW0, DQSW270, RPOINT, WPOINT, RVALID, RBURST, RFLAG,
WFLAG, DQSIN, DLLSTEP, WSTEP, READ, RLOADN, RMOVE, RDIR, WLOADN, WMOVE, WDIR,
HOLD, RCLKSEL, PCLK, FCLK, RESET) ;
    input DQSIN,PCLK,FCLK,RESET;
    input [3:0] READ;
    input [2:0] RCLKSEL;
    input [7:0] DLLSTEP;
    input [7:0] WSTEP;
    input RLOADN, RMOVE, RDIR, WLOADN, WMOVE, WDIR, HOLD;

    output DQSR90, DQSW0, DQSW270;
    output [2:0] RPOINT, WPOINT;
    output RVALID,RBURST, RFLAG, WFLAG;

    parameter FIFO_MODE_SEL = "";
    parameter RD_PNTR = "";
    parameter DQS_MODE = "";
    parameter HWL = "";
    parameter GSREN = "";
    parameter ID = "";
endmodule

(* blackbox *)
module ODDR(D0, D1, TX, CLK, Q0, Q1);
	input D0;
	input D1;
	input TX;
	input CLK;
	output Q0;
	output Q1;
	parameter TXCLK_POL = 0;
	parameter INIT = 0;
endmodule

(* blackbox *)
module ODDRC(D0, D1, CLEAR, TX, CLK, Q0, Q1);
	input D0;
	input D1;
	input CLEAR;
	input TX;
	input CLK;
	output Q0;
	output Q1;
	parameter TXCLK_POL = 0;
	parameter INIT = 0;
endmodule

(* blackbox, keep *)
module GSR (input GSRI);
endmodule

(* blackbox, keep *)
module BANDGAP (input BGEN);
endmodule

(* abc9_box, lib_whitebox *)
module ALU (SUM, COUT, I0, I1, I3, CIN);

input I0;
input I1;
input I3;
(* abc9_carry *) input CIN;
output SUM;
(* abc9_carry *) output COUT;

localparam ADD = 0;
localparam SUB = 1;
localparam ADDSUB = 2;
localparam NE = 3;
localparam GE = 4;
localparam LE = 5;
localparam CUP = 6;
localparam CDN = 7;
localparam CUPCDN = 8;
localparam MULT = 9;

parameter ALU_MODE = 0;

reg S, C;

specify
	(I0 => SUM) = (1043, 1432);
	(I1 => SUM) = (775, 1049);
	(I3 => SUM) = (751, 1010);
	(CIN => SUM) = (694, 811);
	(I0  => COUT) = (1010, 1380);
	(I1  => COUT) = (1021, 1505);
	(I3  => COUT) = (483, 792);
	(CIN => COUT) = (49, 82);
endspecify

assign SUM = S ^ CIN;
assign COUT = S? CIN : C;

always @* begin
	case (ALU_MODE)
		ADD: begin
			S = I0 ^ I1;
			C = I0;
		end
		SUB: begin
			S = I0 ^ ~I1;
			C = I0;
		end
		ADDSUB: begin
			S = I3? I0 ^ I1 : I0 ^ ~I1;
			C = I0;
		end
		NE: begin
			S = I0 ^ ~I1;
			C = 1'b1;
		end
		GE: begin
			S = I0 ^ ~I1;
			C = I0;
		end
		LE: begin
			S = ~I0 ^ I1;
			C = I1;
		end
		CUP: begin
			S = I0;
			C = 1'b0;
		end
		CDN: begin
			S = ~I0;
			C = 1'b1;
		end
		CUPCDN: begin
			S = I3? I0 : ~I0;
			C = I0;
		end
		MULT: begin
			S = (I0 & I1) ^ I3;
			C = I0 & I1;
		end
	endcase
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S1 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;

input [3:0] AD;
input DI;
output DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 1'bx)) = (474, 565);
endspecify

reg [15:0] mem;

initial begin
	mem = INIT_0;
end

assign DO = mem[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem[AD] <= DI;
	end
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S2 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;

input [3:0] AD;
input [1:0] DI;
output [1:0] DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 2'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
end

assign DO[0] = mem0[AD];
assign DO[1] = mem1[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[AD] <= DI[0];
		mem1[AD] <= DI[1];
	end
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S4 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;
parameter INIT_2 = 16'h0000;
parameter INIT_3 = 16'h0000;

input [3:0] AD;
input [3:0] DI;
output [3:0] DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 4'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1, mem2, mem3;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
	mem2 = INIT_2;
	mem3 = INIT_3;
end

assign DO[0] = mem0[AD];
assign DO[1] = mem1[AD];
assign DO[2] = mem2[AD];
assign DO[3] = mem3[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[AD] <= DI[0];
		mem1[AD] <= DI[1];
		mem2[AD] <= DI[2];
		mem3[AD] <= DI[3];
	end
end

endmodule


module RAM16SDP1 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input DI;
output DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 1'bx)) = (474, 565);
endspecify

reg [15:0] mem;

initial begin
	mem = INIT_0;
end

assign DO = mem[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem[WAD] <= DI;
	end
end

endmodule


module RAM16SDP2 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input [1:0] DI;
output [1:0] DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 2'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
end

assign DO[0] = mem0[RAD];
assign DO[1] = mem1[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[WAD] <= DI[0];
		mem1[WAD] <= DI[1];
	end
end

endmodule


module RAM16SDP4 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;
parameter INIT_2 = 16'h0000;
parameter INIT_3 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input [3:0] DI;
output [3:0] DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 4'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1, mem2, mem3;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
	mem2 = INIT_2;
	mem3 = INIT_3;
end

assign DO[0] = mem0[RAD];
assign DO[1] = mem1[RAD];
assign DO[2] = mem2[RAD];
assign DO[3] = mem3[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[WAD] <= DI[0];
		mem1[WAD] <= DI[1];
		mem2[WAD] <= DI[2];
		mem3[WAD] <= DI[3];
	end
end

endmodule


(* blackbox *)
module SP (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);

// 1 Enables output pipeline registers.
parameter READ_MODE = 1'b0;
// 0: no read on write, 1: transparent, 2: read-before-write
parameter WRITE_MODE = 2'b00;
parameter BIT_WIDTH = 32; // 1, 2, 4, 8, 16, 32
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [31:0] DO;
input [31:0] DI;
input [2:0] BLKSEL;
input [13:0] AD;
input WRE;
input CLK;
input CE;
input OCE;
input RESET;

endmodule

(* blackbox *)
module SPX9 (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);

// 1 Enables output pipeline registers.
parameter READ_MODE = 1'b0;
// 0: no read on write, 1: transparent, 2: read-before-write
parameter WRITE_MODE = 2'b00;
parameter BIT_WIDTH = 36; // 9, 18, 36
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [35:0] DO;
input [35:0] DI;
input [2:0] BLKSEL;
input [13:0] AD;
input WRE;
input CLK;
input CE;
input OCE;
input RESET;

endmodule


(* blackbox *)
module SDP (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);

parameter READ_MODE = 1'b0;
parameter BIT_WIDTH_0 = 32; // 1, 2, 4, 8, 16, 32
parameter BIT_WIDTH_1 = 32; // 1, 2, 4, 8, 16, 32
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [31:0] DO;
input [31:0] DI;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCE;
input RESETA, RESETB;

specify
	(posedge CLKB => (DO : DI)) = (419, 493);
	$setup(RESETA, posedge CLKA, 62);
	$setup(RESETB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(CEA, posedge CLKA, 62);
	$setup(CEB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(WREA, posedge CLKA, 62);
	$setup(WREB, posedge CLKB, 62);
	$setup(DI, posedge CLKA, 62);
	$setup(ADA, posedge CLKA, 62);
	$setup(ADB, posedge CLKB, 62);
	$setup(BLKSEL, posedge CLKA, 62);
endspecify

endmodule

(* blackbox *)
module SDPX9 (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);

parameter READ_MODE = 1'b0;
parameter BIT_WIDTH_0 = 36; // 9, 18, 36
parameter BIT_WIDTH_1 = 36; // 9, 18, 36
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [35:0] DO;
input [35:0] DI;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCE;
input RESETA, RESETB;

specify
	(posedge CLKB => (DO : DI)) = (419, 493);
	$setup(RESETA, posedge CLKA, 62);
	$setup(RESETB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(CEA, posedge CLKA, 62);
	$setup(CEB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(WREA, posedge CLKA, 62);
	$setup(WREB, posedge CLKB, 62);
	$setup(DI, posedge CLKA, 62);
	$setup(ADA, posedge CLKA, 62);
	$setup(ADB, posedge CLKB, 62);
	$setup(BLKSEL, posedge CLKA, 62);
endspecify

endmodule


(* blackbox *)
module DP (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);

parameter READ_MODE0 = 1'b0;
parameter READ_MODE1 = 1'b0;
parameter WRITE_MODE0 = 2'b00;
parameter WRITE_MODE1 = 2'b00;
parameter BIT_WIDTH_0 = 16; // 1, 2, 4, 8, 16
parameter BIT_WIDTH_1 = 16; // 1, 2, 4, 8, 16
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [15:0] DOA, DOB;
input [15:0] DIA, DIB;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCEA, OCEB;
input RESETA, RESETB;

endmodule

(* blackbox *)
module DPX9 (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);

parameter READ_MODE0 = 1'b0;
parameter READ_MODE1 = 1'b0;
parameter WRITE_MODE0 = 2'b00;
parameter WRITE_MODE1 = 2'b00;
parameter BIT_WIDTH_0 = 18; // 9, 18
parameter BIT_WIDTH_1 = 18; // 9, 18
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [17:0] DOA, DOB;
input [17:0] DIA, DIB;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCEA, OCEB;
input RESETA, RESETB;

endmodule


(* blackbox *)
module rPLL (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY;
input [3:0] DUTYDA;

output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;

parameter FCLKIN = "100.0";         // frequency of CLKIN
parameter DYN_IDIV_SEL= "false";    // true:IDSEL, false:IDIV_SEL
parameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64
parameter DYN_FBDIV_SEL= "false";   // true:FBDSEL, false:FBDIV_SEL
parameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64
parameter DYN_ODIV_SEL= "false";    // true:ODSEL, false:ODIV_SEL
parameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128

parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";      // true:PSDA or DUTYDA or FDA, false: DA_SEL
parameter DUTYDA_SEL= "1000";

parameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only
parameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only
parameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4
parameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2

parameter CLKFB_SEL = "internal";   // "internal", "external"
parameter CLKOUT_BYPASS = "false";  // "true", "false"
parameter CLKOUTP_BYPASS = "false"; // "true", "false"
parameter CLKOUTD_BYPASS = "false"; // "true", "false"
parameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers
parameter CLKOUTD_SRC =  "CLKOUT";  // CLKOUT, CLKOUTP
parameter CLKOUTD3_SRC = "CLKOUT";  // CLKOUT, CLKOUTP
parameter DEVICE = "GW1N-1";        // "GW1N-1", "GW1N-4", "GW1N-9", "GW1NR-4", "GW1NR-9", "GW1N-4B", "GW1NR-4B", "GW1NS-2", "GW1NS-2C", "GW1NZ-1", "GW1NSR-2", "GW1NSR-2C", "GW1N-1S", "GW1NSE-2C", "GW1NRF-4B", "GW1N-9C", "GW1NR-9C", "GW1N-4C", "GW1NR-4C"

endmodule

(* blackbox *)
module PLLVR (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P, VREN);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY;
input [3:0] DUTYDA;
input VREN;

output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;

parameter FCLKIN = "100.0";         // frequency of CLKIN
parameter DYN_IDIV_SEL= "false";    // true:IDSEL, false:IDIV_SEL
parameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64
parameter DYN_FBDIV_SEL= "false";   // true:FBDSEL, false:FBDIV_SEL
parameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64
parameter DYN_ODIV_SEL= "false";    // true:ODSEL, false:ODIV_SEL
parameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128

parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";      // true:PSDA or DUTYDA or FDA, false: DA_SEL
parameter DUTYDA_SEL= "1000";

parameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only
parameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only
parameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4
parameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2

parameter CLKFB_SEL = "internal";   // "internal", "external"
parameter CLKOUT_BYPASS = "false";  // "true", "false"
parameter CLKOUTP_BYPASS = "false"; // "true", "false"
parameter CLKOUTD_BYPASS = "false"; // "true", "false"
parameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers
parameter CLKOUTD_SRC =  "CLKOUT";  // CLKOUT, CLKOUTP
parameter CLKOUTD3_SRC = "CLKOUT";  // CLKOUT, CLKOUTP
parameter DEVICE = "GW1NS-4";       // "GW1NS-4", "GW1NS-4C", "GW1NSR-4", "GW1NSR-4C", "GW1NSER-4C"

endmodule

(* blackbox *)
module OSC(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 100;
parameter DEVICE = "GW1N-4";
endmodule

(* blackbox *)
module OSCZ(OSCOUT, OSCEN);
input OSCEN;

output OSCOUT;

parameter FREQ_DIV = 100;
endmodule

(* blackbox *)
module OSCF(OSCOUT, OSCOUT30M, OSCEN);
input OSCEN;

output OSCOUT;
output OSCOUT30M;

parameter FREQ_DIV = 100;
endmodule

(* blackbox *)
module OSCH(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 96;
endmodule

(* blackbox *)
module OSCW(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 80;
endmodule

(* blackbox *)
module OSCO(OSCOUT, OSCEN);
input OSCEN;

output OSCOUT;

parameter FREQ_DIV = 100;
parameter REGULATOR_EN = 1'b0;
endmodule

(* blackbox *)
module DCS (CLK0, CLK1, CLK2, CLK3, CLKSEL, SELFORCE, CLKOUT);
input CLK0, CLK1, CLK2, CLK3, SELFORCE;
input [3:0] CLKSEL;
output CLKOUT;
parameter DCS_MODE = "RISING";
endmodule

(* blackbox *)
module EMCU (
  input          FCLK,
  input          PORESETN,
  input          SYSRESETN,
  input          RTCSRCCLK,
  output  [15:0] IOEXPOUTPUTO,
  output  [15:0] IOEXPOUTPUTENO,
  input   [15:0] IOEXPINPUTI,
  output         UART0TXDO,
  output         UART1TXDO,
  output         UART0BAUDTICK,
  output         UART1BAUDTICK,
  input          UART0RXDI,
  input          UART1RXDI,
  output         INTMONITOR,
  output         MTXHRESETN,
  output  [12:0] SRAM0ADDR,
  output   [3:0] SRAM0WREN,
  output  [31:0] SRAM0WDATA,
  output         SRAM0CS,
  input   [31:0] SRAM0RDATA,
  output         TARGFLASH0HSEL,
  output  [28:0] TARGFLASH0HADDR,
  output   [1:0] TARGFLASH0HTRANS,
  output   [2:0] TARGFLASH0HSIZE,
  output   [2:0] TARGFLASH0HBURST,
  output         TARGFLASH0HREADYMUX,
  input   [31:0] TARGFLASH0HRDATA,
  input    [2:0] TARGFLASH0HRUSER,
  input          TARGFLASH0HRESP,
  input          TARGFLASH0EXRESP,
  input          TARGFLASH0HREADYOUT,
  output         TARGEXP0HSEL,
  output  [31:0] TARGEXP0HADDR,
  output   [1:0] TARGEXP0HTRANS,
  output         TARGEXP0HWRITE,
  output   [2:0] TARGEXP0HSIZE,
  output   [2:0] TARGEXP0HBURST,
  output   [3:0] TARGEXP0HPROT,
  output   [1:0] TARGEXP0MEMATTR,
  output         TARGEXP0EXREQ,
  output   [3:0] TARGEXP0HMASTER,
  output  [31:0] TARGEXP0HWDATA,
  output         TARGEXP0HMASTLOCK,
  output         TARGEXP0HREADYMUX,
  output         TARGEXP0HAUSER,
  output   [3:0] TARGEXP0HWUSER,
  input   [31:0] TARGEXP0HRDATA,
  input          TARGEXP0HREADYOUT,
  input          TARGEXP0HRESP,
  input          TARGEXP0EXRESP,
  input    [2:0] TARGEXP0HRUSER,
  output  [31:0] INITEXP0HRDATA,
  output         INITEXP0HREADY,
  output         INITEXP0HRESP,
  output         INITEXP0EXRESP,
  output   [2:0] INITEXP0HRUSER,
  input          INITEXP0HSEL,
  input   [31:0] INITEXP0HADDR,
  input    [1:0] INITEXP0HTRANS,
  input          INITEXP0HWRITE,
  input    [2:0] INITEXP0HSIZE,
  input    [2:0] INITEXP0HBURST,
  input    [3:0] INITEXP0HPROT,
  input    [1:0] INITEXP0MEMATTR,
  input          INITEXP0EXREQ,
  input    [3:0] INITEXP0HMASTER,
  input   [31:0] INITEXP0HWDATA,
  input          INITEXP0HMASTLOCK,
  input          INITEXP0HAUSER,
  input    [3:0] INITEXP0HWUSER,
  output   [3:0] APBTARGEXP2PSTRB,
  output   [2:0] APBTARGEXP2PPROT,
  output         APBTARGEXP2PSEL,
  output         APBTARGEXP2PENABLE,
  output  [11:0] APBTARGEXP2PADDR,
  output         APBTARGEXP2PWRITE,
  output  [31:0] APBTARGEXP2PWDATA,
  input   [31:0] APBTARGEXP2PRDATA,
  input          APBTARGEXP2PREADY,
  input          APBTARGEXP2PSLVERR,
  input    [3:0] MTXREMAP,
  output         DAPTDO,
  output         DAPJTAGNSW,
  output         DAPNTDOEN,
  input          DAPSWDITMS,
  input          DAPTDI,
  input          DAPNTRST,
  input          DAPSWCLKTCK,
  output   [3:0] TPIUTRACEDATA,
  output         TPIUTRACECLK,
  input    [4:0] GPINT,
  input          FLASHERR,
  input          FLASHINT

 );
endmodule


`,"cells_xtra_gw1n.v":`// Created by cells_xtra.py


module LUT5 (...);
parameter INIT = 32'h00000000;
input I0, I1, I2, I3, I4;
output F;
endmodule


module LUT6 (...);
parameter INIT = 64'h0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5;
output F;
endmodule


module LUT7 (...);
parameter INIT = 128'h0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6;
output F;
endmodule


module LUT8 (...);
parameter INIT = 256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6, I7;
output F;
endmodule


module INV (...);
input  I;
output O;
endmodule


module IODELAY (...);
parameter C_STATIC_DLY = 0; 
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
output DF;
output DO;
endmodule


module IEM (...);
parameter WINSIZE = "SMALL"; 
parameter GSREN = "false"; 
parameter LSREN = "true";    
input D, CLK, RESET, MCLK;
output LAG, LEAD;
endmodule


module ROM16 (...);
parameter INIT_0 = 16'h0000;
input [3:0] AD;
output DO;
endmodule


module ROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [31:0] DO;
endmodule


module ROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [35:0] DO;
endmodule


module pROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [31:0] DO;
endmodule


module pROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [35:0] DO;
endmodule


module SDPB (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 32; 
parameter BIT_WIDTH_1 = 32; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [31:0] DI;
input [2:0] BLKSELA, BLKSELB;
output [31:0] DO;
endmodule


module SDPX9B (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 36; 
parameter BIT_WIDTH_1 = 36; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [35:0] DI;
output [35:0] DO;
endmodule


module DPB (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 16; 
parameter BIT_WIDTH_1 = 16; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [15:0] DIA, DIB;
output [15:0] DOA, DOB;
endmodule


module DPX9B (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 18; 
parameter BIT_WIDTH_1 = 18; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [17:0] DIA, DIB;
input [2:0] BLKSELA, BLKSELB;
output [17:0] DOA, DOB;
endmodule


module PADD18 (...);
input  [17:0] A;
input  [17:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [17:0] SI,SBI;
output [17:0] SO,SBO;
output [17:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module PADD9 (...);
input  [8:0] A;
input  [8:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [8:0] SI,SBI;
output [8:0] SO,SBO;
output [8:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0; 
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module MULT9X9 (...);
input  [8:0] A,SIA;
input  [8:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [17:0] DOUT;
output [8:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0; 
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT18X18 (...);
input  [17:0] A,SIA;
input  [17:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [35:0] DOUT;
output [17:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT36X36 (...);
input  [35:0] A;
input  [35:0] B;
input  ASIGN,BSIGN;
input  CE;
input  CLK;
input  RESET;
output [71:0] DOUT;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT0_REG = 1'b0;
parameter OUT1_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULTALU36X18 (...);
input  [17:0] A;
input  [35:0] B;
input  [53:0] C;
input  ASIGN,BSIGN,ACCLOAD;
input  CE;
input  CLK;
input  RESET;
input  [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter MULTALU36X18_MODE = 0; 
parameter C_ADD_SUB = 1'b0; 
endmodule

module MULTADDALU18X18 (...);
input [17:0] A0;
input [17:0] B0;
input [17:0] A1;
input [17:0] B1;
input [53:0] C;
input [17:0] SIA, SIB;
input [1:0] ASIGN, BSIGN;
input [1:0] ASEL, BSEL;
input [54:0] CASI;
input CE;
input CLK;
input RESET;
input ACCLOAD;
output [53:0] DOUT;
output [54:0] CASO;
output [17:0] SOA, SOB;
parameter A0REG = 1'b0; 
parameter A1REG = 1'b0;
parameter B0REG = 1'b0;
parameter B1REG = 1'b0;
parameter CREG = 1'b0;
parameter PIPE0_REG = 1'b0;
parameter PIPE1_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter ASIGN0_REG = 1'b0;
parameter ASIGN1_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter BSIGN0_REG = 1'b0;
parameter BSIGN1_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTADDALU18X18_MODE = 0;
parameter MULT_RESET_MODE = "SYNC";
endmodule

module MULTALU18X18 (...);
input [17:0] A, B;
input CLK,CE,RESET;
input ASIGN, BSIGN;
input ACCLOAD,DSIGN;
input [53:0] C,D;
input [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter DREG = 1'b0;
parameter DSIGN_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter PIPE_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTALU18X18_MODE = 0; 
endmodule

module ALU54D (...);
input [53:0] A, B;
input ASIGN,BSIGN;
input ACCLOAD;
input [54:0] CASI;
input CLK, CE, RESET;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter ALUD_MODE = 0;
parameter ALU_RESET_MODE = "SYNC";
endmodule

module BUFG (...);
output O;
input I;
endmodule


module BUFS (...);
output O;
input I;
endmodule


module PLL (...);
input CLKIN;
input CLKFB;
input RESET; 
input RESET_P; 
input RESET_I;
input RESET_S;
input [5:0] FBDSEL; 
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY; 
input [3:0] DUTYDA;
output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;
parameter FCLKIN = "100.0"; 
parameter DYN_IDIV_SEL= "false";
parameter IDIV_SEL = 0; 
parameter DYN_FBDIV_SEL= "false";
parameter FBDIV_SEL = 0; 
parameter DYN_ODIV_SEL= "false";
parameter ODIV_SEL = 8; 
parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";
parameter DUTYDA_SEL= "1000";
parameter CLKOUT_FT_DIR = 1'b1; 
parameter CLKOUTP_FT_DIR = 1'b1; 
parameter CLKOUT_DLY_STEP = 0; 
parameter CLKOUTP_DLY_STEP = 0; 
parameter CLKFB_SEL = "internal"; 
parameter CLKOUT_BYPASS = "false";  
parameter CLKOUTP_BYPASS = "false";   
parameter CLKOUTD_BYPASS = "false";  
parameter DYN_SDIV_SEL = 2; 
parameter CLKOUTD_SRC =  "CLKOUT";  
parameter CLKOUTD3_SRC = "CLKOUT"; 
parameter DEVICE = "GW1N-4";
endmodule

module TLVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module TLVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module TLVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module ELVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module ELVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module ELVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module MIPI_IBUF (...);
output OH, OL, OB;
inout IO, IOB;
input  I, IB;
input OEN, OENB;
input HSREN;
endmodule

module MIPI_IBUF_HS (...);
output OH;
input  I, IB;
endmodule

module MIPI_IBUF_LP (...);
output OL;
output OB;
input  I;
input IB;
endmodule

module MIPI_OBUF (...);
output O, OB;
input  I, IB, MODESEL;
endmodule

module MIPI_OBUF_A (...);
output O, OB;
input  I, IB, IL, MODESEL;
endmodule

module ELVDS_IBUF_MIPI (...);
output OH, OL;
input  I, IB;
endmodule

module I3C_IOBUF (...);
output O;
inout IO;
input  I, MODESEL;
endmodule

module CLKDIV (...);
input HCLKIN;
input RESETN;
input CALIB;
output CLKOUT;
parameter DIV_MODE = "2"; 
parameter GSREN = "false"; 
endmodule

module DHCEN (...);
input CLKIN,CE;
output CLKOUT;
endmodule

module DLLDLY (...);
input CLKIN;
input [7:0] DLLSTEP;
input DIR,LOADN,MOVE;
output CLKOUT;
output FLAG;
parameter DLL_INSEL = 1'b1; 
parameter DLY_SIGN = 1'b0; 
parameter DLY_ADJ = 0; 
endmodule

module FLASH96K (...);
input [5:0] RA,CA,PA;
input [3:0] MODE;
input [1:0] SEQ;
input ACLK,PW,RESET,PE,OE;
input [1:0] RMODE,WMODE;
input [1:0] RBYTESEL,WBYTESEL;
input [31:0] DIN;
output [31:0] DOUT;
endmodule

module FLASH256K (...);
input[6:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module FLASH608K (...);
input[8:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
   		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;
endmodule

module DQCE (...);
input CLKIN;
input CE;
output CLKOUT;
endmodule

module CLKDIV2 (...);
parameter GSREN = "false"; 
input HCLKIN, RESETN;
output CLKOUT;
endmodule

module DHCENC (...);
input CLKIN, CE;
output CLKOUT, CLKOUTN;
endmodule

module FLASH64K (...);
input[4:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input SLEEP;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module FLASH64KZ (...);
input[4:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule
`,"cells_xtra_gw2a.v":`// Created by cells_xtra.py


module LUT5 (...);
parameter INIT = 32'h00000000;
input I0, I1, I2, I3, I4;
output F;
endmodule


module LUT6 (...);
parameter INIT = 64'h0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5;
output F;
endmodule


module LUT7 (...);
parameter INIT = 128'h0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6;
output F;
endmodule


module LUT8 (...);
parameter INIT = 256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6, I7;
output F;
endmodule


module INV (...);
input  I;
output O;
endmodule


module IDDR_MEM (...);
parameter GSREN = "false";  
parameter LSREN = "true";    
input D, ICLK, PCLK;
input [2:0] WADDR;
input [2:0] RADDR;
input RESET;
output  Q0,Q1;
endmodule


module ODDR_MEM (...);
parameter GSREN = "false"; 
parameter LSREN = "true";    
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1;
input TX, PCLK, TCLK, RESET;
output  Q0, Q1;
endmodule


module IDES4_MEM (...);
parameter GSREN = "false"; 
parameter LSREN = "true";    
input D, ICLK, FCLK, PCLK;
input [2:0] WADDR;
input [2:0] RADDR;
input RESET,CALIB;
output Q0,Q1,Q2,Q3;
endmodule


module IDES8_MEM (...);
parameter GSREN = "false"; 
parameter LSREN = "true";    
input D, ICLK, FCLK, PCLK;
input [2:0] WADDR;
input [2:0] RADDR;
input RESET,CALIB;
output  Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;
endmodule


module OSER4_MEM (...);
parameter GSREN = "false"; 
parameter LSREN = "true";    
parameter HWL = "false";     
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1, D2, D3;
input TX0, TX1;
input PCLK, FCLK, TCLK, RESET;
output  Q0,  Q1;
endmodule


module OSER8_MEM (...);
parameter GSREN = "false"; 
parameter LSREN = "true";    
parameter HWL = "false";    
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1, D2, D3, D4, D5, D6, D7;
input TX0, TX1, TX2, TX3;
input PCLK, FCLK, TCLK, RESET;
output  Q0,  Q1;
endmodule


module IODELAY (...);
parameter C_STATIC_DLY = 0; 
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
output DF;
output DO;
endmodule


module IEM (...);
parameter WINSIZE = "SMALL"; 
parameter GSREN = "false"; 
parameter LSREN = "true";    
input D, CLK, RESET, MCLK;
output LAG, LEAD;
endmodule


module ROM16 (...);
parameter INIT_0 = 16'h0000;
input [3:0] AD;
output DO;
endmodule


module ROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [31:0] DO;
endmodule


module ROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [35:0] DO;
endmodule


module pROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [31:0] DO;
endmodule


module pROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [35:0] DO;
endmodule


module SDPB (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 32; 
parameter BIT_WIDTH_1 = 32; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [31:0] DI;
input [2:0] BLKSELA, BLKSELB;
output [31:0] DO;
endmodule


module SDPX9B (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 36; 
parameter BIT_WIDTH_1 = 36; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [35:0] DI;
output [35:0] DO;
endmodule


module DPB (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 16; 
parameter BIT_WIDTH_1 = 16; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [15:0] DIA, DIB;
output [15:0] DOA, DOB;
endmodule


module DPX9B (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 18; 
parameter BIT_WIDTH_1 = 18; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [17:0] DIA, DIB;
input [2:0] BLKSELA, BLKSELB;
output [17:0] DOA, DOB;
endmodule


module PADD18 (...);
input  [17:0] A;
input  [17:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [17:0] SI,SBI;
output [17:0] SO,SBO;
output [17:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module PADD9 (...);
input  [8:0] A;
input  [8:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [8:0] SI,SBI;
output [8:0] SO,SBO;
output [8:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0; 
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module MULT9X9 (...);
input  [8:0] A,SIA;
input  [8:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [17:0] DOUT;
output [8:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0; 
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT18X18 (...);
input  [17:0] A,SIA;
input  [17:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [35:0] DOUT;
output [17:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT36X36 (...);
input  [35:0] A;
input  [35:0] B;
input  ASIGN,BSIGN;
input  CE;
input  CLK;
input  RESET;
output [71:0] DOUT;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT0_REG = 1'b0;
parameter OUT1_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULTALU36X18 (...);
input  [17:0] A;
input  [35:0] B;
input  [53:0] C;
input  ASIGN,BSIGN,ACCLOAD;
input  CE;
input  CLK;
input  RESET;
input  [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter MULTALU36X18_MODE = 0; 
parameter C_ADD_SUB = 1'b0; 
endmodule

module MULTADDALU18X18 (...);
input [17:0] A0;
input [17:0] B0;
input [17:0] A1;
input [17:0] B1;
input [53:0] C;
input [17:0] SIA, SIB;
input [1:0] ASIGN, BSIGN;
input [1:0] ASEL, BSEL;
input [54:0] CASI;
input CE;
input CLK;
input RESET;
input ACCLOAD;
output [53:0] DOUT;
output [54:0] CASO;
output [17:0] SOA, SOB;
parameter A0REG = 1'b0; 
parameter A1REG = 1'b0;
parameter B0REG = 1'b0;
parameter B1REG = 1'b0;
parameter CREG = 1'b0;
parameter PIPE0_REG = 1'b0;
parameter PIPE1_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter ASIGN0_REG = 1'b0;
parameter ASIGN1_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter BSIGN0_REG = 1'b0;
parameter BSIGN1_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTADDALU18X18_MODE = 0;
parameter MULT_RESET_MODE = "SYNC";
endmodule

module MULTALU18X18 (...);
input [17:0] A, B;
input CLK,CE,RESET;
input ASIGN, BSIGN;
input ACCLOAD,DSIGN;
input [53:0] C,D;
input [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter DREG = 1'b0;
parameter DSIGN_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter PIPE_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTALU18X18_MODE = 0; 
endmodule

module ALU54D (...);
input [53:0] A, B;
input ASIGN,BSIGN;
input ACCLOAD;
input [54:0] CASI;
input CLK, CE, RESET;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter ALUD_MODE = 0;
parameter ALU_RESET_MODE = "SYNC";
endmodule

module BUFG (...);
output O;
input I;
endmodule


module BUFS (...);
output O;
input I;
endmodule


module PLL (...);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input RESET_I;
input RESET_S;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY;
input [3:0] DUTYDA;
output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;
parameter FCLKIN = "100.0"; 
parameter DYN_IDIV_SEL= "false";
parameter IDIV_SEL = 0; 
parameter DYN_FBDIV_SEL= "false";
parameter FBDIV_SEL = 0; 
parameter DYN_ODIV_SEL= "false";
parameter ODIV_SEL = 8; 
parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";
parameter DUTYDA_SEL= "1000";
parameter CLKOUT_FT_DIR = 1'b1; 
parameter CLKOUTP_FT_DIR = 1'b1; 
parameter CLKOUT_DLY_STEP = 0; 
parameter CLKOUTP_DLY_STEP = 0; 
parameter CLKFB_SEL = "internal"; 
parameter CLKOUT_BYPASS = "false";  
parameter CLKOUTP_BYPASS = "false";   
parameter CLKOUTD_BYPASS = "false";  
parameter DYN_SDIV_SEL = 2; 
parameter CLKOUTD_SRC =  "CLKOUT";  
parameter CLKOUTD3_SRC = "CLKOUT"; 
parameter DEVICE = "GW2A-18";
endmodule

module TLVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module TLVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module TLVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module ELVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module ELVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module ELVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module CLKDIV (...);
input HCLKIN;
input RESETN;
input CALIB;
output CLKOUT;
parameter DIV_MODE = "2"; 
parameter GSREN = "false"; 
endmodule

module DHCEN (...);
input CLKIN,CE;
output CLKOUT;
endmodule

module DQS (...);
input DQSIN,PCLK,FCLK,RESET;
input [3:0] READ;
input [2:0] RCLKSEL;
input [7:0] DLLSTEP;
input [7:0] WSTEP;
input RLOADN, RMOVE, RDIR, WLOADN, WMOVE, WDIR, HOLD;
output DQSR90, DQSW0, DQSW270; 
output [2:0] RPOINT, WPOINT;
output RVALID,RBURST, RFLAG, WFLAG;
endmodule

module DLLDLY (...);
input CLKIN;
input [7:0] DLLSTEP;
input DIR,LOADN,MOVE;
output CLKOUT;
output FLAG;
parameter DLL_INSEL = 1'b1; 
parameter DLY_SIGN = 1'b0; 
parameter DLY_ADJ = 0; 
endmodule

module DQCE (...);
input CLKIN;
input CE;
output CLKOUT;
endmodule

module CLKDIV2 (...);
parameter GSREN = "false"; 
input HCLKIN, RESETN;
output CLKOUT;
endmodule

module IBUF_R (...);
input  I;
input RTEN;
output O;
endmodule

module IOBUF_R (...);
input I,OEN;
input RTEN;
output O;
inout IO;
endmodule

module ELVDS_IBUF_R (...);
output O;
input I, IB;
input RTEN;
endmodule

module ELVDS_IOBUF_R (...);
output  O;
inout IO, IOB;
input I, OEN;
input RTEN;
endmodule

module OTP (...);
input CSB, SCLK;
output DOUT;
endmodule

module SAMB (...);
input [23:0] SPIAD;
input LOADN_SPIAD;
endmodule

module ELVDS_IBUF_MIPI (...);
output OH, OL;
input  I, IB;
endmodule

module MIPI_IBUF (...);
output OH, OL, OB;
inout IO, IOB;
input  I, IB;
input OEN, OENB;
input HSREN;
endmodule

module I3C_IOBUF (...);
output O;
inout IO;
input  I, MODESEL;
endmodule
`,"cells_xtra_gw5a.v":`// Created by cells_xtra.py


module LUT5 (...);
parameter INIT = 32'h00000000;
input I0, I1, I2, I3, I4;
output F;
endmodule


module LUT6 (...);
parameter INIT = 64'h0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5;
output F;
endmodule


module LUT7 (...);
parameter INIT = 128'h0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6;
output F;
endmodule


module LUT8 (...);
parameter INIT = 256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6, I7;
output F;
endmodule


module ROM16 (...);
parameter INIT_0 = 16'h0000;
input [3:0] AD;
output DO;
endmodule


module INV (...);
input  I;
output O;
endmodule


module TLVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module TLVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module TLVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module ELVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module ELVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module MIPI_IBUF (...);
output OH, OL, OB;
inout IO, IOB;
input  I, IB;
input OEN, OENB;
input HSEN, HSREN;
endmodule

module MIPI_OBUF_A (...);
output O, OB;
input  I, IB, IL, MODESEL;
inout IO, IOB;
input OEN, OENB;
endmodule

module ELVDS_IOBUF_R (...);
output  O;
inout IO, IOB;
input I, OEN;
input RTEN;
endmodule

module I3C_IOBUF (...);
output O;
inout IO;
input  I, MODESEL;
endmodule

module TLVDS_IBUF_ADC (...);
input I, IB;
input ADCEN;
endmodule

module MIPI_CPHY_IBUF (...);
output OH0, OL0, OB0, OH1, OL1, OB1, OH2, OL2, OB2;
inout IO0, IOB0, IO1, IOB1, IO2, IOB2;
input  I0, IB0, I1, IB1, I2, IB2;
input OEN, OENB;
input HSEN;
endmodule

module MIPI_CPHY_OBUF (...);
output O0, OB0, O1, OB1, O2, OB2;
input  I0, IB0, IL0, I1, IB1, IL1, I2, IB2, IL2;
inout IO0, IOB0, IO1, IOB1, IO2, IOB2;
input OEN, OENB, MODESEL, VCOME;
endmodule

module SDPB (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 32; 
parameter BIT_WIDTH_1 = 32; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESET; 
input [13:0] ADA, ADB;
input [31:0] DI;
input [2:0] BLKSELA, BLKSELB;
output [31:0] DO;
endmodule


module SDPX9B (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 36; 
parameter BIT_WIDTH_1 = 36; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESET; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [35:0] DI;
output [35:0] DO;
endmodule


module DPB (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 16; 
parameter BIT_WIDTH_1 = 16; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [15:0] DIA, DIB;
output [15:0] DOA, DOB;
endmodule


module DPX9B (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 18; 
parameter BIT_WIDTH_1 = 18; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [17:0] DIA, DIB;
input [2:0] BLKSELA, BLKSELB;
output [17:0] DOA, DOB;
endmodule


module pROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [31:0] DO;
endmodule


module pROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [35:0] DO;
endmodule


module SDP36KE (...);
parameter ECC_WRITE_EN="TRUE"; 
parameter ECC_READ_EN="TRUE"; 
parameter READ_MODE = 1'b0; 
parameter BLK_SEL_A = 3'b000;
parameter BLK_SEL_B = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_FILE = "NONE"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_40 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_41 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_42 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_43 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_44 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_45 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_46 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_47 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_48 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_49 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_4F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_50 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_51 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_52 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_53 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_54 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_55 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_56 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_57 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_58 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_59 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_5F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_60 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_61 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_62 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_63 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_64 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_65 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_66 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_67 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_68 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_69 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_6F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_70 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_71 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_72 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_73 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_74 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_75 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_76 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_77 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_78 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_79 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_7F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INITP_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESET; 
input [8:0] ADA, ADB;
input [63:0] DI;
input [7:0] DIP;
input [2:0] BLKSELA, BLKSELB;
input DECCI, SECCI;
output [63:0] DO;
output [7:0] DOP;
output DECCO, SECCO;
output [7:0] ECCP;
endmodule


module SDP136K (...);
input CLKA, CLKB;
input WE, RE;
input [10:0] ADA, ADB;
input [67:0] DI;
output [67:0] DO;
endmodule

module MULTADDALU12X12 (...);
parameter A0REG_CLK = "BYPASS"; 
parameter A0REG_CE = "CE0"; 
parameter A0REG_RESET = "RESET0"; 
parameter A1REG_CLK = "BYPASS"; 
parameter A1REG_CE = "CE0"; 
parameter A1REG_RESET = "RESET0"; 
parameter B0REG_CLK = "BYPASS"; 
parameter B0REG_CE = "CE0"; 
parameter B0REG_RESET = "RESET0"; 
parameter B1REG_CLK = "BYPASS"; 
parameter B1REG_CE = "CE0"; 
parameter B1REG_RESET = "RESET0"; 
parameter ACCSEL_IREG_CLK = "BYPASS"; 
parameter ACCSEL_IREG_CE = "CE0"; 
parameter ACCSEL_IREG_RESET = "RESET0"; 
parameter CASISEL_IREG_CLK = "BYPASS"; 
parameter CASISEL_IREG_CE = "CE0"; 
parameter CASISEL_IREG_RESET = "RESET0"; 
parameter ADDSUB0_IREG_CLK = "BYPASS"; 
parameter ADDSUB0_IREG_CE = "CE0"; 
parameter ADDSUB0_IREG_RESET = "RESET0"; 
parameter ADDSUB1_IREG_CLK = "BYPASS"; 
parameter ADDSUB1_IREG_CE = "CE0"; 
parameter ADDSUB1_IREG_RESET = "RESET0"; 
parameter PREG0_CLK = "BYPASS"; 
parameter PREG0_CE = "CE0"; 
parameter PREG0_RESET = "RESET0"; 
parameter PREG1_CLK = "BYPASS"; 
parameter PREG1_CE = "CE0"; 
parameter PREG1_RESET = "RESET0"; 
parameter FB_PREG_EN = "FALSE"; 
parameter ACCSEL_PREG_CLK = "BYPASS"; 
parameter ACCSEL_PREG_CE = "CE0"; 
parameter ACCSEL_PREG_RESET = "RESET0"; 
parameter CASISEL_PREG_CLK = "BYPASS"; 
parameter CASISEL_PREG_CE = "CE0"; 
parameter CASISEL_PREG_RESET = "RESET0"; 
parameter ADDSUB0_PREG_CLK = "BYPASS"; 
parameter ADDSUB0_PREG_CE = "CE0"; 
parameter ADDSUB0_PREG_RESET = "RESET0"; 
parameter ADDSUB1_PREG_CLK = "BYPASS"; 
parameter ADDSUB1_PREG_CE = "CE0"; 
parameter ADDSUB1_PREG_RESET = "RESET0"; 
parameter OREG_CLK = "BYPASS"; 
parameter OREG_CE = "CE0"; 
parameter OREG_RESET = "RESET0"; 
parameter MULT_RESET_MODE = "SYNC";
parameter PRE_LOAD = 48'h000000000000;
parameter DYN_ADD_SUB_0 = "FALSE";
parameter ADD_SUB_0 = 1'b0;
parameter DYN_ADD_SUB_1 = "FALSE";
parameter ADD_SUB_1 = 1'b0;
parameter DYN_CASI_SEL = "FALSE";
parameter CASI_SEL = 1'b0;
parameter DYN_ACC_SEL = "FALSE";
parameter ACC_SEL = 1'b0;
output [47:0] DOUT, CASO;
input  [11:0] A0, B0, A1, B1;
input  [47:0] CASI;
input  ACCSEL;
input  CASISEL;
input  [1:0] ADDSUB;
input  [1:0] CLK, CE, RESET;
endmodule

module MULTALU27X18 (...);
parameter AREG_CLK = "BYPASS"; 
parameter AREG_CE = "CE0"; 
parameter AREG_RESET = "RESET0"; 
parameter BREG_CLK = "BYPASS"; 
parameter BREG_CE = "CE0"; 
parameter BREG_RESET = "RESET0"; 
parameter DREG_CLK = "BYPASS"; 
parameter DREG_CE = "CE0"; 
parameter DREG_RESET = "RESET0"; 
parameter C_IREG_CLK = "BYPASS"; 
parameter C_IREG_CE = "CE0"; 
parameter C_IREG_RESET = "RESET0"; 
parameter PSEL_IREG_CLK = "BYPASS"; 
parameter PSEL_IREG_CE = "CE0"; 
parameter PSEL_IREG_RESET = "RESET0"; 
parameter PADDSUB_IREG_CLK = "BYPASS"; 
parameter PADDSUB_IREG_CE = "CE0"; 
parameter PADDSUB_IREG_RESET = "RESET0"; 
parameter ADDSUB0_IREG_CLK = "BYPASS"; 
parameter ADDSUB0_IREG_CE = "CE0"; 
parameter ADDSUB0_IREG_RESET = "RESET0"; 
parameter ADDSUB1_IREG_CLK = "BYPASS"; 
parameter ADDSUB1_IREG_CE = "CE0"; 
parameter ADDSUB1_IREG_RESET = "RESET0"; 
parameter CSEL_IREG_CLK = "BYPASS"; 
parameter CSEL_IREG_CE = "CE0"; 
parameter CSEL_IREG_RESET = "RESET0"; 
parameter CASISEL_IREG_CLK = "BYPASS"; 
parameter CASISEL_IREG_CE = "CE0"; 
parameter CASISEL_IREG_RESET = "RESET0"; 
parameter ACCSEL_IREG_CLK = "BYPASS"; 
parameter ACCSEL_IREG_CE = "CE0"; 
parameter ACCSEL_IREG_RESET = "RESET0"; 
parameter PREG_CLK = "BYPASS"; 
parameter PREG_CE = "CE0"; 
parameter PREG_RESET = "RESET0"; 
parameter ADDSUB0_PREG_CLK = "BYPASS"; 
parameter ADDSUB0_PREG_CE = "CE0"; 
parameter ADDSUB0_PREG_RESET = "RESET0"; 
parameter ADDSUB1_PREG_CLK = "BYPASS"; 
parameter ADDSUB1_PREG_CE = "CE0"; 
parameter ADDSUB1_PREG_RESET = "RESET0"; 
parameter CSEL_PREG_CLK = "BYPASS"; 
parameter CSEL_PREG_CE = "CE0"; 
parameter CSEL_PREG_RESET = "RESET0"; 
parameter CASISEL_PREG_CLK = "BYPASS"; 
parameter CASISEL_PREG_CE = "CE0"; 
parameter CASISEL_PREG_RESET = "RESET0"; 
parameter ACCSEL_PREG_CLK = "BYPASS"; 
parameter ACCSEL_PREG_CE = "CE0"; 
parameter ACCSEL_PREG_RESET = "RESET0"; 
parameter C_PREG_CLK = "BYPASS"; 
parameter C_PREG_CE = "CE0"; 
parameter C_PREG_RESET = "RESET0"; 
parameter FB_PREG_EN = "FALSE"; 
parameter SOA_PREG_EN = "FALSE"; 
parameter OREG_CLK = "BYPASS"; 
parameter OREG_CE = "CE0"; 
parameter OREG_RESET = "RESET0"; 
parameter MULT_RESET_MODE = "SYNC";
parameter PRE_LOAD = 48'h000000000000;
parameter DYN_P_SEL = "FALSE";
parameter P_SEL = 1'b0;
parameter DYN_P_ADDSUB = "FALSE";
parameter P_ADDSUB = 1'b0;
parameter DYN_A_SEL = "FALSE";
parameter A_SEL = 1'b0;
parameter DYN_ADD_SUB_0 = "FALSE";
parameter ADD_SUB_0 = 1'b0;
parameter DYN_ADD_SUB_1 = "FALSE";
parameter ADD_SUB_1 = 1'b0;
parameter DYN_C_SEL = "FALSE";
parameter C_SEL = 1'b1;
parameter DYN_CASI_SEL = "FALSE";
parameter CASI_SEL = 1'b0;
parameter DYN_ACC_SEL = "FALSE";
parameter ACC_SEL = 1'b0;
parameter MULT12X12_EN = "FALSE";
output [47:0] DOUT, CASO;
output [26:0] SOA;
input  [26:0] A, SIA;
input  [17:0] B;
input  [47:0] C;
input  [25:0] D;
input  [47:0] CASI;
input  ACCSEL;
input  PSEL;
input  ASEL;
input  PADDSUB;
input  CSEL, CASISEL;
input  [1:0] ADDSUB;
input  [1:0] CLK, CE, RESET;
endmodule

module MULT12X12 (...);
parameter AREG_CLK = "BYPASS"; 
parameter AREG_CE = "CE0"; 
parameter AREG_RESET = "RESET0"; 
parameter BREG_CLK = "BYPASS"; 
parameter BREG_CE = "CE0"; 
parameter BREG_RESET = "RESET0"; 
parameter PREG_CLK = "BYPASS"; 
parameter PREG_CE = "CE0"; 
parameter PREG_RESET = "RESET0"; 
parameter OREG_CLK = "BYPASS"; 
parameter OREG_CE = "CE0"; 
parameter OREG_RESET = "RESET0"; 
parameter MULT_RESET_MODE = "SYNC";
output [23:0] DOUT;
input  [11:0] A, B;
input  [1:0] CLK, CE, RESET;
endmodule

module MULT27X36 (...);
parameter AREG_CLK = "BYPASS"; 
parameter AREG_CE = "CE0"; 
parameter AREG_RESET = "RESET0"; 
parameter BREG_CLK = "BYPASS"; 
parameter BREG_CE = "CE0"; 
parameter BREG_RESET = "RESET0"; 
parameter DREG_CLK = "BYPASS"; 
parameter DREG_CE = "CE0"; 
parameter DREG_RESET = "RESET0"; 
parameter PADDSUB_IREG_CLK = "BYPASS"; 
parameter PADDSUB_IREG_CE = "CE0"; 
parameter PADDSUB_IREG_RESET = "RESET0"; 
parameter PREG_CLK = "BYPASS"; 
parameter PREG_CE = "CE0"; 
parameter PREG_RESET = "RESET0"; 
parameter PSEL_IREG_CLK = "BYPASS"; 
parameter PSEL_IREG_CE = "CE0"; 
parameter PSEL_IREG_RESET = "RESET0"; 
parameter OREG_CLK = "BYPASS"; 
parameter OREG_CE = "CE0"; 
parameter OREG_RESET = "RESET0"; 
parameter MULT_RESET_MODE = "SYNC";
parameter DYN_P_SEL = "FALSE";
parameter P_SEL = 1'b0;
parameter DYN_P_ADDSUB = "FALSE";
parameter P_ADDSUB = 1'b0;
output [62:0] DOUT;
input  [26:0] A;
input  [35:0] B;
input  [25:0] D;
input  [1:0] CLK, CE, RESET;
input  PSEL;
input  PADDSUB;
endmodule

module MULTACC (...);
output  [23:0] DATAO, CASO;
input CE, CLK;
input [5:0] COFFIN0, COFFIN1, COFFIN2;
input [9:0] DATAIN0, DATAIN1;
input [9:0] DATAIN2;
input RSTN;
input [23:0] CASI;
parameter COFFIN_WIDTH = 4; 
parameter DATAIN_WIDTH = 8; 
parameter IREG = 1'b0; 
parameter OREG = 1'b0; 
parameter PREG = 1'b0; 
parameter ACC_EN = "FALSE";  
parameter CASI_EN = "FALSE"; 
parameter CASO_EN = "FALSE"; 
endmodule

module IDDR_MEM (...);
input D, ICLK, PCLK;
input [2:0] WADDR;
input [2:0] RADDR;
input RESET;
output  Q0,Q1;
endmodule


module ODDR_MEM (...);
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1;
input TX, PCLK, TCLK, RESET;
output  Q0, Q1;
endmodule


module IDES4_MEM (...);
input PCLK, D, ICLK, FCLK, RESET, CALIB;
input [2:0] WADDR;
input [2:0] RADDR;
output Q0,Q1,Q2,Q3;
endmodule


module IDES8_MEM (...);
input PCLK, D, ICLK, FCLK, RESET, CALIB;
input [2:0] WADDR;
input [2:0] RADDR;
output Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7;
endmodule


module IDES14 (...);
input D, FCLK, PCLK, CALIB,RESET;
output Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12, Q13;
endmodule


module IDES32 (...);
input D, FCLK, PCLK, CALIB,RESET;
output Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12, Q13, Q14, Q15, Q16, Q17, Q18, Q19, Q20, Q21, Q22, Q23, Q24, Q25, Q26, Q27, Q28, Q29, Q30, Q31;
endmodule


module OSER4_MEM (...);
parameter HWL = "false";     
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1, D2, D3;
input TX0, TX1;
input PCLK, FCLK, TCLK, RESET;
output  Q0,  Q1;
endmodule


module OSER8_MEM (...);
parameter HWL = "false";    
parameter TCLK_SOURCE = "DQSW"; 
parameter TXCLK_POL = 1'b0; 
input D0, D1, D2, D3, D4, D5, D6, D7;
input TX0, TX1, TX2, TX3;
input PCLK, FCLK, TCLK, RESET;
output  Q0,  Q1;
endmodule


module OSER14 (...);
input D0, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13;
input PCLK, FCLK, RESET;
output  Q;
endmodule

module IODELAY (...);
parameter C_STATIC_DLY = 0; 
parameter DYN_DLY_EN = "FALSE";
parameter ADAPT_EN = "FALSE";
input  DI;
input  SDTAP;
input  VALUE;
input  [7:0] DLYSTEP;
output DF;
output DO;
endmodule


module OSIDES32 (...);
output [31:0] Q;
input D;
input PCLK, FCLKP, FCLKN, FCLKQP, FCLKQN;
input RESET;
output DF0, DF1;
input  SDTAP0, SDTAP1;
input  VALUE0,VALUE1;
input  [7:0] DLYSTEP0,DLYSTEP1;
parameter C_STATIC_DLY_0 = 0; 
parameter DYN_DLY_EN_0 = "FALSE";
parameter ADAPT_EN_0 = "FALSE";
parameter C_STATIC_DLY_1 = 0; 
parameter DYN_DLY_EN_1 = "FALSE";
parameter ADAPT_EN_1 = "FALSE";
endmodule

module OSIDES64 (...);
output [63:0] Q;
input D;
input PCLK, FCLKP, FCLKN, FCLKQP, FCLKQN;
input RESET;
output DF0, DF1, DF2, DF3;
input  SDTAP0, SDTAP1, SDTAP2, SDTAP3;
input  VALUE0, VALUE1, VALUE2, VALUE3;
input  [7:0] DLYSTEP0, DLYSTEP1, DLYSTEP2, DLYSTEP3;
parameter C_STATIC_DLY_0 = 0; 
parameter DYN_DLY_EN_0 = "FALSE";
parameter ADAPT_EN_0 = "FALSE";
parameter C_STATIC_DLY_1 = 0; 
parameter DYN_DLY_EN_1 = "FALSE";
parameter ADAPT_EN_1 = "FALSE";
parameter C_STATIC_DLY_2 = 0; 
parameter DYN_DLY_EN_2 = "FALSE";
parameter ADAPT_EN_2 = "FALSE";
parameter C_STATIC_DLY_3 = 0; 
parameter DYN_DLY_EN_3 = "FALSE";
parameter ADAPT_EN_3 = "FALSE";
endmodule

module DCE (...);
input CLKIN;
input CE;
output CLKOUT;
endmodule

module DDRDLL (...);
input CLKIN;
input STOP;
input UPDNCNTL;
input RESET;
output [7:0]STEP;
output LOCK;
parameter DLL_FORCE = "FALSE";
parameter CODESCAL = "000";
parameter SCAL_EN = "TRUE";
parameter DIV_SEL = 1'b0; 
endmodule

module DLLDLY (...);
input CLKIN;
input [7:0] DLLSTEP, CSTEP;
input LOADN,MOVE;
output CLKOUT;
output FLAG;
parameter DLY_SIGN = 1'b0; 
parameter DLY_ADJ = 0; 
parameter DYN_DLY_EN = "FALSE";
parameter ADAPT_EN = "FALSE";
parameter STEP_SEL = 1'b0;
endmodule

module CLKDIV (...);
input HCLKIN;
input RESETN;
input CALIB;
output CLKOUT;
parameter DIV_MODE = "2"; 
endmodule

module CLKDIV2 (...);
input HCLKIN, RESETN;
output CLKOUT;
endmodule

module DHCE (...);
input CLKIN;
input CEN;
output CLKOUT;
endmodule

module OSCA (...);
parameter  FREQ_DIV = 100; 
output OSCOUT;
input OSCEN;
endmodule

module OSCB (...);
parameter FREQ_MODE = "25"; 
parameter FREQ_DIV = 10; 
parameter DYN_TRIM_EN = "FALSE"; 
output OSCOUT;
output OSCREF;
input OSCEN, FMODE;
input [7:0] RTRIM;
input [5:0] RTCTRIM; 
endmodule

module PLL (...);
input CLKIN;
input CLKFB;
input RESET;
input PLLPWD;
input RESET_I;
input RESET_O;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [6:0] MDSEL;
input [2:0] MDSEL_FRAC;
input [6:0] ODSEL0;
input [2:0] ODSEL0_FRAC;
input [6:0] ODSEL1;
input [6:0] ODSEL2;
input [6:0] ODSEL3;
input [6:0] ODSEL4;
input [6:0] ODSEL5;
input [6:0] ODSEL6;
input [3:0] DT0,DT1,DT2,DT3;
input [5:0] ICPSEL;
input [2:0] LPFRES;
input [1:0] LPFCAP;
input [2:0] PSSEL;
input PSDIR;
input PSPULSE;
input ENCLK0;
input ENCLK1;
input ENCLK2;
input ENCLK3;
input ENCLK4;
input ENCLK5;
input ENCLK6;
input SSCPOL;
input SSCON;
input [6:0] SSCMDSEL;
input [2:0] SSCMDSEL_FRAC;
output LOCK;
output CLKOUT0;
output CLKOUT1;
output CLKOUT2;
output CLKOUT3;
output CLKOUT4;
output CLKOUT5;
output CLKOUT6;
output CLKFBOUT;
parameter FCLKIN = "100.0"; 
parameter DYN_IDIV_SEL= "FALSE";
parameter IDIV_SEL = 1; 
parameter DYN_FBDIV_SEL= "FALSE";
parameter FBDIV_SEL = 1; 
parameter DYN_ODIV0_SEL= "FALSE";
parameter ODIV0_SEL = 8; 
parameter DYN_ODIV1_SEL= "FALSE";
parameter ODIV1_SEL = 8; 
parameter DYN_ODIV2_SEL= "FALSE";
parameter ODIV2_SEL = 8; 
parameter DYN_ODIV3_SEL= "FALSE";
parameter ODIV3_SEL = 8; 
parameter DYN_ODIV4_SEL= "FALSE";
parameter ODIV4_SEL = 8; 
parameter DYN_ODIV5_SEL= "FALSE";
parameter ODIV5_SEL = 8; 
parameter DYN_ODIV6_SEL= "FALSE";
parameter ODIV6_SEL = 8; 
parameter DYN_MDIV_SEL= "FALSE";
parameter MDIV_SEL = 8; 
parameter MDIV_FRAC_SEL = 0; 
parameter ODIV0_FRAC_SEL = 0; 
parameter CLKOUT0_EN = "TRUE";
parameter CLKOUT1_EN = "FALSE";
parameter CLKOUT2_EN = "FALSE";
parameter CLKOUT3_EN = "FALSE";
parameter CLKOUT4_EN = "FALSE";
parameter CLKOUT5_EN = "FALSE";
parameter CLKOUT6_EN = "FALSE";
parameter CLKFB_SEL = "INTERNAL"; 
parameter DYN_DT0_SEL = "FALSE"; 
parameter DYN_DT1_SEL = "FALSE"; 
parameter DYN_DT2_SEL = "FALSE"; 
parameter DYN_DT3_SEL = "FALSE"; 
parameter CLKOUT0_DT_DIR = 1'b1; 
parameter CLKOUT1_DT_DIR = 1'b1; 
parameter CLKOUT2_DT_DIR = 1'b1; 
parameter CLKOUT3_DT_DIR = 1'b1; 
parameter CLKOUT0_DT_STEP = 0; 
parameter CLKOUT1_DT_STEP = 0; 
parameter CLKOUT2_DT_STEP = 0; 
parameter CLKOUT3_DT_STEP = 0; 
parameter CLK0_IN_SEL = 1'b0;
parameter CLK0_OUT_SEL = 1'b0;
parameter CLK1_IN_SEL = 1'b0;
parameter CLK1_OUT_SEL = 1'b0;
parameter CLK2_IN_SEL = 1'b0;
parameter CLK2_OUT_SEL = 1'b0;
parameter CLK3_IN_SEL = 1'b0;
parameter CLK3_OUT_SEL = 1'b0;
parameter CLK4_IN_SEL = 2'b00;
parameter CLK4_OUT_SEL = 1'b0;
parameter CLK5_IN_SEL = 1'b0;
parameter CLK5_OUT_SEL = 1'b0;
parameter CLK6_IN_SEL = 1'b0;
parameter CLK6_OUT_SEL = 1'b0;
parameter DYN_DPA_EN = "FALSE";
parameter CLKOUT0_PE_COARSE = 0;
parameter CLKOUT0_PE_FINE = 0;
parameter CLKOUT1_PE_COARSE = 0;
parameter CLKOUT1_PE_FINE = 0;
parameter CLKOUT2_PE_COARSE = 0;
parameter CLKOUT2_PE_FINE = 0;
parameter CLKOUT3_PE_COARSE = 0;
parameter CLKOUT3_PE_FINE = 0;
parameter CLKOUT4_PE_COARSE = 0;
parameter CLKOUT4_PE_FINE = 0;
parameter CLKOUT5_PE_COARSE = 0;
parameter CLKOUT5_PE_FINE = 0;
parameter CLKOUT6_PE_COARSE = 0;
parameter CLKOUT6_PE_FINE = 0;
parameter DYN_PE0_SEL = "FALSE";
parameter DYN_PE1_SEL = "FALSE";
parameter DYN_PE2_SEL = "FALSE";
parameter DYN_PE3_SEL = "FALSE";
parameter DYN_PE4_SEL = "FALSE";
parameter DYN_PE5_SEL = "FALSE";
parameter DYN_PE6_SEL = "FALSE";
parameter DE0_EN = "FALSE";
parameter DE1_EN = "FALSE";
parameter DE2_EN = "FALSE";
parameter DE3_EN = "FALSE";
parameter DE4_EN = "FALSE";
parameter DE5_EN = "FALSE";
parameter DE6_EN = "FALSE";
parameter RESET_I_EN = "FALSE";
parameter RESET_O_EN =  "FALSE";
parameter DYN_ICP_SEL= "FALSE";
parameter ICP_SEL = 6'bXXXXXX;
parameter DYN_LPF_SEL= "FALSE";
parameter LPF_RES = 3'bXXX;
parameter LPF_CAP = 2'b00;
parameter SSC_EN = "FALSE";
endmodule

module PLLA (...);
input CLKIN;
input CLKFB;
input RESET;
input PLLPWD;
input RESET_I;
input RESET_O;
input [2:0] PSSEL;
input PSDIR;
input PSPULSE;
input SSCPOL;
input SSCON;
input [6:0] SSCMDSEL;
input [2:0] SSCMDSEL_FRAC;
input MDCLK;
input [1:0] MDOPC;
input MDAINC;
input [7:0] MDWDI;
output [7:0] MDRDO;
output LOCK;
output CLKOUT0;
output CLKOUT1;
output CLKOUT2;
output CLKOUT3;
output CLKOUT4;
output CLKOUT5;
output CLKOUT6;
output CLKFBOUT;
parameter FCLKIN = "100.0"; 
parameter IDIV_SEL = 1; 
parameter FBDIV_SEL = 1; 
parameter ODIV0_SEL = 8; 
parameter ODIV1_SEL = 8; 
parameter ODIV2_SEL = 8; 
parameter ODIV3_SEL = 8; 
parameter ODIV4_SEL = 8; 
parameter ODIV5_SEL = 8; 
parameter ODIV6_SEL = 8; 
parameter MDIV_SEL = 8; 
parameter MDIV_FRAC_SEL = 0; 
parameter ODIV0_FRAC_SEL = 0; 
parameter CLKOUT0_EN = "TRUE";
parameter CLKOUT1_EN = "FALSE";
parameter CLKOUT2_EN = "FALSE";
parameter CLKOUT3_EN = "FALSE";
parameter CLKOUT4_EN = "FALSE";
parameter CLKOUT5_EN = "FALSE";
parameter CLKOUT6_EN = "FALSE";
parameter CLKFB_SEL = "INTERNAL"; 
parameter CLKOUT0_DT_DIR = 1'b1; 
parameter CLKOUT1_DT_DIR = 1'b1; 
parameter CLKOUT2_DT_DIR = 1'b1; 
parameter CLKOUT3_DT_DIR = 1'b1; 
parameter CLKOUT0_DT_STEP = 0; 
parameter CLKOUT1_DT_STEP = 0; 
parameter CLKOUT2_DT_STEP = 0; 
parameter CLKOUT3_DT_STEP = 0; 
parameter CLK0_IN_SEL = 1'b0;
parameter CLK0_OUT_SEL = 1'b0;
parameter CLK1_IN_SEL = 1'b0;
parameter CLK1_OUT_SEL = 1'b0;
parameter CLK2_IN_SEL = 1'b0;
parameter CLK2_OUT_SEL = 1'b0;
parameter CLK3_IN_SEL = 1'b0;
parameter CLK3_OUT_SEL = 1'b0;
parameter CLK4_IN_SEL = 2'b00;
parameter CLK4_OUT_SEL = 1'b0;
parameter CLK5_IN_SEL = 1'b0;
parameter CLK5_OUT_SEL = 1'b0;
parameter CLK6_IN_SEL = 1'b0;
parameter CLK6_OUT_SEL = 1'b0;
parameter DYN_DPA_EN = "FALSE";
parameter CLKOUT0_PE_COARSE = 0;
parameter CLKOUT0_PE_FINE = 0;
parameter CLKOUT1_PE_COARSE = 0;
parameter CLKOUT1_PE_FINE = 0;
parameter CLKOUT2_PE_COARSE = 0;
parameter CLKOUT2_PE_FINE = 0;
parameter CLKOUT3_PE_COARSE = 0;
parameter CLKOUT3_PE_FINE = 0;
parameter CLKOUT4_PE_COARSE = 0;
parameter CLKOUT4_PE_FINE = 0;
parameter CLKOUT5_PE_COARSE = 0;
parameter CLKOUT5_PE_FINE = 0;
parameter CLKOUT6_PE_COARSE = 0;
parameter CLKOUT6_PE_FINE = 0;
parameter DYN_PE0_SEL = "FALSE";
parameter DYN_PE1_SEL = "FALSE";
parameter DYN_PE2_SEL = "FALSE";
parameter DYN_PE3_SEL = "FALSE";
parameter DYN_PE4_SEL = "FALSE";
parameter DYN_PE5_SEL = "FALSE";
parameter DYN_PE6_SEL = "FALSE";
parameter DE0_EN = "FALSE";
parameter DE1_EN = "FALSE";
parameter DE2_EN = "FALSE";
parameter DE3_EN = "FALSE";
parameter DE4_EN = "FALSE";
parameter DE5_EN = "FALSE";
parameter DE6_EN = "FALSE";
parameter RESET_I_EN = "FALSE";
parameter RESET_O_EN =  "FALSE";
parameter ICP_SEL = 6'bXXXXXX;
parameter LPF_RES = 3'bXXX;
parameter LPF_CAP = 2'b00;
parameter SSC_EN = "FALSE";
endmodule

module AE350_SOC (...);
input               POR_N;
input               HW_RSTN;
input               CORE_CLK;
input               DDR_CLK;
input               AHB_CLK;
input               APB_CLK;
input               DBG_TCK;
input               RTC_CLK;
input               CORE_CE;
input               AXI_CE;
input               DDR_CE;
input               AHB_CE;
input     [7:0]     APB_CE;
input               APB2AHB_CE;
input               SCAN_TEST;
input               SCAN_EN;
output              PRESETN;
output              HRESETN;
output              DDR_RSTN;
input       [15:0]  GP_INT;
input       [ 7:0]  DMA_REQ;
output      [ 7:0]  DMA_ACK;
output              CORE0_WFI_MODE;
input               WAKEUP_IN;           
output              RTC_WAKEUP;           
input               TEST_CLK;
input               TEST_MODE;
input               TEST_RSTN;
output  [31:0]      ROM_HADDR;
input   [31:0]      ROM_HRDATA;
input               ROM_HREADY;
input               ROM_HRESP;
output   [1:0]      ROM_HTRANS;
output              ROM_HWRITE;
output  [31:0]      APB_PADDR;
output              APB_PENABLE;
input   [31:0]      APB_PRDATA;
input               APB_PREADY;
output              APB_PSEL;
output  [31:0]      APB_PWDATA;
output              APB_PWRITE;
input               APB_PSLVERR;
output   [2:0]      APB_PPROT;
output   [3:0]      APB_PSTRB;
input   [31:0]      EXTS_HRDATA;
input               EXTS_HREADYIN;
input               EXTS_HRESP;
output  [31:0]      EXTS_HADDR;
output   [2:0]      EXTS_HBURST;
output   [3:0]      EXTS_HPROT;
output              EXTS_HSEL;
output   [2:0]      EXTS_HSIZE;
output   [1:0]      EXTS_HTRANS;
output  [31:0]      EXTS_HWDATA;
output              EXTS_HWRITE;
input   [31:0]      EXTM_HADDR;
input    [2:0]      EXTM_HBURST;
input    [3:0]      EXTM_HPROT;
output  [63:0]      EXTM_HRDATA;
input               EXTM_HREADY;
output              EXTM_HREADYOUT;
output              EXTM_HRESP;
input               EXTM_HSEL;
input    [2:0]      EXTM_HSIZE;
input    [1:0]      EXTM_HTRANS;
input   [63:0]      EXTM_HWDATA;
input               EXTM_HWRITE;
output  [31:0]      DDR_HADDR;
output   [2:0]      DDR_HBURST;
output   [3:0]      DDR_HPROT;
input   [63:0]      DDR_HRDATA;
input               DDR_HREADY;
input               DDR_HRESP;
output   [2:0]      DDR_HSIZE;
output   [1:0]      DDR_HTRANS;
output  [63:0]      DDR_HWDATA;
output              DDR_HWRITE;
input               TMS_IN;           
input               TRST_IN;
input               TDI_IN;
output              TDO_OUT;
output              TDO_OE;
input               SPI2_HOLDN_IN;
input               SPI2_WPN_IN;
input               SPI2_CLK_IN;
input               SPI2_CSN_IN;
input               SPI2_MISO_IN;
input               SPI2_MOSI_IN;
output              SPI2_HOLDN_OUT;
output              SPI2_HOLDN_OE;
output              SPI2_WPN_OUT;
output              SPI2_WPN_OE;
output              SPI2_CLK_OUT;
output              SPI2_CLK_OE;
output              SPI2_CSN_OUT;
output              SPI2_CSN_OE;
output              SPI2_MISO_OUT;
output              SPI2_MISO_OE;
output              SPI2_MOSI_OUT;
output              SPI2_MOSI_OE;
input               I2C_SCL_IN;
input               I2C_SDA_IN;
output              I2C_SCL;
output              I2C_SDA;
output              UART1_TXD;
output              UART1_RTSN;
input               UART1_RXD;
input               UART1_CTSN;
input               UART1_DSRN;
input               UART1_DCDN;
input               UART1_RIN;
output              UART1_DTRN;
output              UART1_OUT1N;
output              UART1_OUT2N;
output              UART2_TXD;
output              UART2_RTSN;
input               UART2_RXD;
input               UART2_CTSN;
input               UART2_DCDN;
input               UART2_DSRN;
input               UART2_RIN;
output              UART2_DTRN;
output              UART2_OUT1N;
output              UART2_OUT2N;
output              CH0_PWM;
output              CH0_PWMOE;
output              CH1_PWM;
output              CH1_PWMOE;
output              CH2_PWM;
output              CH2_PWMOE;
output              CH3_PWM;
output              CH3_PWMOE;
input     [31:0]    GPIO_IN;
output    [31:0]    GPIO_OE;
output    [31:0]    GPIO_OUT;
input	 [19:0]	SCAN_IN;
input		INTEG_TCK;
input		INTEG_TDI;
input		INTEG_TMS;
input		INTEG_TRST;
output		INTEG_TDO;
output   [19:0]	SCAN_OUT;
input		PGEN_CHAIN_I;
output		PRDYN_CHAIN_O;
input	[2:0]	EMA;
input	[1:0]	EMAW;
input		EMAS;
input		RET1N;
input		RET2N;
endmodule

module AE350_RAM (...);
input               POR_N;
input               HW_RSTN;
input               CORE_CLK;
input               AHB_CLK;
input               APB_CLK;
input               RTC_CLK;
input               CORE_CE;
input               AXI_CE;
input               AHB_CE;
input   [31:0]      EXTM_HADDR;
input    [2:0]      EXTM_HBURST;
input    [3:0]      EXTM_HPROT;
output  [63:0]      EXTM_HRDATA;
input               EXTM_HREADY;
output              EXTM_HREADYOUT;
output              EXTM_HRESP;
input               EXTM_HSEL;
input    [2:0]      EXTM_HSIZE;
input    [1:0]      EXTM_HTRANS;
input   [63:0]      EXTM_HWDATA;
input               EXTM_HWRITE;
input	[2:0]	EMA;
input	[1:0]	EMAW;
input		EMAS;
input		RET1N;
input		RET2N;
endmodule

module SAMB (...);
parameter MODE = 2'b00; 
input [23:0] SPIAD;
input LOAD;
input ADWSEL; 
endmodule

module OTP (...);
parameter MODE = 2'b01; 
input CLK, READ, SHIFT;
output DOUT;
endmodule

module CMSER (...);
output RUNNING;
output CRCERR;
output CRCDONE;
output ECCCORR;
output ECCUNCORR; 
output [27:0] ERRLOC;
output ECCDEC;
output DSRRD;
output DSRWR; 
output ASRRESET;
output ASRINC;
output REFCLK;
input CLK;
input [2:0] SEREN;
input ERRINJECT;
input [6:0] ERRINJLOC;
endmodule

module CMSERA (...);
output RUNNING;
output CRCERR;
output CRCDONE;
output ECCCORR;
output ECCUNCORR; 
output [26:0] ERR0LOC;
output [26:0] ERR1LOC;
output ECCDEC;
output DSRRD;
output DSRWR; 
output ASRRESET;
output ASRINC;
output REFCLK;
input CLK;
input [2:0] SEREN;
input ERR0INJECT,ERR1INJECT;
input [6:0] ERRINJ0LOC,ERRINJ1LOC;
endmodule

module CMSERB (...);
output RUNNING;
output CRCERR;
output CRCDONE;
output ECCCORR;
output ECCUNCORR; 
output [12:0] ERRLOC;
output ECCDEC;
output DSRRD;
output DSRWR; 
output ASRRESET;
output ASRINC;
output REFCLK;
input CLK;
input [2:0] SEREN;
input ERR0INJECT,ERR1INJECT;
input [6:0] ERRINJ0LOC,ERRINJ1LOC;
endmodule

module SAMBA (...);
parameter MODE = 2'b00; 
input SPIAD;
input LOAD;
endmodule

module ADCLRC (...);
endmodule

module ADCULC (...);
endmodule

module ADC (...);
endmodule

module ADC_SAR (...);
endmodule

module LICD (...);
endmodule

module MIPI_DPHY (...);
output RX_CLK_O, TX_CLK_O;
output [15:0] D0LN_HSRXD, D1LN_HSRXD, D2LN_HSRXD, D3LN_HSRXD;
output D0LN_HSRXD_VLD,D1LN_HSRXD_VLD,D2LN_HSRXD_VLD,D3LN_HSRXD_VLD;
input  D0LN_HSRX_DREN, D1LN_HSRX_DREN,  D2LN_HSRX_DREN,  D3LN_HSRX_DREN;
output  DI_LPRX0_N, DI_LPRX0_P, DI_LPRX1_N, DI_LPRX1_P, DI_LPRX2_N,  DI_LPRX2_P, DI_LPRX3_N, DI_LPRX3_P, DI_LPRXCK_N, DI_LPRXCK_P;
inout  CK_N, CK_P, D0_N, D0_P, D1_N, D1_P, D2_N, D2_P, D3_N, D3_P;
input HSRX_STOP, HSTXEN_LN0, HSTXEN_LN1, HSTXEN_LN2, HSTXEN_LN3, HSTXEN_LNCK,
     LPTXEN_LN0, LPTXEN_LN1, LPTXEN_LN2, LPTXEN_LN3, LPTXEN_LNCK;
input PWRON_RX, PWRON_TX, RESET, RX_CLK_1X, TX_CLK_1X;
input TXDPEN_LN0, TXDPEN_LN1, TXDPEN_LN2, TXDPEN_LN3, TXDPEN_LNCK, TXHCLK_EN;
input [15:0]  CKLN_HSTXD,D0LN_HSTXD,D1LN_HSTXD,D2LN_HSTXD,D3LN_HSTXD;
input HSTXD_VLD;
input CK0, CK90, CK180, CK270;
input DO_LPTX0_N, DO_LPTX1_N, DO_LPTX2_N, DO_LPTX3_N, DO_LPTXCK_N, DO_LPTX0_P, DO_LPTX1_P, DO_LPTX2_P, DO_LPTX3_P, DO_LPTXCK_P;
input HSRX_EN_CK, HSRX_EN_D0, HSRX_EN_D1, HSRX_EN_D2, HSRX_EN_D3, HSRX_ODTEN_CK, 
     HSRX_ODTEN_D0, HSRX_ODTEN_D1, HSRX_ODTEN_D2, HSRX_ODTEN_D3, LPRX_EN_CK,
     LPRX_EN_D0, LPRX_EN_D1, LPRX_EN_D2, LPRX_EN_D3; 
input RX_DRST_N, TX_DRST_N, WALIGN_DVLD;
output [7:0] MRDATA;
input MA_INC, MCLK;
input [1:0] MOPCODE;
input [7:0] MWDATA;
output  ALPEDO_LANE0, ALPEDO_LANE1, ALPEDO_LANE2, ALPEDO_LANE3, ALPEDO_LANECK;
output D1LN_DESKEW_DONE,D2LN_DESKEW_DONE,D3LN_DESKEW_DONE,D0LN_DESKEW_DONE;
output D1LN_DESKEW_ERROR, D2LN_DESKEW_ERROR, D3LN_DESKEW_ERROR, D0LN_DESKEW_ERROR;
input D0LN_DESKEW_REQ, D1LN_DESKEW_REQ, D2LN_DESKEW_REQ, D3LN_DESKEW_REQ;
input HSRX_DLYDIR_LANE0, HSRX_DLYDIR_LANE1, HSRX_DLYDIR_LANE2, HSRX_DLYDIR_LANE3, HSRX_DLYDIR_LANECK;
input HSRX_DLYLDN_LANE0, HSRX_DLYLDN_LANE1, HSRX_DLYLDN_LANE2, HSRX_DLYLDN_LANE3, HSRX_DLYLDN_LANECK;
input HSRX_DLYMV_LANE0, HSRX_DLYMV_LANE1,  HSRX_DLYMV_LANE2, HSRX_DLYMV_LANE3, HSRX_DLYMV_LANECK;
input  ALP_EDEN_LANE0, ALP_EDEN_LANE1, ALP_EDEN_LANE2, ALP_EDEN_LANE3, ALP_EDEN_LANECK, ALPEN_LN0, ALPEN_LN1, ALPEN_LN2, ALPEN_LN3, ALPEN_LNCK;
parameter        TX_PLLCLK = "NONE"; 
parameter        RX_ALIGN_BYTE                  = 8'b10111000 ; 
parameter        RX_HS_8BIT_MODE                = 1'b0 ; 
parameter        RX_LANE_ALIGN_EN               = 1'b0 ; 
parameter        TX_HS_8BIT_MODE                = 1'b0 ; 
parameter        HSREG_EN_LN0                   = 1'b0;  
parameter        HSREG_EN_LN1                   = 1'b0;  
parameter        HSREG_EN_LN2                   = 1'b0;  
parameter        HSREG_EN_LN3                   = 1'b0;  
parameter        HSREG_EN_LNCK                  = 1'b0;  
parameter        LANE_DIV_SEL                   = 2'b00;  
parameter        HSRX_EN                        = 1'b1 ;  
parameter        HSRX_LANESEL                   = 4'b1111 ;   
parameter        HSRX_LANESEL_CK                = 1'b1 ;   
parameter        HSTX_EN_LN0                    = 1'b0 ;   
parameter        HSTX_EN_LN1                    = 1'b0 ;   
parameter        HSTX_EN_LN2                    = 1'b0 ;   
parameter        HSTX_EN_LN3                    = 1'b0 ;   
parameter        HSTX_EN_LNCK                   = 1'b0 ;   
parameter        LPTX_EN_LN0                    = 1'b1 ;   
parameter        LPTX_EN_LN1                    = 1'b1 ;   
parameter        LPTX_EN_LN2                    = 1'b1 ;   
parameter        LPTX_EN_LN3                    = 1'b1 ;   
parameter        LPTX_EN_LNCK                   = 1'b1 ;   
parameter        TXDP_EN_LN0                    = 1'b0 ;  
parameter        TXDP_EN_LN1                    = 1'b0 ;   
parameter        TXDP_EN_LN2                    = 1'b0 ;   
parameter        TXDP_EN_LN3                    = 1'b0 ;   
parameter        TXDP_EN_LNCK                   = 1'b0 ;
parameter        CKLN_DELAY_EN                  = 1'b0;  
parameter        CKLN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D0LN_DELAY_EN                  = 1'b0;  
parameter        D0LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D0LN_DESKEW_BYPASS             = 1'b0;  
parameter        D1LN_DELAY_EN                  = 1'b0;  
parameter        D1LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D1LN_DESKEW_BYPASS             = 1'b0;  
parameter        D2LN_DELAY_EN                  = 1'b0;  
parameter        D2LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D2LN_DESKEW_BYPASS             = 1'b0;  
parameter        D3LN_DELAY_EN                  = 1'b0;  
parameter        D3LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D3LN_DESKEW_BYPASS             = 1'b0;  
parameter        DESKEW_EN_LOW_DELAY            = 1'b0;  
parameter        DESKEW_EN_ONE_EDGE             = 1'b0;  
parameter        DESKEW_FAST_LOOP_TIME          = 4'b0000;  
parameter        DESKEW_FAST_MODE               = 1'b0;  
parameter        DESKEW_HALF_OPENING            = 6'b010110; 
parameter        DESKEW_LSB_MODE                = 2'b00;  
parameter        DESKEW_M                       = 3'b011;  
parameter        DESKEW_M_TH                    = 13'b0000110100110; 
parameter        DESKEW_MAX_SETTING           = 7'b0100001; 
parameter        DESKEW_ONE_CLK_EDGE_EN       = 1'b0 ; 
parameter        DESKEW_RST_BYPASS              = 1'b0 ; 
parameter        RX_BYTE_LITTLE_ENDIAN          = 1'b1 ; 
parameter        RX_CLK_1X_SYNC_SEL             = 1'b0 ; 
parameter        RX_INVERT                      = 1'b0 ; 
parameter        RX_ONE_BYTE0_MATCH             = 1'b0 ; 
parameter        RX_RD_START_DEPTH              = 5'b00001; 
parameter        RX_SYNC_MODE                   = 1'b0 ; 
parameter        RX_WORD_ALIGN_BYPASS           = 1'b0 ; 
parameter        RX_WORD_ALIGN_DATA_VLD_SRC_SEL = 1'b0 ; 
parameter        RX_WORD_LITTLE_ENDIAN          = 1'b1 ; 
parameter        TX_BYPASS_MODE                 = 1'b0 ; 
parameter        TX_BYTECLK_SYNC_MODE           = 1'b0 ; 
parameter        TX_OCLK_USE_CIBCLK             = 1'b0 ; 
parameter        TX_RD_START_DEPTH              = 5'b00001; 
parameter        TX_SYNC_MODE                   = 1'b0 ; 
parameter        TX_WORD_LITTLE_ENDIAN          = 1'b1 ; 
parameter        EQ_CS_LANE0                    = 3'b100;  
parameter        EQ_CS_LANE1                    = 3'b100;  
parameter        EQ_CS_LANE2                    = 3'b100;  
parameter        EQ_CS_LANE3                    = 3'b100;  
parameter        EQ_CS_LANECK                   = 3'b100;  
parameter        EQ_RS_LANE0                    = 3'b100;  
parameter        EQ_RS_LANE1                    = 3'b100;  
parameter        EQ_RS_LANE2                    = 3'b100;  
parameter        EQ_RS_LANE3                    = 3'b100;  
parameter        EQ_RS_LANECK                   = 3'b100;  
parameter        HSCLK_LANE_LN0                 = 1'b0;  
parameter        HSCLK_LANE_LN1                 = 1'b0;  
parameter        HSCLK_LANE_LN2                 = 1'b0;  
parameter        HSCLK_LANE_LN3                 = 1'b0;  
parameter        HSCLK_LANE_LNCK                = 1'b1;  
parameter        ALP_ED_EN_LANE0                = 1'b1 ; 
parameter        ALP_ED_EN_LANE1                = 1'b1 ;  
parameter        ALP_ED_EN_LANE2                = 1'b1 ;  
parameter        ALP_ED_EN_LANE3                = 1'b1 ;  
parameter        ALP_ED_EN_LANECK               = 1'b1 ; 
parameter        ALP_ED_TST_LANE0               = 1'b0 ;  
parameter        ALP_ED_TST_LANE1               = 1'b0 ;  
parameter        ALP_ED_TST_LANE2               = 1'b0 ;  
parameter        ALP_ED_TST_LANE3               = 1'b0 ;  
parameter        ALP_ED_TST_LANECK              = 1'b0 ;  
parameter        ALP_EN_LN0                     = 1'b0 ; 
parameter        ALP_EN_LN1                     = 1'b0 ;  
parameter        ALP_EN_LN2                     = 1'b0 ;  
parameter        ALP_EN_LN3                     = 1'b0 ; 
parameter        ALP_EN_LNCK                    = 1'b0 ; 
parameter        ALP_HYS_EN_LANE0               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE1               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE2               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE3               = 1'b1 ;  
parameter        ALP_HYS_EN_LANECK              = 1'b1 ;  
parameter        ALP_TH_LANE0                   = 4'b1000 ;   
parameter        ALP_TH_LANE1                   = 4'b1000 ;   
parameter        ALP_TH_LANE2                   = 4'b1000 ;   
parameter        ALP_TH_LANE3                   = 4'b1000 ;   
parameter        ALP_TH_LANECK                  = 4'b1000 ;   
parameter        ANA_BYTECLK_PH                 = 2'b00 ;  
parameter        BIT_REVERSE_LN0                = 1'b0 ;  
parameter        BIT_REVERSE_LN1                = 1'b0 ;  
parameter        BIT_REVERSE_LN2                = 1'b0 ;  
parameter        BIT_REVERSE_LN3                = 1'b0 ;  
parameter        BIT_REVERSE_LNCK               = 1'b0 ;  
parameter        BYPASS_TXHCLKEN                = 1'b1 ;  
parameter        BYPASS_TXHCLKEN_SYNC           = 1'b0 ;  
parameter        BYTE_CLK_POLAR                 = 1'b0 ;  
parameter        BYTE_REVERSE_LN0               = 1'b0 ;  
parameter        BYTE_REVERSE_LN1               = 1'b0 ;  
parameter        BYTE_REVERSE_LN2               = 1'b0 ;  
parameter        BYTE_REVERSE_LN3               = 1'b0 ;  
parameter        BYTE_REVERSE_LNCK              = 1'b0 ;  
parameter        EN_CLKB1X                      = 1'b1 ;  
parameter        EQ_PBIAS_LANE0                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE1                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE2                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE3                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANECK                = 4'b1000 ;   
parameter        EQ_ZLD_LANE0                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE1                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE2                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE3                   = 4'b1000 ;   
parameter        EQ_ZLD_LANECK                  = 4'b1000 ;   
parameter        HIGH_BW_LANE0                  = 1'b1 ;   
parameter        HIGH_BW_LANE1                  = 1'b1 ;   
parameter        HIGH_BW_LANE2                  = 1'b1 ;   
parameter        HIGH_BW_LANE3                  = 1'b1 ;   
parameter        HIGH_BW_LANECK                 = 1'b1 ;   
parameter        HSREG_VREF_CTL                 = 3'b100 ;   
parameter        HSREG_VREF_EN                  = 1'b1 ;  
parameter        HSRX_DLY_CTL_CK                = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE0             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE1             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE2             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE3             = 7'b0000000 ;   
parameter        HSRX_DLY_SEL_LANE0             = 1'b0 ;  
parameter        HSRX_DLY_SEL_LANE1             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANE2             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANE3             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANECK            = 1'b0 ;   
parameter        HSRX_DUTY_LANE0                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE1                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE2                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE3                = 4'b1000 ;  
parameter        HSRX_DUTY_LANECK               = 4'b1000 ;  
parameter        HSRX_EQ_EN_LANE0               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE1               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE2               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE3               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANECK              = 1'b1 ;  
parameter        HSRX_IBIAS                     = 4'b0011 ;   
parameter        HSRX_IBIAS_TEST_EN             = 1'b0 ;   
parameter        HSRX_IMARG_EN                  = 1'b0 ;   
parameter        HSRX_ODT_EN                    = 1'b1 ;   
parameter        HSRX_ODT_TST                   = 4'b0000 ;   
parameter        HSRX_ODT_TST_CK                = 1'b0 ;   
parameter        HSRX_SEL                       = 4'b0000 ;   
parameter        HSRX_STOP_EN                   = 1'b0 ; 
parameter        HSRX_TST                       = 4'b0000 ;   
parameter        HSRX_TST_CK                    = 1'b0 ;   
parameter        HSRX_WAIT4EDGE                 = 1'b1 ;   
parameter        HYST_NCTL                      = 2'b01 ;  
parameter        HYST_PCTL                      = 2'b01 ;  
parameter        IBIAS_TEST_EN                  = 1'b0 ;   
parameter        LB_CH_SEL                      = 1'b0 ;   
parameter        LB_EN_LN0                      = 1'b0 ;   
parameter        LB_EN_LN1                      = 1'b0 ;   
parameter        LB_EN_LN2                      = 1'b0 ;   
parameter        LB_EN_LN3                      = 1'b0 ;   
parameter        LB_EN_LNCK                     = 1'b0 ;   
parameter        LB_POLAR_LN0                   = 1'b0 ;   
parameter        LB_POLAR_LN1                   = 1'b0 ;   
parameter        LB_POLAR_LN2                   = 1'b0 ;   
parameter        LB_POLAR_LN3                   = 1'b0 ;   
parameter        LB_POLAR_LNCK                  = 1'b0 ;   
parameter        LOW_LPRX_VTH                   = 1'b0 ;   
parameter        LPBK_DATA2TO1                  = 4'b0000;  
parameter        LPBK_DATA2TO1_CK               = 1'b0 ;   
parameter        LPBK_EN                        = 1'b0 ;   
parameter        LPBK_SEL                       = 4'b0000;  
parameter        LPBKTST_EN                     = 4'b0000;  
parameter        LPBKTST_EN_CK                  = 1'b0 ;   
parameter        LPRX_EN                        = 1'b1 ;   
parameter        LPRX_TST                       = 4'b0000;  
parameter        LPRX_TST_CK                    = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN0             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN1             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN2             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN3             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LNCK            = 1'b0 ;   
parameter        LPTX_NIMP_LN0                  = 3'b100 ; 
parameter        LPTX_NIMP_LN1                  = 3'b100 ; 
parameter        LPTX_NIMP_LN2                  = 3'b100 ; 
parameter        LPTX_NIMP_LN3                  = 3'b100 ; 
parameter        LPTX_NIMP_LNCK                 = 3'b100 ; 
parameter        LPTX_PIMP_LN0                  = 3'b100 ; 
parameter        LPTX_PIMP_LN1                  = 3'b100 ; 
parameter        LPTX_PIMP_LN2                  = 3'b100 ; 
parameter        LPTX_PIMP_LN3                  = 3'b100 ; 
parameter        LPTX_PIMP_LNCK                 = 3'b100 ; 
parameter        MIPI_PMA_DIS_N                 = 1'b1 ;   
parameter        PGA_BIAS_LANE0                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE1                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE2                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE3                 = 4'b1000 ;   
parameter        PGA_BIAS_LANECK                = 4'b1000 ;   
parameter        PGA_GAIN_LANE0                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE1                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE2                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE3                 = 4'b1000 ;   
parameter        PGA_GAIN_LANECK                = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE0              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE1              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE2              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE3              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANECK             = 4'b1000 ;   
parameter        SLEWN_CTL_LN0                  = 4'b1111 ;  
parameter        SLEWN_CTL_LN1                  = 4'b1111 ;   
parameter        SLEWN_CTL_LN2                  = 4'b1111 ;   
parameter        SLEWN_CTL_LN3                  = 4'b1111 ;   
parameter        SLEWN_CTL_LNCK                 = 4'b1111 ;   
parameter        SLEWP_CTL_LN0                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN1                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN2                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN3                  = 4'b1111 ;   
parameter        SLEWP_CTL_LNCK                 = 4'b1111 ;   
parameter        STP_UNIT                       = 2'b01 ;  
parameter        TERMN_CTL_LN0                  = 4'b1000 ;   
parameter        TERMN_CTL_LN1                  = 4'b1000 ;   
parameter        TERMN_CTL_LN2                  = 4'b1000 ;   
parameter        TERMN_CTL_LN3                  = 4'b1000 ;   
parameter        TERMN_CTL_LNCK                 = 4'b1000 ;   
parameter        TERMP_CTL_LN0                  = 4'b1000 ;   
parameter        TERMP_CTL_LN1                  = 4'b1000 ;   
parameter        TERMP_CTL_LN2                  = 4'b1000 ;   
parameter        TERMP_CTL_LN3                  = 4'b1000 ;   
parameter        TERMP_CTL_LNCK                 = 4'b1000 ;   
parameter        TEST_EN_LN0                    = 1'b0 ;   
parameter        TEST_EN_LN1                    = 1'b0 ;   
parameter        TEST_EN_LN2                    = 1'b0 ;   
parameter        TEST_EN_LN3                    = 1'b0 ;   
parameter        TEST_EN_LNCK                   = 1'b0 ;   
parameter        TEST_N_IMP_LN0                 = 1'b0 ;   
parameter        TEST_N_IMP_LN1                 = 1'b0 ;   
parameter        TEST_N_IMP_LN2                 = 1'b0 ;   
parameter        TEST_N_IMP_LN3                 = 1'b0 ;   
parameter        TEST_N_IMP_LNCK                = 1'b0 ;   
parameter        TEST_P_IMP_LN0                 = 1'b0 ;   
parameter        TEST_P_IMP_LN1                 = 1'b0 ;   
parameter        TEST_P_IMP_LN2                 = 1'b0 ;   
parameter        TEST_P_IMP_LN3                 = 1'b0 ;   
parameter        TEST_P_IMP_LNCK                = 1'b0 ;   
endmodule

module MIPI_DPHYA (...);
output RX_CLK_O, TX_CLK_O;
output [15:0] D0LN_HSRXD, D1LN_HSRXD, D2LN_HSRXD, D3LN_HSRXD;
output D0LN_HSRXD_VLD,D1LN_HSRXD_VLD,D2LN_HSRXD_VLD,D3LN_HSRXD_VLD;
input  D0LN_HSRX_DREN, D1LN_HSRX_DREN,  D2LN_HSRX_DREN,  D3LN_HSRX_DREN;
output  DI_LPRX0_N, DI_LPRX0_P, DI_LPRX1_N, DI_LPRX1_P, DI_LPRX2_N,  DI_LPRX2_P, DI_LPRX3_N, DI_LPRX3_P, DI_LPRXCK_N, DI_LPRXCK_P;
inout  CK_N, CK_P, D0_N, D0_P, D1_N, D1_P, D2_N, D2_P, D3_N, D3_P;
input HSRX_STOP, HSTXEN_LN0, HSTXEN_LN1, HSTXEN_LN2, HSTXEN_LN3, HSTXEN_LNCK,
     LPTXEN_LN0, LPTXEN_LN1, LPTXEN_LN2, LPTXEN_LN3, LPTXEN_LNCK;
input PWRON_RX, PWRON_TX, RESET, RX_CLK_1X, TX_CLK_1X;
input TXDPEN_LN0, TXDPEN_LN1, TXDPEN_LN2, TXDPEN_LN3, TXDPEN_LNCK, TXHCLK_EN;
input [15:0]  CKLN_HSTXD,D0LN_HSTXD,D1LN_HSTXD,D2LN_HSTXD,D3LN_HSTXD;
input HSTXD_VLD;
input CK0, CK90, CK180, CK270;
input DO_LPTX0_N, DO_LPTX1_N, DO_LPTX2_N, DO_LPTX3_N, DO_LPTXCK_N, DO_LPTX0_P, DO_LPTX1_P, DO_LPTX2_P, DO_LPTX3_P, DO_LPTXCK_P;
input HSRX_EN_CK, HSRX_EN_D0, HSRX_EN_D1, HSRX_EN_D2, HSRX_EN_D3, HSRX_ODTEN_CK, 
     HSRX_ODTEN_D0, HSRX_ODTEN_D1, HSRX_ODTEN_D2, HSRX_ODTEN_D3, LPRX_EN_CK,
     LPRX_EN_D0, LPRX_EN_D1, LPRX_EN_D2, LPRX_EN_D3; 
input RX_DRST_N, TX_DRST_N, WALIGN_DVLD;
output [7:0] MRDATA;
input MA_INC, MCLK;
input [1:0] MOPCODE;
input [7:0] MWDATA;
input SPLL_CKN, SPLL_CKP;
output  ALPEDO_LANE0, ALPEDO_LANE1, ALPEDO_LANE2, ALPEDO_LANE3, ALPEDO_LANECK;
output D1LN_DESKEW_DONE,D2LN_DESKEW_DONE,D3LN_DESKEW_DONE,D0LN_DESKEW_DONE;
output D1LN_DESKEW_ERROR, D2LN_DESKEW_ERROR, D3LN_DESKEW_ERROR, D0LN_DESKEW_ERROR;
input D0LN_DESKEW_REQ, D1LN_DESKEW_REQ, D2LN_DESKEW_REQ, D3LN_DESKEW_REQ;
input HSRX_DLYDIR_LANE0, HSRX_DLYDIR_LANE1, HSRX_DLYDIR_LANE2, HSRX_DLYDIR_LANE3, HSRX_DLYDIR_LANECK;
input HSRX_DLYLDN_LANE0, HSRX_DLYLDN_LANE1, HSRX_DLYLDN_LANE2, HSRX_DLYLDN_LANE3, HSRX_DLYLDN_LANECK;
input HSRX_DLYMV_LANE0, HSRX_DLYMV_LANE1,  HSRX_DLYMV_LANE2, HSRX_DLYMV_LANE3, HSRX_DLYMV_LANECK;
input  ALP_EDEN_LANE0, ALP_EDEN_LANE1, ALP_EDEN_LANE2, ALP_EDEN_LANE3, ALP_EDEN_LANECK, ALPEN_LN0, ALPEN_LN1, ALPEN_LN2, ALPEN_LN3, ALPEN_LNCK;
parameter        TX_PLLCLK = "NONE"; 
parameter        RX_ALIGN_BYTE                  = 8'b10111000 ; 
parameter        RX_HS_8BIT_MODE                = 1'b0 ; 
parameter        RX_LANE_ALIGN_EN               = 1'b0 ; 
parameter        TX_HS_8BIT_MODE                = 1'b0 ; 
parameter        HSREG_EN_LN0                   = 1'b0;  
parameter        HSREG_EN_LN1                   = 1'b0;  
parameter        HSREG_EN_LN2                   = 1'b0;  
parameter        HSREG_EN_LN3                   = 1'b0;  
parameter        HSREG_EN_LNCK                  = 1'b0;  
parameter        LANE_DIV_SEL                   = 2'b00;  
parameter        HSRX_EN                        = 1'b1 ;  
parameter        HSRX_LANESEL                   = 4'b1111 ;   
parameter        HSRX_LANESEL_CK                = 1'b1 ;   
parameter        HSTX_EN_LN0                    = 1'b0 ;   
parameter        HSTX_EN_LN1                    = 1'b0 ;   
parameter        HSTX_EN_LN2                    = 1'b0 ;   
parameter        HSTX_EN_LN3                    = 1'b0 ;   
parameter        HSTX_EN_LNCK                   = 1'b0 ;   
parameter        LPTX_EN_LN0                    = 1'b1 ;   
parameter        LPTX_EN_LN1                    = 1'b1 ;   
parameter        LPTX_EN_LN2                    = 1'b1 ;   
parameter        LPTX_EN_LN3                    = 1'b1 ;   
parameter        LPTX_EN_LNCK                   = 1'b1 ;   
parameter        TXDP_EN_LN0                    = 1'b0 ;  
parameter        TXDP_EN_LN1                    = 1'b0 ;   
parameter        TXDP_EN_LN2                    = 1'b0 ;   
parameter        TXDP_EN_LN3                    = 1'b0 ;   
parameter        TXDP_EN_LNCK                   = 1'b0 ;
parameter        SPLL_DIV_SEL                   = 2'b00;
parameter        DPHY_CK_SEL                    = 2'b01;
parameter        CKLN_DELAY_EN                  = 1'b0;  
parameter        CKLN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D0LN_DELAY_EN                  = 1'b0;  
parameter        D0LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D0LN_DESKEW_BYPASS             = 1'b0;  
parameter        D1LN_DELAY_EN                  = 1'b0;  
parameter        D1LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D1LN_DESKEW_BYPASS             = 1'b0;  
parameter        D2LN_DELAY_EN                  = 1'b0;  
parameter        D2LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D2LN_DESKEW_BYPASS             = 1'b0;  
parameter        D3LN_DELAY_EN                  = 1'b0;  
parameter        D3LN_DELAY_OVR_VAL             = 7'b0000000; 
parameter        D3LN_DESKEW_BYPASS             = 1'b0;  
parameter        DESKEW_EN_LOW_DELAY            = 1'b0;  
parameter        DESKEW_EN_ONE_EDGE             = 1'b0;  
parameter        DESKEW_FAST_LOOP_TIME          = 4'b0000;  
parameter        DESKEW_FAST_MODE               = 1'b0;  
parameter        DESKEW_HALF_OPENING            = 6'b010110; 
parameter        DESKEW_LSB_MODE                = 2'b00;  
parameter        DESKEW_M                       = 3'b011;  
parameter        DESKEW_M_TH                    = 13'b0000110100110; 
parameter        DESKEW_MAX_SETTING           = 7'b0100001; 
parameter        DESKEW_ONE_CLK_EDGE_EN       = 1'b0 ; 
parameter        DESKEW_RST_BYPASS              = 1'b0 ; 
parameter        RX_BYTE_LITTLE_ENDIAN          = 1'b1 ; 
parameter        RX_CLK_1X_SYNC_SEL             = 1'b0 ; 
parameter        RX_INVERT                      = 1'b0 ; 
parameter        RX_ONE_BYTE0_MATCH             = 1'b0 ; 
parameter        RX_RD_START_DEPTH              = 5'b00001; 
parameter        RX_SYNC_MODE                   = 1'b0 ; 
parameter        RX_WORD_ALIGN_BYPASS           = 1'b0 ; 
parameter        RX_WORD_ALIGN_DATA_VLD_SRC_SEL = 1'b0 ; 
parameter        RX_WORD_LITTLE_ENDIAN          = 1'b1 ; 
parameter        TX_BYPASS_MODE                 = 1'b0 ; 
parameter        TX_BYTECLK_SYNC_MODE           = 1'b0 ; 
parameter        TX_OCLK_USE_CIBCLK             = 1'b0 ; 
parameter        TX_RD_START_DEPTH              = 5'b00001; 
parameter        TX_SYNC_MODE                   = 1'b0 ; 
parameter        TX_WORD_LITTLE_ENDIAN          = 1'b1 ; 
parameter        EQ_CS_LANE0                    = 3'b100;  
parameter        EQ_CS_LANE1                    = 3'b100;  
parameter        EQ_CS_LANE2                    = 3'b100;  
parameter        EQ_CS_LANE3                    = 3'b100;  
parameter        EQ_CS_LANECK                   = 3'b100;  
parameter        EQ_RS_LANE0                    = 3'b100;  
parameter        EQ_RS_LANE1                    = 3'b100;  
parameter        EQ_RS_LANE2                    = 3'b100;  
parameter        EQ_RS_LANE3                    = 3'b100;  
parameter        EQ_RS_LANECK                   = 3'b100;  
parameter        HSCLK_LANE_LN0                 = 1'b0;  
parameter        HSCLK_LANE_LN1                 = 1'b0;  
parameter        HSCLK_LANE_LN2                 = 1'b0;  
parameter        HSCLK_LANE_LN3                 = 1'b0;  
parameter        HSCLK_LANE_LNCK                = 1'b1;  
parameter        ALP_ED_EN_LANE0                = 1'b1 ; 
parameter        ALP_ED_EN_LANE1                = 1'b1 ;  
parameter        ALP_ED_EN_LANE2                = 1'b1 ;  
parameter        ALP_ED_EN_LANE3                = 1'b1 ;  
parameter        ALP_ED_EN_LANECK               = 1'b1 ; 
parameter        ALP_ED_TST_LANE0               = 1'b0 ;  
parameter        ALP_ED_TST_LANE1               = 1'b0 ;  
parameter        ALP_ED_TST_LANE2               = 1'b0 ;  
parameter        ALP_ED_TST_LANE3               = 1'b0 ;  
parameter        ALP_ED_TST_LANECK              = 1'b0 ;  
parameter        ALP_EN_LN0                     = 1'b0 ; 
parameter        ALP_EN_LN1                     = 1'b0 ;  
parameter        ALP_EN_LN2                     = 1'b0 ;  
parameter        ALP_EN_LN3                     = 1'b0 ; 
parameter        ALP_EN_LNCK                    = 1'b0 ; 
parameter        ALP_HYS_EN_LANE0               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE1               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE2               = 1'b1 ;  
parameter        ALP_HYS_EN_LANE3               = 1'b1 ;  
parameter        ALP_HYS_EN_LANECK              = 1'b1 ;  
parameter        ALP_TH_LANE0                   = 4'b1000 ;   
parameter        ALP_TH_LANE1                   = 4'b1000 ;   
parameter        ALP_TH_LANE2                   = 4'b1000 ;   
parameter        ALP_TH_LANE3                   = 4'b1000 ;   
parameter        ALP_TH_LANECK                  = 4'b1000 ;   
parameter        ANA_BYTECLK_PH                 = 2'b00 ;  
parameter        BIT_REVERSE_LN0                = 1'b0 ;  
parameter        BIT_REVERSE_LN1                = 1'b0 ;  
parameter        BIT_REVERSE_LN2                = 1'b0 ;  
parameter        BIT_REVERSE_LN3                = 1'b0 ;  
parameter        BIT_REVERSE_LNCK               = 1'b0 ;  
parameter        BYPASS_TXHCLKEN                = 1'b1 ;  
parameter        BYPASS_TXHCLKEN_SYNC           = 1'b0 ;  
parameter        BYTE_CLK_POLAR                 = 1'b0 ;  
parameter        BYTE_REVERSE_LN0               = 1'b0 ;  
parameter        BYTE_REVERSE_LN1               = 1'b0 ;  
parameter        BYTE_REVERSE_LN2               = 1'b0 ;  
parameter        BYTE_REVERSE_LN3               = 1'b0 ;  
parameter        BYTE_REVERSE_LNCK              = 1'b0 ;  
parameter        EN_CLKB1X                      = 1'b1 ;  
parameter        EQ_PBIAS_LANE0                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE1                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE2                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANE3                 = 4'b1000 ;   
parameter        EQ_PBIAS_LANECK                = 4'b1000 ;   
parameter        EQ_ZLD_LANE0                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE1                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE2                   = 4'b1000 ;   
parameter        EQ_ZLD_LANE3                   = 4'b1000 ;   
parameter        EQ_ZLD_LANECK                  = 4'b1000 ;   
parameter        HIGH_BW_LANE0                  = 1'b1 ;   
parameter        HIGH_BW_LANE1                  = 1'b1 ;   
parameter        HIGH_BW_LANE2                  = 1'b1 ;   
parameter        HIGH_BW_LANE3                  = 1'b1 ;   
parameter        HIGH_BW_LANECK                 = 1'b1 ;   
parameter        HSREG_VREF_CTL                 = 3'b100 ;   
parameter        HSREG_VREF_EN                  = 1'b1 ;  
parameter        HSRX_DLY_CTL_CK                = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE0             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE1             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE2             = 7'b0000000 ;   
parameter        HSRX_DLY_CTL_LANE3             = 7'b0000000 ;   
parameter        HSRX_DLY_SEL_LANE0             = 1'b0 ;  
parameter        HSRX_DLY_SEL_LANE1             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANE2             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANE3             = 1'b0 ;   
parameter        HSRX_DLY_SEL_LANECK            = 1'b0 ;   
parameter        HSRX_DUTY_LANE0                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE1                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE2                = 4'b1000 ;  
parameter        HSRX_DUTY_LANE3                = 4'b1000 ;  
parameter        HSRX_DUTY_LANECK               = 4'b1000 ;  
parameter        HSRX_EQ_EN_LANE0               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE1               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE2               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANE3               = 1'b1 ;  
parameter        HSRX_EQ_EN_LANECK              = 1'b1 ;  
parameter        HSRX_IBIAS                     = 4'b0011 ;   
parameter        HSRX_IBIAS_TEST_EN             = 1'b0 ;   
parameter        HSRX_IMARG_EN                  = 1'b0 ;   
parameter        HSRX_ODT_EN                    = 1'b1 ;   
parameter        HSRX_ODT_TST                   = 4'b0000 ;   
parameter        HSRX_ODT_TST_CK                = 1'b0 ;   
parameter        HSRX_SEL                       = 4'b0000 ;   
parameter        HSRX_STOP_EN                   = 1'b0 ; 
parameter        HSRX_TST                       = 4'b0000 ;   
parameter        HSRX_TST_CK                    = 1'b0 ;   
parameter        HSRX_WAIT4EDGE                 = 1'b1 ;   
parameter        HYST_NCTL                      = 2'b01 ;  
parameter        HYST_PCTL                      = 2'b01 ;  
parameter        IBIAS_TEST_EN                  = 1'b0 ;   
parameter        LB_CH_SEL                      = 1'b0 ;   
parameter        LB_EN_LN0                      = 1'b0 ;   
parameter        LB_EN_LN1                      = 1'b0 ;   
parameter        LB_EN_LN2                      = 1'b0 ;   
parameter        LB_EN_LN3                      = 1'b0 ;   
parameter        LB_EN_LNCK                     = 1'b0 ;   
parameter        LB_POLAR_LN0                   = 1'b0 ;   
parameter        LB_POLAR_LN1                   = 1'b0 ;   
parameter        LB_POLAR_LN2                   = 1'b0 ;   
parameter        LB_POLAR_LN3                   = 1'b0 ;   
parameter        LB_POLAR_LNCK                  = 1'b0 ;   
parameter        LOW_LPRX_VTH                   = 1'b0 ;   
parameter        LPBK_DATA2TO1                  = 4'b0000;  
parameter        LPBK_DATA2TO1_CK               = 1'b0 ;   
parameter        LPBK_EN                        = 1'b0 ;   
parameter        LPBK_SEL                       = 4'b0000;  
parameter        LPBKTST_EN                     = 4'b0000;  
parameter        LPBKTST_EN_CK                  = 1'b0 ;   
parameter        LPRX_EN                        = 1'b1 ;   
parameter        LPRX_TST                       = 4'b0000;  
parameter        LPRX_TST_CK                    = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN0             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN1             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN2             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LN3             = 1'b0 ;   
parameter        LPTX_DAT_POLAR_LNCK            = 1'b0 ;   
parameter        LPTX_NIMP_LN0                  = 3'b100 ; 
parameter        LPTX_NIMP_LN1                  = 3'b100 ; 
parameter        LPTX_NIMP_LN2                  = 3'b100 ; 
parameter        LPTX_NIMP_LN3                  = 3'b100 ; 
parameter        LPTX_NIMP_LNCK                 = 3'b100 ; 
parameter        LPTX_PIMP_LN0                  = 3'b100 ; 
parameter        LPTX_PIMP_LN1                  = 3'b100 ; 
parameter        LPTX_PIMP_LN2                  = 3'b100 ; 
parameter        LPTX_PIMP_LN3                  = 3'b100 ; 
parameter        LPTX_PIMP_LNCK                 = 3'b100 ; 
parameter        MIPI_PMA_DIS_N                 = 1'b1 ;   
parameter        PGA_BIAS_LANE0                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE1                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE2                 = 4'b1000 ;   
parameter        PGA_BIAS_LANE3                 = 4'b1000 ;   
parameter        PGA_BIAS_LANECK                = 4'b1000 ;   
parameter        PGA_GAIN_LANE0                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE1                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE2                 = 4'b1000 ;   
parameter        PGA_GAIN_LANE3                 = 4'b1000 ;   
parameter        PGA_GAIN_LANECK                = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE0              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE1              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE2              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANE3              = 4'b1000 ;   
parameter        RX_ODT_TRIM_LANECK             = 4'b1000 ;   
parameter        SLEWN_CTL_LN0                  = 4'b1111 ;  
parameter        SLEWN_CTL_LN1                  = 4'b1111 ;   
parameter        SLEWN_CTL_LN2                  = 4'b1111 ;   
parameter        SLEWN_CTL_LN3                  = 4'b1111 ;   
parameter        SLEWN_CTL_LNCK                 = 4'b1111 ;   
parameter        SLEWP_CTL_LN0                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN1                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN2                  = 4'b1111 ;   
parameter        SLEWP_CTL_LN3                  = 4'b1111 ;   
parameter        SLEWP_CTL_LNCK                 = 4'b1111 ;   
parameter        STP_UNIT                       = 2'b01 ;  
parameter        TERMN_CTL_LN0                  = 4'b1000 ;   
parameter        TERMN_CTL_LN1                  = 4'b1000 ;   
parameter        TERMN_CTL_LN2                  = 4'b1000 ;   
parameter        TERMN_CTL_LN3                  = 4'b1000 ;   
parameter        TERMN_CTL_LNCK                 = 4'b1000 ;   
parameter        TERMP_CTL_LN0                  = 4'b1000 ;   
parameter        TERMP_CTL_LN1                  = 4'b1000 ;   
parameter        TERMP_CTL_LN2                  = 4'b1000 ;   
parameter        TERMP_CTL_LN3                  = 4'b1000 ;   
parameter        TERMP_CTL_LNCK                 = 4'b1000 ;   
parameter        TEST_EN_LN0                    = 1'b0 ;   
parameter        TEST_EN_LN1                    = 1'b0 ;   
parameter        TEST_EN_LN2                    = 1'b0 ;   
parameter        TEST_EN_LN3                    = 1'b0 ;   
parameter        TEST_EN_LNCK                   = 1'b0 ;   
parameter        TEST_N_IMP_LN0                 = 1'b0 ;   
parameter        TEST_N_IMP_LN1                 = 1'b0 ;   
parameter        TEST_N_IMP_LN2                 = 1'b0 ;   
parameter        TEST_N_IMP_LN3                 = 1'b0 ;   
parameter        TEST_N_IMP_LNCK                = 1'b0 ;   
parameter        TEST_P_IMP_LN0                 = 1'b0 ;   
parameter        TEST_P_IMP_LN1                 = 1'b0 ;   
parameter        TEST_P_IMP_LN2                 = 1'b0 ;   
parameter        TEST_P_IMP_LN3                 = 1'b0 ;   
parameter        TEST_P_IMP_LNCK                = 1'b0 ;   
endmodule

module MIPI_CPHY (...);
output [41:0] D0LN_HSRXD, D1LN_HSRXD, D2LN_HSRXD;
output D0LN_HSRXD_VLD, D1LN_HSRXD_VLD, D2LN_HSRXD_VLD;
output [1:0] D0LN_HSRX_DEMAP_INVLD, D1LN_HSRX_DEMAP_INVLD, D2LN_HSRX_DEMAP_INVLD;
output D0LN_HSRX_FIFO_RDE_ERR, D0LN_HSRX_FIFO_WRF_ERR, D1LN_HSRX_FIFO_RDE_ERR, D1LN_HSRX_FIFO_WRF_ERR, D2LN_HSRX_FIFO_RDE_ERR, D2LN_HSRX_FIFO_WRF_ERR;
output [1:0] D0LN_HSRX_WA, D1LN_HSRX_WA, D2LN_HSRX_WA;
output D0LN_RX_CLK_1X_O, D1LN_RX_CLK_1X_O, D2LN_RX_CLK_1X_O;   
output HSTX_FIFO_AE, HSTX_FIFO_AF;
output HSTX_FIFO_RDE_ERR, HSTX_FIFO_WRF_ERR;
output RX_CLK_MUXED;
output TX_CLK_1X_O;
output DI_LPRX0_A, DI_LPRX0_B, DI_LPRX0_C, DI_LPRX1_A, DI_LPRX1_B, DI_LPRX1_C, DI_LPRX2_A, DI_LPRX2_B, DI_LPRX2_C;
output [7:0] MDRP_RDATA; 
inout  D0A, D0B, D0C, D1A, D1B, D1C, D2A, D2B, D2C;
input  D0LN_HSRX_EN, D0LN_HSTX_EN, D1LN_HSRX_EN, D1LN_HSTX_EN, D2LN_HSRX_EN, D2LN_HSTX_EN;
input  [41:0] D0LN_HSTX_DATA,D1LN_HSTX_DATA, D2LN_HSTX_DATA;
input  D0LN_HSTX_DATA_VLD, D1LN_HSTX_DATA_VLD, D2LN_HSTX_DATA_VLD;
input  [1:0] D0LN_HSTX_MAP_DIS, D1LN_HSTX_MAP_DIS, D2LN_HSTX_MAP_DIS;
input  D0LN_RX_CLK_1X_I,D1LN_RX_CLK_1X_I, D2LN_RX_CLK_1X_I;
input  D0LN_RX_DRST_N, D0LN_TX_DRST_N, D1LN_RX_DRST_N, D1LN_TX_DRST_N, D2LN_RX_DRST_N, D2LN_TX_DRST_N;
input  HSTX_ENLN0, HSTX_ENLN1, HSTX_ENLN2, LPTX_ENLN0, LPTX_ENLN1, LPTX_ENLN2;
input  [7:0] MDRP_A_D_I;
input  MDRP_A_INC_I;
input  MDRP_CLK_I;
input  [1:0] MDRP_OPCODE_I;
input  PWRON_RX_LN0, PWRON_RX_LN1, PWRON_RX_LN2, PWRON_TX;
input  ARST_RXLN0, ARST_RXLN1, ARST_RXLN2; 
input  ARSTN_TX;
input  RX_CLK_EN_LN0, RX_CLK_EN_LN1, RX_CLK_EN_LN2; 
input  TX_CLK_1X_I;
input  TXDP_ENLN0, TXDP_ENLN1, TXDP_ENLN2; 
input  TXHCLK_EN; 
input  DO_LPTX_A_LN0, DO_LPTX_A_LN1, DO_LPTX_A_LN2, DO_LPTX_B_LN0, DO_LPTX_B_LN1, DO_LPTX_B_LN2, DO_LPTX_C_LN0, DO_LPTX_C_LN1, DO_LPTX_C_LN2;
input  GPLL_CK0,GPLL_CK90, GPLL_CK180, GPLL_CK270;
input  HSRX_EN_D0, HSRX_EN_D1, HSRX_EN_D2; 
input  HSRX_ODT_EN_D0, HSRX_ODT_EN_D1, HSRX_ODT_EN_D2;
input  LPRX_EN_D0, LPRX_EN_D1, LPRX_EN_D2; 
input  SPLL0_CKN, SPLL0_CKP, SPLL1_CKN, SPLL1_CKP;
parameter TX_PLLCLK = "NONE"; 
parameter D0LN_HS_TX_EN = 1'b1; 
parameter D1LN_HS_TX_EN = 1'b1;
parameter D2LN_HS_TX_EN = 1'b1;
parameter D0LN_HS_RX_EN = 1'b1; 
parameter D1LN_HS_RX_EN = 1'b1;
parameter D2LN_HS_RX_EN = 1'b1;
parameter TX_HS_21BIT_MODE = 1'b0; 
parameter RX_OUTCLK_SEL = 2'b00; 
parameter TX_W_LENDIAN = 1'b1; 
parameter CLK_SEL = 2'b00; 
parameter LNDIV_RATIO = 4'b0000; 
parameter LNDIV_EN = 1'b0; 
parameter D0LN_TX_REASGN_A = 2'b00; 
parameter D0LN_TX_REASGN_B = 2'b01; 
parameter D0LN_TX_REASGN_C = 2'b10; 
parameter D0LN_RX_HS_21BIT_MODE = 1'b0; 
parameter D0LN_RX_WA_SYNC_PAT0_EN = 1'b1;  
parameter D0LN_RX_WA_SYNC_PAT0_H = 7'b1001001;  
parameter D0LN_RX_WA_SYNC_PAT0_L = 8'b00100100;  
parameter D0LN_RX_WA_SYNC_PAT1_EN = 1'b1;  
parameter D0LN_RX_WA_SYNC_PAT1_H = 7'b0101001;  
parameter D0LN_RX_WA_SYNC_PAT1_L = 8'b00100100;  
parameter D0LN_RX_WA_SYNC_PAT2_EN = 1'b1;  
parameter D0LN_RX_WA_SYNC_PAT2_H = 7'b0011001;  
parameter D0LN_RX_WA_SYNC_PAT2_L = 8'b00100100;  
parameter D0LN_RX_WA_SYNC_PAT3_EN = 1'b0;  
parameter D0LN_RX_WA_SYNC_PAT3_H = 7'b0001001;  
parameter D0LN_RX_WA_SYNC_PAT3_L = 8'b00100100;  
parameter D0LN_RX_W_LENDIAN = 1'b1;  
parameter D0LN_RX_REASGN_A = 2'b00; 
parameter D0LN_RX_REASGN_B = 2'b01; 
parameter D0LN_RX_REASGN_C = 2'b10; 
parameter HSRX_LNSEL = 3'b111; 
parameter EQ_RS_LN0 = 3'b001; 
parameter EQ_CS_LN0 = 3'b101; 
parameter PGA_GAIN_LN0 = 4'b0110; 
parameter PGA_BIAS_LN0 = 4'b1000; 
parameter EQ_PBIAS_LN0 = 4'b0100; 
parameter EQ_ZLD_LN0 = 4'b1000; 
parameter D1LN_TX_REASGN_A = 2'b00; 
parameter D1LN_TX_REASGN_B = 2'b01; 
parameter D1LN_TX_REASGN_C = 2'b10; 
parameter D1LN_RX_HS_21BIT_MODE = 1'b0; 
parameter D1LN_RX_WA_SYNC_PAT0_EN = 1'b1;  
parameter D1LN_RX_WA_SYNC_PAT0_H = 7'b1001001;  
parameter D1LN_RX_WA_SYNC_PAT0_L = 8'b00100100;  
parameter D1LN_RX_WA_SYNC_PAT1_EN = 1'b1;  
parameter D1LN_RX_WA_SYNC_PAT1_H = 7'b0101001;  
parameter D1LN_RX_WA_SYNC_PAT1_L = 8'b00100100;  
parameter D1LN_RX_WA_SYNC_PAT2_EN = 1'b1;  
parameter D1LN_RX_WA_SYNC_PAT2_H = 7'b0011001;  
parameter D1LN_RX_WA_SYNC_PAT2_L = 8'b00100100;  
parameter D1LN_RX_WA_SYNC_PAT3_EN = 1'b0;  
parameter D1LN_RX_WA_SYNC_PAT3_H = 7'b0001001;  
parameter D1LN_RX_WA_SYNC_PAT3_L = 8'b00100100;  
parameter D1LN_RX_W_LENDIAN = 1'b1;  
parameter D1LN_RX_REASGN_A = 2'b00; 
parameter D1LN_RX_REASGN_B = 2'b01; 
parameter D1LN_RX_REASGN_C = 2'b10; 
parameter EQ_RS_LN1 = 3'b001; 
parameter EQ_CS_LN1 = 3'b101; 
parameter PGA_GAIN_LN1 = 4'b0110; 
parameter PGA_BIAS_LN1 = 4'b1000; 
parameter EQ_PBIAS_LN1 = 4'b0100; 
parameter EQ_ZLD_LN1 = 4'b1000; 
parameter D2LN_TX_REASGN_A = 2'b00; 
parameter D2LN_TX_REASGN_B = 2'b01; 
parameter D2LN_TX_REASGN_C = 2'b10; 
parameter D2LN_RX_HS_21BIT_MODE = 1'b0; 
parameter D2LN_RX_WA_SYNC_PAT0_EN = 1'b1;  
parameter D2LN_RX_WA_SYNC_PAT0_H = 7'b1001001;  
parameter D2LN_RX_WA_SYNC_PAT0_L = 8'b00100100;  
parameter D2LN_RX_WA_SYNC_PAT1_EN = 1'b1;  
parameter D2LN_RX_WA_SYNC_PAT1_H = 7'b0101001;  
parameter D2LN_RX_WA_SYNC_PAT1_L = 8'b00100100;  
parameter D2LN_RX_WA_SYNC_PAT2_EN = 1'b1;  
parameter D2LN_RX_WA_SYNC_PAT2_H = 7'b0011001;  
parameter D2LN_RX_WA_SYNC_PAT2_L = 8'b00100100;  
parameter D2LN_RX_WA_SYNC_PAT3_EN = 1'b0;  
parameter D2LN_RX_WA_SYNC_PAT3_H = 7'b0001001;  
parameter D2LN_RX_WA_SYNC_PAT3_L = 8'b00100100;  
parameter D2LN_RX_W_LENDIAN = 1'b1;  
parameter D2LN_RX_REASGN_A = 2'b00; 
parameter D2LN_RX_REASGN_B = 2'b01; 
parameter D2LN_RX_REASGN_C = 2'b10; 
parameter EQ_RS_LN2 = 3'b001; 
parameter EQ_CS_LN2 = 3'b101; 
parameter PGA_GAIN_LN2 = 4'b0110; 
parameter PGA_BIAS_LN2 = 4'b1000; 
parameter EQ_PBIAS_LN2 = 4'b0100; 
parameter EQ_ZLD_LN2 = 4'b1000; 
endmodule

module GTR12_QUAD (...);
endmodule

module GTR12_UPAR (...);
endmodule

module GTR12_PMAC (...);
endmodule

module GTR12_QUADA (...);
endmodule

module GTR12_UPARA (...);
endmodule

module GTR12_PMACA (...);
endmodule

module GTR12_QUADB (...);
endmodule

module DQS (...);
input DQSIN,PCLK,FCLK,RESET;
input [3:0] READ;
input [2:0] RCLKSEL;
input [7:0] DLLSTEP;
input [7:0] WSTEP;
input RLOADN, RMOVE, RDIR, WLOADN, WMOVE, WDIR, HOLD;
output DQSR90, DQSW0, DQSW270; 
output [2:0] RPOINT, WPOINT;
output RVALID,RBURST, RFLAG, WFLAG;
parameter FIFO_MODE_SEL = 1'b0; 
parameter RD_PNTR = 3'b000; 
parameter DQS_MODE = "X1"; 
parameter HWL = "false";   
endmodule
`,"lutrams.txt":`ram distributed $__GOWIN_LUTRAM_ {
	abits 4;
	width 4;
	cost 4;
	widthscale;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__GOWIN_LUTRAM_(...);

parameter INIT = 64'bx;
parameter BITS_USED = 0;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input [3:0] PORT_W_WR_DATA;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

function [15:0] init_slice;
input integer idx;
integer i;
for (i = 0; i < 16; i = i + 1)
	init_slice[i] = INIT[4*i+idx];
endfunction

generate

casez(BITS_USED)
4'b000z:
RAM16SDP1 #(
	.INIT_0(init_slice(0)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA[0]),
	.DO(PORT_R_RD_DATA[0]),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
4'b00zz:
RAM16SDP2 #(
	.INIT_0(init_slice(0)),
	.INIT_1(init_slice(1)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA[1:0]),
	.DO(PORT_R_RD_DATA[1:0]),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
default:
RAM16SDP4 #(
	.INIT_0(init_slice(0)),
	.INIT_1(init_slice(1)),
	.INIT_2(init_slice(2)),
	.INIT_3(init_slice(3)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA),
	.DO(PORT_R_RD_DATA),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
endcase

endgenerate

endmodule
`},greenpak4:{"cells_blackbox.v":`module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

	input wire CE;
	input wire CLK;
	output reg OUT;
	output reg[WIDTH-1:0] POUT;
	input wire RST;
	input wire UP;

	parameter COUNT_TO = 1;
	parameter RESET_MODE = "RISING";
	parameter RESET_TO_MAX = "1";
	parameter HAS_POUT = 0;
	parameter HAS_CE = 0;
	parameter WIDTH = 8;
	parameter DIRECTION = "DOWN";

endmodule
`,"cells_latch.v":`module $_DLATCH_P_(input E, input D, output Q);
	GP_DLATCH _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(!E),
		.Q(Q)
		);
endmodule

module $_DLATCH_N_(input E, input D, output Q);
	GP_DLATCH _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(E),
		.Q(Q)
		);
endmodule
`,"cells_map.v":`module GP_DFFS(input D, CLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSR #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nSET),
		.Q(Q)
	);
endmodule

module GP_DFFR(input D, CLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSR #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nRST),
		.Q(Q)
	);
endmodule

module GP_DFFSI(input D, CLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSRI #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nSET),
		.nQ(nQ)
	);
endmodule

module GP_DFFRI(input D, CLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSRI #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nRST),
		.nQ(nQ)
	);
endmodule

module GP_DLATCHS(input D, nCLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSR #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nSET),
		.Q(Q)
	);
endmodule

module GP_DLATCHR(input D, nCLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSR #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nRST),
		.Q(Q)
	);
endmodule

module GP_DLATCHSI(input D, nCLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSRI #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nSET),
		.nQ(nQ)
	);
endmodule

module GP_DLATCHRI(input D, nCLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSRI #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nRST),
		.nQ(nQ)
	);
endmodule

module GP_OBUFT(input IN, input OE, output OUT);
	GP_IOBUF _TECHMAP_REPLACE_ (
		.IN(IN),
		.OE(OE),
		.IO(OUT),
		.OUT()
	);
endmodule

module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	(* force_downto *)
	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
		if(LUT == 2'b01) begin
			GP_INV _TECHMAP_REPLACE_ (.OUT(Y), .IN(A[0]) );
		end
		else begin
			GP_2LUT #(.INIT({2'b00, LUT})) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(1'b0));
		end
		end else
		if (WIDTH == 2) begin
			GP_2LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]));
		end else
		if (WIDTH == 3) begin
			GP_3LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]), .IN2(A[2]));
		end else
		if (WIDTH == 4) begin
			GP_4LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]), .IN2(A[2]), .IN3(A[3]));
		end else begin
			wire _TECHMAP_FAIL_ = 1;
		end
	endgenerate
endmodule

module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

	input wire CE;
	input wire CLK;
	output reg OUT;
	(* force_downto *)
	output reg[WIDTH-1:0] POUT;
	input wire RST;
	input wire UP;

	parameter COUNT_TO = 1;
	parameter RESET_MODE = "RISING";
	parameter RESET_TO_MAX = 0;
	parameter HAS_POUT = 0;
	parameter HAS_CE = 0;
	parameter WIDTH = 8;
	parameter DIRECTION = "DOWN";

	//If we have a DIRECTION other than DOWN fail... GP_COUNTx_ADV is not supported yet
	if(DIRECTION != "DOWN") begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for GP_COUNTx_ADV is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//If counter is more than 14 bits wide, complain (also shouldn't happen)
	else if(WIDTH > 14) begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for cascaded counters is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//If counter is more than 8 bits wide and has parallel output, we have a problem
	else if(WIDTH > 8 && HAS_POUT) begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for 9-14 bit counters with parallel output is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//Looks like a legal counter! Do something with it
	else if(WIDTH <= 8) begin
		if(HAS_CE) begin
			wire ce_not;
			GP_INV ceinv(
				.IN(CE),
				.OUT(ce_not)
			);
			GP_COUNT8_ADV #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.RESET_VALUE(RESET_TO_MAX ? "COUNT_TO" : "ZERO"),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.UP(1'b0),		//always count down for now
				.KEEP(ce_not),
				.POUT(POUT)
			);
		end
		else begin
			GP_COUNT8 #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.POUT(POUT)
			);
		end
	end

	else begin
		if(HAS_CE) begin
			wire ce_not;
			GP_INV ceinv(
				.IN(CE),
				.OUT(ce_not)
			);
			GP_COUNT14_ADV #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_TO_MAX ? "COUNT_TO" : "ZERO"),
				.RESET_VALUE("COUNT_TO"),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.UP(1'b0),		//always count down for now
				.KEEP(ce_not),
				.POUT(POUT)
			);
		end
		else begin
			GP_COUNT14 #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT)
			);
		end
	end

endmodule
`,"cells_sim.v":`\`timescale 1ns/1ps

\`include "cells_sim_ams.v"
\`include "cells_sim_digital.v"
\`include "cells_sim_wip.v"
`,"cells_sim_ams.v":`\`timescale 1ns/1ps

/*
 This file contains analog / mixed signal cells, or other things that are not possible to fully model
 in behavioral Verilog.

 It also contains some stuff like oscillators that use non-synthesizeable constructs such as delays.
 TODO: do we want a third file for those cells?
 */

module GP_ABUF(input wire IN, output wire OUT);

	assign OUT = IN;

	//must be 1, 5, 20, 50
	//values >1 only available with Vdd > 2.7V
	parameter BANDWIDTH_KHZ = 1;

endmodule

module GP_ACMP(input wire PWREN, input wire VIN, input wire VREF, output reg OUT);

	parameter BANDWIDTH = "HIGH";
	parameter VIN_ATTEN = 1;
	parameter VIN_ISRC_EN = 0;
	parameter HYSTERESIS = 0;

	initial OUT = 0;

endmodule

module GP_BANDGAP(output reg OK);
	parameter AUTO_PWRDN = 1;
	parameter CHOPPER_EN = 1;
	parameter OUT_DELAY = 100;

endmodule

module GP_DAC(input[7:0] DIN, input wire VREF, output reg VOUT);

	initial VOUT = 0;

	//analog hard IP is not supported for simulation

endmodule

module GP_LFOSC(input PWRDN, output reg CLKOUT);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter OUT_DIV = 1;

	initial CLKOUT = 0;

	//auto powerdown not implemented for simulation
	//output dividers not implemented for simulation

	always begin
		if(PWRDN)
			CLKOUT = 0;
		else begin
			//half period of 1730 Hz
			#289017;
			CLKOUT = ~CLKOUT;
		end
	end

endmodule

module GP_PGA(input wire VIN_P, input wire VIN_N, input wire VIN_SEL, output reg VOUT);

	parameter GAIN = 1;
	parameter INPUT_MODE = "SINGLE";

	initial VOUT = 0;

	//cannot simulate mixed signal IP

endmodule

module GP_PWRDET(output reg VDD_LOW);
	initial VDD_LOW = 0;
endmodule

module GP_VREF(input VIN, output reg VOUT);
	parameter VIN_DIV = 1;
	parameter VREF = 0;
	//cannot simulate mixed signal IP
endmodule

module GP_POR(output reg RST_DONE);
	parameter POR_TIME = 500;

	initial begin
		RST_DONE = 0;

		if(POR_TIME == 4)
			#4000;
		else if(POR_TIME == 500)
			#500000;
		else begin
			$display("ERROR: bad POR_TIME for GP_POR cell");
			$finish;
		end

		RST_DONE = 1;

	end

endmodule
`,"cells_sim_digital.v":`\`timescale 1ns/1ps

/*
 This file contains simulation models for GreenPAK cells which are possible to fully model using synthesizeable
 behavioral Verilog constructs only.
 */

module GP_2LUT(input IN0, IN1, output OUT);
	parameter [3:0] INIT = 0;
	assign OUT = INIT[{IN1, IN0}];
endmodule

module GP_3LUT(input IN0, IN1, IN2, output OUT);
	parameter [7:0] INIT = 0;
	assign OUT = INIT[{IN2, IN1, IN0}];
endmodule

module GP_4LUT(
	input wire IN0,
	input wire IN1,
	input wire IN2,
	input wire IN3,
	output wire OUT);

	parameter [15:0] INIT = 0;
	assign OUT = INIT[{IN3, IN2, IN1, IN0}];
endmodule

module GP_CLKBUF(input wire IN, output wire OUT);
	assign OUT = IN;
endmodule

module GP_COUNT14(input CLK, input wire RST, output reg OUT);

	parameter RESET_MODE 	= "RISING";

	parameter COUNT_TO		= 14'h1;
	parameter CLKIN_DIVIDE	= 1;

	reg[13:0] count = COUNT_TO;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		OUT = (count == 14'h0);
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count		<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin
					if(!RST)
						count		<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT14 not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count		<= 0;

					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT14");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT14_ADV(input CLK, input RST, output reg OUT,
                     input UP, input KEEP, output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";
	parameter RESET_VALUE   = "ZERO";

	parameter COUNT_TO		= 14'h1;
	parameter CLKIN_DIVIDE	= 1;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	reg[13:0] count = COUNT_TO;

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		if(UP)
			OUT = (count == 14'h3fff);
		else
			OUT = (count == 14'h0);
		POUT = count[7:0];
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 14'h3fff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin

					//Resets
					if(!RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 14'h3fff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT14_ADV not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else begin

						if(KEEP) begin
						end
						else if(UP) begin
							count		<= count + 1'd1;
							if(count == 14'h3fff)
								count	<= COUNT_TO;
						end
						else begin
							count		<= count - 1'd1;

							if(count == 0)
								count	<= COUNT_TO;
						end

					end

				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT14_ADV");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT8_ADV(input CLK, input RST, output reg OUT,
                     input UP, input KEEP, output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";
	parameter RESET_VALUE   = "ZERO";

	parameter COUNT_TO		= 8'h1;
	parameter CLKIN_DIVIDE	= 1;

	reg[7:0] count = COUNT_TO;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		if(UP)
			OUT = (count == 8'hff);
		else
			OUT = (count == 8'h0);
		POUT = count;
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					//Main counter
					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 8'hff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin

					//Resets
					if(!RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					//Main counter
					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 8'hff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT8_ADV not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else begin

						if(KEEP) begin
						end
						else if(UP) begin
							count		<= count + 1'd1;
							if(count == 8'hff)
								count	<= COUNT_TO;
						end
						else begin
							count		<= count - 1'd1;

							if(count == 0)
								count	<= COUNT_TO;
						end
					end

				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT8_ADV");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT8(
	input wire CLK,
	input wire RST,
	output reg OUT,
	output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";

	parameter COUNT_TO		= 8'h1;
	parameter CLKIN_DIVIDE	= 1;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	reg[7:0] count = COUNT_TO;

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		OUT = (count == 8'h0);
		POUT = count;
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count	<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin
					if(!RST)
						count	<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT8 not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count	<= 0;

					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT8");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_DCMPREF(output reg[7:0]OUT);
	parameter[7:0] REF_VAL = 8'h00;
	initial OUT = REF_VAL;
endmodule

module GP_DCMPMUX(input[1:0] SEL, input[7:0] IN0, input[7:0] IN1, input[7:0] IN2, input[7:0] IN3, output reg[7:0] OUTA, output reg[7:0] OUTB);

	always @(*) begin
		case(SEL)
			2'd00: begin
				OUTA = IN0;
				OUTB = IN3;
			end

			2'd01: begin
				OUTA = IN1;
				OUTB = IN2;
			end

			2'd02: begin
				OUTA = IN2;
				OUTB = IN1;
			end

			2'd03: begin
				OUTA = IN3;
				OUTB = IN0;
			end

		endcase
	end
endmodule

module GP_DELAY(input IN, output reg OUT);

	parameter DELAY_STEPS = 1;
	parameter GLITCH_FILTER = 0;

	initial OUT = 0;

	generate

		if(GLITCH_FILTER) begin
			initial begin
				$display("ERROR: GP_DELAY glitch filter mode not implemented");
				$finish;
			end
		end

		//TODO: These delays are PTV dependent! For now, hard code 3v3 timing
		//Change simulation-mode delay depending on global Vdd range (how to specify this?)
		always @(*) begin
			case(DELAY_STEPS)
				1: #166 OUT = IN;
				2: #318 OUT = IN;
				2: #471 OUT = IN;
				3: #622 OUT = IN;
				default: begin
					$display("ERROR: GP_DELAY must have DELAY_STEPS in range [1,4]");
					$finish;
				end
			endcase
		end

	endgenerate

endmodule

module GP_DFF(input D, CLK, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK) begin
		Q <= D;
	end
endmodule

module GP_DFFI(input D, CLK, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK) begin
		nQ <= ~D;
	end
endmodule

module GP_DFFR(input D, CLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nRST) begin
		if (!nRST)
			Q <= 1'b0;
		else
			Q <= D;
	end
endmodule

module GP_DFFRI(input D, CLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nRST) begin
		if (!nRST)
			nQ <= 1'b1;
		else
			nQ <= ~D;
	end
endmodule

module GP_DFFS(input D, CLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nSET) begin
		if (!nSET)
			Q <= 1'b1;
		else
			Q <= D;
	end
endmodule

module GP_DFFSI(input D, CLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nSET) begin
		if (!nSET)
			nQ <= 1'b0;
		else
			nQ <= ~D;
	end
endmodule

module GP_DFFSR(input D, CLK, nSR, output reg Q);
	parameter [0:0] INIT = 1'bx;
	parameter [0:0] SRMODE = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nSR) begin
		if (!nSR)
			Q <= SRMODE;
		else
			Q <= D;
	end
endmodule

module GP_DFFSRI(input D, CLK, nSR, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	parameter [0:0] SRMODE = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nSR) begin
		if (!nSR)
			nQ <= ~SRMODE;
		else
			nQ <= ~D;
	end
endmodule

module GP_DLATCH(input D, input nCLK, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nCLK)
			Q = D;
	end
endmodule

module GP_DLATCHI(input D, input nCLK, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nCLK)
			nQ = ~D;
	end
endmodule

module GP_DLATCHR(input D, input nCLK, input nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nRST)
			Q = 1'b0;
		else if(!nCLK)
			Q = D;
	end
endmodule

module GP_DLATCHRI(input D, input nCLK, input nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nRST)
			nQ = 1'b1;
		else if(!nCLK)
			nQ = ~D;
	end
endmodule

module GP_DLATCHS(input D, input nCLK, input nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nSET)
			Q = 1'b1;
		else if(!nCLK)
			Q = D;
	end
endmodule

module GP_DLATCHSI(input D, input nCLK, input nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nSET)
			nQ = 1'b0;
		else if(!nCLK)
			nQ = ~D;
	end
endmodule

module GP_DLATCHSR(input D, input nCLK, input nSR, output reg Q);
	parameter [0:0] INIT = 1'bx;
	parameter[0:0] SRMODE = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nSR)
			Q = SRMODE;
		else if(!nCLK)
			Q = D;
	end
endmodule

module GP_DLATCHSRI(input D, input nCLK, input nSR, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	parameter[0:0] SRMODE = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nSR)
			nQ = ~SRMODE;
		else if(!nCLK)
			nQ = ~D;
	end
endmodule

module GP_IBUF(input IN, output OUT);
	assign OUT = IN;
endmodule

module GP_IOBUF(input IN, input OE, output OUT, inout IO);
	assign OUT = IO;
	assign IO = OE ? IN : 1'bz;
endmodule

module GP_INV(input IN, output OUT);
	assign OUT = ~IN;
endmodule

module GP_OBUF(input IN, output OUT);
	assign OUT = IN;
endmodule

module GP_OBUFT(input IN, input OE, output OUT);
	assign OUT = OE ? IN : 1'bz;
endmodule

module GP_PGEN(input wire nRST, input wire CLK, output reg OUT);
	initial OUT = 0;
	parameter PATTERN_DATA = 16'h0;
	parameter PATTERN_LEN = 5'd16;

	localparam COUNT_MAX =  PATTERN_LEN - 1'h1;

	reg[3:0] count = 0;
	always @(posedge CLK, negedge nRST) begin

		if(!nRST)
			count	<= 0;

		else begin
			count	<= count - 1'h1;
			if(count == 0)
				count <= COUNT_MAX;
		end
	end

	always @(*)
		OUT	= PATTERN_DATA[count];

endmodule

module GP_SHREG(input nRST, input CLK, input IN, output OUTA, output OUTB);

	parameter OUTA_TAP = 1;
	parameter OUTA_INVERT = 0;
	parameter OUTB_TAP = 1;

	reg[15:0] shreg = 0;

	always @(posedge CLK, negedge nRST) begin

		if(!nRST)
			shreg = 0;

		else
			shreg <= {shreg[14:0], IN};

	end

	assign OUTA = (OUTA_INVERT) ? ~shreg[OUTA_TAP - 1] : shreg[OUTA_TAP - 1];
	assign OUTB = shreg[OUTB_TAP - 1];

endmodule

module GP_VDD(output OUT);
       assign OUT = 1;
endmodule

module GP_VSS(output OUT);
       assign OUT = 0;
endmodule
`,"cells_sim_wip.v":`
//Cells still in this file have INCOMPLETE simulation models, need to finish them

module GP_DCMP(input[7:0] INP, input[7:0] INN, input CLK, input PWRDN, output reg GREATER, output reg EQUAL);
	parameter PWRDN_SYNC = 1'b0;
	parameter CLK_EDGE = "RISING";
	parameter GREATER_OR_EQUAL = 1'b0;

	//TODO implement power-down mode

	initial GREATER = 0;
	initial EQUAL = 0;

	wire clk_minv = (CLK_EDGE == "RISING") ? CLK : ~CLK;
	always @(posedge clk_minv) begin
		if(GREATER_OR_EQUAL)
			GREATER <= (INP >= INN);
		else
			GREATER <= (INP > INN);

		EQUAL <= (INP == INN);
	end

endmodule

module GP_EDGEDET(input IN, output reg OUT);

	parameter EDGE_DIRECTION = "RISING";
	parameter DELAY_STEPS = 1;
	parameter GLITCH_FILTER = 0;

	//not implemented for simulation

endmodule

module GP_RCOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter HARDIP_DIV = 1;
	parameter FABRIC_DIV = 1;
	parameter OSC_FREQ = "25k";

	initial CLKOUT_HARDIP = 0;
	initial CLKOUT_FABRIC = 0;

	//output dividers not implemented for simulation
	//auto powerdown not implemented for simulation

	always begin
		if(PWRDN) begin
			CLKOUT_HARDIP = 0;
			CLKOUT_FABRIC = 0;
		end
		else begin

			if(OSC_FREQ == "25k") begin
				//half period of 25 kHz
				#20000;
			end

			else begin
				//half period of 2 MHz
				#250;
			end

			CLKOUT_HARDIP = ~CLKOUT_HARDIP;
			CLKOUT_FABRIC = ~CLKOUT_FABRIC;
		end
	end

endmodule

module GP_RINGOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter HARDIP_DIV = 1;
	parameter FABRIC_DIV = 1;

	initial CLKOUT_HARDIP = 0;
	initial CLKOUT_FABRIC = 0;

	//output dividers not implemented for simulation
	//auto powerdown not implemented for simulation

	always begin
		if(PWRDN) begin
			CLKOUT_HARDIP = 0;
			CLKOUT_FABRIC = 0;
		end
		else begin
			//half period of 27 MHz
			#18.518;
			CLKOUT_HARDIP = ~CLKOUT_HARDIP;
			CLKOUT_FABRIC = ~CLKOUT_FABRIC;
		end
	end

endmodule

module GP_SPI(
	input SCK,
	inout SDAT,
	input CSN,
	input[7:0] TXD_HIGH,
	input[7:0] TXD_LOW,
	output reg[7:0] RXD_HIGH,
	output reg[7:0] RXD_LOW,
	output reg INT);

	initial RXD_HIGH = 0;
	initial RXD_LOW = 0;
	initial INT = 0;

	parameter DATA_WIDTH = 8;		//byte or word width
	parameter SPI_CPHA = 0;			//SPI clock phase
	parameter SPI_CPOL = 0;			//SPI clock polarity
	parameter DIRECTION = "INPUT";	//SPI data direction (either input to chip or output to host)
	//parallel output to fabric not yet implemented

	//TODO: write sim model
	//TODO: SPI SDIO control... can we use ADC output while SPI is input??
	//TODO: clock sync

endmodule

//keep constraint needed to prevent optimization since we have no outputs
(* keep *)
module GP_SYSRESET(input RST);
	parameter RESET_MODE = "EDGE";
	parameter EDGE_SPEED = 4;

	//cannot simulate whole system reset

endmodule
`,"gp_dff.lib":`library(gp_dff) {
  cell(GP_DFF) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                      next_state: D; }
    pin(CLK) { direction: input;
                   clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
  }
  cell(GP_DFFS) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                  next_state: D;
                      preset: "nSET'"; }
    pin(CLK) { direction: input;
                 clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
    pin(nSET) { direction: input; }
  }
  cell(GP_DFFR) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                      next_state: D;
                           clear: "nRST'"; }
    pin(CLK) { direction: input;
                   clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
    pin(nRST) { direction: input; }
  }
}
`},ice40:{"abc9_model.v":`(* abc9_box, lib_whitebox *)
module \\$__ICE40_CARRY_WRAPPER (
	(* abc9_carry *)
	output CO,
	output O,
	input A, B,
	(* abc9_carry *)
	input CI,
	input I0, I3
);
	parameter LUT = 0;
	parameter I3_IS_CI = 0;
	wire I3_OR_CI = I3_IS_CI ? CI : I3;
	SB_CARRY carry (
		.I0(A),
		.I1(B),
		.CI(CI),
		.CO(CO)
	);
	SB_LUT4 #(
		.LUT_INIT(LUT)
	) adder (
		.I0(I0),
		.I1(A),
		.I2(B),
		.I3(I3_OR_CI),
		.O(O)
	);
\`ifdef ICE40_HX
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L79
		(CI => CO) = (126, 105);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L80
		(I0 => O) = (449, 386);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L82
		(A => CO) = (259, 245);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L83
		(A => O) = (400, 379);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L85
		(B => CO) = (231, 133);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L86
		(B => O) = (379, 351);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L88
		(I3 => O) = (316, 288);
		(CI => O) = (316, 288);
	endspecify
\`endif
\`ifdef ICE40_LP
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L79
		(CI => CO) = (186, 155);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L80
		(I0 => O) = (662, 569);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L82
		(A => CO) = (382, 362);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L83
		(A => O) = (589, 558);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L85
		(B => CO) = (341, 196);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L86
		(B => O) = (558, 517);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L88
		(I3 => O) = (465, 423);
		(CI => O) = (465, 423);
	endspecify
\`endif
\`ifdef ICE40_U
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L91
		(CI => CO) = (278, 278);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L92
		(I0 => O) = (1245, 1285);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L94
		(A => CO) = (675, 662);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L95
		(A => O) = (1179, 1232);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L97
		(B => CO) = (609, 358);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L98
		(B => O) = (1179, 1205);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L100
		(I3 => O) = (861, 874);
		(CI => O) = (861, 874);
	endspecify
\`endif
endmodule
`,"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ice40_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		\\$__ICE40_CARRY_WRAPPER #(
			//    A[0]: 1010 1010 1010 1010
			//    A[1]: 1100 1100 1100 1100
			//    A[2]: 1111 0000 1111 0000
			//    A[3]: 1111 1111 0000 0000
			.LUT(16'b 0110_1001_1001_0110),
			.I3_IS_CI(1'b1)
		) carry (
			.A(AA[i]),
			.B(BB[i]),
			.CI(C[i]),
			.I0(1'b0),
			.I3(1'bx),
			.CO(CO[i]),
			.O(Y[i])
		);
	end endgenerate

	assign X = AA ^ BB;
endmodule

`,"brams.txt":`ram block $__ICE40_RAM4K_ {
	abits 11;
	widths 2 4 8 16 per_port;
	cost 64;
	option "HAS_BE" 1 {
		byte 1;
	}
	init any;
	port sw "W" {
		option "HAS_BE" 0 {
			width 2 4 8;
		}
		option "HAS_BE" 1 {
			width 16;
			wrbe_separate;
		}
		clock anyedge;
	}
	port sr "R" {
		clock anyedge;
		rden;
	}
}
`,"brams_map.v":`module $__ICE40_RAM4K_ (...);

parameter INIT = 0;
parameter OPTION_HAS_BE = 1;
parameter PORT_R_WIDTH = 16;
parameter PORT_W_WIDTH = 16;
parameter PORT_W_WR_BE_WIDTH = 16;
parameter PORT_R_CLK_POL = 1;
parameter PORT_W_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_RD_EN;
input [10:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

input PORT_W_CLK;
input PORT_W_WR_EN;
input [15:0] PORT_W_WR_BE;
input [10:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

wire [15:0] RDATA;
wire [15:0] WDATA;
wire [15:0] MASK;
wire [10:0] RADDR = {PORT_R_ADDR[0], PORT_R_ADDR[1], PORT_R_ADDR[2], PORT_R_ADDR[10:3]};
wire [10:0] WADDR = {PORT_W_ADDR[0], PORT_W_ADDR[1], PORT_W_ADDR[2], PORT_W_ADDR[10:3]};

function [1:0] mode;
	input integer width;
	case (width)
	16: mode = 0;
	8: mode = 1;
	4: mode = 2;
	2: mode = 3;
	endcase
endfunction

function [255:0] slice_init;
	input [3:0] idx;
	integer i;
	reg [7:0] ri;
	reg [11:0] a;
	for (i = 0; i < 256; i = i + 1) begin
		ri = i;
		a = {idx, ri[7:4], ri[0], ri[1], ri[2], ri[3]};
		slice_init[i] = INIT[a];
	end
endfunction

\`define INSTANCE(type, rclk, wclk) \\
	type #( \\
		.INIT_0(slice_init(0)), \\
		.INIT_1(slice_init(1)), \\
		.INIT_2(slice_init(2)), \\
		.INIT_3(slice_init(3)), \\
		.INIT_4(slice_init(4)), \\
		.INIT_5(slice_init(5)), \\
		.INIT_6(slice_init(6)), \\
		.INIT_7(slice_init(7)), \\
		.INIT_8(slice_init(8)), \\
		.INIT_9(slice_init(9)), \\
		.INIT_A(slice_init(10)), \\
		.INIT_B(slice_init(11)), \\
		.INIT_C(slice_init(12)), \\
		.INIT_D(slice_init(13)), \\
		.INIT_E(slice_init(14)), \\
		.INIT_F(slice_init(15)), \\
		.READ_MODE(mode(PORT_R_WIDTH)), \\
		.WRITE_MODE(mode(PORT_W_WIDTH)) \\
	) _TECHMAP_REPLACE_ ( \\
		.RDATA(RDATA), \\
		.rclk(PORT_R_CLK), \\
		.RCLKE(PORT_R_RD_EN), \\
		.RE(1'b1), \\
		.RADDR(RADDR), \\
		.WDATA(WDATA), \\
		.wclk(PORT_W_CLK), \\
		.WCLKE(PORT_W_WR_EN), \\
		.WE(1'b1), \\
		.WADDR(WADDR), \\
		.MASK(MASK), \\
	);

generate

case(PORT_R_WIDTH)
	2: begin
		assign PORT_R_RD_DATA = {
			RDATA[11],
			RDATA[3]
		};
	end
	4: begin
		assign PORT_R_RD_DATA = {
			RDATA[13],
			RDATA[5],
			RDATA[9],
			RDATA[1]
		};
	end
	8: begin
		assign PORT_R_RD_DATA = {
			RDATA[14],
			RDATA[6],
			RDATA[10],
			RDATA[2],
			RDATA[12],
			RDATA[4],
			RDATA[8],
			RDATA[0]
		};
	end
	16: begin
		assign PORT_R_RD_DATA = {
			RDATA[15],
			RDATA[7],
			RDATA[11],
			RDATA[3],
			RDATA[13],
			RDATA[5],
			RDATA[9],
			RDATA[1],
			RDATA[14],
			RDATA[6],
			RDATA[10],
			RDATA[2],
			RDATA[12],
			RDATA[4],
			RDATA[8],
			RDATA[0]
		};
	end
endcase

case(PORT_W_WIDTH)
	2: begin
		assign {
			WDATA[11],
			WDATA[3]
		} = PORT_W_WR_DATA;
	end
	4: begin
		assign {
			WDATA[13],
			WDATA[5],
			WDATA[9],
			WDATA[1]
		} = PORT_W_WR_DATA;
	end
	8: begin
		assign {
			WDATA[14],
			WDATA[6],
			WDATA[10],
			WDATA[2],
			WDATA[12],
			WDATA[4],
			WDATA[8],
			WDATA[0]
		} = PORT_W_WR_DATA;
	end
	16: begin
		assign WDATA = {
			PORT_W_WR_DATA[15],
			PORT_W_WR_DATA[7],
			PORT_W_WR_DATA[11],
			PORT_W_WR_DATA[3],
			PORT_W_WR_DATA[13],
			PORT_W_WR_DATA[5],
			PORT_W_WR_DATA[9],
			PORT_W_WR_DATA[1],
			PORT_W_WR_DATA[14],
			PORT_W_WR_DATA[6],
			PORT_W_WR_DATA[10],
			PORT_W_WR_DATA[2],
			PORT_W_WR_DATA[12],
			PORT_W_WR_DATA[4],
			PORT_W_WR_DATA[8],
			PORT_W_WR_DATA[0]
		};
		assign MASK = ~{
			PORT_W_WR_BE[15],
			PORT_W_WR_BE[7],
			PORT_W_WR_BE[11],
			PORT_W_WR_BE[3],
			PORT_W_WR_BE[13],
			PORT_W_WR_BE[5],
			PORT_W_WR_BE[9],
			PORT_W_WR_BE[1],
			PORT_W_WR_BE[14],
			PORT_W_WR_BE[6],
			PORT_W_WR_BE[10],
			PORT_W_WR_BE[2],
			PORT_W_WR_BE[12],
			PORT_W_WR_BE[4],
			PORT_W_WR_BE[8],
			PORT_W_WR_BE[0]
		};
	end
endcase

if (PORT_R_CLK_POL) begin
	if (PORT_W_CLK_POL) begin
		\`INSTANCE(SB_RAM40_4K, RCLK, WCLK)
	end else begin
		\`INSTANCE(SB_RAM40_4KNW, RCLK, WCLKN)
	end
end else begin
	if (PORT_W_CLK_POL) begin
		\`INSTANCE(SB_RAM40_4KNR, RCLKN, WCLK)
	end else begin
		\`INSTANCE(SB_RAM40_4KNRNW, RCLKN, WCLKN)
	end
end

endgenerate

endmodule
`,"cells_map.v":`module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(1'b0), .I2(1'b0), .I3(A[0]));
    end else
    if (WIDTH == 2) begin
      localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(1'b0), .I2(A[0]), .I3(A[1]));
    end else
    if (WIDTH == 3) begin
      localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(A[0]), .I2(A[1]), .I3(A[2]));
    end else
    if (WIDTH == 4) begin
      SB_LUT4 #(.LUT_INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
`,"cells_sim.v":new URL("cells_sim-15f559e1.v?hash=15f559e1",import.meta.url),"dsp_map.v":`module \\$__MUL16X16 (input [15:0] A, input [15:0] B, output [31:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	SB_MAC16 #(
		.NEG_TRIGGER(1'b0),
		.C_REG(1'b0),
		.A_REG(1'b0),
		.B_REG(1'b0),
		.D_REG(1'b0),
		.TOP_8x8_MULT_REG(1'b0),
		.BOT_8x8_MULT_REG(1'b0),
		.PIPELINE_16x16_MULT_REG1(1'b0),
		.PIPELINE_16x16_MULT_REG2(1'b0),
		.TOPOUTPUT_SELECT(2'b11),
		.TOPADDSUB_LOWERINPUT(2'b0),
		.TOPADDSUB_UPPERINPUT(1'b0),
		.TOPADDSUB_CARRYSELECT(2'b0),
		.BOTOUTPUT_SELECT(2'b11),
		.BOTADDSUB_LOWERINPUT(2'b0),
		.BOTADDSUB_UPPERINPUT(1'b0),
		.BOTADDSUB_CARRYSELECT(2'b0),
		.MODE_8x8(1'b0),
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED)
	) _TECHMAP_REPLACE_ (
		.A(A),
		.B(B),
		.O(Y),
	);
endmodule
`,"ff_map.v":`module  \\$_DFF_N_ (input D, C, output Q); SB_DFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_P_ (input D, C, output Q); SB_DFF  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q); SB_DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP_ (input D, C, E, output Q); SB_DFFE  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); SB_DFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); SB_DFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); SB_DFFR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); SB_DFFS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); SB_DFFNER _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); SB_DFFNES _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); SB_DFFER  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); SB_DFFES  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); SB_DFFNSR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); SB_DFFNSS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); SB_DFFSR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); SB_DFFSS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_SDFFCE_NP0P_ (input D, C, E, R, output Q); SB_DFFNESR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_NP1P_ (input D, C, E, R, output Q); SB_DFFNESS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); SB_DFFESR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); SB_DFFESS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"spram.txt":`ram huge $__ICE40_SPRAM_ {
	abits 14;
	width 16;
	cost 2048;
	byte 4;
	port srsw "A" {
		clock posedge;
		clken;
		wrbe_separate;
		rdwr no_change;
	}
}
`,"spram_map.v":`module $__ICE40_SPRAM_ (...);

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input [3:0] PORT_A_WR_BE;
input [13:0] PORT_A_ADDR;
input [15:0] PORT_A_WR_DATA;
output [15:0] PORT_A_RD_DATA;

SB_SPRAM256KA _TECHMAP_REPLACE_ (
	.ADDRESS(PORT_A_ADDR),
	.DATAIN(PORT_A_WR_DATA),
	.MASKWREN(PORT_A_WR_BE),
	.WREN(PORT_A_WR_EN),
	.CHIPSELECT(PORT_A_CLK_EN),
	.CLOCK(PORT_A_CLK),
	.STANDBY(1'b0),
	.SLEEP(1'b0),
	.POWEROFF(1'b1),
	.DATAOUT(PORT_A_RD_DATA),
);

endmodule
`},include:{backends:{cxxrtl:{runtime:{cxxrtl:{capi:{"cxxrtl_capi.cc":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl/capi/cxxrtl_capi.h\`.

#include <cxxrtl/capi/cxxrtl_capi.h>
#include <cxxrtl/cxxrtl.h>

struct _cxxrtl_handle {
	std::unique_ptr<cxxrtl::module> module;
	cxxrtl::debug_items objects;
};

// Private function for use by other units of the C API.
const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle) {
	return handle->objects;
}

cxxrtl_handle cxxrtl_create(cxxrtl_toplevel design) {
	return cxxrtl_create_at(design, "");
}

cxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path_) {
	std::string top_path = top_path_;
	if (!top_path.empty()) {
		// module::debug_info() accepts either an empty path, or a path ending in space to simplify
		// the logic in generated code. While this is sketchy at best to expose in the C++ API, this
		// would be a lot worse in the C API, so don't expose it here.
		assert(top_path.back() != ' ');
		top_path += ' ';
	}

	cxxrtl_handle handle = new _cxxrtl_handle;
	handle->module = std::move(design->module);
	handle->module->debug_info(&handle->objects, nullptr, top_path);
	delete design;
	return handle;
}

void cxxrtl_destroy(cxxrtl_handle handle) {
	delete handle;
}

void cxxrtl_reset(cxxrtl_handle handle) {
	handle->module->reset();
}

int cxxrtl_eval(cxxrtl_handle handle) {
	return handle->module->eval();
}

int cxxrtl_commit(cxxrtl_handle handle) {
	return handle->module->commit();
}

size_t cxxrtl_step(cxxrtl_handle handle) {
	return handle->module->step();
}

struct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts) {
	auto it = handle->objects.table.find(name);
	if (it == handle->objects.table.end())
		return nullptr;
	*parts = it->second.size();
	return static_cast<cxxrtl_object*>(&it->second[0]);
}

void cxxrtl_enum(cxxrtl_handle handle, void *data,
                 void (*callback)(void *data, const char *name,
                                  cxxrtl_object *object, size_t parts)) {
	for (auto &it : handle->objects.table)
		callback(data, it.first.c_str(), static_cast<cxxrtl_object*>(&it.second[0]), it.second.size());
}

void cxxrtl_outline_eval(cxxrtl_outline outline) {
	outline->eval();
}

int cxxrtl_attr_type(cxxrtl_attr_set attrs_, const char *name) {
	auto attrs = (cxxrtl::metadata_map*)attrs_;
	if (!attrs->count(name))
		return CXXRTL_ATTR_NONE;
	switch (attrs->at(name).value_type) {
		case cxxrtl::metadata::UINT:
			return CXXRTL_ATTR_UNSIGNED_INT;
		case cxxrtl::metadata::SINT:
			return CXXRTL_ATTR_SIGNED_INT;
		case cxxrtl::metadata::STRING:
			return CXXRTL_ATTR_STRING;
		case cxxrtl::metadata::DOUBLE:
			return CXXRTL_ATTR_DOUBLE;
		default:
			// Present unsupported attribute type the same way as no attribute at all.
			return CXXRTL_ATTR_NONE;
	}
}

uint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::UINT);
	return attrs[name].as_uint();
}

int64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::SINT);
	return attrs[name].as_sint();
}

const char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::STRING);
	return attrs[name].as_string().c_str();
}

double cxxrtl_attr_get_double(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::DOUBLE);
	return attrs[name].as_double();
}
`,"cxxrtl_capi.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_CAPI_H
#define CXXRTL_CAPI_H

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl_capi.cc\`.
//
// The CXXRTL C API makes it possible to drive CXXRTL designs using C or any other language that
// supports the C ABI, for example, Python. It does not provide a way to implement black boxes.

#include <stddef.h>
#include <stdint.h>
#include <assert.h>

#ifdef __cplusplus
extern "C" {
#endif

// Opaque reference to a design toplevel.
//
// A design toplevel can only be used to create a design handle.
typedef struct _cxxrtl_toplevel *cxxrtl_toplevel;

// The constructor for a design toplevel is provided as a part of generated code for that design.
// Its prototype matches:
//
// cxxrtl_toplevel <design-name>_create();

// Opaque reference to a design handle.
//
// A design handle is required by all operations in the C API.
typedef struct _cxxrtl_handle *cxxrtl_handle;

// Create a design handle from a design toplevel.
//
// The \`design\` is consumed by this operation and cannot be used afterwards.
cxxrtl_handle cxxrtl_create(cxxrtl_toplevel design);

// Create a design handle at a given hierarchy position from a design toplevel.
//
// This operation is similar to \`cxxrtl_create\`, except the full hierarchical name of every object
// is prepended with \`top_path\`.
cxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path);

// Release all resources used by a design and its handle.
void cxxrtl_destroy(cxxrtl_handle handle);

// Reinitialize the design, replacing the internal state with the reset values while preserving
// black boxes.
//
// This operation is essentially equivalent to a power-on reset. Values, wires, and memories are
// returned to their reset state while preserving the state of black boxes and keeping all of
// the interior pointers obtained with e.g. \`cxxrtl_get\` valid.
void cxxrtl_reset(cxxrtl_handle handle);

// Evaluate the design, propagating changes on inputs to the \`next\` value of internal state and
// output wires.
//
// Returns 1 if the design is known to immediately converge, 0 otherwise.
int cxxrtl_eval(cxxrtl_handle handle);

// Commit the design, replacing the \`curr\` value of internal state and output wires with the \`next\`
// value.
//
// Return 1 if any of the \`curr\` values were updated, 0 otherwise.
int cxxrtl_commit(cxxrtl_handle handle);

// Simulate the design to a fixed point.
//
// Returns the number of delta cycles.
size_t cxxrtl_step(cxxrtl_handle handle);

// Type of a simulated object.
//
// The type of a simulated object indicates the way it is stored and the operations that are legal
// to perform on it (i.e. won't crash the simulation). It says very little about object semantics,
// which is specified through flags.
enum cxxrtl_type {
	// Values correspond to singly buffered netlist nodes, i.e. nodes driven exclusively by
	// combinatorial cells, or toplevel input nodes.
	//
	// Values can be inspected via the \`curr\` pointer. If the \`next\` pointer is NULL, the value is
	// driven by a constant and can never be modified. Otherwise, the value can be modified through
	// the \`next\` pointer (which is equal to \`curr\` if not NULL). Note that changes to the bits
	// driven by combinatorial cells will be ignored.
	//
	// Values always have depth 1.
	CXXRTL_VALUE = 0,

	// Wires correspond to doubly buffered netlist nodes, i.e. nodes driven, at least in part, by
	// storage cells, or by combinatorial cells that are a part of a feedback path. They are also
	// present in non-optimized builds.
	//
	// Wires can be inspected via the \`curr\` pointer and modified via the \`next\` pointer (which are
	// distinct for wires). Note that changes to the bits driven by combinatorial cells will be
	// ignored.
	//
	// Wires always have depth 1.
	CXXRTL_WIRE = 1,

	// Memories correspond to memory cells.
	//
	// Memories can be inspected and modified via the \`curr\` pointer. Due to a limitation of this
	// API, memories cannot yet be modified in a guaranteed race-free way, and the \`next\` pointer is
	// always NULL.
	CXXRTL_MEMORY = 2,

	// Aliases correspond to netlist nodes driven by another node such that their value is always
	// exactly equal.
	//
	// Aliases can be inspected via the \`curr\` pointer. They cannot be modified, and the \`next\`
	// pointer is always NULL.
	CXXRTL_ALIAS = 3,

	// Outlines correspond to netlist nodes that were optimized in a way that makes them inaccessible
	// outside of a module's \`eval()\` function. At the highest debug information level, every inlined
	// node has a corresponding outline object.
	//
	// Outlines can be inspected via the \`curr\` pointer and can never be modified; the \`next\` pointer
	// is always NULL. Unlike all other objects, the bits of an outline object are meaningful only
	// after a call to \`cxxrtl_outline_eval\` and until any subsequent modification to the netlist.
	// Observing this requirement is the responsibility of the caller; it is not enforced.
	//
	// Outlines always correspond to combinatorial netlist nodes that are not ports.
	CXXRTL_OUTLINE = 4,

	// More object types may be added in the future, but the existing ones will never change.
};

// Flags of a simulated object.
//
// The flags of a simulated object indicate its role in the netlist:
//  * The flags \`CXXRTL_INPUT\` and \`CXXRTL_OUTPUT\` designate module ports.
//  * The flags \`CXXRTL_DRIVEN_SYNC\`, \`CXXRTL_DRIVEN_COMB\`, and \`CXXRTL_UNDRIVEN\` specify
//    the semantics of node state. An object with several of these flags set has different bits
//    follow different semantics.
enum cxxrtl_flag {
	// Node is a module input port.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\` and \`CXXRTL_WIRE\`. It may be combined
	// with \`CXXRTL_OUTPUT\`, as well as other flags.
	CXXRTL_INPUT = 1 << 0,

	// Node is a module output port.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with \`CXXRTL_INPUT\`,
	// as well as other flags.
	CXXRTL_OUTPUT = 1 << 1,

	// Node is a module inout port.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with other flags.
	CXXRTL_INOUT = (CXXRTL_INPUT|CXXRTL_OUTPUT),

	// Node has bits that are driven by a storage cell.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with
	// \`CXXRTL_DRIVEN_COMB\` and \`CXXRTL_UNDRIVEN\`, as well as other flags.
	//
	// This flag is set on wires that have bits connected directly to the output of a flip-flop or
	// a latch, and hold its state. Many \`CXXRTL_WIRE\` objects may not have the \`CXXRTL_DRIVEN_SYNC\`
	// flag set; for example, output ports and feedback wires generally won't. Writing to the \`next\`
	// pointer of these wires updates stored state, and for designs without combinatorial loops,
	// capturing the value from every of these wires through the \`curr\` pointer creates a complete
	// snapshot of the design state.
	CXXRTL_DRIVEN_SYNC = 1 << 2,

	// Node has bits that are driven by a combinatorial cell or another node.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\`, \`CXXRTL_WIRE\`, and \`CXXRTL_OUTLINE\`.
	// It may be combined with \`CXXRTL_DRIVEN_SYNC\` and \`CXXRTL_UNDRIVEN\`, as well as other flags.
	//
	// This flag is set on objects that have bits connected to the output of a combinatorial cell,
	// or directly to another node. For designs without combinatorial loops, writing to such bits
	// through the \`next\` pointer (if it is not NULL) has no effect.
	CXXRTL_DRIVEN_COMB = 1 << 3,

	// Node has bits that are not driven.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\` and \`CXXRTL_WIRE\`. It may be combined
	// with \`CXXRTL_DRIVEN_SYNC\` and \`CXXRTL_DRIVEN_COMB\`, as well as other flags.
	//
	// This flag is set on objects that have bits not driven by an output of any cell or by another
	// node, such as inputs and dangling wires.
	CXXRTL_UNDRIVEN = 1 << 4,

	// Generated correspond to netlist nodes that correspond to state with an internal name, that
	// need to be saved, but wouldn't otherwise have a debug item generated.
	CXXRTL_GENERATED = 1 << 5,

	// More object flags may be added in the future, but the existing ones will never change.
};

// Description of a simulated object.
//
// The \`curr\` and \`next\` arrays can be accessed directly to inspect and, if applicable, modify
// the bits stored in the object.
struct cxxrtl_object {
	// Type of the object.
	//
	// All objects have the same memory layout determined by \`width\` and \`depth\`, but the type
	// determines all other properties of the object.
	uint32_t type; // actually \`enum cxxrtl_type\`

	// Flags of the object.
	uint32_t flags; // actually bit mask of \`enum cxxrtl_flags\`

	// Width of the object in bits.
	size_t width;

	// Index of the least significant bit.
	size_t lsb_at;

	// Depth of the object. Only meaningful for memories; for other objects, always 1.
	size_t depth;

	// Index of the first word. Only meaningful for memories; for other objects, always 0;
	size_t zero_at;

	// Bits stored in the object, as 32-bit chunks, least significant bits first.
	//
	// The width is rounded up to a multiple of 32; the padding bits are always set to 0 by
	// the simulation code, and must be always written as 0 when modified by user code.
	// In memories, every element is stored contiguously. Therefore, the total number of chunks
	// in any object is \`((width + 31) / 32) * depth\`.
	//
	// To allow the simulation to be partitioned into multiple independent units communicating
	// through wires, the bits are double buffered. To avoid race conditions, user code should
	// always read from \`curr\` and write to \`next\`. The \`curr\` pointer is always valid; for objects
	// that cannot be modified, or cannot be modified in a race-free way, \`next\` is NULL.
	//
	// In case where \`width == 0\`, \`curr\` is a non-NULL pointer unique for the wire. That is,
	// there is a 1-to-1 correspondence between simulation objects and \`curr\` pointers, regardless
	// of whether they have storage or not. (Aliases' \`curr\` pointer equals that of some other
	// simulated object.)
	uint32_t *curr;
	uint32_t *next;

	// Opaque reference to an outline. Only meaningful for outline objects.
	//
	// See the documentation of \`cxxrtl_outline\` for details. When creating a \`cxxrtl_object\`, set
	// this field to NULL.
	struct _cxxrtl_outline *outline;

	// Opaque reference to an attribute set.
	//
	// See the documentation of \`cxxrtl_attr_set\` for details. When creating a \`cxxrtl_object\`, set
	// this field to NULL.
	//
	// The lifetime of the pointers returned by \`cxxrtl_attr_*\` family of functions is the same as
	// the lifetime of this structure.
	struct _cxxrtl_attr_set *attrs;

	// More description fields may be added in the future, but the existing ones will never change.
};

// Retrieve description of a simulated object.
//
// The \`name\` is the full hierarchical name of the object in the Yosys notation, where public names
// have a \`\\\` prefix and hierarchy levels are separated by single spaces. For example, if
// the top-level module instantiates a module \`foo\`, which in turn contains a wire \`bar\`, the full
// hierarchical name is \`\\foo \\bar\`.
//
// The storage of a single abstract object may be split (usually with the \`splitnets\` pass) into
// many physical parts, all of which correspond to the same hierarchical name. To handle such cases,
// this function returns an array and writes its length to \`parts\`. The array is sorted by \`lsb_at\`.
//
// Returns the object parts if it was found, NULL otherwise. The returned parts are valid until
// the design is destroyed.
struct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts);

// Retrieve description of a single part simulated object.
//
// This function is a shortcut for the most common use of \`cxxrtl_get_parts\`. It asserts that,
// if the object exists, it consists of a single part. If assertions are disabled, it returns NULL
// for multi-part objects.
static inline struct cxxrtl_object *cxxrtl_get(cxxrtl_handle handle, const char *name) {
	size_t parts = 0;
	struct cxxrtl_object *object = cxxrtl_get_parts(handle, name, &parts);
	assert(object == NULL || parts == 1);
	if (object == NULL || parts == 1)
		return object;
	return NULL;
}

// Enumerate simulated objects.
//
// For every object in the simulation, \`callback\` is called with the provided \`data\`, the full
// hierarchical name of the object (see \`cxxrtl_get\` for details), and the object parts.
// The provided \`name\` and \`object\` values are valid until the design is destroyed.
void cxxrtl_enum(cxxrtl_handle handle, void *data,
                 void (*callback)(void *data, const char *name,
                                  struct cxxrtl_object *object, size_t parts));

// Opaque reference to an outline.
//
// An outline is a group of outline objects that are evaluated simultaneously. The identity of
// an outline can be compared to determine whether any two objects belong to the same outline.
typedef struct _cxxrtl_outline *cxxrtl_outline;

// Evaluate an outline.
//
// After evaluating an outline, the bits of every outline object contained in it are consistent
// with the current state of the netlist. In general, any further modification to the netlist
// causes every outline object to become stale, after which the corresponding outline must be
// re-evaluated, otherwise the bits read from that object are meaningless.
void cxxrtl_outline_eval(cxxrtl_outline outline);

// Opaque reference to an attribute set.
//
// An attribute set is a map between attribute names (always strings) and values (which may have
// several different types). To find out the type of an attribute, use \`cxxrtl_attr_type\`, and
// to retrieve the value of an attribute, use \`cxxrtl_attr_as_string\`.
typedef struct _cxxrtl_attr_set *cxxrtl_attr_set;

// Type of an attribute.
enum cxxrtl_attr_type {
	// Attribute is not present.
	CXXRTL_ATTR_NONE = 0,

	// Attribute has an unsigned integer value.
	CXXRTL_ATTR_UNSIGNED_INT = 1,

	// Attribute has an unsigned integer value.
	CXXRTL_ATTR_SIGNED_INT = 2,

	// Attribute has a string value.
	CXXRTL_ATTR_STRING = 3,

	// Attribute has a double precision floating point value.
	CXXRTL_ATTR_DOUBLE = 4,

	// More attribute types may be defined in the future, but the existing values will never change.
};

// Determine the presence and type of an attribute in an attribute set.
//
// This function returns one of the possible \`cxxrtl_attr_type\` values.
int cxxrtl_attr_type(cxxrtl_attr_set attrs, const char *name);

// Retrieve an unsigned integer valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_UNSIGNED_INT\`.
// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.
uint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs, const char *name);

// Retrieve a signed integer valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_SIGNED_INT\`.
// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.
int64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs, const char *name);

// Retrieve a string valued attribute from an attribute set. The returned string is zero-terminated.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_STRING\`. If assertions
// are disabled, returns NULL if the attribute is missing or has an incorrect type.
const char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs, const char *name);

// Retrieve a double precision floating point valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_DOUBLE\`. If assertions
// are disabled, returns NULL if the attribute is missing or has an incorrect type.
double cxxrtl_attr_get_double(cxxrtl_attr_set attrs, const char *name);

#ifdef __cplusplus
}
#endif

#endif
`,"cxxrtl_capi_vcd.cc":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl/capi/cxxrtl_capi_vcd.h\`.

#include <cxxrtl/capi/cxxrtl_capi_vcd.h>
#include <cxxrtl/cxxrtl_vcd.h>

extern const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle);

struct _cxxrtl_vcd {
	cxxrtl::vcd_writer writer;
	bool flush = false;
};

cxxrtl_vcd cxxrtl_vcd_create() {
	return new _cxxrtl_vcd;
}

void cxxrtl_vcd_destroy(cxxrtl_vcd vcd) {
	delete vcd;
}

void cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit) {
	vcd->writer.timescale(number, unit);
}

void cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, cxxrtl_object *object) {
	// Note the copy. We don't know whether \`object\` came from a design (in which case it is
	// an instance of \`debug_item\`), or from user code (in which case it is an instance of
	// \`cxxrtl_object\`), so casting the pointer wouldn't be safe.
	vcd->writer.add(name, cxxrtl::debug_item(*object));
}

void cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle) {
	vcd->writer.add(cxxrtl_debug_items_from_handle(handle));
}

void cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,
														int (*filter)(void *data, const char *name,
														              const cxxrtl_object *object)) {
	vcd->writer.add(cxxrtl_debug_items_from_handle(handle),
		[=](const std::string &name, const cxxrtl::debug_item &item) {
			return filter(data, name.c_str(), static_cast<const cxxrtl_object*>(&item));
		});
}

void cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle) {
	vcd->writer.add_without_memories(cxxrtl_debug_items_from_handle(handle));
}

void cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time) {
	if (vcd->flush) {
		vcd->writer.buffer.clear();
		vcd->flush = false;
	}
	vcd->writer.sample(time);
}

void cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size) {
	if (vcd->flush) {
		vcd->writer.buffer.clear();
		vcd->flush = false;
	}
	*data = vcd->writer.buffer.c_str();
	*size = vcd->writer.buffer.size();
	vcd->flush = true;
}
`,"cxxrtl_capi_vcd.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_CAPI_VCD_H
#define CXXRTL_CAPI_VCD_H

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl_vcd_capi.cc\`.
//
// The CXXRTL C API for VCD writing makes it possible to insert virtual probes into designs and
// dump waveforms to Value Change Dump files.

#include <stddef.h>
#include <stdint.h>

#include <cxxrtl/capi/cxxrtl_capi.h>

#ifdef __cplusplus
extern "C" {
#endif

// Opaque reference to a VCD writer.
typedef struct _cxxrtl_vcd *cxxrtl_vcd;

// Create a VCD writer.
cxxrtl_vcd cxxrtl_vcd_create();

// Release all resources used by a VCD writer.
void cxxrtl_vcd_destroy(cxxrtl_vcd vcd);

// Set VCD timescale.
//
// The \`number\` must be 1, 10, or 100, and the \`unit\` must be one of \`"s"\`, \`"ms"\`, \`"us"\`, \`"ns"\`,
// \`"ps"\`, or \`"fs"\`.
//
// Timescale can only be set before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit);

// Schedule a specific CXXRTL object to be sampled.
//
// The \`name\` is a full hierarchical name as described for \`cxxrtl_get\`; it does not need to match
// the original name of \`object\`, if any. The \`object\` must outlive the VCD writer, but there are
// no other requirements; if desired, it can be provided by user code, rather than come from
// a design.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, struct cxxrtl_object *object);

// Schedule all CXXRTL objects in a simulation.
//
// The design \`handle\` must outlive the VCD writer.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle);

// Schedule CXXRTL objects in a simulation that match a given predicate.
//
// For every object in the simulation, \`filter\` is called with the provided \`data\`, the full
// hierarchical name of the object (see \`cxxrtl_get\` for details), and the object description.
// The object will be sampled if the predicate returns a non-zero value.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,
                            int (*filter)(void *data, const char *name,
                                          const struct cxxrtl_object *object));

// Schedule all CXXRTL objects in a simulation except for memories.
//
// The design \`handle\` must outlive the VCD writer.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle);

// Sample all scheduled objects.
//
// First, \`time\` is written to the internal buffer. Second, the values of every signal changed since
// the previous call to \`cxxrtl_vcd_sample\` (all values if this is the first call) are written to
// the internal buffer. The contents of the buffer can be retrieved with \`cxxrtl_vcd_read\`.
void cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time);

// Retrieve buffered VCD data.
//
// The pointer to the start of the next chunk of VCD data is assigned to \`*data\`, and the length
// of that chunk is assigned to \`*size\`. The pointer to the data is valid until the next call to
// \`cxxrtl_vcd_sample\` or \`cxxrtl_vcd_read\`. Once all of the buffered data has been retrieved,
// this function will always return zero sized chunks.
void cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size);

#ifdef __cplusplus
}
#endif

#endif
`},"cxxrtl.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2019-2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is included by the designs generated with \`write_cxxrtl\`. It is not used in Yosys itself.
//
// The CXXRTL support library implements compile time specialized arbitrary width arithmetics, as well as provides
// composite lvalues made out of bit slices and concatenations of lvalues. This allows the \`write_cxxrtl\` pass
// to perform a straightforward translation of RTLIL structures to readable C++, relying on the C++ compiler
// to unwrap the abstraction and generate efficient code.

#ifndef CXXRTL_H
#define CXXRTL_H

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cassert>
#include <limits>
#include <type_traits>
#include <tuple>
#include <vector>
#include <map>
#include <algorithm>
#include <memory>
#include <functional>
#include <sstream>
#include <iostream>

// \`cxxrtl::debug_item\` has to inherit from \`cxxrtl_object\` to satisfy strict aliasing requirements.
#include <cxxrtl/capi/cxxrtl_capi.h>

#ifndef __has_attribute
#	define __has_attribute(x) 0
#endif

// CXXRTL essentially uses the C++ compiler as a hygienic macro engine that feeds an instruction selector.
// It generates a lot of specialized template functions with relatively large bodies that, when inlined
// into the caller and (for those with loops) unrolled, often expose many new optimization opportunities.
// Because of this, most of the CXXRTL runtime must be always inlined for best performance.
#if __has_attribute(always_inline)
#define CXXRTL_ALWAYS_INLINE inline __attribute__((__always_inline__))
#else
#define CXXRTL_ALWAYS_INLINE inline
#endif
// Conversely, some functions in the generated code are extremely large yet very cold, with both of these
// properties being extreme enough to confuse C++ compilers into spending pathological amounts of time
// on a futile (the code becomes worse) attempt to optimize the least important parts of code.
#if __has_attribute(optnone)
#define CXXRTL_EXTREMELY_COLD __attribute__((__optnone__))
#elif __has_attribute(optimize)
#define CXXRTL_EXTREMELY_COLD __attribute__((__optimize__(0)))
#else
#define CXXRTL_EXTREMELY_COLD
#endif

// CXXRTL uses assert() to check for C++ contract violations (which may result in e.g. undefined behavior
// of the simulation code itself), and CXXRTL_ASSERT to check for RTL contract violations (which may at
// most result in undefined simulation results).
//
// Though by default, CXXRTL_ASSERT() expands to assert(), it may be overridden e.g. when integrating
// the simulation into another process that should survive violating RTL contracts.
#ifndef CXXRTL_ASSERT
#ifndef CXXRTL_NDEBUG
#define CXXRTL_ASSERT(x) assert(x)
#else
#define CXXRTL_ASSERT(x)
#endif
#endif

namespace cxxrtl {

// All arbitrary-width values in CXXRTL are backed by arrays of unsigned integers called chunks. The chunk size
// is the same regardless of the value width to simplify manipulating values via FFI interfaces, e.g. driving
// and introspecting the simulation in Python.
//
// It is practical to use chunk sizes between 32 bits and platform register size because when arithmetics on
// narrower integer types is legalized by the C++ compiler, it inserts code to clear the high bits of the register.
// However, (a) most of our operations do not change those bits in the first place because of invariants that are
// invisible to the compiler, (b) we often operate on non-power-of-2 values and have to clear the high bits anyway.
// Therefore, using relatively wide chunks and clearing the high bits explicitly and only when we know they may be
// clobbered results in simpler generated code.
typedef uint32_t chunk_t;
typedef uint64_t wide_chunk_t;

template<typename T>
struct chunk_traits {
	static_assert(std::is_integral<T>::value && std::is_unsigned<T>::value,
	              "chunk type must be an unsigned integral type");
	using type = T;
	static constexpr size_t bits = std::numeric_limits<T>::digits;
	static constexpr T mask = std::numeric_limits<T>::max();
};

template<class T>
struct expr_base;

template<size_t Bits>
struct value : public expr_base<value<Bits>> {
	static constexpr size_t bits = Bits;

	using chunk = chunk_traits<chunk_t>;
	static constexpr chunk::type msb_mask = (Bits % chunk::bits == 0) ? chunk::mask
		: chunk::mask >> (chunk::bits - (Bits % chunk::bits));

	static constexpr size_t chunks = (Bits + chunk::bits - 1) / chunk::bits;
	chunk::type data[chunks] = {};

	value() = default;
	template<typename... Init>
	explicit constexpr value(Init ...init) : data{init...} {}

	value(const value<Bits> &) = default;
	value<Bits> &operator=(const value<Bits> &) = default;

	value(value<Bits> &&) = default;
	value<Bits> &operator=(value<Bits> &&) = default;

	// A (no-op) helper that forces the cast to value<>.
	CXXRTL_ALWAYS_INLINE
	const value<Bits> &val() const {
		return *this;
	}

	std::string str() const {
		std::stringstream ss;
		ss << *this;
		return ss.str();
	}

	// Conversion operations.
	//
	// These functions ensure that a conversion is never out of range, and should be always used, if at all
	// possible, instead of direct manipulation of the \`data\` member. For very large types, .slice() and
	// .concat() can be used to split them into more manageable parts.
	template<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		static_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,
		              "get<T>() requires T to be an unsigned integral type");
		static_assert(std::numeric_limits<IntegerT>::digits >= Bits,
		              "get<T>() requires T to be at least as wide as the value is");
		IntegerT result = 0;
		for (size_t n = 0; n < chunks; n++)
			result |= IntegerT(data[n]) << (n * chunk::bits);
		return result;
	}

	template<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		auto unsigned_result = get<typename std::make_unsigned<IntegerT>::type>();
		IntegerT result;
		memcpy(&result, &unsigned_result, sizeof(IntegerT));
		return result;
	}

	template<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT value) {
		static_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,
		              "set<T>() requires T to be an unsigned integral type");
		static_assert(std::numeric_limits<IntegerT>::digits >= Bits,
		              "set<T>() requires the value to be at least as wide as T is");
		for (size_t n = 0; n < chunks; n++)
			data[n] = (value >> (n * chunk::bits)) & chunk::mask;
	}

	template<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT value) {
		typename std::make_unsigned<IntegerT>::type unsigned_value;
		memcpy(&unsigned_value, &value, sizeof(IntegerT));
		set(unsigned_value);
	}

	// Operations with compile-time parameters.
	//
	// These operations are used to implement slicing, concatenation, and blitting.
	// The trunc, zext and sext operations add or remove most significant bits (i.e. on the left);
	// the rtrunc and rzext operations add or remove least significant bits (i.e. on the right).
	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> trunc() const {
		static_assert(NewBits <= Bits, "trunc() may not increase width");
		value<NewBits> result;
		for (size_t n = 0; n < result.chunks; n++)
			result.data[n] = data[n];
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> zext() const {
		static_assert(NewBits >= Bits, "zext() may not decrease width");
		value<NewBits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n];
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> sext() const {
		static_assert(NewBits >= Bits, "sext() may not decrease width");
		value<NewBits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n];
		if (is_neg()) {
			result.data[chunks - 1] |= ~msb_mask;
			for (size_t n = chunks; n < result.chunks; n++)
				result.data[n] = chunk::mask;
			result.data[result.chunks - 1] &= result.msb_mask;
		}
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> rtrunc() const {
		static_assert(NewBits <= Bits, "rtrunc() may not increase width");
		value<NewBits> result;
		constexpr size_t shift_chunks = (Bits - NewBits) / chunk::bits;
		constexpr size_t shift_bits   = (Bits - NewBits) % chunk::bits;
		chunk::type carry = 0;
		if (shift_chunks + result.chunks < chunks) {
			carry = (shift_bits == 0) ? 0
				: data[shift_chunks + result.chunks] << (chunk::bits - shift_bits);
		}
		for (size_t n = result.chunks; n > 0; n--) {
			result.data[n - 1] = carry | (data[shift_chunks + n - 1] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[shift_chunks + n - 1] << (chunk::bits - shift_bits);
		}
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> rzext() const {
		static_assert(NewBits >= Bits, "rzext() may not decrease width");
		value<NewBits> result;
		constexpr size_t shift_chunks = (NewBits - Bits) / chunk::bits;
		constexpr size_t shift_bits   = (NewBits - Bits) % chunk::bits;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		if (shift_chunks + chunks < result.chunks)
			result.data[shift_chunks + chunks] = carry;
		return result;
	}

	// Bit blit operation, i.e. a partial read-modify-write.
	template<size_t Stop, size_t Start>
	CXXRTL_ALWAYS_INLINE
	value<Bits> blit(const value<Stop - Start + 1> &source) const {
		static_assert(Stop >= Start, "blit() may not reverse bit order");
		constexpr chunk::type start_mask = ~(chunk::mask << (Start % chunk::bits));
		constexpr chunk::type stop_mask = (Stop % chunk::bits + 1 == chunk::bits) ? 0
			: (chunk::mask << (Stop % chunk::bits + 1));
		value<Bits> masked = *this;
		if (Start / chunk::bits == Stop / chunk::bits) {
			masked.data[Start / chunk::bits] &= stop_mask | start_mask;
		} else {
			masked.data[Start / chunk::bits] &= start_mask;
			for (size_t n = Start / chunk::bits + 1; n < Stop / chunk::bits; n++)
				masked.data[n] = 0;
			masked.data[Stop / chunk::bits] &= stop_mask;
		}
		value<Bits> shifted = source
			.template rzext<Stop + 1>()
			.template zext<Bits>();
		return masked.bit_or(shifted);
	}

	// Helpers for selecting extending or truncating operation depending on whether the result is wider or narrower
	// than the operand. In C++17 these can be replaced with \`if constexpr\`.
	template<size_t NewBits, typename = void>
	struct zext_cast {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template zext<NewBits>();
		}
	};

	template<size_t NewBits>
	struct zext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template trunc<NewBits>();
		}
	};

	template<size_t NewBits, typename = void>
	struct sext_cast {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template sext<NewBits>();
		}
	};

	template<size_t NewBits>
	struct sext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template trunc<NewBits>();
		}
	};

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> zcast() const {
		return zext_cast<NewBits>()(*this);
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> scast() const {
		return sext_cast<NewBits>()(*this);
	}

	// Bit replication is far more efficient than the equivalent concatenation.
	template<size_t Count>
	CXXRTL_ALWAYS_INLINE
	value<Bits * Count> repeat() const {
		static_assert(Bits == 1, "repeat() is implemented only for 1-bit values");
		return *this ? value<Bits * Count>().bit_not() : value<Bits * Count>();
	}

	// Operations with run-time parameters (offsets, amounts, etc).
	//
	// These operations are used for computations.
	bool bit(size_t offset) const {
		return data[offset / chunk::bits] & (1 << (offset % chunk::bits));
	}

	void set_bit(size_t offset, bool value = true) {
		size_t offset_chunks = offset / chunk::bits;
		size_t offset_bits = offset % chunk::bits;
		data[offset_chunks] &= ~(1 << offset_bits);
		data[offset_chunks] |= value ? 1 << offset_bits : 0;
	}

	explicit operator bool() const {
		return !is_zero();
	}

	bool is_zero() const {
		for (size_t n = 0; n < chunks; n++)
			if (data[n] != 0)
				return false;
		return true;
	}

	bool is_neg() const {
		return data[chunks - 1] & (1 << ((Bits - 1) % chunk::bits));
	}

	bool operator ==(const value<Bits> &other) const {
		for (size_t n = 0; n < chunks; n++)
			if (data[n] != other.data[n])
				return false;
		return true;
	}

	bool operator !=(const value<Bits> &other) const {
		return !(*this == other);
	}

	value<Bits> bit_not() const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = ~data[n];
		result.data[chunks - 1] &= msb_mask;
		return result;
	}

	value<Bits> bit_and(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] & other.data[n];
		return result;
	}

	value<Bits> bit_or(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] | other.data[n];
		return result;
	}

	value<Bits> bit_xor(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] ^ other.data[n];
		return result;
	}

	value<Bits> update(const value<Bits> &val, const value<Bits> &mask) const {
		return bit_and(mask.bit_not()).bit_or(val.bit_and(mask));
	}

	template<size_t AmountBits>
	value<Bits> shl(const value<AmountBits> &amount) const {
		// Ensure our early return is correct by prohibiting values larger than 4 Gbit.
		static_assert(Bits <= chunk::mask, "shl() of unreasonably large values is not supported");
		// Detect shifts definitely large than Bits early.
		for (size_t n = 1; n < amount.chunks; n++)
			if (amount.data[n] != 0)
				return {};
		// Past this point we can use the least significant chunk as the shift size.
		size_t shift_chunks = amount.data[0] / chunk::bits;
		size_t shift_bits   = amount.data[0] % chunk::bits;
		if (shift_chunks >= chunks)
			return {};
		value<Bits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks - shift_chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	template<size_t AmountBits, bool Signed = false>
	value<Bits> shr(const value<AmountBits> &amount) const {
		// Ensure our early return is correct by prohibiting values larger than 4 Gbit.
		static_assert(Bits <= chunk::mask, "shr() of unreasonably large values is not supported");
		// Detect shifts definitely large than Bits early.
		for (size_t n = 1; n < amount.chunks; n++)
			if (amount.data[n] != 0)
				return (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();
		// Past this point we can use the least significant chunk as the shift size.
		size_t shift_chunks = amount.data[0] / chunk::bits;
		size_t shift_bits   = amount.data[0] % chunk::bits;
		if (shift_chunks >= chunks)
			return (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();
		value<Bits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks - shift_chunks; n++) {
			result.data[chunks - shift_chunks - 1 - n] = carry | (data[chunks - 1 - n] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[chunks - 1 - n] << (chunk::bits - shift_bits);
		}
		if (Signed && is_neg()) {
			size_t top_chunk_idx  = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) / chunk::bits;
			size_t top_chunk_bits = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) % chunk::bits;
			for (size_t n = top_chunk_idx + 1; n < chunks; n++)
				result.data[n] = chunk::mask;
			if (amount.data[0] != 0)
				result.data[top_chunk_idx] |= chunk::mask << top_chunk_bits;
			result.data[result.chunks - 1] &= result.msb_mask;
		}
		return result;
	}

	template<size_t AmountBits>
	value<Bits> sshr(const value<AmountBits> &amount) const {
		return shr<AmountBits, /*Signed=*/true>(amount);
	}

	template<size_t ResultBits, size_t SelBits>
	value<ResultBits> bmux(const value<SelBits> &sel) const {
		static_assert(ResultBits << SelBits == Bits, "invalid sizes used in bmux()");
		size_t amount = sel.data[0] * ResultBits;
		size_t shift_chunks = amount / chunk::bits;
		size_t shift_bits   = amount % chunk::bits;
		value<ResultBits> result;
		chunk::type carry = 0;
		if (ResultBits % chunk::bits + shift_bits > chunk::bits)
			carry = data[result.chunks + shift_chunks] << (chunk::bits - shift_bits);
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[result.chunks - 1 - n] = carry | (data[result.chunks + shift_chunks - 1 - n] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[result.chunks + shift_chunks - 1 - n] << (chunk::bits - shift_bits);
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	CXXRTL_ALWAYS_INLINE
	value<Bits> bwmux(const value<Bits> &b, const value<Bits> &s) const {
		return (bit_and(s.bit_not())).bit_or(b.bit_and(s));
	}

	template<size_t ResultBits, size_t SelBits>
	value<ResultBits> demux(const value<SelBits> &sel) const {
		static_assert(Bits << SelBits == ResultBits, "invalid sizes used in demux()");
		size_t amount = sel.data[0] * Bits;
		size_t shift_chunks = amount / chunk::bits;
		size_t shift_bits   = amount % chunk::bits;
		value<ResultBits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		if (Bits % chunk::bits + shift_bits > chunk::bits)
			result.data[shift_chunks + chunks] = carry;
		return result;
	}

	size_t ctpop() const {
		size_t count = 0;
		for (size_t n = 0; n < chunks; n++) {
			// This loop implements the population count idiom as recognized by LLVM and GCC.
			for (chunk::type x = data[n]; x != 0; count++)
				x = x & (x - 1);
		}
		return count;
	}

	size_t ctlz() const {
		size_t count = 0;
		for (size_t n = 0; n < chunks; n++) {
			chunk::type x = data[chunks - 1 - n];
			// First add to \`count\` as if the chunk is zero
			constexpr size_t msb_chunk_bits = Bits % chunk::bits != 0 ? Bits % chunk::bits : chunk::bits;
			count += (n == 0 ? msb_chunk_bits : chunk::bits);
			// If the chunk isn't zero, correct the \`count\` value and return
			if (x != 0) {
				for (; x != 0; count--)
					x >>= 1;
				break;
			}
		}
		return count;
	}

	template<bool Invert, bool CarryIn>
	std::pair<value<Bits>, bool /*CarryOut*/> alu(const value<Bits> &other) const {
		value<Bits> result;
		bool carry = CarryIn;
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[n] = data[n] + (Invert ? ~other.data[n] : other.data[n]) + carry;
			if (result.chunks - 1 == n)
				result.data[result.chunks - 1] &= result.msb_mask;
			carry = (result.data[n] <  data[n]) ||
			        (result.data[n] == data[n] && carry);
		}
		return {result, carry};
	}

	value<Bits> add(const value<Bits> &other) const {
		return alu</*Invert=*/false, /*CarryIn=*/false>(other).first;
	}

	value<Bits> sub(const value<Bits> &other) const {
		return alu</*Invert=*/true, /*CarryIn=*/true>(other).first;
	}

	value<Bits> neg() const {
		return value<Bits>().sub(*this);
	}

	bool ucmp(const value<Bits> &other) const {
		bool carry;
		std::tie(std::ignore, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);
		return !carry; // a.ucmp(b) \u2261 a u< b
	}

	bool scmp(const value<Bits> &other) const {
		value<Bits> result;
		bool carry;
		std::tie(result, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);
		bool overflow = (is_neg() == !other.is_neg()) && (is_neg() != result.is_neg());
		return result.is_neg() ^ overflow; // a.scmp(b) \u2261 a s< b
	}

	template<size_t ResultBits>
	value<ResultBits> mul(const value<Bits> &other) const {
		value<ResultBits> result;
		wide_chunk_t wide_result[result.chunks + 1] = {};
		for (size_t n = 0; n < chunks; n++) {
			for (size_t m = 0; m < chunks && n + m < result.chunks; m++) {
				wide_result[n + m] += wide_chunk_t(data[n]) * wide_chunk_t(other.data[m]);
				wide_result[n + m + 1] += wide_result[n + m] >> chunk::bits;
				wide_result[n + m] &= chunk::mask;
			}
		}
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[n] = wide_result[n];
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	std::pair<value<Bits>, value<Bits>> udivmod(value<Bits> divisor) const {
		value<Bits> quotient;
		value<Bits> dividend = *this;
		if (dividend.ucmp(divisor))
			return {/*quotient=*/value<Bits>{0u}, /*remainder=*/dividend};
		int64_t divisor_shift = divisor.ctlz() - dividend.ctlz();
		assert(divisor_shift >= 0);
		divisor = divisor.shl(value<Bits>{(chunk::type) divisor_shift});
		for (size_t step = 0; step <= divisor_shift; step++) {
			quotient = quotient.shl(value<Bits>{1u});
			if (!dividend.ucmp(divisor)) {
				dividend = dividend.sub(divisor);
				quotient.set_bit(0, true);
			}
			divisor = divisor.shr(value<Bits>{1u});
		}
		return {quotient, /*remainder=*/dividend};
	}

	std::pair<value<Bits>, value<Bits>> sdivmod(const value<Bits> &other) const {
		value<Bits + 1> quotient;
		value<Bits + 1> remainder;
		value<Bits + 1> dividend = sext<Bits + 1>();
		value<Bits + 1> divisor = other.template sext<Bits + 1>();
		if (is_neg()) dividend = dividend.neg();
		if (other.is_neg()) divisor = divisor.neg();
		std::tie(quotient, remainder) = dividend.udivmod(divisor);
		if (is_neg() != other.is_neg()) quotient = quotient.neg();
		if (is_neg()) remainder = remainder.neg();
		return {quotient.template trunc<Bits>(), remainder.template trunc<Bits>()};
	}
};

// Expression template for a slice, usable as lvalue or rvalue, and composable with other expression templates here.
template<class T, size_t Stop, size_t Start>
struct slice_expr : public expr_base<slice_expr<T, Stop, Start>> {
	static_assert(Stop >= Start, "slice_expr() may not reverse bit order");
	static_assert(Start < T::bits && Stop < T::bits, "slice_expr() must be within bounds");
	static constexpr size_t bits = Stop - Start + 1;

	T &expr;

	slice_expr(T &expr) : expr(expr) {}
	slice_expr(const slice_expr<T, Stop, Start> &) = delete;

	CXXRTL_ALWAYS_INLINE
	operator value<bits>() const {
		return static_cast<const value<T::bits> &>(expr)
			.template rtrunc<T::bits - Start>()
			.template trunc<bits>();
	}

	CXXRTL_ALWAYS_INLINE
	slice_expr<T, Stop, Start> &operator=(const value<bits> &rhs) {
		// Generic partial assignment implemented using a read-modify-write operation on the sliced expression.
		expr = static_cast<const value<T::bits> &>(expr)
			.template blit<Stop, Start>(rhs);
		return *this;
	}

	// A helper that forces the cast to value<>, which allows deduction to work.
	CXXRTL_ALWAYS_INLINE
	value<bits> val() const {
		return static_cast<const value<bits> &>(*this);
	}
};

// Expression template for a concatenation, usable as lvalue or rvalue, and composable with other expression templates here.
template<class T, class U>
struct concat_expr : public expr_base<concat_expr<T, U>> {
	static constexpr size_t bits = T::bits + U::bits;

	T &ms_expr;
	U &ls_expr;

	concat_expr(T &ms_expr, U &ls_expr) : ms_expr(ms_expr), ls_expr(ls_expr) {}
	concat_expr(const concat_expr<T, U> &) = delete;

	CXXRTL_ALWAYS_INLINE
	operator value<bits>() const {
		value<bits> ms_shifted = static_cast<const value<T::bits> &>(ms_expr)
			.template rzext<bits>();
		value<bits> ls_extended = static_cast<const value<U::bits> &>(ls_expr)
			.template zext<bits>();
		return ms_shifted.bit_or(ls_extended);
	}

	CXXRTL_ALWAYS_INLINE
	concat_expr<T, U> &operator=(const value<bits> &rhs) {
		ms_expr = rhs.template rtrunc<T::bits>();
		ls_expr = rhs.template trunc<U::bits>();
		return *this;
	}

	// A helper that forces the cast to value<>, which allows deduction to work.
	CXXRTL_ALWAYS_INLINE
	value<bits> val() const {
		return static_cast<const value<bits> &>(*this);
	}
};

// Base class for expression templates, providing helper methods for operations that are valid on both rvalues and lvalues.
//
// Note that expression objects (slices and concatenations) constructed in this way should NEVER be captured because
// they refer to temporaries that will, in general, only live until the end of the statement. For example, both of
// these snippets perform use-after-free:
//
//    const auto &a = val.slice<7,0>().slice<1>();
//    value<1> b = a;
//
//    auto &&c = val.slice<7,0>().slice<1>();
//    c = value<1>{1u};
//
// An easy way to write code using slices and concatenations safely is to follow two simple rules:
//   * Never explicitly name any type except \`value<W>\` or \`const value<W> &\`.
//   * Never use a \`const auto &\` or \`auto &&\` in any such expression.
// Then, any code that compiles will be well-defined.
template<class T>
struct expr_base {
	template<size_t Stop, size_t Start = Stop>
	CXXRTL_ALWAYS_INLINE
	slice_expr<const T, Stop, Start> slice() const {
		return {*static_cast<const T *>(this)};
	}

	template<size_t Stop, size_t Start = Stop>
	CXXRTL_ALWAYS_INLINE
	slice_expr<T, Stop, Start> slice() {
		return {*static_cast<T *>(this)};
	}

	template<class U>
	CXXRTL_ALWAYS_INLINE
	concat_expr<const T, typename std::remove_reference<const U>::type> concat(const U &other) const {
		return {*static_cast<const T *>(this), other};
	}

	template<class U>
	CXXRTL_ALWAYS_INLINE
	concat_expr<T, typename std::remove_reference<U>::type> concat(U &&other) {
		return {*static_cast<T *>(this), other};
	}
};

template<size_t Bits>
std::ostream &operator<<(std::ostream &os, const value<Bits> &val) {
	auto old_flags = os.flags(std::ios::right);
	auto old_width = os.width(0);
	auto old_fill  = os.fill('0');
	os << val.bits << '\\'' << std::hex;
	for (size_t n = val.chunks - 1; n != (size_t)-1; n--) {
		if (n == val.chunks - 1 && Bits % value<Bits>::chunk::bits != 0)
			os.width((Bits % value<Bits>::chunk::bits + 3) / 4);
		else
			os.width((value<Bits>::chunk::bits + 3) / 4);
		os << val.data[n];
	}
	os.fill(old_fill);
	os.width(old_width);
	os.flags(old_flags);
	return os;
}

template<size_t Bits>
struct wire {
	static constexpr size_t bits = Bits;

	value<Bits> curr;
	value<Bits> next;

	wire() = default;
	explicit constexpr wire(const value<Bits> &init) : curr(init), next(init) {}
	template<typename... Init>
	explicit constexpr wire(Init ...init) : curr{init...}, next{init...} {}

	// Copying and copy-assigning values is natural. If, however, a value is replaced with a wire,
	// e.g. because a module is built with a different optimization level, then existing code could
	// unintentionally copy a wire instead, which would create a subtle but serious bug. To make sure
	// this doesn't happen, prohibit copying and copy-assigning wires.
	wire(const wire<Bits> &) = delete;
	wire<Bits> &operator=(const wire<Bits> &) = delete;

	wire(wire<Bits> &&) = default;
	wire<Bits> &operator=(wire<Bits> &&) = default;

	template<class IntegerT>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		return curr.template get<IntegerT>();
	}

	template<class IntegerT>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT other) {
		next.template set<IntegerT>(other);
	}

	// This method intentionally takes a mandatory argument (to make it more difficult to misuse in
	// black box implementations, leading to missed observer events). It is generic over its argument
	// to allow the \`on_update\` method to be non-virtual.
	template<class ObserverT>
	bool commit(ObserverT &observer) {
		if (curr != next) {
			observer.on_update(curr.chunks, curr.data, next.data);
			curr = next;
			return true;
		}
		return false;
	}
};

template<size_t Bits>
std::ostream &operator<<(std::ostream &os, const wire<Bits> &val) {
	os << val.curr;
	return os;
}

template<size_t Width>
struct memory {
	const size_t depth;
	std::unique_ptr<value<Width>[]> data;

	explicit memory(size_t depth) : depth(depth), data(new value<Width>[depth]) {}

	memory(const memory<Width> &) = delete;
	memory<Width> &operator=(const memory<Width> &) = delete;

	memory(memory<Width> &&) = default;
	memory<Width> &operator=(memory<Width> &&other) {
		assert(depth == other.depth);
		data = std::move(other.data);
		write_queue = std::move(other.write_queue);
		return *this;
	}

	// An operator for direct memory reads. May be used at any time during the simulation.
	const value<Width> &operator [](size_t index) const {
		assert(index < depth);
		return data[index];
	}

	// An operator for direct memory writes. May only be used before the simulation is started. If used
	// after the simulation is started, the design may malfunction.
	value<Width> &operator [](size_t index) {
		assert(index < depth);
		return data[index];
	}

	// A simple way to make a writable memory would be to use an array of wires instead of an array of values.
	// However, there are two significant downsides to this approach: first, it has large overhead (2\xD7 space
	// overhead, and O(depth) time overhead during commit); second, it does not simplify handling write port
	// priorities. Although in principle write ports could be ordered or conditionally enabled in generated
	// code based on their priorities and selected addresses, the feedback arc set problem is computationally
	// expensive, and the heuristic based algorithms are not easily modified to guarantee (rather than prefer)
	// a particular write port evaluation order.
	//
	// The approach used here instead is to queue writes into a buffer during the eval phase, then perform
	// the writes during the commit phase in the priority order. This approach has low overhead, with both space
	// and time proportional to the amount of write ports. Because virtually every memory in a practical design
	// has at most two write ports, linear search is used on every write, being the fastest and simplest approach.
	struct write {
		size_t index;
		value<Width> val;
		value<Width> mask;
		int priority;
	};
	std::vector<write> write_queue;

	void update(size_t index, const value<Width> &val, const value<Width> &mask, int priority = 0) {
		assert(index < depth);
		// Queue up the write while keeping the queue sorted by priority.
		write_queue.insert(
			std::upper_bound(write_queue.begin(), write_queue.end(), priority,
				[](const int a, const write& b) { return a < b.priority; }),
			write { index, val, mask, priority });
	}

	// See the note for \`wire::commit()\`.
	template<class ObserverT>
	bool commit(ObserverT &observer) {
		bool changed = false;
		for (const write &entry : write_queue) {
			value<Width> elem = data[entry.index];
			elem = elem.update(entry.val, entry.mask);
			if (data[entry.index] != elem) {
				observer.on_update(value<Width>::chunks, data[0].data, elem.data, entry.index);
				changed |= true;
			}
			data[entry.index] = elem;
		}
		write_queue.clear();
		return changed;
	}
};

struct metadata {
	const enum {
		MISSING = 0,
		UINT   	= 1,
		SINT   	= 2,
		STRING 	= 3,
		DOUBLE 	= 4,
	} value_type;

	// In debug mode, using the wrong .as_*() function will assert.
	// In release mode, using the wrong .as_*() function will safely return a default value.
	const uint64_t    uint_value = 0;
	const int64_t     sint_value = 0;
	const std::string string_value = "";
	const double      double_value = 0.0;

	metadata() : value_type(MISSING) {}
	metadata(uint64_t value) : value_type(UINT), uint_value(value) {}
	metadata(int64_t value) : value_type(SINT), sint_value(value) {}
	metadata(const std::string &value) : value_type(STRING), string_value(value) {}
	metadata(const char *value) : value_type(STRING), string_value(value) {}
	metadata(double value) : value_type(DOUBLE), double_value(value) {}

	metadata(const metadata &) = default;
	metadata &operator=(const metadata &) = delete;

	uint64_t as_uint() const {
		assert(value_type == UINT);
		return uint_value;
	}

	int64_t as_sint() const {
		assert(value_type == SINT);
		return sint_value;
	}

	const std::string &as_string() const {
		assert(value_type == STRING);
		return string_value;
	}

	double as_double() const {
		assert(value_type == DOUBLE);
		return double_value;
	}

	// Internal CXXRTL use only.
	static std::map<std::string, metadata> deserialize(const char *ptr) {
		std::map<std::string, metadata> result;
		std::string name;
		// Grammar:
		// string   ::= [^\\0]+ \\0
		// metadata ::= [uid] .{8} | s <string>
		// map      ::= ( <string> <metadata> )* \\0
		for (;;) {
			if (*ptr) {
				name += *ptr++;
			} else if (!name.empty()) {
				ptr++;
				auto get_u64 = [&]() {
					uint64_t result = 0;
					for (size_t count = 0; count < 8; count++)
						result = (result << 8) | *ptr++;
					return result;
				};
				char type = *ptr++;
				if (type == 'u') {
					uint64_t value = get_u64();
					result.emplace(name, value);
				} else if (type == 'i') {
					int64_t value = (int64_t)get_u64();
					result.emplace(name, value);
				} else if (type == 'd') {
					double dvalue;
					uint64_t uvalue = get_u64();
					static_assert(sizeof(dvalue) == sizeof(uvalue), "double must be 64 bits in size");
					memcpy(&dvalue, &uvalue, sizeof(dvalue));
					result.emplace(name, dvalue);
				} else if (type == 's') {
					std::string value;
					while (*ptr)
						value += *ptr++;
					ptr++;
					result.emplace(name, value);
				} else {
					assert(false && "Unknown type specifier");
					return result;
				}
				name.clear();
			} else {
				return result;
			}
		}
	}
};

typedef std::map<std::string, metadata> metadata_map;

struct performer;

// An object that allows formatting a string lazily.
struct lazy_fmt {
	virtual std::string operator() () const = 0;
};

// Flavor of a \`$check\` cell.
enum class flavor {
	// Corresponds to a \`$assert\` cell in other flows, and a Verilog \`assert ()\` statement.
	ASSERT,
	// Corresponds to a \`$assume\` cell in other flows, and a Verilog \`assume ()\` statement.
	ASSUME,
	// Corresponds to a \`$live\` cell in other flows, and a Verilog \`assert (eventually)\` statement.
	ASSERT_EVENTUALLY,
	// Corresponds to a \`$fair\` cell in other flows, and a Verilog \`assume (eventually)\` statement.
	ASSUME_EVENTUALLY,
	// Corresponds to a \`$cover\` cell in other flows, and a Verilog \`cover ()\` statement.
	COVER,
};

// An object that can be passed to a \`eval()\` method in order to act on side effects. The default behavior implemented
// below is the same as the behavior of \`eval(nullptr)\`, except that \`-print-output\` option of \`write_cxxrtl\` is not
// taken into account.
struct performer {
	// Called by generated formatting code to evaluate a Verilog \`$time\` expression.
	virtual int64_t vlog_time() const { return 0; }

	// Called by generated formatting code to evaluate a Verilog \`$realtime\` expression.
	virtual double vlog_realtime() const { return vlog_time(); }

	// Called when a \`$print\` cell is triggered.
	virtual void on_print(const lazy_fmt &formatter, const metadata_map &attributes) {
		std::cout << formatter();
	}

	// Called when a \`$check\` cell is triggered.
	virtual void on_check(flavor type, bool condition, const lazy_fmt &formatter, const metadata_map &attributes) {
		if (type == flavor::ASSERT || type == flavor::ASSUME) {
			if (!condition)
				std::cerr << formatter();
			CXXRTL_ASSERT(condition && "Check failed");
		}
	}
};

// An object that can be passed to a \`commit()\` method in order to produce a replay log of every state change in
// the simulation. Unlike \`performer\`, \`observer\` does not use virtual calls as their overhead is unacceptable, and
// a comparatively heavyweight template-based solution is justified.
struct observer {
	// Called when the \`commit()\` method for a wire is about to update the \`chunks\` chunks at \`base\` with \`chunks\` chunks
	// at \`value\` that have a different bit pattern. It is guaranteed that \`chunks\` is equal to the wire chunk count and
	// \`base\` points to the first chunk.
	void on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {}

	// Called when the \`commit()\` method for a memory is about to update the \`chunks\` chunks at \`&base[chunks * index]\`
	// with \`chunks\` chunks at \`value\` that have a different bit pattern. It is guaranteed that \`chunks\` is equal to
	// the memory element chunk count and \`base\` points to the first chunk of the first element of the memory.
	void on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {}
};

// Must be kept in sync with \`struct FmtPart\` in kernel/fmt.h!
// Default member initializers would make this a non-aggregate-type in C++11, so they are commented out.
struct fmt_part {
	enum {
		LITERAL   = 0,
		INTEGER   = 1,
		STRING    = 2,
		UNICHAR   = 3,
		VLOG_TIME = 4,
	} type;

	// LITERAL type
	std::string str;

	// INTEGER/STRING/UNICHAR types
	// + value<Bits> val;

	// INTEGER/STRING/VLOG_TIME types
	enum {
		RIGHT	= 0,
		LEFT	= 1,
		NUMERIC	= 2,
	} justify; // = RIGHT;
	char padding; // = '\\0';
	size_t width; // = 0;

	// INTEGER type
	unsigned base; // = 10;
	bool signed_; // = false;
	enum {
		MINUS		= 0,
		PLUS_MINUS	= 1,
		SPACE_MINUS	= 2,
	} sign; // = MINUS;
	bool hex_upper; // = false;
	bool show_base; // = false;
	bool group; // = false;

	// VLOG_TIME type
	bool realtime; // = false;
	// + int64_t itime;
	// + double ftime;

	// Format the part as a string.
	//
	// The values of \`vlog_time\` and \`vlog_realtime\` are used for Verilog \`$time\` and \`$realtime\`, correspondingly.
	template<size_t Bits>
	std::string render(value<Bits> val, performer *performer = nullptr)
	{
		// We might want to replace some of these bit() calls with direct
		// chunk access if it turns out to be slow enough to matter.
		std::string buf;
		std::string prefix;
		switch (type) {
			case LITERAL:
				return str;

			case STRING: {
				buf.reserve(Bits/8);
				for (int i = 0; i < Bits; i += 8) {
					char ch = 0;
					for (int j = 0; j < 8 && i + j < int(Bits); j++)
						if (val.bit(i + j))
							ch |= 1 << j;
					if (ch != 0)
						buf.append({ch});
				}
				std::reverse(buf.begin(), buf.end());
				break;
			}

			case UNICHAR: {
				uint32_t codepoint = val.template zcast<32>().template get<uint32_t>();
				if (codepoint >= 0x10000)
					buf += (char)(0xf0 |  (codepoint >> 18));
				else if (codepoint >= 0x800)
					buf += (char)(0xe0 |  (codepoint >> 12));
				else if (codepoint >= 0x80)
					buf += (char)(0xc0 |  (codepoint >>  6));
				else
					buf += (char)codepoint;
				if (codepoint >= 0x10000)
					buf += (char)(0x80 | ((codepoint >> 12) & 0x3f));
				if (codepoint >= 0x800)
					buf += (char)(0x80 | ((codepoint >>  6) & 0x3f));
				if (codepoint >= 0x80)
					buf += (char)(0x80 | ((codepoint >>  0) & 0x3f));
				break;
			}

			case INTEGER: {
				bool negative = signed_ && val.is_neg();
				if (negative) {
					prefix = "-";
					val = val.neg();
				} else {
					switch (sign) {
						case MINUS:       break;
						case PLUS_MINUS:  prefix = "+"; break;
						case SPACE_MINUS: prefix = " "; break;
					}
				}

				size_t val_width = Bits;
				if (base != 10) {
					val_width = 1;
					for (size_t index = 0; index < Bits; index++)
						if (val.bit(index))
							val_width = index + 1;
				}

				if (base == 2) {
					if (show_base)
						prefix += "0b";
					for (size_t index = 0; index < val_width; index++) {
						if (group && index > 0 && index % 4 == 0)
							buf += '_';
						buf += (val.bit(index) ? '1' : '0');
					}
				} else if (base == 8 || base == 16) {
					if (show_base)
						prefix += (base == 16) ? (hex_upper ? "0X" : "0x") : "0o";
					size_t step = (base == 16) ? 4 : 3;
					for (size_t index = 0; index < val_width; index += step) {
						if (group && index > 0 && index % (4 * step) == 0)
							buf += '_';
						uint8_t value = val.bit(index) | (val.bit(index + 1) << 1) | (val.bit(index + 2) << 2);
						if (step == 4)
							value |= val.bit(index + 3) << 3;
						buf += (hex_upper ? "0123456789ABCDEF" : "0123456789abcdef")[value];
					}
				} else if (base == 10) {
					if (show_base)
						prefix += "0d";
					if (val.is_zero())
						buf += '0';
					value<(Bits > 4 ? Bits : 4)> xval = val.template zext<(Bits > 4 ? Bits : 4)>();
					size_t index = 0;
					while (!xval.is_zero()) {
						if (group && index > 0 && index % 3 == 0)
							buf += '_';
						value<(Bits > 4 ? Bits : 4)> quotient, remainder;
						if (Bits >= 4)
							std::tie(quotient, remainder) = xval.udivmod(value<(Bits > 4 ? Bits : 4)>{10u});
						else
							std::tie(quotient, remainder) = std::make_pair(value<(Bits > 4 ? Bits : 4)>{0u}, xval);
						buf += '0' + remainder.template trunc<4>().template get<uint8_t>();
						xval = quotient;
						index++;
					}
				} else assert(false && "Unsupported base for fmt_part");
				if (justify == NUMERIC && group && padding == '0') {
					int group_size = base == 10 ? 3 : 4;
					while (prefix.size() + buf.size() < width) {
						if (buf.size() % (group_size + 1) == group_size)
							buf += '_';
						buf += '0';
					}
				}
				std::reverse(buf.begin(), buf.end());
				break;
			}

			case VLOG_TIME: {
				if (performer) {
					buf = realtime ? std::to_string(performer->vlog_realtime()) : std::to_string(performer->vlog_time());
				} else {
					buf = realtime ? std::to_string(0.0) : std::to_string(0);
				}
				break;
			}
		}

		std::string str;
		assert(width == 0 || padding != '\\0');
		if (prefix.size() + buf.size() < width) {
			size_t pad_width = width - prefix.size() - buf.size();
			switch (justify) {
				case LEFT:
					str += prefix;
					str += buf;
					str += std::string(pad_width, padding);
					break;
				case RIGHT:
					str += std::string(pad_width, padding);
					str += prefix;
					str += buf;
					break;
				case NUMERIC:
					str += prefix;
					str += std::string(pad_width, padding);
					str += buf;
					break;
				}
		} else {
			str += prefix;
			str += buf;
		}
		return str;
	}
};

// Tag class to disambiguate values/wires and their aliases.
struct debug_alias {};

// Tag declaration to disambiguate values and debug outlines.
using debug_outline = ::_cxxrtl_outline;

// This structure is intended for consumption via foreign function interfaces, like Python's ctypes.
// Because of this it uses a C-style layout that is easy to parse rather than more idiomatic C++.
//
// To avoid violating strict aliasing rules, this structure has to be a subclass of the one used
// in the C API, or it would not be possible to cast between the pointers to these.
//
// The \`attrs\` member cannot be owned by this structure because a \`cxxrtl_object\` can be created
// from external C code.
struct debug_item : ::cxxrtl_object {
	// Object types.
	enum : uint32_t {
		VALUE   = CXXRTL_VALUE,
		WIRE    = CXXRTL_WIRE,
		MEMORY  = CXXRTL_MEMORY,
		ALIAS   = CXXRTL_ALIAS,
		OUTLINE = CXXRTL_OUTLINE,
	};

	// Object flags.
	enum : uint32_t {
		INPUT  = CXXRTL_INPUT,
		OUTPUT = CXXRTL_OUTPUT,
		INOUT  = CXXRTL_INOUT,
		DRIVEN_SYNC = CXXRTL_DRIVEN_SYNC,
		DRIVEN_COMB = CXXRTL_DRIVEN_COMB,
		UNDRIVEN    = CXXRTL_UNDRIVEN,
		GENERATED = CXXRTL_GENERATED,
	};

	debug_item(const ::cxxrtl_object &object) : cxxrtl_object(object) {}

	template<size_t Bits>
	debug_item(value<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = VALUE;
		flags   = flags_;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = item.data;
		next    = item.data;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = VALUE;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(wire<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {
		static_assert(Bits == 0 ||
		              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&
		               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),
		              "wire<Bits> is not compatible with C layout");
		type    = WIRE;
		flags   = flags_;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = item.curr.data;
		next    = item.next.data;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Width>
	debug_item(memory<Width> &item, size_t zero_offset = 0) {
		static_assert(Width == 0 || sizeof(item.data[0]) == value<Width>::chunks * sizeof(chunk_t),
		              "memory<Width> is not compatible with C layout");
		type    = MEMORY;
		flags   = 0;
		width   = Width;
		lsb_at  = 0;
		depth   = item.depth;
		zero_at = zero_offset;
		curr    = item.data ? item.data[0].data : nullptr;
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_alias, const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = ALIAS;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_alias, const wire<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 ||
		              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&
		               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),
		              "wire<Bits> is not compatible with C layout");
		type    = ALIAS;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.curr.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_outline &group, const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = OUTLINE;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = &group;
		attrs   = nullptr;
	}

	template<size_t Bits, class IntegerT>
	IntegerT get() const {
		assert(width == Bits && depth == 1);
		value<Bits> item;
		std::copy(curr, curr + value<Bits>::chunks, item.data);
		return item.template get<IntegerT>();
	}

	template<size_t Bits, class IntegerT>
	void set(IntegerT other) const {
		assert(width == Bits && depth == 1);
		value<Bits> item;
		item.template set<IntegerT>(other);
		std::copy(item.data, item.data + value<Bits>::chunks, next);
	}
};
static_assert(std::is_standard_layout<debug_item>::value, "debug_item is not compatible with C layout");

} // namespace cxxrtl

typedef struct _cxxrtl_attr_set {
	cxxrtl::metadata_map map;
} *cxxrtl_attr_set;

namespace cxxrtl {

// Representation of an attribute set in the C++ interface.
using debug_attrs = ::_cxxrtl_attr_set;

struct debug_items {
	// Debug items may be composed of multiple parts, but the attributes are shared between all of them.
	// There are additional invariants, not all of which are not checked by this code:
	// - Memories and non-memories cannot be mixed together.
	// - Bit indices (considering \`lsb_at\` and \`width\`) must not overlap.
	// - Row indices (considering \`depth\` and \`zero_at\`) must be the same.
	// - The \`INPUT\` and \`OUTPUT\` flags must be the same for all parts.
	// Other than that, the parts can be quite different, e.g. it is OK to mix a value, a wire, an alias,
	// and an outline, in the debug information for a single name in four parts.
	std::map<std::string, std::vector<debug_item>> table;
	std::map<std::string, std::unique_ptr<debug_attrs>> attrs_table;

	void add(const std::string &path, debug_item &&item, metadata_map &&item_attrs = {}) {
		assert((path.empty() || path[path.size() - 1] != ' ') && path.find("  ") == std::string::npos);
		std::unique_ptr<debug_attrs> &attrs = attrs_table[path];
		if (attrs.get() == nullptr)
			attrs = std::unique_ptr<debug_attrs>(new debug_attrs);
		for (auto attr : item_attrs)
			attrs->map.insert(attr);
		item.attrs = attrs.get();
		std::vector<debug_item> &parts = table[path];
		parts.emplace_back(item);
		std::sort(parts.begin(), parts.end(),
			[](const debug_item &a, const debug_item &b) {
				return a.lsb_at < b.lsb_at;
			});
	}

	// This overload exists to reduce excessive stack slot allocation in \`CXXRTL_EXTREMELY_COLD void debug_info()\`.
	template<class... T>
	void add(const std::string &base_path, const char *path, const char *serialized_item_attrs, T&&... args) {
		add(base_path + path, debug_item(std::forward<T>(args)...), metadata::deserialize(serialized_item_attrs));
	}

	size_t count(const std::string &path) const {
		if (table.count(path) == 0)
			return 0;
		return table.at(path).size();
	}

	const std::vector<debug_item> &at(const std::string &path) const {
		return table.at(path);
	}

	// Like \`at()\`, but operates only on single-part debug items.
	const debug_item &operator [](const std::string &path) const {
		const std::vector<debug_item> &parts = table.at(path);
		assert(parts.size() == 1);
		return parts.at(0);
	}

	bool is_memory(const std::string &path) const {
		return at(path).at(0).type == debug_item::MEMORY;
	}

	const metadata_map &attrs(const std::string &path) const {
		return attrs_table.at(path)->map;
	}
};

// Only \`module\` scopes are defined. The type is implicit, since Yosys does not currently support
// any other scope types.
struct debug_scope {
	std::string module_name;
	std::unique_ptr<debug_attrs> module_attrs;
	std::unique_ptr<debug_attrs> cell_attrs;
};

struct debug_scopes {
	std::map<std::string, debug_scope> table;

	void add(const std::string &path, const std::string &module_name, metadata_map &&module_attrs, metadata_map &&cell_attrs) {
		assert((path.empty() || path[path.size() - 1] != ' ') && path.find("  ") == std::string::npos);
		assert(table.count(path) == 0);
		debug_scope &scope = table[path];
		scope.module_name = module_name;
		scope.module_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { module_attrs });
		scope.cell_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { cell_attrs });
	}

	// This overload exists to reduce excessive stack slot allocation in \`CXXRTL_EXTREMELY_COLD void debug_info()\`.
	void add(const std::string &base_path, const char *path, const char *module_name, const char *serialized_module_attrs, const char *serialized_cell_attrs) {
		add(base_path + path, module_name, metadata::deserialize(serialized_module_attrs), metadata::deserialize(serialized_cell_attrs));
	}

	size_t contains(const std::string &path) const {
		return table.count(path);
	}

	const debug_scope &operator [](const std::string &path) const {
		return table.at(path);
	}
};

// Tag class to disambiguate the default constructor used by the toplevel module that calls \`reset()\`,
// and the constructor of interior modules that should not call it.
struct interior {};

// The core API of the \`module\` class consists of only four virtual methods: \`reset()\`, \`eval()\`,
// \`commit\`, and \`debug_info()\`. (The virtual destructor is made necessary by C++.) Every other method
// is a convenience method, and exists solely to simplify some common pattern for C++ API consumers.
// No behavior may be added to such convenience methods that other parts of CXXRTL can rely on, since
// there is no guarantee they will be called (and, for example, other CXXRTL libraries will often call
// the \`eval()\` and \`commit()\` directly instead, as well as being exposed in the C API).
struct module {
	module() {}
	virtual ~module() {}

	// Modules with black boxes cannot be copied. Although not all designs include black boxes,
	// delete the copy constructor and copy assignment operator to make sure that any downstream
	// code that manipulates modules doesn't accidentally depend on their availability.
	module(const module &) = delete;
	module &operator=(const module &) = delete;

	module(module &&) = default;
	module &operator=(module &&) = default;

	virtual void reset() = 0;

	// The \`eval()\` callback object, \`performer\`, is included in the virtual call signature since
	// the generated code has broadly identical performance properties.
	virtual bool eval(performer *performer = nullptr) = 0;

	// The \`commit()\` callback object, \`observer\`, is not included in the virtual call signature since
	// the generated code is severely pessimized by it. To observe commit events, the non-virtual
	// \`commit(observer *)\` overload must be called directly on a \`module\` subclass.
	virtual bool commit() = 0;

	size_t step(performer *performer = nullptr) {
		size_t deltas = 0;
		bool converged = false;
		do {
			converged = eval(performer);
			deltas++;
		} while (commit() && !converged);
		return deltas;
	}

	virtual void debug_info(debug_items *items, debug_scopes *scopes, std::string path, metadata_map &&cell_attrs = {}) {
		(void)items, (void)scopes, (void)path, (void)cell_attrs;
	}

	// Compatibility method.
#if __has_attribute(deprecated)
	__attribute__((deprecated("Use \`debug_info(&items, /*scopes=*/nullptr, path);\` instead.")))
#endif
	void debug_info(debug_items &items, std::string path) {
		debug_info(&items, /*scopes=*/nullptr, path);
	}
};

} // namespace cxxrtl

// Internal structures used to communicate with the implementation of the C interface.

typedef struct _cxxrtl_toplevel {
	std::unique_ptr<cxxrtl::module> module;
} *cxxrtl_toplevel;

typedef struct _cxxrtl_outline {
	std::function<void()> eval;
} *cxxrtl_outline;

// Definitions of internal Yosys cells. Other than the functions in this namespace, CXXRTL is fully generic
// and indepenent of Yosys implementation details.
//
// The \`write_cxxrtl\` pass translates internal cells (cells with names that start with \`$\`) to calls of these
// functions. All of Yosys arithmetic and logical cells perform sign or zero extension on their operands,
// whereas basic operations on arbitrary width values require operands to be of the same width. These functions
// bridge the gap by performing the necessary casts. They are named similar to \`cell_A[B]\`, where A and B are \`u\`
// if the corresponding operand is unsigned, and \`s\` if it is signed.
namespace cxxrtl_yosys {

using namespace cxxrtl;

// std::max isn't constexpr until C++14 for no particular reason (it's an oversight), so we define our own.
template<class T>
CXXRTL_ALWAYS_INLINE
constexpr T max(const T &a, const T &b) {
	return a > b ? a : b;
}

// Logic operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_not(const value<BitsA> &a) {
	return value<BitsY> { a ? 0u : 1u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_and(const value<BitsA> &a, const value<BitsB> &b) {
	return value<BitsY> { (bool(a) && bool(b)) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_or(const value<BitsA> &a, const value<BitsB> &b) {
	return value<BitsY> { (bool(a) || bool(b)) ? 1u : 0u };
}

// Reduction operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_and(const value<BitsA> &a) {
	return value<BitsY> { a.bit_not().is_zero() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_or(const value<BitsA> &a) {
	return value<BitsY> { a ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_xor(const value<BitsA> &a) {
	return value<BitsY> { (a.ctpop() % 2) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_xnor(const value<BitsA> &a) {
	return value<BitsY> { (a.ctpop() % 2) ? 0u : 1u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_bool(const value<BitsA> &a) {
	return value<BitsY> { a ? 1u : 0u };
}

// Bitwise operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> not_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>().bit_not();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> not_s(const value<BitsA> &a) {
	return a.template scast<BitsY>().bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> and_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_and(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> and_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_and(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> or_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_or(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> or_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_or(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_xor(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xnor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>()).bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xnor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_xor(b.template scast<BitsY>()).bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shl_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shl_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshl_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshl_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shr_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.shr(b).template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shr_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().shr(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshr_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.shr(b).template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshr_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.sshr(b).template scast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return shr_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_su(const value<BitsA> &a, const value<BitsB> &b) {
	return shr_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_us(const value<BitsA> &a, const value<BitsB> &b) {
	return b.is_neg() ? shl_uu<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return b.is_neg() ? shl_su<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_su(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_us(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_us<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_ss<BitsY>(a, b);
}

// Comparison operations
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eq_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template zext<BitsExt>() == b.template zext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eq_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template sext<BitsExt>() == b.template sext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ne_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template zext<BitsExt>() != b.template zext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ne_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template sext<BitsExt>() != b.template sext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eqx_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return eq_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eqx_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return eq_ss<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> nex_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return ne_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> nex_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return ne_ss<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> gt_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> gt_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ge_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ge_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> lt_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> lt_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> le_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> le_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };
}

// Arithmetic operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> pos_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> pos_s(const value<BitsA> &a) {
	return a.template scast<BitsY>();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> neg_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>().neg();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> neg_s(const value<BitsA> &a) {
	return a.template scast<BitsY>().neg();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> add_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().add(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> add_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().add(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sub_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().sub(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sub_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().sub(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mul_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsM = BitsA >= BitsB ? BitsA : BitsB;
	return a.template zcast<BitsM>().template mul<BitsY>(b.template zcast<BitsM>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mul_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().template mul<BitsY>(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
std::pair<value<BitsY>, value<BitsY>> divmod_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t Bits = max(BitsY, max(BitsA, BitsB));
	value<Bits> quotient;
	value<Bits> remainder;
	value<Bits> dividend = a.template zext<Bits>();
	value<Bits> divisor  = b.template trunc<BitsB>().template zext<Bits>();
	std::tie(quotient, remainder) = dividend.udivmod(divisor);
	return {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
std::pair<value<BitsY>, value<BitsY>> divmod_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t Bits = max(BitsY, max(BitsA, BitsB));
	value<Bits> quotient;
	value<Bits> remainder;
	value<Bits> dividend = a.template sext<Bits>();
	value<Bits> divisor = b.template sext<Bits>();
	std::tie(quotient, remainder) = dividend.sdivmod(divisor);
	return {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> div_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).first;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> div_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_ss<BitsY>(a, b).first;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mod_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).second;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mod_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_ss<BitsY>(a, b).second;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> modfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).second;
}

// GHDL Modfloor operator. Returns r=a mod b, such that r has the same sign as b and
// a=b*N+r where N is some integer
// In practical terms, when a and b have different signs and the remainder returned by divmod_ss is not 0
// then return the remainder + b
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> modfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	value<BitsY> r;
	r = divmod_ss<BitsY>(a, b).second;
	if((b.is_neg() != a.is_neg()) && !r.is_zero())
		return add_ss<BitsY>(b, r);
	return r;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> divfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).first;
}

// Divfloor. Similar to above: returns q=a//b, where q has the sign of a*b and a=b*q+N.
// In other words, returns (truncating) a/b, except if a and b have different signs
// and there's non-zero remainder, subtract one more towards floor.
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> divfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	value<BitsY> q, r;
	std::tie(q, r) = divmod_ss<BitsY>(a, b);
	if ((b.is_neg() != a.is_neg()) && !r.is_zero())
		return sub_uu<BitsY>(q, value<1> { 1u });
	return q;

}

// Memory helper
struct memory_index {
	bool valid;
	size_t index;

	template<size_t BitsAddr>
	memory_index(const value<BitsAddr> &addr, size_t offset, size_t depth) {
		static_assert(value<BitsAddr>::chunks <= 1, "memory address is too wide");
		size_t offset_index = addr.data[0];

		valid = (offset_index >= offset && offset_index < offset + depth);
		index = offset_index - offset;
	}
};

} // namespace cxxrtl_yosys

#endif
`,"cxxrtl_replay.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_REPLAY_H
#define CXXRTL_REPLAY_H

#if !defined(WIN32)
#include <unistd.h>
#define O_BINARY 0
#else
#include <io.h>
#endif

#include <fcntl.h>
#include <cstring>
#include <cstdio>
#include <atomic>
#include <unordered_map>

#include <cxxrtl/cxxrtl.h>
#include <cxxrtl/cxxrtl_time.h>

// Theory of operation
// ===================
//
// Log format
// ----------
//
// The replay log is a simple data format based on a sequence of 32-bit words. The following BNF-like grammar describes
// enough detail to understand the overall structure of the log data and be able to read hex dumps. For a greater
// degree of detail see the source code. The format is considered fully internal to CXXRTL and is subject to change
// without notice.
//
// <file>           ::= <file-header> <definitions> <sample>+
// <file-header>    ::= 0x52585843 0x00004c54
// <definitions>    ::= <packet-define>* <packet-end>
// <sample>         ::= <packet-sample> (<packet-change> | <packet-diag>)* <packet-end>
// <packet-define>  ::= 0xc0000000 ...
// <packet-sample>  ::= 0xc0000001 ...
// <packet-change>  ::= 0x0??????? <chunk>+ | 0x1??????? <index> <chunk>+ | 0x2??????? | 0x3???????
// <chunk>, <index> ::= 0x????????
// <packet-diag>    ::= <packet-break> | <packet-print> | <packet-assert> | <packet-assume>
// <packet-break>   ::= 0xc0000010 <message> <source-location>
// <packet-print>   ::= 0xc0000011 <message> <source-location>
// <packet-assert>  ::= 0xc0000012 <message> <source-location>
// <packet-assume>  ::= 0xc0000013 <message> <source-location>
// <packet-end>     ::= 0xFFFFFFFF
//
// The replay log contains sample data, however, it does not cover the entire design. Rather, it only contains sample
// data for the subset of debug items containing _design state_: inputs and registers/latches. This keeps its size to
// a minimum, and recording speed to a maximum. The player samples any missing data by setting the design state items
// to the same values they had during recording, and re-evaluating the design.
//
// Packets for diagnostics (prints, breakpoints, assertions, and assumptions) are used solely for diagnostics emitted
// by the C++ testbench driving the simulation, and are not recorded while evaluating the design. (Diagnostics emitted
// by the RTL can be reconstructed at replay time, so recording them would be a waste of space.)
//
// Limits
// ------
//
// The log may contain:
//
// * Up to 2**28-1 debug items containing design state.
// * Up to 2**32 chunks per debug item.
// * Up to 2**32 rows per memory.
// * Up to 2**32 samples.
//
// Of these limits, the last two are most likely to be eventually exceeded by practical recordings. However, other
// performance considerations will likely limit the size of such practical recordings first, so the log data format
// will undergo a breaking change at that point.
//
// Operations
// ----------
//
// As suggested by the name "replay log", this format is designed for recording (writing) once and playing (reading)
// many times afterwards, such that reading the format can be done linearly and quickly. The log format is designed to
// support three primary read operations:
//
// 1. Initialization
// 2. Rewinding (to time T)
// 3. Replaying (for N samples)
//
// During initialization, the player establishes the mapping between debug item names and their 28-bit identifiers in
// the log. It is done once.
//
// During rewinding, the player begins reading at the latest non-incremental sample that still lies before the requested
// sample time. It continues reading incremental samples after that point until it reaches the requested sample time.
// This process is very cheap as the design is not evaluated; it is essentially a (convoluted) memory copy operation.
//
// During replaying, the player evaluates the design at the current time, which causes all debug items to assume
// the values they had before recording. This process is expensive. Once done, the player advances to the next state
// by reading the next (complete or incremental) sample, as above. Since a range of samples is replayed, this process
// is repeated several times in a row.
//
// In principle, when replaying, the player could only read the state of the inputs and the time delta and use a normal
// eval/commit loop to progress the simulation, which is fully deterministic so its calculated design state should be
// exactly the same as the recorded design state. In practice, it is both faster and more reliable (in presence of e.g.
// user-defined black boxes) to read the recorded values instead of calculating them.
//
// Note: The operations described above are conceptual and do not correspond exactly to methods on \`cxxrtl::player\`.
// The \`cxxrtl::player::replay()\` method does not evaluate the design. This is so that delta cycles could be ignored
// if they are not of interest while replaying.

namespace cxxrtl {

// A single diagnostic that can be manipulated as an object (including being written to and read from a file).
// This differs from the base CXXRTL interface, where diagnostics can only be emitted via a procedure call, and are
// not materialized as objects.
struct diagnostic {
	// The \`BREAK\` flavor corresponds to a breakpoint, which is a diagnostic type that can currently only be emitted
	// by the C++ testbench code.
	enum flavor {
		BREAK  = 0,
		PRINT  = 1,
		ASSERT = 2,
		ASSUME = 3,
	};

	flavor type;
	std::string message;
	std::string location; // same format as the \`src\` attribute of \`$print\` or \`$check\` cell

	diagnostic()
	: type(BREAK) {}

	diagnostic(flavor type, const std::string &message, const std::string &location)
	: type(type), message(message), location(location) {}

	diagnostic(flavor type, const std::string &message, const char *file, unsigned line)
	: type(type), message(message), location(std::string(file) + ':' + std::to_string(line)) {}
};

// A spool stores CXXRTL design state changes in a file.
class spool {
public:
	// Unique pointer to a specific sample within a replay log. (Timestamps are not unique.)
	typedef uint32_t pointer_t;

	// Numeric identifier assigned to a debug item within a replay log. Range limited to [1, MAXIMUM_IDENT].
	typedef uint32_t ident_t;

	static constexpr uint16_t VERSION = 0x0400;

	static constexpr uint64_t HEADER_MAGIC = 0x00004c5452585843;
	static constexpr uint64_t VERSION_MASK = 0xffff000000000000;

	static constexpr uint32_t PACKET_DEFINE  = 0xc0000000;

	static constexpr uint32_t PACKET_SAMPLE  = 0xc0000001;
	enum sample_flag : uint32_t {
		EMPTY       = 0,
		INCREMENTAL = 1,
	};

	static constexpr uint32_t MAXIMUM_IDENT  = 0x0fffffff;
	static constexpr uint32_t CHANGE_MASK    = 0x30000000;

	static constexpr uint32_t PACKET_CHANGE  = 0x00000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEI = 0x10000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEL = 0x20000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEH = 0x30000000/* | ident */;

	static constexpr uint32_t PACKET_DIAGNOSTIC = 0xc0000010/* | diagnostic::flavor */;
	static constexpr uint32_t DIAGNOSTIC_MASK   = 0x0000000f;

	static constexpr uint32_t PACKET_END     = 0xffffffff;

	// Writing spools.

	class writer {
		int fd;
		size_t position;
		std::vector<uint32_t> buffer;

		// These functions aren't overloaded because of implicit numeric conversions.

		void emit_word(uint32_t word) {
			if (position + 1 == buffer.size())
				flush();
			buffer[position++] = word;
		}

		void emit_dword(uint64_t dword) {
			emit_word(dword >>  0);
			emit_word(dword >> 32);
		}

		void emit_ident(ident_t ident) {
			assert(ident <= MAXIMUM_IDENT);
			emit_word(ident);
		}

		void emit_size(size_t size) {
			assert(size <= std::numeric_limits<uint32_t>::max());
			emit_word(size);
		}

		// Same implementation as \`emit_size()\`, different declared intent.
		void emit_index(size_t index) {
			assert(index <= std::numeric_limits<uint32_t>::max());
			emit_word(index);
		}

		void emit_string(std::string str) {
			// Align to a word boundary, and add at least one terminating \\0.
			str.resize(str.size() + (sizeof(uint32_t) - (str.size() + sizeof(uint32_t)) % sizeof(uint32_t)));
			for (size_t index = 0; index < str.size(); index += sizeof(uint32_t)) {
				uint32_t word;
				memcpy(&word, &str[index], sizeof(uint32_t));
				emit_word(word);
			}
		}

		void emit_time(const time &timestamp) {
			const value<time::bits> &raw_timestamp(timestamp);
			emit_word(raw_timestamp.data[0]);
			emit_word(raw_timestamp.data[1]);
			emit_word(raw_timestamp.data[2]);
		}

	public:
		// Creates a writer, and transfers ownership of \`fd\`, which must be open for appending.
		//
		// The buffer size is currently fixed to a "reasonably large" size, determined empirically by measuring writer
		// performance on a representative design; large but not so large it would e.g. cause address space exhaustion
		// on 32-bit platforms.
		writer(spool &spool) : fd(spool.take_write()), position(0), buffer(32 * 1024 * 1024) {
			assert(fd != -1);
#if !defined(WIN32)
			int result = ftruncate(fd, 0);
#else
			int result = _chsize_s(fd, 0);
#endif
			assert(result == 0);
		}

		writer(writer &&moved) : fd(moved.fd), position(moved.position), buffer(moved.buffer) {
			moved.fd = -1;
			moved.position = 0;
		}

		writer(const writer &) = delete;
		writer &operator=(const writer &) = delete;

		// Both write() calls and fwrite() calls are too expensive to perform implicitly. The API consumer must determine
		// the optimal time to flush the writer and do that explicitly for best performance.
		void flush() {
			assert(fd != -1);
			size_t data_size = position * sizeof(uint32_t);
			size_t data_written = write(fd, buffer.data(), data_size);
			assert(data_size == data_written);
			position = 0;
		}

		~writer() {
			if (fd != -1) {
				flush();
				close(fd);
			}
		}

		void write_magic() {
			// \`CXXRTL\` followed by version in binary. This header will read backwards on big-endian machines, which allows
			// detection of this case, both visually and programmatically.
			emit_dword(((uint64_t)VERSION << 48) | HEADER_MAGIC);
		}

		void write_define(ident_t ident, const std::string &name, size_t part_index, size_t chunks, size_t depth) {
			emit_word(PACKET_DEFINE);
			emit_ident(ident);
			emit_string(name);
			emit_index(part_index);
			emit_size(chunks);
			emit_size(depth);
		}

		void write_sample(bool incremental, pointer_t pointer, const time &timestamp) {
			uint32_t flags = (incremental ? sample_flag::INCREMENTAL : 0);
			emit_word(PACKET_SAMPLE);
			emit_word(flags);
			emit_word(pointer);
			emit_time(timestamp);
		}

		void write_change(ident_t ident, size_t chunks, const chunk_t *data) {
			assert(ident <= MAXIMUM_IDENT);

			if (chunks == 1 && *data == 0) {
				emit_word(PACKET_CHANGEL | ident);
			} else if (chunks == 1 && *data == 1) {
				emit_word(PACKET_CHANGEH | ident);
			} else {
				emit_word(PACKET_CHANGE | ident);
				for (size_t offset = 0; offset < chunks; offset++)
					emit_word(data[offset]);
			}
		}

		void write_change(ident_t ident, size_t chunks, const chunk_t *data, size_t index) {
			assert(ident <= MAXIMUM_IDENT);

			emit_word(PACKET_CHANGEI | ident);
			emit_index(index);
			for (size_t offset = 0; offset < chunks; offset++)
				emit_word(data[offset]);
		}

		void write_diagnostic(const diagnostic &diagnostic) {
			emit_word(PACKET_DIAGNOSTIC | diagnostic.type);
			emit_string(diagnostic.message);
			emit_string(diagnostic.location);
		}

		void write_end() {
			emit_word(PACKET_END);
		}
	};

	// Reading spools.

	class reader {
		FILE *f;

		uint32_t absorb_word() {
			// If we're at end of file, \`fread\` will not write to \`word\`, and \`PACKET_END\` will be returned.
			uint32_t word = PACKET_END;
			fread(&word, sizeof(word), 1, f);
			return word;
		}

		uint64_t absorb_dword() {
			uint32_t lo = absorb_word();
			uint32_t hi = absorb_word();
			return ((uint64_t)hi << 32) | lo;
		}

		ident_t absorb_ident() {
			ident_t ident = absorb_word();
			assert(ident <= MAXIMUM_IDENT);
			return ident;
		}

		size_t absorb_size() {
			return absorb_word();
		}

		size_t absorb_index() {
			return absorb_word();
		}

		std::string absorb_string() {
			std::string str;
			do {
				size_t end = str.size();
				str.resize(end + 4);
				uint32_t word = absorb_word();
				memcpy(&str[end], &word, sizeof(uint32_t));
			} while (str.back() != '\\0');
			// Strings have no embedded zeroes besides the terminating one(s).
			return str.substr(0, str.find('\\0'));
		}

		time absorb_time() {
			value<time::bits> raw_timestamp;
			raw_timestamp.data[0] = absorb_word();
			raw_timestamp.data[1] = absorb_word();
			raw_timestamp.data[2] = absorb_word();
			return time(raw_timestamp);
		}

	public:
		typedef uint64_t pos_t;

		// Creates a reader, and transfers ownership of \`fd\`, which must be open for reading.
		reader(spool &spool) : f(fdopen(spool.take_read(), "r")) {
			assert(f != nullptr);
		}

		reader(reader &&moved) : f(moved.f) {
			moved.f = nullptr;
		}

		reader(const reader &) = delete;
		reader &operator=(const reader &) = delete;

		~reader() {
			if (f != nullptr)
				fclose(f);
		}

		pos_t position() {
			return ftell(f);
		}

		void rewind(pos_t position) {
			fseek(f, position, SEEK_SET);
		}

		void read_magic() {
			uint64_t magic = absorb_dword();
			assert((magic & ~VERSION_MASK) == HEADER_MAGIC);
			assert((magic >> 48) == VERSION);
		}

		bool read_define(ident_t &ident, std::string &name, size_t &part_index, size_t &chunks, size_t &depth) {
			uint32_t header = absorb_word();
			if (header == PACKET_END)
				return false;
			assert(header == PACKET_DEFINE);
			ident = absorb_ident();
			name = absorb_string();
			part_index = absorb_index();
			chunks = absorb_size();
			depth = absorb_size();
			return true;
		}

		bool read_sample(bool &incremental, pointer_t &pointer, time &timestamp) {
			uint32_t header = absorb_word();
			if (header == PACKET_END)
				return false;
			assert(header == PACKET_SAMPLE);
			uint32_t flags = absorb_word();
			incremental = (flags & sample_flag::INCREMENTAL);
			pointer = absorb_word();
			timestamp = absorb_time();
			return true;
		}

		bool read_header(uint32_t &header) {
			header = absorb_word();
			return header != PACKET_END;
		}

		// This method must be separate from \`read_change_data\` because \`chunks\` and \`depth\` can only be looked up
		// if \`ident\` is known.
		bool read_change_ident(uint32_t header, ident_t &ident) {
			if ((header & ~(CHANGE_MASK | MAXIMUM_IDENT)) != 0)
				return false; // some other packet
			ident = header & MAXIMUM_IDENT;
			return true;
		}

		void read_change_data(uint32_t header, size_t chunks, size_t depth, chunk_t *data) {
			uint32_t index = 0;
			switch (header & CHANGE_MASK) {
				case PACKET_CHANGEL:
					*data = 0;
					return;
				case PACKET_CHANGEH:
					*data = 1;
					return;
				case PACKET_CHANGE:
					break;
				case PACKET_CHANGEI:
					index = absorb_word();
					assert(index < depth);
					break;
				default:
					assert(false && "Unrecognized change packet");
			}
			for (size_t offset = 0; offset < chunks; offset++)
				data[chunks * index + offset] = absorb_word();
		}

		bool read_diagnostic(uint32_t header, diagnostic &diagnostic) {
			if ((header & ~DIAGNOSTIC_MASK) != PACKET_DIAGNOSTIC)
				return false; // some other packet
			uint32_t type = header & DIAGNOSTIC_MASK;
			assert(type == diagnostic::BREAK  || type == diagnostic::PRINT ||
			       type == diagnostic::ASSERT || type == diagnostic::ASSUME);
			diagnostic.type = (diagnostic::flavor)type;
			diagnostic.message = absorb_string();
			diagnostic.location = absorb_string();
			return true;
		}
	};

	// Opening spools. For certain uses of the record/replay mechanism, two distinct open files (two open files, i.e.
	// two distinct file pointers, and not just file descriptors, which share the file pointer if duplicated) are used,
	// for a reader and writer thread. This class manages the lifetime of the descriptors for these files. When only
	// one of them is used, the other is closed harmlessly when the spool is destroyed.
private:
	std::atomic<int> writefd;
	std::atomic<int> readfd;

public:
	spool(const std::string &filename)
		: writefd(open(filename.c_str(), O_CREAT|O_BINARY|O_WRONLY|O_APPEND, 0644)),
		  readfd(open(filename.c_str(), O_BINARY|O_RDONLY)) {
		assert(writefd.load() != -1 && readfd.load() != -1);
	}

	spool(spool &&moved) : writefd(moved.writefd.exchange(-1)), readfd(moved.readfd.exchange(-1)) {}

	spool(const spool &) = delete;
	spool &operator=(const spool &) = delete;

	~spool() {
		int fd;
		if ((fd = writefd.exchange(-1)) != -1)
			close(fd);
		if ((fd = readfd.exchange(-1)) != -1)
			close(fd);
	}

	// Atomically acquire a write file descriptor for the spool. Can be called once, and will return -1 the next time
	// it is called. Thread-safe.
	int take_write() {
		return writefd.exchange(-1);
	}

	// Atomically acquire a read file descriptor for the spool. Can be called once, and will return -1 the next time
	// it is called. Thread-safe.
	int take_read() {
		return readfd.exchange(-1);
	}
};

// A CXXRTL recorder samples design state, producing complete or incremental updates, and writes them to a spool.
class recorder {
	struct variable {
		spool::ident_t ident; /* <= spool::MAXIMUM_IDENT */
		size_t chunks;
		size_t depth; /* == 1 for wires */
		chunk_t *curr;
		bool memory;
	};

	spool::writer writer;
	std::vector<variable> variables;
	std::vector<size_t> inputs; // values of inputs must be recorded explicitly, as their changes are not observed
	std::unordered_map<const chunk_t*, spool::ident_t> ident_lookup;
	bool streaming = false; // whether variable definitions have been written
	spool::pointer_t pointer = 0;
	time timestamp;

public:
	template<typename ...Args>
	recorder(Args &&...args) : writer(std::forward<Args>(args)...) {}

	void start(module &module, std::string top_path = "") {
		debug_items items;
		module.debug_info(&items, /*scopes=*/nullptr, top_path);
		start(items);
	}

	void start(const debug_items &items) {
		assert(!streaming);

		writer.write_magic();
		for (auto item : items.table)
			for (size_t part_index = 0; part_index < item.second.size(); part_index++) {
				auto &part = item.second[part_index];
				if ((part.flags & debug_item::INPUT) || (part.flags & debug_item::DRIVEN_SYNC) ||
						(part.type == debug_item::MEMORY)) {
					variable var;
					var.ident = variables.size() + 1;
					var.chunks = (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8);
					var.depth = part.depth;
					var.curr = part.curr;
					var.memory = (part.type == debug_item::MEMORY);
					ident_lookup[var.curr] = var.ident;

					assert(variables.size() < spool::MAXIMUM_IDENT);
					if (part.flags & debug_item::INPUT)
						inputs.push_back(variables.size());
					variables.push_back(var);

					writer.write_define(var.ident, item.first, part_index, var.chunks, var.depth);
				}
			}
		writer.write_end();
		streaming = true;
	}

	const time &latest_time() {
		return timestamp;
	}

	const time &advance_time(const time &delta) {
		assert(!delta.is_negative());
		timestamp += delta;
		return timestamp;
	}

	void record_complete() {
		assert(streaming);

		writer.write_sample(/*incremental=*/false, pointer++, timestamp);
		for (auto var : variables) {
			assert(var.ident != 0);
			if (!var.memory)
				writer.write_change(var.ident, var.chunks, var.curr);
			else
				for (size_t index = 0; index < var.depth; index++)
					writer.write_change(var.ident, var.chunks, &var.curr[var.chunks * index], index);
		}
		writer.write_end();
	}

	// This function is generic over ModuleT to encourage observer callbacks to be inlined into the commit function.
	template<class ModuleT>
	bool record_incremental(ModuleT &module) {
		assert(streaming);

		struct : observer {
			std::unordered_map<const chunk_t*, spool::ident_t> *ident_lookup;
			spool::writer *writer;

			CXXRTL_ALWAYS_INLINE
			void on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {
				writer->write_change(ident_lookup->at(base), chunks, value);
			}

			CXXRTL_ALWAYS_INLINE
			void on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {
				writer->write_change(ident_lookup->at(base), chunks, value, index);
			}
		} record_observer;
		record_observer.ident_lookup = &ident_lookup;
		record_observer.writer = &writer;

		writer.write_sample(/*incremental=*/true, pointer++, timestamp);
		for (auto input_index : inputs) {
			variable &var = variables.at(input_index);
			assert(!var.memory);
			writer.write_change(var.ident, var.chunks, var.curr);
		}
		bool changed = module.commit(record_observer);
		writer.write_end();
		return changed;
	}

	void record_diagnostic(const diagnostic &diagnostic) {
		assert(streaming);

		// Emit an incremental delta cycle per diagnostic to simplify the logic of the recorder. This is inefficient, but
		// diagnostics should be rare enough that this inefficiency does not matter. If it turns out to be an issue, this
		// code should be changed to accumulate diagnostics to a buffer that is flushed in \`record_{complete,incremental}\`
		// and also in \`advance_time\` before the timestamp is changed. (Right now \`advance_time\` never writes to the spool.)
		writer.write_sample(/*incremental=*/true, pointer++, timestamp);
		writer.write_diagnostic(diagnostic);
		writer.write_end();
	}

	void flush() {
		writer.flush();
	}
};

// A CXXRTL player reads samples from a spool, and changes the design state accordingly. To start reading samples,
// a spool must have been initialized: the recorder must have been started and an initial complete sample must have
// been written.
class player {
	struct variable {
		size_t chunks;
		size_t depth; /* == 1 for wires */
		chunk_t *curr;
	};

	spool::reader reader;
	std::unordered_map<spool::ident_t, variable> variables;
	bool streaming = false; // whether variable definitions have been read
	bool initialized = false; // whether a sample has ever been read
	spool::pointer_t pointer = 0;
	time timestamp;

	std::map<spool::pointer_t, spool::reader::pos_t, std::greater<spool::pointer_t>> index_by_pointer;
	std::map<time, spool::reader::pos_t, std::greater<time>> index_by_timestamp;

	bool peek_sample(spool::pointer_t &pointer, time &timestamp) {
		bool incremental;
		auto position = reader.position();
		bool success = reader.read_sample(incremental, pointer, timestamp);
		reader.rewind(position);
		return success;
	}

public:
	template<typename ...Args>
	player(Args &&...args) : reader(std::forward<Args>(args)...) {}

	// The \`top_path\` must match the one given to the recorder.
	void start(module &module, std::string top_path = "") {
		debug_items items;
		module.debug_info(&items, /*scopes=*/nullptr, top_path);
		start(items);
	}

	void start(const debug_items &items) {
		assert(!streaming);

		reader.read_magic();
		while (true) {
			spool::ident_t ident;
			std::string name;
			size_t part_index;
			size_t chunks;
			size_t depth;
			if (!reader.read_define(ident, name, part_index, chunks, depth))
				break;
			assert(variables.count(ident) == 0);
			assert(items.count(name) != 0);
			assert(part_index < items.count(name));

			const debug_item &part = items.at(name).at(part_index);
			assert(chunks == (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8));
			assert(depth == part.depth);

			variable &var = variables[ident];
			var.chunks = chunks;
			var.depth = depth;
			var.curr = part.curr;
		}
		assert(variables.size() > 0);
		streaming = true;

		// Establish the initial state of the design.
		std::vector<diagnostic> diagnostics;
		initialized = replay(&diagnostics);
		assert(initialized && diagnostics.empty());
	}

	// Returns the pointer of the current sample.
	spool::pointer_t current_pointer() {
		assert(initialized);
		return pointer;
	}

	// Returns the time of the current sample.
	const time &current_time() {
		assert(initialized);
		return timestamp;
	}

	// Returns \`true\` if there is a next sample to read, and sets \`pointer\` to its pointer if there is.
	bool get_next_pointer(spool::pointer_t &pointer) {
		assert(streaming);
		time timestamp;
		return peek_sample(pointer, timestamp);
	}

	// Returns \`true\` if there is a next sample to read, and sets \`timestamp\` to its time if there is.
	bool get_next_time(time &timestamp) {
		assert(streaming);
		uint32_t pointer;
		return peek_sample(pointer, timestamp);
	}

	// If this function returns \`true\`, then \`current_pointer() == at_pointer\`, and the module contains values that
	// correspond to this pointer in the replay log. To obtain a valid pointer, call \`current_pointer()\`; while pointers
	// are monotonically increasing for each consecutive sample, using arithmetic operations to create a new pointer is
	// not allowed. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in this sample.
	bool rewind_to(spool::pointer_t at_pointer, std::vector<diagnostic> *diagnostics) {
		assert(initialized);

		// The pointers in the replay log start from one that is greater than \`at_pointer\`. In this case the pointer will
		// never be reached.
		assert(index_by_pointer.size() > 0);
		if (at_pointer < index_by_pointer.rbegin()->first)
			return false;

		// Find the last complete sample whose pointer is less than or equal to \`at_pointer\`. Note that the comparison
		// function used here is \`std::greater\`, inverting the direction of \`lower_bound\`.
		auto position_it = index_by_pointer.lower_bound(at_pointer);
		assert(position_it != index_by_pointer.end());
		reader.rewind(position_it->second);

		// Replay samples until eventually arriving to \`at_pointer\` or encountering end of file.
		while(replay(diagnostics)) {
			if (pointer == at_pointer)
				return true;

			if (diagnostics)
				diagnostics->clear();
		}
		return false;
	}

	// If this function returns \`true\`, then \`current_time() <= at_or_before_timestamp\`, and the module contains values
	// that correspond to \`current_time()\` in the replay log. If \`current_time() == at_or_before_timestamp\` and there
	// are several consecutive samples with the same time, the module contains values that correspond to the first of
	// these samples. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in this sample.
	bool rewind_to_or_before(const time &at_or_before_timestamp, std::vector<diagnostic> *diagnostics) {
		assert(initialized);

		// The timestamps in the replay log start from one that is greater than \`at_or_before_timestamp\`. In this case
		// the timestamp will never be reached. Otherwise, this function will always succeed.
		assert(index_by_timestamp.size() > 0);
		if (at_or_before_timestamp < index_by_timestamp.rbegin()->first)
			return false;

		// Find the last complete sample whose timestamp is less than or equal to \`at_or_before_timestamp\`. Note that
		// the comparison function used here is \`std::greater\`, inverting the direction of \`lower_bound\`.
		auto position_it = index_by_timestamp.lower_bound(at_or_before_timestamp);
		assert(position_it != index_by_timestamp.end());
		reader.rewind(position_it->second);

		// Replay samples until eventually arriving to or past \`at_or_before_timestamp\` or encountering end of file.
		while (replay(diagnostics)) {
			if (timestamp == at_or_before_timestamp)
				break;

			time next_timestamp;
			if (!get_next_time(next_timestamp))
				break;
			if (next_timestamp > at_or_before_timestamp)
				break;

			if (diagnostics)
				diagnostics->clear();
		}
		return true;
	}

	// If this function returns \`true\`, then \`current_pointer()\` and \`current_time()\` are updated for the next sample
	// and the module now contains values that correspond to that sample. If it returns \`false\`, there was no next sample
	// to read. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in the next sample.
	bool replay(std::vector<diagnostic> *diagnostics) {
		assert(streaming);

		bool incremental;
		auto position = reader.position();
		if (!reader.read_sample(incremental, pointer, timestamp))
			return false;

		// The very first sample that is read must be a complete sample. This is required for the rewind functions to work.
		assert(initialized || !incremental);

		// It is possible (though not very useful) to have several complete samples with the same timestamp in a row.
		// Ensure that we associate the timestamp with the position of the first such complete sample. (This condition
		// works because the player never jumps over a sample.)
		if (!incremental && !index_by_pointer.count(pointer)) {
			assert(!index_by_timestamp.count(timestamp));
			index_by_pointer[pointer] = position;
			index_by_timestamp[timestamp] = position;
		}

		uint32_t header;
		while (reader.read_header(header)) {
			spool::ident_t ident;
			diagnostic diag;
			if (reader.read_change_ident(header, ident)) {
				variable &var = variables.at(ident);
				reader.read_change_data(header, var.chunks, var.depth, var.curr);
			} else if (reader.read_diagnostic(header, diag)) {
				if (diagnostics)
					diagnostics->push_back(diag);
			} else assert(false && "Unrecognized packet header");
		}
		return true;
	}
};

}

#endif
`,"cxxrtl_time.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_TIME_H
#define CXXRTL_TIME_H

#include <cinttypes>
#include <string>

#include <cxxrtl/cxxrtl.h>

namespace cxxrtl {

// A timestamp or a difference in time, stored as a 96-bit number of femtoseconds (10e-15 s). The range and resolution
// of this format can represent any VCD timestamp within approx. \xB11255321.2 years, without the need for a timescale.
class time {
public:
	static constexpr size_t bits = 96; // 3 chunks

private:
	static constexpr size_t resolution_digits = 15;

	static_assert(sizeof(chunk_t) == 4, "a chunk is expected to be 32-bit");
	static constexpr value<bits> resolution = value<bits> {
		chunk_t(1000000000000000ull & 0xffffffffull), chunk_t(1000000000000000ull >> 32), 0u
	};

	// Signed number of femtoseconds from the beginning of time.
	value<bits> raw;

public:
	constexpr time() {}

	explicit constexpr time(const value<bits> &raw) : raw(raw) {}
	explicit operator const value<bits> &() const { return raw; }

	static constexpr time maximum() {
		return time(value<bits> { 0xffffffffu, 0xffffffffu, 0x7fffffffu });
	}

	time(int64_t secs, int64_t femtos) {
		value<64> secs_val;
		secs_val.set(secs);
		value<64> femtos_val;
		femtos_val.set(femtos);
		raw = secs_val.sext<bits>().mul<bits>(resolution).add(femtos_val.sext<bits>());
	}

	bool is_zero() const {
		return raw.is_zero();
	}

	// Extracts the sign of the value.
	bool is_negative() const {
		return raw.is_neg();
	}

	// Extracts the number of whole seconds. Negative if the value is negative.
	int64_t secs() const {
		return raw.sdivmod(resolution).first.trunc<64>().get<int64_t>();
	}

	// Extracts the number of femtoseconds in the fractional second. Negative if the value is negative.
	int64_t femtos() const {
		return raw.sdivmod(resolution).second.trunc<64>().get<int64_t>();
	}

	bool operator==(const time &other) const {
		return raw == other.raw;
	}

	bool operator!=(const time &other) const {
		return raw != other.raw;
	}

	bool operator>(const time &other) const {
		return other.raw.scmp(raw);
	}

	bool operator>=(const time &other) const {
		return !raw.scmp(other.raw);
	}

	bool operator<(const time &other) const {
		return raw.scmp(other.raw);
	}

	bool operator<=(const time &other) const {
		return !other.raw.scmp(raw);
	}

	time operator+(const time &other) const {
		return time(raw.add(other.raw));
	}

	time &operator+=(const time &other) {
		*this = *this + other;
		return *this;
	}

	time operator-() const {
		return time(raw.neg());
	}

	time operator-(const time &other) const {
		return *this + (-other);
	}

	time &operator-=(const time &other) {
		*this = *this - other;
		return *this;
	}

	operator std::string() const {
		char buf[48]; // x=2**95; len(f"-{x/1_000_000_000_000_000}.{x^1_000_000_000_000_000}") == 48
		int64_t secs = this->secs();
		int64_t femtos = this->femtos();
		snprintf(buf, sizeof(buf), "%s%" PRIi64 ".%015" PRIi64,
			is_negative() ? "-" : "", secs >= 0 ? secs : -secs, femtos >= 0 ? femtos : -femtos);
		return buf;
	}

#if __cplusplus >= 201603L
	[[nodiscard("ignoring parse errors")]]
#endif
	bool parse(const std::string &str) {
		enum {
			parse_sign_opt,
			parse_integral,
			parse_fractional,
		} state = parse_sign_opt;
		bool negative = false;
		int64_t integral = 0;
		int64_t fractional = 0;
		size_t frac_digits = 0;
		for (auto chr : str) {
			switch (state) {
				case parse_sign_opt:
					state = parse_integral;
					if (chr == '+' || chr == '-') {
						negative = (chr == '-');
						break;
					}
					/* fallthrough */
				case parse_integral:
					if (chr >= '0' && chr <= '9') {
						integral *= 10;
						integral += chr - '0';
					} else if (chr == '.') {
						state = parse_fractional;
					} else {
						return false;
					}
					break;
				case parse_fractional:
					if (chr >= '0' && chr <= '9' && frac_digits < resolution_digits) {
						fractional *= 10;
						fractional += chr - '0';
						frac_digits++;
					} else {
						return false;
					}
					break;
			}
		}
		if (frac_digits == 0)
			return false;
		while (frac_digits++ < resolution_digits)
			fractional *= 10;
		*this = negative ? -time { integral, fractional} : time { integral, fractional };
		return true;
	}
};

// Out-of-line definition required until C++17.
constexpr value<time::bits> time::resolution;

std::ostream &operator<<(std::ostream &os, const time &val) {
	os << (std::string)val;
	return os;
}

// These literals are (confusingly) compatible with the ones from \`std::chrono\`: the \`std::chrono\` literals do not
// have an underscore (e.g. 1ms) and the \`cxxrtl::time\` literals do (e.g. 1_ms). This syntactic difference is
// a requirement of the C++ standard. Despite being compatible the literals should not be mixed in the same namespace.
namespace time_literals {

time operator""_s(unsigned long long seconds) {
	return time { (int64_t)seconds, 0 };
}

time operator""_ms(unsigned long long milliseconds) {
	return time { 0, (int64_t)milliseconds * 1000000000000 };
}

time operator""_us(unsigned long long microseconds) {
	return time { 0, (int64_t)microseconds * 1000000000 };
}

time operator""_ns(unsigned long long nanoseconds) {
	return time { 0, (int64_t)nanoseconds * 1000000 };
}

time operator""_ps(unsigned long long picoseconds) {
	return time { 0, (int64_t)picoseconds * 1000 };
}

time operator""_fs(unsigned long long femtoseconds) {
	return time { 0, (int64_t)femtoseconds };
}

};

};

#endif
`,"cxxrtl_vcd.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_VCD_H
#define CXXRTL_VCD_H

#include <cxxrtl/cxxrtl.h>

namespace cxxrtl {

class vcd_writer {
	struct variable {
		size_t ident;
		size_t width;
		chunk_t *curr;
		size_t cache_offset;
		debug_outline *outline;
		bool *outline_warm;
	};

	std::vector<std::string> current_scope;
	std::map<debug_outline*, bool> outlines;
	std::vector<variable> variables;
	std::vector<chunk_t> cache;
	std::map<chunk_t*, size_t> aliases;
	bool streaming = false;

	void emit_timescale(unsigned number, const std::string &unit) {
		assert(!streaming);
		assert(number == 1 || number == 10 || number == 100);
		assert(unit == "s" || unit == "ms" || unit == "us" ||
		       unit == "ns" || unit == "ps" || unit == "fs");
		buffer += "$timescale " + std::to_string(number) + " " + unit + " $end\\n";
	}

	void emit_scope(const std::vector<std::string> &scope) {
		assert(!streaming);
		size_t same_scope_count = 0;
		while ((same_scope_count < current_scope.size()) &&
			   (same_scope_count < scope.size()) &&
			   (current_scope[same_scope_count] == scope[same_scope_count])) {
			same_scope_count++;
		}
		while (current_scope.size() > same_scope_count) {
			buffer += "$upscope $end\\n";
			current_scope.pop_back();
		}
		while (current_scope.size() < scope.size()) {
			buffer += "$scope module " + scope[current_scope.size()] + " $end\\n";
			current_scope.push_back(scope[current_scope.size()]);
		}
	}

	void emit_ident(size_t ident) {
		do {
			buffer += '!' + ident % 94; // "base94"
			ident /= 94;
		} while (ident != 0);
	}

	void emit_name(const std::string &name) {
		for (char c : name) {
			if (c == ':') {
				// Due to a bug, GTKWave cannot parse a colon in the variable name, causing the VCD file
				// to be unreadable. It cannot be escaped either, so replace it with the sideways colon.
				buffer += "..";
			} else {
				buffer += c;
			}
		}
	}

	void emit_var(const variable &var, const std::string &type, const std::string &name,
	              size_t lsb_at, bool multipart) {
		assert(!streaming);
		buffer += "$var " + type + " " + std::to_string(var.width) + " ";
		emit_ident(var.ident);
		buffer += " ";
		emit_name(name);
		if (multipart || name.back() == ']' || lsb_at != 0) {
			if (var.width == 1)
				buffer += " [" + std::to_string(lsb_at) + "]";
			else
				buffer += " [" + std::to_string(lsb_at + var.width - 1) + ":" + std::to_string(lsb_at) + "]";
		}
		buffer += " $end\\n";
	}

	void emit_enddefinitions() {
		assert(!streaming);
		buffer += "$enddefinitions $end\\n";
		streaming = true;
	}

	void emit_time(uint64_t timestamp) {
		assert(streaming);
		buffer += "#" + std::to_string(timestamp) + "\\n";
	}

	void emit_scalar(const variable &var) {
		assert(streaming);
		assert(var.width == 1);
		buffer += (*var.curr ? '1' : '0');
		emit_ident(var.ident);
		buffer += '\\n';
	}

	void emit_vector(const variable &var) {
		assert(streaming);
		buffer += 'b';
		for (size_t bit = var.width - 1; bit != (size_t)-1; bit--) {
			bool bit_curr = var.curr[bit / (8 * sizeof(chunk_t))] & (1 << (bit % (8 * sizeof(chunk_t))));
			buffer += (bit_curr ? '1' : '0');
		}
		if (var.width == 0)
			buffer += '0';
		buffer += ' ';
		emit_ident(var.ident);
		buffer += '\\n';
	}

	void reset_outlines() {
		for (auto &outline_it : outlines)
			outline_it.second = /*warm=*/(outline_it.first == nullptr);
	}

	variable &register_variable(size_t width, chunk_t *curr, bool constant = false, debug_outline *outline = nullptr) {
		if (aliases.count(curr)) {
			return variables[aliases[curr]];
		} else {
			auto outline_it = outlines.emplace(outline, /*warm=*/(outline == nullptr)).first;
			const size_t chunks = (width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
			aliases[curr] = variables.size();
			if (constant) {
				variables.emplace_back(variable { variables.size(), width, curr, (size_t)-1, outline_it->first, &outline_it->second });
			} else {
				variables.emplace_back(variable { variables.size(), width, curr, cache.size(), outline_it->first, &outline_it->second });
				cache.insert(cache.end(), &curr[0], &curr[chunks]);
			}
			return variables.back();
		}
	}

	bool test_variable(const variable &var) {
		if (var.cache_offset == (size_t)-1)
			return false; // constant
		if (!*var.outline_warm) {
			var.outline->eval();
			*var.outline_warm = true;
		}
		const size_t chunks = (var.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
		if (std::equal(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset])) {
			return false;
		} else {
			std::copy(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset]);
			return true;
		}
	}

	static std::vector<std::string> split_hierarchy(const std::string &hier_name) {
		std::vector<std::string> hierarchy;
		size_t prev = 0;
		while (true) {
			size_t curr = hier_name.find_first_of(' ', prev);
			if (curr == std::string::npos) {
				hierarchy.push_back(hier_name.substr(prev));
				break;
			} else {
				hierarchy.push_back(hier_name.substr(prev, curr - prev));
				prev = curr + 1;
			}
		}
		return hierarchy;
	}

public:
	std::string buffer;

	void timescale(unsigned number, const std::string &unit) {
		emit_timescale(number, unit);
	}

	void add(const std::string &hier_name, const debug_item &item, bool multipart = false) {
		std::vector<std::string> scope = split_hierarchy(hier_name);
		std::string name = scope.back();
		scope.pop_back();

		emit_scope(scope);
		switch (item.type) {
			// Not the best naming but oh well...
			case debug_item::VALUE:
				emit_var(register_variable(item.width, item.curr, /*constant=*/item.next == nullptr),
				         "wire", name, item.lsb_at, multipart);
				break;
			case debug_item::WIRE:
				emit_var(register_variable(item.width, item.curr),
				         "reg", name, item.lsb_at, multipart);
				break;
			case debug_item::MEMORY: {
				const size_t stride = (item.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
				for (size_t index = 0; index < item.depth; index++) {
					chunk_t *nth_curr = &item.curr[stride * index];
					std::string nth_name = name + '[' + std::to_string(index) + ']';
					emit_var(register_variable(item.width, nth_curr),
					         "reg", nth_name, item.lsb_at, multipart);
				}
				break;
			}
			case debug_item::ALIAS:
				// Like VALUE, but, even though \`item.next == nullptr\` always holds, the underlying value
				// can actually change, and must be tracked. In most cases the VCD identifier will be
				// unified with the aliased reg, but we should handle the case where only the alias is
				// added to the VCD writer, too.
				emit_var(register_variable(item.width, item.curr),
				         "wire", name, item.lsb_at, multipart);
				break;
			case debug_item::OUTLINE:
				emit_var(register_variable(item.width, item.curr, /*constant=*/false, item.outline),
				         "wire", name, item.lsb_at, multipart);
				break;
		}
	}

	template<class Filter>
	void add(const debug_items &items, const Filter &filter) {
		// \`debug_items\` is a map, so the items are already sorted in an order optimal for emitting
		// VCD scope sections.
		for (auto &it : items.table)
			for (auto &part : it.second)
				if (filter(it.first, part))
					add(it.first, part, it.second.size() > 1);
	}

	void add(const debug_items &items) {
		this->add(items, [](const std::string &, const debug_item &) {
			return true;
		});
	}

	void add_without_memories(const debug_items &items) {
		this->add(items, [](const std::string &, const debug_item &item) {
			return item.type != debug_item::MEMORY;
		});
	}

	void sample(uint64_t timestamp) {
		bool first_sample = !streaming;
		if (first_sample) {
			emit_scope({});
			emit_enddefinitions();
		}
		reset_outlines();
		emit_time(timestamp);
		for (auto var : variables)
			if (test_variable(var) || first_sample) {
				if (var.width == 1)
					emit_scalar(var);
				else
					emit_vector(var);
			}
	}
};

}

#endif
`}}},rtlil:{"rtlil_backend.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  A very simple and straightforward backend for the RTLIL text
 *  representation.
 *
 */

#ifndef RTLIL_BACKEND_H
#define RTLIL_BACKEND_H

#include "kernel/yosys.h"
#include <stdio.h>

YOSYS_NAMESPACE_BEGIN

namespace RTLIL_BACKEND {
	void dump_const(std::ostream &f, const RTLIL::Const &data, int width = -1, int offset = 0, bool autoint = true);
	void dump_sigchunk(std::ostream &f, const RTLIL::SigChunk &chunk, bool autoint = true);
	void dump_sigspec(std::ostream &f, const RTLIL::SigSpec &sig, bool autoint = true);
	void dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire);
	void dump_memory(std::ostream &f, std::string indent, const RTLIL::Memory *memory);
	void dump_cell(std::ostream &f, std::string indent, const RTLIL::Cell *cell);
	void dump_proc_case_body(std::ostream &f, std::string indent, const RTLIL::CaseRule *cs);
	void dump_proc_switch(std::ostream &f, std::string indent, const RTLIL::SwitchRule *sw);
	void dump_proc_sync(std::ostream &f, std::string indent, const RTLIL::SyncRule *sy);
	void dump_proc(std::ostream &f, std::string indent, const RTLIL::Process *proc);
	void dump_conn(std::ostream &f, std::string indent, const RTLIL::SigSpec &left, const RTLIL::SigSpec &right);
	void dump_module(std::ostream &f, std::string indent, RTLIL::Module *module, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);
	void dump_design(std::ostream &f, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);
}

YOSYS_NAMESPACE_END

#endif
`}},frontends:{ast:{"ast.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The AST frontend library is not a frontend on its own but provides an
 *  abstract syntax tree (AST) abstraction for the open source Verilog frontend
 *  at frontends/verilog.
 *
 */

#ifndef AST_H
#define AST_H

#include "kernel/rtlil.h"
#include "kernel/fmt.h"
#include <stdint.h>
#include <set>

YOSYS_NAMESPACE_BEGIN

namespace AST
{
	// all node types, type2str() must be extended
	// whenever a new node type is added here
	enum AstNodeType
	{
		AST_NONE,
		AST_DESIGN,
		AST_MODULE,
		AST_TASK,
		AST_FUNCTION,
		AST_DPI_FUNCTION,

		AST_WIRE,
		AST_MEMORY,
		AST_AUTOWIRE,
		AST_PARAMETER,
		AST_LOCALPARAM,
		AST_DEFPARAM,
		AST_PARASET,
		AST_ARGUMENT,
		AST_RANGE,
		AST_MULTIRANGE,
		AST_CONSTANT,
		AST_REALVALUE,
		AST_CELLTYPE,
		AST_IDENTIFIER,
		AST_PREFIX,
		AST_ASSERT,
		AST_ASSUME,
		AST_LIVE,
		AST_FAIR,
		AST_COVER,
		AST_ENUM,
		AST_ENUM_ITEM,

		AST_FCALL,
		AST_TO_BITS,
		AST_TO_SIGNED,
		AST_TO_UNSIGNED,
		AST_SELFSZ,
		AST_CAST_SIZE,
		AST_CONCAT,
		AST_REPLICATE,
		AST_BIT_NOT,
		AST_BIT_AND,
		AST_BIT_OR,
		AST_BIT_XOR,
		AST_BIT_XNOR,
		AST_REDUCE_AND,
		AST_REDUCE_OR,
		AST_REDUCE_XOR,
		AST_REDUCE_XNOR,
		AST_REDUCE_BOOL,
		AST_SHIFT_LEFT,
		AST_SHIFT_RIGHT,
		AST_SHIFT_SLEFT,
		AST_SHIFT_SRIGHT,
		AST_SHIFTX,
		AST_SHIFT,
		AST_LT,
		AST_LE,
		AST_EQ,
		AST_NE,
		AST_EQX,
		AST_NEX,
		AST_GE,
		AST_GT,
		AST_ADD,
		AST_SUB,
		AST_MUL,
		AST_DIV,
		AST_MOD,
		AST_POW,
		AST_POS,
		AST_NEG,
		AST_LOGIC_AND,
		AST_LOGIC_OR,
		AST_LOGIC_NOT,
		AST_TERNARY,
		AST_MEMRD,
		AST_MEMWR,
		AST_MEMINIT,

		AST_TCALL,
		AST_ASSIGN,
		AST_CELL,
		AST_PRIMITIVE,
		AST_CELLARRAY,
		AST_ALWAYS,
		AST_INITIAL,
		AST_BLOCK,
		AST_ASSIGN_EQ,
		AST_ASSIGN_LE,
		AST_CASE,
		AST_COND,
		AST_CONDX,
		AST_CONDZ,
		AST_DEFAULT,
		AST_FOR,
		AST_WHILE,
		AST_REPEAT,

		AST_GENVAR,
		AST_GENFOR,
		AST_GENIF,
		AST_GENCASE,
		AST_GENBLOCK,
		AST_TECALL,

		AST_POSEDGE,
		AST_NEGEDGE,
		AST_EDGE,

		AST_INTERFACE,
		AST_INTERFACEPORT,
		AST_INTERFACEPORTTYPE,
		AST_MODPORT,
		AST_MODPORTMEMBER,
		AST_PACKAGE,

		AST_WIRETYPE,
		AST_TYPEDEF,
		AST_STRUCT,
		AST_UNION,
		AST_STRUCT_ITEM,
		AST_BIND
	};

	struct AstSrcLocType {
		unsigned int first_line, last_line;
		unsigned int first_column, last_column;
		AstSrcLocType() : first_line(0), last_line(0), first_column(0), last_column(0) {}
		AstSrcLocType(int _first_line, int _first_column, int _last_line, int _last_column) : first_line(_first_line), last_line(_last_line), first_column(_first_column), last_column(_last_column) {}
	};

	// convert an node type to a string (e.g. for debug output)
	std::string type2str(AstNodeType type);

	// The AST is built using instances of this struct
	struct AstNode
	{
		// for dict<> and pool<>
		unsigned int hashidx_;
		[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

		// this nodes type
		AstNodeType type;

		// the list of child nodes for this node
		std::vector<AstNode*> children;

		// the list of attributes assigned to this node
		std::map<RTLIL::IdString, AstNode*> attributes;
		bool get_bool_attribute(RTLIL::IdString id);

		// node content - most of it is unused in most node types
		std::string str;
		std::vector<RTLIL::State> bits;
		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid, range_swapped, was_checked, is_unsized, is_custom_type;
		int port_id, range_left, range_right;
		uint32_t integer;
		double realvalue;
		// set for IDs typed to an enumeration, not used
		bool is_enum;

		// Declared range for array dimension.
		struct dimension_t {
			int range_right;     // lsb in [msb:lsb]
			int range_width;     // msb - lsb + 1
			bool range_swapped;  // if the declared msb < lsb, msb and lsb above are swapped
		};
		// Packed and unpacked dimensions for arrays.
		// Unpacked dimensions go first, to follow the order of indexing.
		std::vector<dimension_t> dimensions;
		// Number of unpacked dimensions.
		int unpacked_dimensions;

		// this is set by simplify and used during RTLIL generation
		AstNode *id2ast;

		// this is used by simplify to detect if basic analysis has been performed already on the node
		bool basic_prep;

		// this is used for ID references in RHS expressions that should use the "new" value for non-blocking assignments
		bool lookahead;

		// this is the original sourcecode location that resulted in this AST node
		// it is automatically set by the constructor using AST::current_filename and
		// the AST::get_line_num() callback function.
		std::string filename;
		AstSrcLocType location;

		// are we embedded in an lvalue, param?
		// (see fixup_hierarchy_flags)
		bool in_lvalue;
		bool in_param;
		bool in_lvalue_from_above;
		bool in_param_from_above;

		// creating and deleting nodes
		AstNode(AstNodeType type = AST_NONE, AstNode *child1 = nullptr, AstNode *child2 = nullptr, AstNode *child3 = nullptr, AstNode *child4 = nullptr);
		AstNode *clone() const;
		void cloneInto(AstNode *other) const;
		void delete_children();
		~AstNode();

		enum mem2reg_flags
		{
			/* status flags */
			MEM2REG_FL_ALL       = 0x00000001,
			MEM2REG_FL_ASYNC     = 0x00000002,
			MEM2REG_FL_INIT      = 0x00000004,

			/* candidate flags */
			MEM2REG_FL_FORCED    = 0x00000100,
			MEM2REG_FL_SET_INIT  = 0x00000200,
			MEM2REG_FL_SET_ELSE  = 0x00000400,
			MEM2REG_FL_SET_ASYNC = 0x00000800,
			MEM2REG_FL_EQ2       = 0x00001000,
			MEM2REG_FL_CMPLX_LHS = 0x00002000,
			MEM2REG_FL_CONST_LHS = 0x00004000,
			MEM2REG_FL_VAR_LHS   = 0x00008000,

			/* proc flags */
			MEM2REG_FL_EQ1       = 0x01000000,
		};

		// simplify() creates a simpler AST by unrolling for-loops, expanding generate blocks, etc.
		// it also sets the id2ast pointers so that identifier lookups are fast in genRTLIL()
		bool simplify(bool const_fold, int stage, int width_hint, bool sign_hint);
		void replace_result_wire_name_in_function(const std::string &from, const std::string &to);
		AstNode *readmem(bool is_readmemh, std::string mem_filename, AstNode *memory, int start_addr, int finish_addr, bool unconditional_init);
		void expand_genblock(const std::string &prefix);
		void label_genblks(std::set<std::string>& existing, int &counter);
		void mem2reg_as_needed_pass1(dict<AstNode*, pool<std::string>> &mem2reg_places,
				dict<AstNode*, uint32_t> &mem2reg_flags, dict<AstNode*, uint32_t> &proc_flags, uint32_t &status_flags);
		bool mem2reg_as_needed_pass2(pool<AstNode*> &mem2reg_set, AstNode *mod, AstNode *block, AstNode *&async_block);
		bool mem2reg_check(pool<AstNode*> &mem2reg_set);
		void mem2reg_remove(pool<AstNode*> &mem2reg_set, vector<AstNode*> &delnodes);
		void meminfo(int &mem_width, int &mem_size, int &addr_bits);
		bool detect_latch(const std::string &var);
		const RTLIL::Module* lookup_cell_module();

		// additional functionality for evaluating constant functions
		struct varinfo_t {
			RTLIL::Const val;
			int offset;
			bool range_swapped;
			bool is_signed;
			AstNode *arg = nullptr;
			bool explicitly_sized;
		};
		bool has_const_only_constructs();
		bool replace_variables(std::map<std::string, varinfo_t> &variables, AstNode *fcall, bool must_succeed);
		AstNode *eval_const_function(AstNode *fcall, bool must_succeed);
		bool is_simple_const_expr();

		// helper for parsing format strings
		Fmt processFormat(int stage, bool sformat_like, int default_base = 10, size_t first_arg_at = 0, bool may_fail = false);

		bool is_recursive_function() const;
		std::pair<AstNode*, AstNode*> get_tern_choice();

		// create a human-readable text representation of the AST (for debugging)
		void dumpAst(FILE *f, std::string indent) const;
		void dumpVlog(FILE *f, std::string indent) const;

		// Generate RTLIL for a bind construct
		std::vector<RTLIL::Binding *> genBindings() const;

		// used by genRTLIL() for detecting expression width and sign
		void detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *found_real = NULL);
		void detectSignWidth(int &width_hint, bool &sign_hint, bool *found_real = NULL);

		// create RTLIL code for this AST node
		// for expressions the resulting signal vector is returned
		// all generated cell instances, etc. are written to the RTLIL::Module pointed to by AST_INTERNAL::current_module
		RTLIL::SigSpec genRTLIL(int width_hint = -1, bool sign_hint = false);
		RTLIL::SigSpec genWidthRTLIL(int width, bool sgn, const dict<RTLIL::SigBit, RTLIL::SigBit> *new_subst_ptr = NULL);

		// compare AST nodes
		bool operator==(const AstNode &other) const;
		bool operator!=(const AstNode &other) const;
		bool contains(const AstNode *other) const;

		// helper functions for creating AST nodes for constants
		static AstNode *mkconst_int(uint32_t v, bool is_signed, int width = 32);
		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized);
		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed);
		static AstNode *mkconst_str(const std::vector<RTLIL::State> &v);
		static AstNode *mkconst_str(const std::string &str);

		// helper function to create an AST node for a temporary register
		AstNode *mktemp_logic(const std::string &name, AstNode *mod, bool nosync, int range_left, int range_right, bool is_signed);

		// helper function for creating sign-extended const objects
		RTLIL::Const bitsAsConst(int width, bool is_signed);
		RTLIL::Const bitsAsConst(int width = -1);
		RTLIL::Const bitsAsUnsizedConst(int width);
		RTLIL::Const asAttrConst() const;
		RTLIL::Const asParaConst() const;
		uint64_t asInt(bool is_signed);
		bool bits_only_01() const;
		bool asBool() const;

		// helper functions for real valued const eval
		int isConst() const; // return '1' for AST_CONSTANT and '2' for AST_REALVALUE
		double asReal(bool is_signed);
		RTLIL::Const realAsConst(int width);

		// helpers for enum
		void allocateDefaultEnumValues();
		void annotateTypedEnums(AstNode *template_node);

		// helpers for locations
		std::string loc_string() const;

		// Helper for looking up identifiers which are prefixed with the current module name
		std::string try_pop_module_prefix() const;

		// helper to clone the node with some of its subexpressions replaced with zero (this is used
		// to evaluate widths of dynamic ranges)
		AstNode *clone_at_zero();

		void set_attribute(RTLIL::IdString key, AstNode *node)
		{
			attributes[key] = node;
			node->set_in_param_flag(true);
		}

		// helper to set in_lvalue/in_param flags from the hierarchy context (the actual flag
		// can be overridden based on the intrinsic properties of this node, i.e. based on its type)
		void set_in_lvalue_flag(bool flag, bool no_descend = false);
		void set_in_param_flag(bool flag, bool no_descend = false);

		// fix up the hierarchy flags (in_lvalue/in_param) of this node and its children
		//
		// to keep the flags in sync, fixup_hierarchy_flags(true) needs to be called once after
		// parsing the AST to walk the full tree, then plain fixup_hierarchy_flags() performs
		// localized fixups after modifying children/attributes of a particular node
		void fixup_hierarchy_flags(bool force_descend = false);

		// helpers for indexing
		AstNode *make_index_range(AstNode *node, bool unpacked_range = false);
		AstNode *get_struct_member() const;

		// helper to print errors from simplify/genrtlil code
		[[noreturn]] void input_error(const char *format, ...) const YS_ATTRIBUTE(format(printf, 2, 3));
	};

	// process an AST tree (ast must point to an AST_DESIGN node) and generate RTLIL code
	void process(RTLIL::Design *design, AstNode *ast, bool nodisplay, bool dump_ast1, bool dump_ast2, bool no_dump_ptr, bool dump_vlog1, bool dump_vlog2, bool dump_rtlil, bool nolatches, bool nomeminit,
			bool nomem2reg, bool mem2reg, bool noblackbox, bool lib, bool nowb, bool noopt, bool icells, bool pwires, bool nooverwrite, bool overwrite, bool defer, bool autowire);

	// parametric modules are supported directly by the AST library
	// therefore we need our own derivate of RTLIL::Module with overloaded virtual functions
	struct AstModule : RTLIL::Module {
		AstNode *ast;
		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, autowire;
		~AstModule() override;
		RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail) override;
		RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail) override;
		std::string derive_common(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, AstNode **new_ast_out, bool quiet = false);
		void expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces) override;
		bool reprocess_if_necessary(RTLIL::Design *design) override;
		RTLIL::Module *clone() const override;
		void loadconfig() const;
	};

	// this must be set by the language frontend before parsing the sources
	// the AstNode constructor then uses current_filename and get_line_num()
	// to initialize the filename and linenum properties of new nodes
	extern std::string current_filename;
	extern void (*set_line_num)(int);
	extern int (*get_line_num)();

	// for stats
	unsigned long long astnode_count();

	// set set_line_num and get_line_num to internal dummy functions (done by simplify() and AstModule::derive
	// to control the filename and linenum properties of new nodes not generated by a frontend parser)
	void use_internal_line_num();

	// call a DPI function
	AstNode *dpi_call(const std::string &rtype, const std::string &fname, const std::vector<std::string> &argtypes, const std::vector<AstNode*> &args);

	// Helper functions related to handling SystemVerilog interfaces
	std::pair<std::string,std::string> split_modport_from_type(std::string name_type);
	AstNode * find_modport(AstNode *intf, std::string name);
	void explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string intfname, AstNode *modport);

	// Helper for setting the src attribute.
	void set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast);

	// generate standard $paramod... derived module name; parameters should be
	// in the order they are declared in the instantiated module
	std::string derived_module_name(std::string stripped_name, const std::vector<std::pair<RTLIL::IdString, RTLIL::Const>> &parameters);

	// used to provide simplify() access to the current design for looking up
	// modules, ports, wires, etc.
	void set_simplify_design_context(const RTLIL::Design *design);
}

namespace AST_INTERNAL
{
	// internal state variables
	extern bool flag_nodisplay, flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_rtlil, flag_nolatches, flag_nomeminit;
	extern bool flag_nomem2reg, flag_mem2reg, flag_lib, flag_noopt, flag_icells, flag_pwires, flag_autowire;
	extern AST::AstNode *current_ast, *current_ast_mod;
	extern std::map<std::string, AST::AstNode*> current_scope;
	extern const dict<RTLIL::SigBit, RTLIL::SigBit> *genRTLIL_subst_ptr;
	extern RTLIL::SigSpec ignoreThisSignalsInInitial;
	extern AST::AstNode *current_always, *current_top_block, *current_block, *current_block_child;
	extern RTLIL::Module *current_module;
	extern bool current_always_clocked;
	extern dict<std::string, int> current_memwr_count;
	extern dict<std::string, pool<int>> current_memwr_visible;
	struct LookaheadRewriter;
	struct ProcessGenerator;

	// Create and add a new AstModule from new_ast, then use it to replace
	// old_module in design, renaming old_module to move it out of the way.
	// Return the new module.
	//
	// If original_ast is not null, it will be used as the AST node for the
	// new module. Otherwise, new_ast will be used.
	RTLIL::Module *
	process_and_replace_module(RTLIL::Design *design,
	                           RTLIL::Module *old_module,
	                           AST::AstNode *new_ast,
	                           AST::AstNode *original_ast = nullptr);
}

YOSYS_NAMESPACE_END

#endif
`,"ast_binding.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  This header declares the AST::Binding class
 *
 *  This is used to support the bind directive and is to RTLIL::Binding as
 *  AST::AstModule is to RTLIL::Module, holding a syntax-level representation of
 *  cells until we get to a stage where they make sense. In the case of a bind
 *  directive, this is when we elaborate the design in the hierarchy pass.
 *
 */

#ifndef AST_BINDING_H
#define AST_BINDING_H

#include "kernel/rtlil.h"
#include "kernel/binding.h"

#include <memory>

YOSYS_NAMESPACE_BEGIN

namespace AST
{
	class Binding : public RTLIL::Binding
	{
	public:
		Binding(RTLIL::IdString  target_type,
		        RTLIL::IdString  target_name,
		        const AstNode   &cell);

		std::string describe() const override;

	private:
		// The syntax-level representation of the cell to be bound.
		std::unique_ptr<AstNode> ast_node;
	};
}

YOSYS_NAMESPACE_END

#endif
`},blif:{"blifparse.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef ABC_BLIFPARSE
#define ABC_BLIFPARSE

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

extern void parse_blif(RTLIL::Design *design, std::istream &f, IdString dff_name,
		bool run_clean = false, bool sop_mode = false, bool wideports = false);

YOSYS_NAMESPACE_END

#endif
`}},kernel:{"binding.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef BINDING_H
#define BINDING_H

#include "kernel/rtlil.h"

YOSYS_NAMESPACE_BEGIN

struct RTLIL::Binding
{
	// Represents a bind construct.
	//
	// The target of the binding is represented by target_type and
	// target_name (see comments above the fields).

	Binding(RTLIL::IdString target_type,
	        RTLIL::IdString target_name);

	virtual ~Binding() {}

	// Return a string describing the binding
	virtual std::string describe() const = 0;

protected:
	// May be empty. If not, it's the name of the module or interface to
	// bind to.
	RTLIL::IdString target_type;

	// If target_type is nonempty (the usual case), this is a hierarchical
	// reference to the bind target. If target_type is empty, we have to
	// wait until the hierarchy pass to figure out whether this was the name
	// of a module/interface type or an instance.
	RTLIL::IdString target_name;

	// An attribute name which contains an ID that's unique across binding
	// instances (used to ensure we don't apply a binding twice to a module)
	RTLIL::IdString attr_name;
};

YOSYS_NAMESPACE_END

#endif
`,"bitpattern.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef BITPATTERN_H
#define BITPATTERN_H

#include "kernel/log.h"
#include "kernel/rtlil.h"

YOSYS_NAMESPACE_BEGIN

struct BitPatternPool
{
	int width;
	struct bits_t {
		std::vector<RTLIL::State> bitdata;
		mutable Hasher::hash_t cached_hash;
		bits_t(int width = 0) : bitdata(width), cached_hash(0) { }
		RTLIL::State &operator[](int index) {
			return bitdata[index];
		}
		const RTLIL::State &operator[](int index) const {
			return bitdata[index];
		}
		bool operator==(const bits_t &other) const {
			if (run_hash(*this) != run_hash(other))
				return false;
			return bitdata == other.bitdata;
		}
		[[nodiscard]] Hasher hash_into(Hasher h) const {
			if (!cached_hash)
				cached_hash = run_hash(bitdata);
			h.eat(cached_hash);
			return h;
		}
	};
	pool<bits_t> database;

	BitPatternPool(RTLIL::SigSpec sig)
	{
		width = sig.size();
		if (width > 0) {
			bits_t pattern(width);
			for (int i = 0; i < width; i++) {
				if (sig[i].wire == NULL && sig[i].data <= RTLIL::State::S1)
					pattern[i] = sig[i].data;
				else
					pattern[i] = RTLIL::State::Sa;
			}
			database.insert(pattern);
		}
	}

	BitPatternPool(int width)
	{
		this->width = width;
		if (width > 0) {
			bits_t pattern(width);
			for (int i = 0; i < width; i++)
				pattern[i] = RTLIL::State::Sa;
			database.insert(pattern);
		}
	}

	bits_t sig2bits(RTLIL::SigSpec sig)
	{
		bits_t bits;
		bits.bitdata = sig.as_const().bits();
		for (auto &b : bits.bitdata)
			if (b > RTLIL::State::S1)
				b = RTLIL::State::Sa;
		return bits;
	}

	bool match(bits_t a, bits_t b)
	{
		log_assert(int(a.bitdata.size()) == width);
		log_assert(int(b.bitdata.size()) == width);
		for (int i = 0; i < width; i++)
			if (a[i] <= RTLIL::State::S1 && b[i] <= RTLIL::State::S1 && a[i] != b[i])
				return false;
		return true;
	}

	bool has_any(RTLIL::SigSpec sig)
	{
		bits_t bits = sig2bits(sig);
		for (auto &it : database)
			if (match(it, bits))
				return true;
		return false;
	}

	bool has_all(RTLIL::SigSpec sig)
	{
		bits_t bits = sig2bits(sig);
		for (auto &it : database)
			if (match(it, bits)) {
				for (int i = 0; i < width; i++)
					if (bits[i] > RTLIL::State::S1 && it[i] <= RTLIL::State::S1)
						goto next_database_entry;
				return true;
	next_database_entry:;
			}
		return false;
	}

	bool take(RTLIL::SigSpec sig)
	{
		bool status = false;
		bits_t bits = sig2bits(sig);
		for (auto it = database.begin(); it != database.end();)
			if (match(*it, bits)) {
				for (int i = 0; i < width; i++) {
					if ((*it)[i] != RTLIL::State::Sa || bits[i] == RTLIL::State::Sa)
						continue;
					bits_t new_pattern;
					new_pattern.bitdata = it->bitdata;
					new_pattern[i] = bits[i] == RTLIL::State::S1 ? RTLIL::State::S0 : RTLIL::State::S1;
					database.insert(new_pattern);
				}
				it = database.erase(it);
				status = true;
				continue;
			} else
				++it;
		return status;
	}

	bool take_all()
	{
		if (database.empty())
			return false;
		database.clear();
		return true;
	}

	bool empty()
	{
		return database.empty();
	}
};

YOSYS_NAMESPACE_END

#endif
`,"cellaigs.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLAIGS_H
#define CELLAIGS_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct AigNode
{
	IdString portname;
	int portbit;
	bool inverter;
	int left_parent, right_parent;
	vector<pair<IdString, int>> outports;

	AigNode();
	bool operator==(const AigNode &other) const;
	[[nodiscard]] Hasher hash_into(Hasher h) const;
};

struct Aig
{
	string name;
	vector<AigNode> nodes;
	Aig(Cell *cell);

	bool operator==(const Aig &other) const;
	[[nodiscard]] Hasher hash_into(Hasher h) const;
};

YOSYS_NAMESPACE_END

#endif
`,"celledges.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLEDGES_H
#define CELLEDGES_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"

YOSYS_NAMESPACE_BEGIN

struct AbstractCellEdgesDatabase
{
	virtual ~AbstractCellEdgesDatabase() { }
	virtual void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int delay) = 0;
	bool add_edges_from_cell(RTLIL::Cell *cell);
};

struct FwdCellEdgesDatabase : AbstractCellEdgesDatabase
{
	SigMap &sigmap;
	dict<SigBit, pool<SigBit>> db;
	FwdCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }

	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {
		SigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);
		SigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);
		db[from_sigbit].insert(to_sigbit);
	}
};

struct RevCellEdgesDatabase : AbstractCellEdgesDatabase
{
	SigMap &sigmap;
	dict<SigBit, pool<SigBit>> db;
	RevCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }

	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {
		SigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);
		SigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);
		db[to_sigbit].insert(from_sigbit);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"celltypes.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLTYPES_H
#define CELLTYPES_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct CellType
{
	RTLIL::IdString type;
	pool<RTLIL::IdString> inputs, outputs;
	bool is_evaluable;
	bool is_combinatorial;
	bool is_synthesizable;
};

struct CellTypes
{
	dict<RTLIL::IdString, CellType> cell_types;

	CellTypes()
	{
	}

	CellTypes(RTLIL::Design *design)
	{
		setup(design);
	}

	void setup(RTLIL::Design *design = NULL)
	{
		if (design)
			setup_design(design);

		setup_internals();
		setup_internals_mem();
		setup_internals_anyinit();
		setup_stdcells();
		setup_stdcells_mem();
	}

	void setup_type(RTLIL::IdString type, const pool<RTLIL::IdString> &inputs, const pool<RTLIL::IdString> &outputs, bool is_evaluable = false, bool is_combinatorial = false, bool is_synthesizable = false)
	{
		CellType ct = {type, inputs, outputs, is_evaluable, is_combinatorial, is_synthesizable};
		cell_types[ct.type] = ct;
	}

	void setup_module(RTLIL::Module *module)
	{
		pool<RTLIL::IdString> inputs, outputs;
		for (RTLIL::IdString wire_name : module->ports) {
			RTLIL::Wire *wire = module->wire(wire_name);
			if (wire->port_input)
				inputs.insert(wire->name);
			if (wire->port_output)
				outputs.insert(wire->name);
		}
		setup_type(module->name, inputs, outputs);
	}

	void setup_design(RTLIL::Design *design)
	{
		for (auto module : design->modules())
			setup_module(module);
	}

	void setup_internals()
	{
		setup_internals_eval();

		setup_type(ID($tribuf), {ID::A, ID::EN}, {ID::Y}, true);

		setup_type(ID($assert), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($assume), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($live), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($fair), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($cover), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($initstate), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($anyconst), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($anyseq), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($allconst), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($allseq), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($equiv), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($specify2), {ID::EN, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);
		setup_type(ID($specify3), {ID::EN, ID::SRC, ID::DST, ID::DAT}, pool<RTLIL::IdString>(), true);
		setup_type(ID($specrule), {ID::EN_SRC, ID::EN_DST, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);
		setup_type(ID($print), {ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());
		setup_type(ID($check), {ID::A, ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());
		setup_type(ID($set_tag), {ID::A, ID::SET, ID::CLR}, {ID::Y});
		setup_type(ID($get_tag), {ID::A}, {ID::Y});
		setup_type(ID($overwrite_tag), {ID::A, ID::SET, ID::CLR}, pool<RTLIL::IdString>());
		setup_type(ID($original_tag), {ID::A}, {ID::Y});
		setup_type(ID($future_ff), {ID::A}, {ID::Y});
		setup_type(ID($scopeinfo), {}, {});
	}

	void setup_internals_eval()
	{
		std::vector<RTLIL::IdString> unary_ops = {
			ID($not), ID($pos), ID($buf), ID($neg),
			ID($reduce_and), ID($reduce_or), ID($reduce_xor), ID($reduce_xnor), ID($reduce_bool),
			ID($logic_not), ID($slice), ID($lut), ID($sop)
		};

		std::vector<RTLIL::IdString> binary_ops = {
			ID($and), ID($or), ID($xor), ID($xnor),
			ID($shl), ID($shr), ID($sshl), ID($sshr), ID($shift), ID($shiftx),
			ID($lt), ID($le), ID($eq), ID($ne), ID($eqx), ID($nex), ID($ge), ID($gt),
			ID($add), ID($sub), ID($mul), ID($div), ID($mod), ID($divfloor), ID($modfloor), ID($pow),
			ID($logic_and), ID($logic_or), ID($concat), ID($macc),
			ID($bweqx)
		};

		for (auto type : unary_ops)
			setup_type(type, {ID::A}, {ID::Y}, true);

		for (auto type : binary_ops)
			setup_type(type, {ID::A, ID::B}, {ID::Y}, true);

		for (auto type : std::vector<RTLIL::IdString>({ID($mux), ID($pmux), ID($bwmux)}))
			setup_type(type, {ID::A, ID::B, ID::S}, {ID::Y}, true);

		for (auto type : std::vector<RTLIL::IdString>({ID($bmux), ID($demux)}))
			setup_type(type, {ID::A, ID::S}, {ID::Y}, true);

		setup_type(ID($lcu), {ID::P, ID::G, ID::CI}, {ID::CO}, true);
		setup_type(ID($alu), {ID::A, ID::B, ID::CI, ID::BI}, {ID::X, ID::Y, ID::CO}, true);
		setup_type(ID($macc_v2), {ID::A, ID::B, ID::C}, {ID::Y}, true);
		setup_type(ID($fa), {ID::A, ID::B, ID::C}, {ID::X, ID::Y}, true);
	}

	void setup_internals_ff()
	{
		setup_type(ID($sr), {ID::SET, ID::CLR}, {ID::Q});
		setup_type(ID($ff), {ID::D}, {ID::Q});
		setup_type(ID($dff), {ID::CLK, ID::D}, {ID::Q});
		setup_type(ID($dffe), {ID::CLK, ID::EN, ID::D}, {ID::Q});
		setup_type(ID($dffsr), {ID::CLK, ID::SET, ID::CLR, ID::D}, {ID::Q});
		setup_type(ID($dffsre), {ID::CLK, ID::SET, ID::CLR, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($adff), {ID::CLK, ID::ARST, ID::D}, {ID::Q});
		setup_type(ID($adffe), {ID::CLK, ID::ARST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($aldff), {ID::CLK, ID::ALOAD, ID::AD, ID::D}, {ID::Q});
		setup_type(ID($aldffe), {ID::CLK, ID::ALOAD, ID::AD, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($sdff), {ID::CLK, ID::SRST, ID::D}, {ID::Q});
		setup_type(ID($sdffe), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($sdffce), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($dlatch), {ID::EN, ID::D}, {ID::Q});
		setup_type(ID($adlatch), {ID::EN, ID::D, ID::ARST}, {ID::Q});
		setup_type(ID($dlatchsr), {ID::EN, ID::SET, ID::CLR, ID::D}, {ID::Q});
	}

	void setup_internals_anyinit()
	{
		setup_type(ID($anyinit), {ID::D}, {ID::Q});
	}

	void setup_internals_mem()
	{
		setup_internals_ff();

		setup_type(ID($memrd), {ID::CLK, ID::EN, ID::ADDR}, {ID::DATA});
		setup_type(ID($memrd_v2), {ID::CLK, ID::EN, ID::ARST, ID::SRST, ID::ADDR}, {ID::DATA});
		setup_type(ID($memwr), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($memwr_v2), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($meminit), {ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($meminit_v2), {ID::ADDR, ID::DATA, ID::EN}, pool<RTLIL::IdString>());
		setup_type(ID($mem), {ID::RD_CLK, ID::RD_EN, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});
		setup_type(ID($mem_v2), {ID::RD_CLK, ID::RD_EN, ID::RD_ARST, ID::RD_SRST, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});

		setup_type(ID($fsm), {ID::CLK, ID::ARST, ID::CTRL_IN}, {ID::CTRL_OUT});
	}

	void setup_stdcells()
	{
		setup_stdcells_eval();

		setup_type(ID($_TBUF_), {ID::A, ID::E}, {ID::Y}, true);
	}

	void setup_stdcells_eval()
	{
		setup_type(ID($_BUF_), {ID::A}, {ID::Y}, true);
		setup_type(ID($_NOT_), {ID::A}, {ID::Y}, true);
		setup_type(ID($_AND_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_NAND_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_OR_),  {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_NOR_),  {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_XOR_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_XNOR_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_ANDNOT_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_ORNOT_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_MUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);
		setup_type(ID($_NMUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);
		setup_type(ID($_MUX4_), {ID::A, ID::B, ID::C, ID::D, ID::S, ID::T}, {ID::Y}, true);
		setup_type(ID($_MUX8_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::S, ID::T, ID::U}, {ID::Y}, true);
		setup_type(ID($_MUX16_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::I, ID::J, ID::K, ID::L, ID::M, ID::N, ID::O, ID::P, ID::S, ID::T, ID::U, ID::V}, {ID::Y}, true);
		setup_type(ID($_AOI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);
		setup_type(ID($_OAI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);
		setup_type(ID($_AOI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);
		setup_type(ID($_OAI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);
	}

	void setup_stdcells_mem()
	{
		std::vector<char> list_np = {'N', 'P'}, list_01 = {'0', '1'};

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_SR_%c%c_", c1, c2), {ID::S, ID::R}, {ID::Q});

		setup_type(ID($_FF_), {ID::D}, {ID::Q});

		for (auto c1 : list_np)
			setup_type(stringf("$_DFF_%c_", c1), {ID::C, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_DFFE_%c%c_", c1, c2), {ID::C, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_DFF_%c%c%c_", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_DFFE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_ALDFF_%c%c_", c1, c2), {ID::C, ID::L, ID::AD, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_ALDFFE_%c%c%c_", c1, c2, c3), {ID::C, ID::L, ID::AD, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_DFFSR_%c%c%c_", c1, c2, c3), {ID::C, ID::S, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
		for (auto c4 : list_np)
			setup_type(stringf("$_DFFSRE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::S, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_SDFF_%c%c%c_", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_SDFFE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_SDFFCE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
			setup_type(stringf("$_DLATCH_%c_", c1), {ID::E, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_DLATCH_%c%c%c_", c1, c2, c3), {ID::E, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_DLATCHSR_%c%c%c_", c1, c2, c3), {ID::E, ID::S, ID::R, ID::D}, {ID::Q});
	}

	void clear()
	{
		cell_types.clear();
	}

	bool cell_known(RTLIL::IdString type) const
	{
		return cell_types.count(type) != 0;
	}

	bool cell_output(RTLIL::IdString type, RTLIL::IdString port) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.outputs.count(port) != 0;
	}

	bool cell_input(RTLIL::IdString type, RTLIL::IdString port) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.inputs.count(port) != 0;
	}

	bool cell_evaluable(RTLIL::IdString type) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.is_evaluable;
	}

	static RTLIL::Const eval_not(RTLIL::Const v)
	{
		for (auto &bit : v.bits())
			if (bit == State::S0) bit = State::S1;
			else if (bit == State::S1) bit = State::S0;
		return v;
	}

	static RTLIL::Const eval(RTLIL::IdString type, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len, bool *errp = nullptr)
	{
		if (type == ID($sshr) && !signed1)
			type = ID($shr);
		if (type == ID($sshl) && !signed1)
			type = ID($shl);

		if (type != ID($sshr) && type != ID($sshl) && type != ID($shr) && type != ID($shl) && type != ID($shift) && type != ID($shiftx) &&
				type != ID($pos) && type != ID($buf) && type != ID($neg) && type != ID($not)) {
			if (!signed1 || !signed2)
				signed1 = false, signed2 = false;
		}

#define HANDLE_CELL_TYPE(_t) if (type == ID($##_t)) return const_ ## _t(arg1, arg2, signed1, signed2, result_len);
		HANDLE_CELL_TYPE(not)
		HANDLE_CELL_TYPE(and)
		HANDLE_CELL_TYPE(or)
		HANDLE_CELL_TYPE(xor)
		HANDLE_CELL_TYPE(xnor)
		HANDLE_CELL_TYPE(reduce_and)
		HANDLE_CELL_TYPE(reduce_or)
		HANDLE_CELL_TYPE(reduce_xor)
		HANDLE_CELL_TYPE(reduce_xnor)
		HANDLE_CELL_TYPE(reduce_bool)
		HANDLE_CELL_TYPE(logic_not)
		HANDLE_CELL_TYPE(logic_and)
		HANDLE_CELL_TYPE(logic_or)
		HANDLE_CELL_TYPE(shl)
		HANDLE_CELL_TYPE(shr)
		HANDLE_CELL_TYPE(sshl)
		HANDLE_CELL_TYPE(sshr)
		HANDLE_CELL_TYPE(shift)
		HANDLE_CELL_TYPE(shiftx)
		HANDLE_CELL_TYPE(lt)
		HANDLE_CELL_TYPE(le)
		HANDLE_CELL_TYPE(eq)
		HANDLE_CELL_TYPE(ne)
		HANDLE_CELL_TYPE(eqx)
		HANDLE_CELL_TYPE(nex)
		HANDLE_CELL_TYPE(ge)
		HANDLE_CELL_TYPE(gt)
		HANDLE_CELL_TYPE(add)
		HANDLE_CELL_TYPE(sub)
		HANDLE_CELL_TYPE(mul)
		HANDLE_CELL_TYPE(div)
		HANDLE_CELL_TYPE(mod)
		HANDLE_CELL_TYPE(divfloor)
		HANDLE_CELL_TYPE(modfloor)
		HANDLE_CELL_TYPE(pow)
		HANDLE_CELL_TYPE(pos)
		HANDLE_CELL_TYPE(neg)
#undef HANDLE_CELL_TYPE

		if (type.in(ID($_BUF_), ID($buf)))
			return arg1;
		if (type == ID($_NOT_))
			return eval_not(arg1);
		if (type == ID($_AND_))
			return const_and(arg1, arg2, false, false, 1);
		if (type == ID($_NAND_))
			return eval_not(const_and(arg1, arg2, false, false, 1));
		if (type == ID($_OR_))
			return const_or(arg1, arg2, false, false, 1);
		if (type == ID($_NOR_))
			return eval_not(const_or(arg1, arg2, false, false, 1));
		if (type == ID($_XOR_))
			return const_xor(arg1, arg2, false, false, 1);
		if (type == ID($_XNOR_))
			return const_xnor(arg1, arg2, false, false, 1);
		if (type == ID($_ANDNOT_))
			return const_and(arg1, eval_not(arg2), false, false, 1);
		if (type == ID($_ORNOT_))
			return const_or(arg1, eval_not(arg2), false, false, 1);

		if (errp != nullptr) {
			*errp = true;
			return State::Sm;
		}

		log_abort();
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool *errp = nullptr)
	{
		if (cell->type == ID($slice)) {
			RTLIL::Const ret;
			int width = cell->parameters.at(ID::Y_WIDTH).as_int();
			int offset = cell->parameters.at(ID::OFFSET).as_int();
			ret.bits().insert(ret.bits().end(), arg1.begin()+offset, arg1.begin()+offset+width);
			return ret;
		}

		if (cell->type == ID($concat)) {
			RTLIL::Const ret = arg1;
			ret.bits().insert(ret.bits().end(), arg2.begin(), arg2.end());
			return ret;
		}

		if (cell->type == ID($bmux))
		{
			return const_bmux(arg1, arg2);
		}

		if (cell->type == ID($demux))
		{
			return const_demux(arg1, arg2);
		}

		if (cell->type == ID($bweqx))
		{
			return const_bweqx(arg1, arg2);
		}

		if (cell->type == ID($lut))
		{
			int width = cell->parameters.at(ID::WIDTH).as_int();

			std::vector<RTLIL::State> t = cell->parameters.at(ID::LUT).to_bits();
			while (GetSize(t) < (1 << width))
				t.push_back(State::S0);
			t.resize(1 << width);

			return const_bmux(t, arg1);
		}

		if (cell->type == ID($sop))
		{
			int width = cell->parameters.at(ID::WIDTH).as_int();
			int depth = cell->parameters.at(ID::DEPTH).as_int();
			std::vector<RTLIL::State> t = cell->parameters.at(ID::TABLE).to_bits();

			while (GetSize(t) < width*depth*2)
				t.push_back(State::S0);

			RTLIL::State default_ret = State::S0;

			for (int i = 0; i < depth; i++)
			{
				bool match = true;
				bool match_x = true;

				for (int j = 0; j < width; j++) {
					RTLIL::State a = arg1.at(j);
					if (t.at(2*width*i + 2*j + 0) == State::S1) {
						if (a == State::S1) match_x = false;
						if (a != State::S0) match = false;
					}
					if (t.at(2*width*i + 2*j + 1) == State::S1) {
						if (a == State::S0) match_x = false;
						if (a != State::S1) match = false;
					}
				}

				if (match)
					return State::S1;

				if (match_x)
					default_ret = State::Sx;
			}

			return default_ret;
		}

		bool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();
		bool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();
		int result_len = cell->parameters.count(ID::Y_WIDTH) > 0 ? cell->parameters[ID::Y_WIDTH].as_int() : -1;
		return eval(cell->type, arg1, arg2, signed_a, signed_b, result_len, errp);
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, bool *errp = nullptr)
	{
		if (cell->type.in(ID($mux), ID($_MUX_)))
			return const_mux(arg1, arg2, arg3);
		if (cell->type == ID($bwmux))
			return const_bwmux(arg1, arg2, arg3);
		if (cell->type == ID($pmux))
			return const_pmux(arg1, arg2, arg3);
		if (cell->type == ID($_AOI3_))
			return eval_not(const_or(const_and(arg1, arg2, false, false, 1), arg3, false, false, 1));
		if (cell->type == ID($_OAI3_))
			return eval_not(const_and(const_or(arg1, arg2, false, false, 1), arg3, false, false, 1));

		log_assert(arg3.size() == 0);
		return eval(cell, arg1, arg2, errp);
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, const RTLIL::Const &arg4, bool *errp = nullptr)
	{
		if (cell->type == ID($_AOI4_))
			return eval_not(const_or(const_and(arg1, arg2, false, false, 1), const_and(arg3, arg4, false, false, 1), false, false, 1));
		if (cell->type == ID($_OAI4_))
			return eval_not(const_and(const_or(arg1, arg2, false, false, 1), const_or(arg3, arg4, false, false, 1), false, false, 1));

		log_assert(arg4.size() == 0);
		return eval(cell, arg1, arg2, arg3, errp);
	}
};

// initialized by yosys_setup()
extern CellTypes yosys_celltypes;

YOSYS_NAMESPACE_END

#endif
`,"consteval.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CONSTEVAL_H
#define CONSTEVAL_H

#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"
#include "kernel/macc.h"

YOSYS_NAMESPACE_BEGIN

struct ConstEval
{
	RTLIL::Module *module;
	SigMap assign_map;
	SigMap values_map;
	SigPool stop_signals;
	SigSet<RTLIL::Cell*> sig2driver;
	std::set<RTLIL::Cell*> busy;
	std::vector<SigMap> stack;
	RTLIL::State defaultval;

	ConstEval(RTLIL::Module *module, RTLIL::State defaultval = RTLIL::State::Sm) : module(module), assign_map(module), defaultval(defaultval)
	{
		CellTypes ct;
		ct.setup_internals();
		ct.setup_stdcells();

		for (auto &it : module->cells_) {
			if (!ct.cell_known(it.second->type))
				continue;
			for (auto &it2 : it.second->connections())
				if (ct.cell_output(it.second->type, it2.first))
					sig2driver.insert(assign_map(it2.second), it.second);
		}
	}

	void clear()
	{
		values_map.clear();
		stop_signals.clear();
	}

	void push()
	{
		stack.push_back(values_map);
	}

	void pop()
	{
		values_map.swap(stack.back());
		stack.pop_back();
	}

	void set(RTLIL::SigSpec sig, RTLIL::Const value)
	{
		assign_map.apply(sig);
#ifndef NDEBUG
		RTLIL::SigSpec current_val = values_map(sig);
		for (int i = 0; i < GetSize(current_val); i++)
			log_assert(current_val[i].wire != NULL || current_val[i] == value[i]);
#endif
		values_map.add(sig, RTLIL::SigSpec(value));
	}

	void stop(RTLIL::SigSpec sig)
	{
		assign_map.apply(sig);
		stop_signals.add(sig);
	}

	bool eval(RTLIL::Cell *cell, RTLIL::SigSpec &undef)
	{
		if (cell->type == ID($lcu))
		{
			RTLIL::SigSpec sig_p = cell->getPort(ID::P);
			RTLIL::SigSpec sig_g = cell->getPort(ID::G);
			RTLIL::SigSpec sig_ci = cell->getPort(ID::CI);
			RTLIL::SigSpec sig_co = values_map(assign_map(cell->getPort(ID::CO)));

			if (sig_co.is_fully_const())
				return true;

			if (!eval(sig_p, undef, cell))
				return false;

			if (!eval(sig_g, undef, cell))
				return false;

			if (!eval(sig_ci, undef, cell))
				return false;

			if (sig_p.is_fully_def() && sig_g.is_fully_def() && sig_ci.is_fully_def())
			{
				RTLIL::Const coval(RTLIL::Sx, GetSize(sig_co));
				bool carry = sig_ci.as_bool();

				for (int i = 0; i < GetSize(coval); i++) {
					carry = (sig_g[i] == State::S1) || (sig_p[i] == RTLIL::S1 && carry);
					coval.bits()[i] = carry ? State::S1 : State::S0;
				}

				set(sig_co, coval);
			}
			else
				set(sig_co, RTLIL::Const(RTLIL::Sx, GetSize(sig_co)));

			return true;
		}

		RTLIL::SigSpec sig_a, sig_b, sig_s, sig_y;

		log_assert(cell->hasPort(ID::Y));
		sig_y = values_map(assign_map(cell->getPort(ID::Y)));
		if (sig_y.is_fully_const())
			return true;

		if (cell->hasPort(ID::S)) {
			sig_s = cell->getPort(ID::S);
		}

		if (cell->hasPort(ID::A))
			sig_a = cell->getPort(ID::A);

		if (cell->hasPort(ID::B))
			sig_b = cell->getPort(ID::B);

		if (cell->type.in(ID($mux), ID($pmux), ID($_MUX_), ID($_NMUX_)))
		{
			std::vector<RTLIL::SigSpec> y_candidates;
			int count_set_s_bits = 0;

			if (!eval(sig_s, undef, cell))
				return false;

			for (int i = 0; i < sig_s.size(); i++)
			{
				RTLIL::State s_bit = sig_s.extract(i, 1).as_const().at(0);
				RTLIL::SigSpec b_slice = sig_b.extract(sig_y.size()*i, sig_y.size());

				if (s_bit == RTLIL::State::Sx || s_bit == RTLIL::State::S1)
					y_candidates.push_back(b_slice);

				if (s_bit == RTLIL::State::S1)
					count_set_s_bits++;
			}

			if (count_set_s_bits == 0)
				y_candidates.push_back(sig_a);

			std::vector<RTLIL::Const> y_values;

			log_assert(y_candidates.size() > 0);
			for (auto &yc : y_candidates) {
				if (!eval(yc, undef, cell))
					return false;
				if (cell->type == ID($_NMUX_))
					y_values.push_back(RTLIL::const_not(yc.as_const(), Const(), false, false, GetSize(yc)));
				else
					y_values.push_back(yc.as_const());
			}

			if (y_values.size() > 1)
			{
				std::vector<RTLIL::State> master_bits = y_values.at(0).to_bits();

				for (size_t i = 1; i < y_values.size(); i++) {
					std::vector<RTLIL::State> slave_bits = y_values.at(i).to_bits();
					log_assert(master_bits.size() == slave_bits.size());
					for (size_t j = 0; j < master_bits.size(); j++)
						if (master_bits[j] != slave_bits[j])
							master_bits[j] = RTLIL::State::Sx;
				}

				set(sig_y, RTLIL::Const(master_bits));
			}
			else
				set(sig_y, y_values.front());
		}
		else if (cell->type == ID($bmux))
		{
			if (!eval(sig_s, undef, cell))
				return false;

			if (sig_s.is_fully_def()) {
				int sel = sig_s.as_int();
				int width = GetSize(sig_y);
				SigSpec res = sig_a.extract(sel * width, width);
				if (!eval(res, undef, cell))
					return false;
				set(sig_y, res.as_const());
			} else {
				if (!eval(sig_a, undef, cell))
					return false;
				set(sig_y, const_bmux(sig_a.as_const(), sig_s.as_const()));
			}
		}
		else if (cell->type == ID($demux))
		{
			if (!eval(sig_a, undef, cell))
				return false;
			if (sig_a.is_fully_zero()) {
				set(sig_y, Const(0, GetSize(sig_y)));
			} else {
				if (!eval(sig_s, undef, cell))
					return false;
				set(sig_y, const_demux(sig_a.as_const(), sig_s.as_const()));
			}
		}
		else if (cell->type == ID($fa))
		{
			RTLIL::SigSpec sig_c = cell->getPort(ID::C);
			RTLIL::SigSpec sig_x = cell->getPort(ID::X);
			int width = GetSize(sig_c);

			if (!eval(sig_a, undef, cell))
				return false;

			if (!eval(sig_b, undef, cell))
				return false;

			if (!eval(sig_c, undef, cell))
				return false;

			RTLIL::Const t1 = const_xor(sig_a.as_const(), sig_b.as_const(), false, false, width);
			RTLIL::Const val_y = const_xor(t1, sig_c.as_const(), false, false, width);

			RTLIL::Const t2 = const_and(sig_a.as_const(), sig_b.as_const(), false, false, width);
			RTLIL::Const t3 = const_and(sig_c.as_const(), t1, false, false, width);
			RTLIL::Const val_x = const_or(t2, t3, false, false, width);

			for (int i = 0; i < GetSize(val_y); i++)
				if (val_y[i] == RTLIL::Sx)
					val_x.bits()[i] = RTLIL::Sx;

			set(sig_y, val_y);
			set(sig_x, val_x);
		}
		else if (cell->type == ID($alu))
		{
			bool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();
			bool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();

			RTLIL::SigSpec sig_ci = cell->getPort(ID::CI);
			RTLIL::SigSpec sig_bi = cell->getPort(ID::BI);

			if (!eval(sig_a, undef, cell))
				return false;

			if (!eval(sig_b, undef, cell))
				return false;

			if (!eval(sig_ci, undef, cell))
				return false;

			if (!eval(sig_bi, undef, cell))
				return false;

			RTLIL::SigSpec sig_x = cell->getPort(ID::X);
			RTLIL::SigSpec sig_co = cell->getPort(ID::CO);

			bool any_input_undef = !(sig_a.is_fully_def() && sig_b.is_fully_def() && sig_ci.is_fully_def() && sig_bi.is_fully_def());
			sig_a.extend_u0(GetSize(sig_y), signed_a);
			sig_b.extend_u0(GetSize(sig_y), signed_b);

			bool carry = sig_ci[0] == State::S1;
			bool b_inv = sig_bi[0] == State::S1;

			for (int i = 0; i < GetSize(sig_y); i++)
			{
				RTLIL::SigSpec x_inputs = { sig_a[i], sig_b[i], sig_bi[0] };

				if (!x_inputs.is_fully_def()) {
					set(sig_x[i], RTLIL::Sx);
				} else {
					bool bit_a = sig_a[i] == State::S1;
					bool bit_b = (sig_b[i] == State::S1) != b_inv;
					bool bit_x = bit_a != bit_b;
					set(sig_x[i], bit_x ? State::S1 : State::S0);
				}

				if (any_input_undef) {
					set(sig_y[i], RTLIL::Sx);
					set(sig_co[i], RTLIL::Sx);
				} else {
					bool bit_a = sig_a[i] == State::S1;
					bool bit_b = (sig_b[i] == State::S1) != b_inv;
					bool bit_y = (bit_a != bit_b) != carry;
					carry = (bit_a && bit_b) || (bit_a && carry) || (bit_b && carry);
					set(sig_y[i], bit_y ? State::S1 : State::S0);
					set(sig_co[i], carry ? State::S1 : State::S0);
				}
			}
		}
		else if (cell->type.in(ID($macc), ID($macc_v2)))
		{
			Macc macc;
			macc.from_cell(cell);

			for (auto &port : macc.terms) {
				if (!eval(port.in_a, undef, cell))
					return false;
				if (!eval(port.in_b, undef, cell))
					return false;
			}

			RTLIL::Const result(0, GetSize(cell->getPort(ID::Y)));
			if (!macc.eval(result))
				log_abort();

			set(cell->getPort(ID::Y), result);
		}
		else
		{
			RTLIL::SigSpec sig_c, sig_d;

			if (cell->type.in(ID($_AOI3_), ID($_OAI3_), ID($_AOI4_), ID($_OAI4_))) {
				if (cell->hasPort(ID::C))
					sig_c = cell->getPort(ID::C);
				if (cell->hasPort(ID::D))
					sig_d = cell->getPort(ID::D);
			}

			if (sig_a.size() > 0 && !eval(sig_a, undef, cell))
				return false;
			if (sig_b.size() > 0 && !eval(sig_b, undef, cell))
				return false;
			if (sig_c.size() > 0 && !eval(sig_c, undef, cell))
				return false;
			if (sig_d.size() > 0 && !eval(sig_d, undef, cell))
				return false;

			bool eval_err = false;
			RTLIL::Const eval_ret = CellTypes::eval(cell, sig_a.as_const(), sig_b.as_const(), sig_c.as_const(), sig_d.as_const(), &eval_err);

			if (eval_err)
				return false;

			set(sig_y, eval_ret);
		}

		return true;
	}

	bool eval(RTLIL::SigSpec &sig, RTLIL::SigSpec &undef, RTLIL::Cell *busy_cell = NULL)
	{
		assign_map.apply(sig);
		values_map.apply(sig);

		if (sig.is_fully_const())
			return true;

		if (stop_signals.check_any(sig)) {
			undef = stop_signals.extract(sig);
			return false;
		}

		if (busy_cell) {
			if (busy.count(busy_cell) > 0) {
				undef = sig;
				return false;
			}
			busy.insert(busy_cell);
		}

		std::set<RTLIL::Cell*> driver_cells;
		sig2driver.find(sig, driver_cells);
		for (auto cell : driver_cells) {
			if (!eval(cell, undef)) {
				if (busy_cell)
					busy.erase(busy_cell);
				return false;
			}
		}

		if (busy_cell)
			busy.erase(busy_cell);

		values_map.apply(sig);
		if (sig.is_fully_const())
			return true;

		if (defaultval != RTLIL::State::Sm) {
			for (auto &bit : sig)
				if (bit.wire) bit = defaultval;
			return true;
		}

		for (auto &c : sig.chunks())
			if (c.wire != NULL)
				undef.append(c);
		return false;
	}

	bool eval(RTLIL::SigSpec &sig)
	{
		RTLIL::SigSpec undef;
		return eval(sig, undef);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"constids.inc":`X(A)
X(abc9_box)
X(abc9_box_id)
X(abc9_box_seq)
X(abc9_bypass)
X(abc9_carry)
X(abc9_flop)
X(abc9_keep)
X(abc9_lut)
X(abc9_mergeability)
X(abc9_scc_id)
X(abcgroup)
X(ABITS)
X(AD)
X(ADDR)
X(allconst)
X(allseq)
X(ALOAD)
X(ALOAD_POLARITY)
X(always_comb)
X(always_ff)
X(always_latch)
X(anyconst)
X(anyseq)
X(ARGS)
X(ARGS_WIDTH)
X(ARST)
X(ARST_POLARITY)
X(ARST_VALUE)
X(A_SIGNED)
X(A_WIDTH)
X(B)
X(BI)
X(BITS_USED)
X(blackbox)
X(B_SIGNED)
X(bugpoint_keep)
X(B_WIDTH)
X(BYTE)
X(C)
X(cells_not_processed)
X(CE_OVER_SRST)
X(CFG_ABITS)
X(CFG_DBITS)
X(CFG_INIT)
X(chain)
X(CI)
X(CLK)
X(clkbuf_driver)
X(clkbuf_inhibit)
X(clkbuf_inv)
X(clkbuf_sink)
X(CLK_ENABLE)
X(CLK_POLARITY)
X(CLR)
X(CLR_POLARITY)
X(CO)
X(COLLISION_X_MASK)
X(CONFIG)
X(CONFIG_WIDTH)
X(CTRL_IN)
X(CTRL_IN_WIDTH)
X(CTRL_OUT)
X(CTRL_OUT_WIDTH)
X(D)
X(DAT)
X(DATA)
X(DAT_DST_PEN)
X(DAT_DST_POL)
X(defaultvalue)
X(DELAY)
X(DEPTH)
X(DST)
X(DST_EN)
X(DST_PEN)
X(DST_POL)
X(DST_WIDTH)
X(dynports)
X(E)
X(EDGE_EN)
X(EDGE_POL)
X(EN)
X(EN_DST)
X(EN_POLARITY)
X(EN_SRC)
X(enum_base_type)
X(enum_type)
X(equiv_merged)
X(equiv_region)
X(extract_order)
X(F)
X(FLAVOR)
X(FORMAT)
X(force_downto)
X(force_upto)
X(fsm_encoding)
X(fsm_export)
X(FULL)
X(full_case)
X(G)
X(gclk)
X(gentb_clock)
X(gentb_constant)
X(gentb_skip)
X(H)
X(hdlname)
X(hierconn)
X(I)
X(INIT)
X(INIT_VALUE)
X(init)
X(initial_top)
X(interface_modport)
X(interfaces_replaced_in_module)
X(interface_type)
X(invertible_pin)
X(iopad_external_pin)
X(is_interface)
X(J)
X(K)
X(keep)
X(keep_hierarchy)
X(L)
X(lib_whitebox)
X(localparam)
X(logic_block)
X(lram)
X(LUT)
X(lut_keep)
X(M)
X(maximize)
X(mem2reg)
X(MEMID)
X(minimize)
X(module_not_derived)
X(N)
X(NAME)
X(noblackbox)
X(nolatches)
X(nomem2init)
X(nomem2reg)
X(nomeminit)
X(nosync)
X(nowrshmsk)
X(no_ram)
X(no_rw_check)
X(O)
X(OFFSET)
X(onehot)
X(P)
X(parallel_case)
X(parameter)
X(PORTID)
X(PRIORITY)
X(PRIORITY_MASK)
X(promoted_if)
X(Q)
X(R)
X(ram_block)
X(ram_style)
X(ramstyle)
X(RD_ADDR)
X(RD_ARST)
X(RD_ARST_VALUE)
X(RD_CE_OVER_SRST)
X(RD_CLK)
X(RD_CLK_ENABLE)
X(RD_CLK_POLARITY)
X(RD_COLLISION_X_MASK)
X(RD_DATA)
X(RD_EN)
X(RD_INIT_VALUE)
X(RD_PORTS)
X(RD_SRST)
X(RD_SRST_VALUE)
X(RD_TRANSPARENCY_MASK)
X(RD_TRANSPARENT)
X(RD_WIDE_CONTINUATION)
X(reg)
X(replaced_by_gclk)
X(reprocess_after)
X(rom_block)
X(rom_style)
X(romstyle)
X(S)
X(SET)
X(SET_POLARITY)
X(single_bit_vector)
X(SIZE)
X(SRC)
X(src)
X(SRC_DST_PEN)
X(SRC_DST_POL)
X(SRC_EN)
X(SRC_PEN)
X(SRC_POL)
X(SRC_WIDTH)
X(SRST)
X(SRST_POLARITY)
X(SRST_VALUE)
X(sta_arrival)
X(STATE_BITS)
X(STATE_NUM)
X(STATE_NUM_LOG2)
X(STATE_RST)
X(STATE_TABLE)
X(smtlib2_module)
X(smtlib2_comb_expr)
X(submod)
X(syn_ramstyle)
X(syn_romstyle)
X(S_WIDTH)
X(T)
X(TABLE)
X(TAG)
X(techmap_autopurge)
X(_TECHMAP_BITS_CONNMAP_)
X(_TECHMAP_CELLNAME_)
X(_TECHMAP_CELLTYPE_)
X(techmap_celltype)
X(_TECHMAP_FAIL_)
X(techmap_maccmap)
X(_TECHMAP_REPLACE_)
X(techmap_simplemap)
X(_techmap_special_)
X(techmap_wrap)
X(_TECHMAP_PLACEHOLDER_)
X(techmap_chtype)
X(T_FALL_MAX)
X(T_FALL_MIN)
X(T_FALL_TYP)
X(T_LIMIT)
X(T_LIMIT2)
X(T_LIMIT2_MAX)
X(T_LIMIT2_MIN)
X(T_LIMIT2_TYP)
X(T_LIMIT_MAX)
X(T_LIMIT_MIN)
X(T_LIMIT_TYP)
X(to_delete)
X(top)
X(TRANS_NUM)
X(TRANSPARENCY_MASK)
X(TRANSPARENT)
X(TRANS_TABLE)
X(TRG)
X(TRG_ENABLE)
X(TRG_POLARITY)
X(TRG_WIDTH)
X(T_RISE_MAX)
X(T_RISE_MIN)
X(T_RISE_TYP)
X(TYPE)
X(U)
X(unique)
X(unused_bits)
X(V)
X(via_celltype)
X(wand)
X(whitebox)
X(WIDTH)
X(wildcard_port_conns)
X(wiretype)
X(wor)
X(WORDS)
X(WR_ADDR)
X(WR_CLK)
X(WR_CLK_ENABLE)
X(WR_CLK_POLARITY)
X(WR_DATA)
X(WR_EN)
X(WR_PORTS)
X(WR_PRIORITY_MASK)
X(WR_WIDE_CONTINUATION)
X(X)
X(xprop_decoder)
X(Y)
X(Y_WIDTH)
X(area)
X(capacitance)
X(NPRODUCTS)
X(NADDENDS)
X(PRODUCT_NEGATED)
X(ADDEND_NEGATED)
X(A_WIDTHS)
X(B_WIDTHS)
X(C_WIDTHS)
X(C_SIGNED)
`,"cost.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef COST_H
#define COST_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct CellCosts
{

	private:
	dict<RTLIL::IdString, int> mod_cost_cache_;
	Design *design_ = nullptr;

	public:
	CellCosts(RTLIL::Design *design) : design_(design) { }

	static const dict<RTLIL::IdString, int>& default_gate_cost() {
		// Default size heuristics for several common PDK standard cells
		// used by abc and stat
		static const dict<RTLIL::IdString, int> db = {
			{ ID($_BUF_),    1 },
			{ ID($_NOT_),    2 },
			{ ID($_AND_),    4 },
			{ ID($_NAND_),   4 },
			{ ID($_OR_),     4 },
			{ ID($_NOR_),    4 },
			{ ID($_ANDNOT_), 4 },
			{ ID($_ORNOT_),  4 },
			{ ID($_XOR_),    5 },
			{ ID($_XNOR_),   5 },
			{ ID($_AOI3_),   6 },
			{ ID($_OAI3_),   6 },
			{ ID($_AOI4_),   7 },
			{ ID($_OAI4_),   7 },
			{ ID($_MUX_),    4 },
			{ ID($_NMUX_),   4 },
		};
		return db;
	}

	static const dict<RTLIL::IdString, int>& cmos_gate_cost() {
		// Estimated CMOS transistor counts for several common PDK standard cells
		// used by stat and optionally by abc
		static const dict<RTLIL::IdString, int> db = {
			{ ID($_BUF_),     1 },
			{ ID($_NOT_),     2 },
			{ ID($_AND_),     6 },
			{ ID($_NAND_),    4 },
			{ ID($_OR_),      6 },
			{ ID($_NOR_),     4 },
			{ ID($_ANDNOT_),  6 },
			{ ID($_ORNOT_),   6 },
			{ ID($_XOR_),    12 },
			{ ID($_XNOR_),   12 },
			{ ID($_AOI3_),    6 },
			{ ID($_OAI3_),    6 },
			{ ID($_AOI4_),    8 },
			{ ID($_OAI4_),    8 },
			{ ID($_MUX_),    12 },
			{ ID($_NMUX_),   10 },
			{ ID($_DFF_P_),  16 },
			{ ID($_DFF_N_),  16 },
		};
		return db;
	}

	// Get the cell cost for a cell based on its parameters.
	// This cost is an *approximate* upper bound for the number of gates that
	// the cell will get mapped to with "opt -fast; techmap"
	// The intended usage is for flattening heuristics and similar situations
	unsigned int get(RTLIL::Cell *cell);
	// Sum up the cell costs of all cells in the module
	// and all its submodules recursively
	unsigned int get(RTLIL::Module *mod);
};

YOSYS_NAMESPACE_END

#endif
`,"drivertools.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef DRIVERTOOLS_H
#define DRIVERTOOLS_H

#include <type_traits>

#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"

YOSYS_NAMESPACE_BEGIN

// TODO move implementation into a .cc file

struct DriveBit;

struct DriveChunkWire;
struct DriveChunkPort;
struct DriveChunkMarker;
struct DriveChunk;

struct DriveSpec;

const char *log_signal(DriveChunkWire const &chunk);
const char *log_signal(DriveChunkPort const &chunk);
const char *log_signal(DriveChunkMarker const &chunk);
const char *log_signal(DriveChunk const &chunk);
const char *log_signal(DriveSpec const &chunk);

enum class DriveType : unsigned char
{
	NONE,
	CONSTANT,
	WIRE,
	PORT,
	MULTIPLE,
	MARKER,
};

struct DriveBitWire
{
	Wire *wire;
	int offset;

	DriveBitWire(Wire *wire, int offset) : wire(wire), offset(offset) {}

	bool operator==(const DriveBitWire &other) const
	{
		return wire == other.wire && offset == other.offset;
	}

	bool operator<(const DriveBitWire &other) const
	{
		if (wire != other.wire)
			return wire->name < other.wire->name;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;


	operator SigBit() const
	{
		return SigBit(wire, offset);
	}
};

struct DriveBitPort
{
	Cell *cell;
	IdString port;
	int offset;

	DriveBitPort(Cell *cell, IdString port, int offset) : cell(cell), port(port), offset(offset) {}

	bool operator==(const DriveBitPort &other) const
	{
		return cell == other.cell && port == other.port && offset == other.offset;
	}

	bool operator<(const DriveBitPort &other) const
	{
		if (cell != other.cell)
			return cell->name < other.cell->name;
		if (port != other.port)
			return port < other.port;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;

};


struct DriveBitMarker
{
	int marker;
	int offset;

	DriveBitMarker(int marker, int offset) : marker(marker), offset(offset) {}

	bool operator==(const DriveBitMarker &other) const
	{
		return marker == other.marker && offset == other.offset;
	}

	bool operator<(const DriveBitMarker &other) const
	{
		if (marker != other.marker)
			return marker < other.marker;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;

};

struct DriveBitMultiple
{
private:
	pool<DriveBit> multiple_;

public:
	DriveBitMultiple();
	DriveBitMultiple(DriveBit const &single);

	pool<DriveBit> const &multiple() const { return multiple_; }

	void merge(DriveBitMultiple const &other)
	{
		for (DriveBit const &single : other.multiple_)
			merge(single);
	}

	void merge(DriveBitMultiple &&other)
	{
		for (DriveBit &single : other.multiple_)
			merge(std::move(single));
	}

	void merge(DriveBit const &single);
	void merge(DriveBit &&single);

	bool operator==(const DriveBitMultiple &other) const
	{
		return multiple_ == other.multiple_;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;
};

struct DriveBit
{
private:
	DriveType type_ = DriveType::NONE;
	union
	{
		State constant_;
		DriveBitWire wire_;
		DriveBitPort port_;
		DriveBitMarker marker_;
		DriveBitMultiple multiple_;
	};
public:
	DriveBit()  {}

	DriveBit(SigBit const &bit);

	DriveBit(DriveBit const &other) { *this = other; }
	DriveBit(DriveBit &&other) { *this = other; }


	DriveBit(State constant) { *this = constant; }
	DriveBit(DriveBitWire const &wire) { *this = wire; }
	DriveBit(DriveBitWire &&wire) { *this = wire; }
	DriveBit(DriveBitPort const &port) { *this = port; }
	DriveBit(DriveBitPort &&port) { *this = port; }
	DriveBit(DriveBitMarker const &marker) { *this = marker; }
	DriveBit(DriveBitMarker &&marker) { *this = marker; }
	DriveBit(DriveBitMultiple const &multiple) { *this = multiple; }
	DriveBit(DriveBitMultiple &&multiple) { *this = multiple; }

	~DriveBit() { set_none(); }

	void set_none()
	{
		switch (type_)
		{
			case DriveType::NONE:
				break;
			case DriveType::CONSTANT:
				break;
			case DriveType::WIRE:
				wire_.~DriveBitWire();
				break;
			case DriveType::PORT:
				port_.~DriveBitPort();
				break;
			case DriveType::MARKER:
				marker_.~DriveBitMarker();
				break;
			case DriveType::MULTIPLE:
				multiple_.~DriveBitMultiple();
				break;
		}
		type_ = DriveType::NONE;
	}

	DriveBit &operator=(DriveBit const &other)
	{
		switch (other.type_)
		{
			case DriveType::NONE:
				set_none();
				break;
			case DriveType::CONSTANT:
				*this = other.constant_;
				break;
			case DriveType::WIRE:
				*this = other.wire_;
				break;
			case DriveType::PORT:
				*this = other.port_;
				break;
			case DriveType::MARKER:
				*this = other.marker_;
				break;
			case DriveType::MULTIPLE:
				*this = other.multiple_;
				break;
		}
		return *this;
	}

	DriveBit &operator=(DriveBit &&other)
	{
		switch (other.type_)
		{
			case DriveType::NONE:
				set_none();
				break;
			case DriveType::CONSTANT:
				*this = std::move(other.constant_);
				break;
			case DriveType::WIRE:
				*this = std::move(other.wire_);
				break;
			case DriveType::PORT:
				*this = std::move(other.port_);
				break;
			case DriveType::MARKER:
				*this = std::move(other.marker_);
				break;
			case DriveType::MULTIPLE:
				*this = std::move(other.multiple_);
				break;
		}
		return *this;
	}

	DriveBit &operator=(State constant)
	{
		set_none();
		constant_ = constant;
		type_ = DriveType::CONSTANT;
		return *this;
	}

	DriveBit &operator=(DriveBitWire const &wire)
	{
		set_none();
		new (&wire_) DriveBitWire(wire);
		type_ = DriveType::WIRE;
		return *this;
	}

	DriveBit &operator=(DriveBitWire &&wire)
	{
		set_none();
		new (&wire_) DriveBitWire(wire);
		type_ = DriveType::WIRE;
		return *this;
	}

	DriveBit &operator=(DriveBitPort const &port)
	{
		set_none();
		new (&port_) DriveBitPort(port);
		type_ = DriveType::PORT;
		return *this;
	}

	DriveBit &operator=(DriveBitPort &&port)
	{
		set_none();
		new (&port_) DriveBitPort(port);
		type_ = DriveType::PORT;
		return *this;
	}

	DriveBit &operator=(DriveBitMarker const &marker)
	{
		set_none();
		new (&marker_) DriveBitMarker(marker);
		type_ = DriveType::MARKER;
		return *this;
	}

	DriveBit &operator=(DriveBitMarker &&marker)
	{
		set_none();
		new (&marker_) DriveBitMarker(marker);
		type_ = DriveType::MARKER;
		return *this;
	}

	DriveBit &operator=(DriveBitMultiple const &multiple)
	{
		set_none();
		if (multiple.multiple().empty())
			return *this;
		new (&multiple_) DriveBitMultiple(multiple);
		type_ = DriveType::MULTIPLE;
		return *this;
	}

	DriveBit &operator=(DriveBitMultiple &&multiple)
	{
		set_none();
		if (multiple.multiple().empty())
			return *this;
		new (&multiple_) DriveBitMultiple(multiple);
		type_ = DriveType::MULTIPLE;
		return *this;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;

	bool operator==(const DriveBit &other) const
	{
		if (type_ != other.type_)
			return false;

		switch (type_)
		{
			case DriveType::NONE:
				return true;
			case DriveType::CONSTANT:
				return constant_ == other.constant_;
			case DriveType::WIRE:
				return wire_ == other.wire_;
			case DriveType::PORT:
				return port_ == other.port_;
			case DriveType::MARKER:
				return marker_ == other.marker_;
			case DriveType::MULTIPLE:
				return multiple_ == other.multiple_;
		}
		log_abort();
	}

	bool operator!=(const DriveBit &other) const
	{
		return !(*this == other);
	}

	bool operator<(const DriveBit &other) const
	{
		if (type_ != other.type_)
			return type_ < other.type_;
		switch (type_)
		{
			case DriveType::NONE:
				return false;
			case DriveType::CONSTANT:
				return constant_ < other.constant_;
			case DriveType::WIRE:
				return wire_ < other.wire_;
			case DriveType::PORT:
				return port_ < other.port_;
			case DriveType::MARKER:
				return marker_ < other.marker_;
			case DriveType::MULTIPLE:
				log_assert(!"TODO");
		}
		log_abort();
	}


	DriveType type() const { return type_; }

	bool is_none() const { return type_ == DriveType::NONE; }
	bool is_constant() const { return type_ == DriveType::CONSTANT; }
	bool is_wire() const { return type_ == DriveType::WIRE; }
	bool is_port() const { return type_ == DriveType::PORT; }
	bool is_marker() const { return type_ == DriveType::MARKER; }
	bool is_multiple() const { return type_ == DriveType::MULTIPLE; }

	State &constant() { log_assert(is_constant()); return constant_; }
	State const &constant() const { log_assert(is_constant()); return constant_; }
	DriveBitWire &wire() { log_assert(is_wire()); return wire_; }
	DriveBitWire const &wire() const { log_assert(is_wire()); return wire_; }
	DriveBitPort &port() { log_assert(is_port()); return port_; }
	DriveBitPort const &port() const { log_assert(is_port()); return port_; }
	DriveBitMarker &marker() { log_assert(is_marker()); return marker_; }
	DriveBitMarker const &marker() const { log_assert(is_marker()); return marker_; }
	DriveBitMultiple &multiple() { log_assert(is_multiple()); return multiple_; }
	DriveBitMultiple const &multiple() const { log_assert(is_multiple()); return multiple_; }

	void merge(DriveBit const &other);

};

inline DriveBitMultiple::DriveBitMultiple() {}
inline DriveBitMultiple::DriveBitMultiple(DriveBit const &single)
{
	multiple_.emplace(single);
}

struct DriveChunkWire
{
	Wire *wire;
	int offset;
	int width;

	DriveChunkWire(Wire *wire, int offset, int width) : wire(wire), offset(offset), width(width) {}
	DriveChunkWire(DriveBitWire const &bit) : wire(bit.wire), offset(bit.offset), width(1) {}

	int size() const { return width; }

	DriveBitWire operator[](int i) const
	{
		log_assert(i >= 0 && i < width);
		return DriveBitWire(wire, offset + i);
	}

	bool can_append(DriveBitWire const &bit) const;
	bool try_append(DriveBitWire const &bit);
	bool try_append(DriveChunkWire const &chunk);

	// Whether this chunk is a whole wire
	bool is_whole() const { return offset == 0 && width == wire->width; }

	bool operator==(const DriveChunkWire &other) const
	{
		return wire == other.wire && offset == other.offset && width == other.width;
	}

	bool operator<(const DriveChunkWire &other) const
	{
		if (wire != other.wire)
			return wire->name < other.wire->name;
		if (width != other.width)
			return width < other.width;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;

	explicit operator SigChunk() const
	{
		return SigChunk(wire, offset, width);
	}
};

struct DriveChunkPort
{
	Cell *cell;
	IdString port;
	int offset;
	int width;

	DriveChunkPort(Cell *cell, IdString port, int offset, int width) :
		cell(cell), port(port), offset(offset), width(width) { }
	DriveChunkPort(Cell *cell, IdString port) :
		cell(cell), port(port), offset(0), width(GetSize(cell->connections().at(port))) { }
	DriveChunkPort(Cell *cell, std::pair<IdString, SigSpec> const &conn) :
		cell(cell), port(conn.first), offset(0), width(GetSize(conn.second)) { }
	DriveChunkPort(DriveBitPort const &bit) :
		cell(bit.cell), port(bit.port), offset(bit.offset), width(1) { }

	int size() const { return width; }

	DriveBitPort operator[](int i) const
	{
		log_assert(i >= 0 && i < width);
		return DriveBitPort(cell, port, offset + i);
	}

	bool can_append(DriveBitPort const &bit) const;
	bool try_append(DriveBitPort const &bit);
	bool try_append(DriveChunkPort const &chunk);

	// Whether this chunk is a whole port
	bool is_whole() const
	{
		return offset == 0 && width == cell->connections().at(port).size();
	}

	bool operator==(const DriveChunkPort &other) const
	{
		return cell == other.cell && port == other.port && offset == other.offset && width == other.width;
	}

	bool operator<(const DriveChunkPort &other) const
	{
		if (cell != other.cell)
			return cell->name < other.cell->name;
		if (port != other.port)
			return port < other.port;
		if (width != other.width)
			return width < other.width;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;
};


struct DriveChunkMarker
{
	int marker;
	int offset;
	int width;

	DriveChunkMarker(int marker, int offset, int width) :
		marker(marker), offset(offset), width(width) {}
	DriveChunkMarker(DriveBitMarker const &bit) :
		marker(bit.marker), offset(bit.offset), width(1) {}

	int size() const { return width; }

	DriveBitMarker operator[](int i) const
	{
		log_assert(i >= 0 && i < width);
		return DriveBitMarker(marker, offset + i);
	}

	bool can_append(DriveBitMarker const &bit) const;
	bool try_append(DriveBitMarker const &bit);
	bool try_append(DriveChunkMarker const &chunk);

	bool operator==(const DriveChunkMarker &other) const
	{
		return marker == other.marker && offset == other.offset && width == other.width;
	}

	bool operator<(const DriveChunkMarker &other) const
	{
		if (marker != other.marker)
			return marker < other.marker;
		if (width != other.width)
			return width < other.width;
		return offset < other.offset;
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;
};

struct DriveChunkMultiple
{
private:
	mutable pool<DriveChunk> multiple_;
	int width_;

public:
	pool<DriveChunk> const &multiple() const { return multiple_; }

	DriveChunkMultiple(DriveBitMultiple const &bit);

	int size() const { return width_; }

	DriveBitMultiple operator[](int i) const;

	bool can_append(DriveBitMultiple const &bit) const;

	bool try_append(DriveBitMultiple const &bit);


	bool can_append(DriveChunkMultiple const &bit) const;

	bool try_append(DriveChunkMultiple const &bit);

	bool operator==(const DriveChunkMultiple &other) const
	{
		return width_ == other.width_ && multiple_ == other.multiple_;
	}

	bool operator<(const DriveChunkMultiple &other) const
	{
		if (multiple_.size() < other.multiple_.size())

		multiple_.sort();
		return false; // TODO implement, canonicalize order
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;
};

struct DriveChunk
{
private:
	DriveType type_ = DriveType::NONE;
	union
	{
		int none_;
		Const constant_;
		DriveChunkWire wire_;
		DriveChunkPort port_;
		DriveChunkMarker marker_;
		DriveChunkMultiple multiple_;
	};

public:
	DriveChunk() { set_none(); }

	DriveChunk(DriveChunk const &other) { *this = other; }
	DriveChunk(DriveChunk &&other) { *this = other; }

	DriveChunk(DriveBit const &other) { *this = other; }

	DriveChunk(Const const &constant) { *this = constant; }
	DriveChunk(Const &&constant) { *this = constant; }
	DriveChunk(DriveChunkWire const &wire) { *this = wire; }
	DriveChunk(DriveChunkWire &&wire) { *this = wire; }
	DriveChunk(DriveChunkPort const &port) { *this = port; }
	DriveChunk(DriveChunkPort &&port) { *this = port; }
	DriveChunk(DriveChunkMarker const &marker) { *this = marker; }
	DriveChunk(DriveChunkMarker &&marker) { *this = marker; }
	DriveChunk(DriveChunkMultiple const &multiple) { *this = multiple; }
	DriveChunk(DriveChunkMultiple &&multiple) { *this = multiple; }

	~DriveChunk() { set_none(); }

	DriveBit operator[](int i) const
	{
		switch (type_)
		{
			case DriveType::NONE:
				return DriveBit();
			case DriveType::CONSTANT:
				return constant_[i];
			case DriveType::WIRE:
				return wire_[i];
			case DriveType::PORT:
				return port_[i];
			case DriveType::MARKER:
				return marker_[i];
			case DriveType::MULTIPLE:
				return multiple_[i];
		}
		log_abort();
	}

	void set_none(int width = 0)
	{
		switch (type_)
		{
			case DriveType::NONE:
				none_ = width;
				break;
			case DriveType::CONSTANT:
				constant_.~Const();
				break;
			case DriveType::WIRE:
				wire_.~DriveChunkWire();
				break;
			case DriveType::PORT:
				port_.~DriveChunkPort();
				break;
			case DriveType::MARKER:
				marker_.~DriveChunkMarker();
				break;
			case DriveType::MULTIPLE:
				multiple_.~DriveChunkMultiple();
				break;
		}
		type_ = DriveType::NONE;
		none_ = width;
	}

	DriveChunk &operator=(DriveChunk const &other)
	{
		switch (other.type_)
		{
			case DriveType::NONE:
				set_none(other.none_);
				break;
			case DriveType::CONSTANT:
				*this = other.constant_;
				break;
			case DriveType::WIRE:
				*this = other.wire_;
				break;
			case DriveType::PORT:
				*this = other.port_;
				break;
			case DriveType::MARKER:
				*this = other.marker_;
				break;
			case DriveType::MULTIPLE:
				*this = other.multiple_;
				break;
		}
		return *this;
	}

	DriveChunk &operator=(DriveChunk &&other)
	{
		switch (other.type_)
		{
			case DriveType::NONE:
				set_none(other.none_);
				break;
			case DriveType::CONSTANT:
				*this = std::move(other.constant_);
				break;
			case DriveType::WIRE:
				*this = std::move(other.wire_);
				break;
			case DriveType::PORT:
				*this = std::move(other.port_);
				break;
			case DriveType::MARKER:
				*this = std::move(other.marker_);
				break;
			case DriveType::MULTIPLE:
				*this = std::move(other.multiple_);
				break;
		}
		return *this;
	}

	DriveChunk &operator=(Const const &constant)
	{
		set_none();
		new (&constant_) Const(constant);
		type_ = DriveType::CONSTANT;
		return *this;
	}

	DriveChunk &operator=(Const &&constant)
	{
		set_none();
		new (&constant_) Const(std::move(constant));
		type_ = DriveType::CONSTANT;
		return *this;
	}

	DriveChunk &operator=(DriveChunkWire const &wire)
	{
		set_none();
		new (&wire_) DriveChunkWire(wire);
		type_ = DriveType::WIRE;
		return *this;
	}

	DriveChunk &operator=(DriveChunkWire &&wire)
	{
		set_none();
		new (&wire_) DriveChunkWire(wire);
		type_ = DriveType::WIRE;
		return *this;
	}

	DriveChunk &operator=(DriveChunkPort const &port)
	{
		set_none();
		new (&port_) DriveChunkPort(port);
		type_ = DriveType::PORT;
		return *this;
	}

	DriveChunk &operator=(DriveChunkPort &&port)
	{
		set_none();
		new (&port_) DriveChunkPort(port);
		type_ = DriveType::PORT;
		return *this;
	}

	DriveChunk &operator=(DriveChunkMarker const &marker)
	{
		set_none();
		new (&marker_) DriveChunkMarker(marker);
		type_ = DriveType::MARKER;
		return *this;
	}

	DriveChunk &operator=(DriveChunkMarker &&marker)
	{
		set_none();
		new (&marker_) DriveChunkMarker(marker);
		type_ = DriveType::MARKER;
		return *this;
	}

	DriveChunk &operator=(DriveChunkMultiple const &multiple)
	{
		set_none(multiple.size());
		if (multiple.multiple().empty())
			return *this;
		new (&multiple_) DriveChunkMultiple(multiple);
		type_ = DriveType::MULTIPLE;
		return *this;
	}

	DriveChunk &operator=(DriveChunkMultiple &&multiple)
	{
		set_none(multiple.size());
		if (multiple.multiple().empty())
			return *this;
		new (&multiple_) DriveChunkMultiple(multiple);
		type_ = DriveType::MULTIPLE;
		return *this;
	}

	DriveChunk &operator=(DriveBit const &other)
	{
		switch (other.type())
		{
			case DriveType::NONE:
				set_none(1);
				break;
			case DriveType::CONSTANT:
				*this = Const(other.constant());
				break;
			case DriveType::WIRE:
				*this = DriveChunkWire(other.wire());
				break;
			case DriveType::PORT:
				*this = DriveChunkPort(other.port());
				break;
			case DriveType::MARKER:
				*this = DriveChunkMarker(other.marker());
				break;
			case DriveType::MULTIPLE:
				*this = DriveChunkMultiple(other.multiple());
				break;
		}
		return *this;
	}

	bool can_append(DriveBit const &bit) const;
	bool try_append(DriveBit const &bit);
	bool try_append(DriveChunk const &chunk);

	[[nodiscard]] Hasher hash_into(Hasher h) const;

	bool operator==(const DriveChunk &other) const
	{
		if (type_ != other.type_)
			return false;

		switch (type_)
		{
			case DriveType::NONE:
				return true;
			case DriveType::CONSTANT:
				return constant_ == other.constant_;
			case DriveType::WIRE:
				return wire_ == other.wire_;
			case DriveType::PORT:
				return port_ == other.port_;
			case DriveType::MARKER:
				return marker_ == other.marker_;
			case DriveType::MULTIPLE:
				return multiple_ == other.multiple_;
		}
		log_abort();
	}

	bool operator!=(const DriveChunk &other) const
	{
		return !(*this == other);
	}

	bool operator<(const DriveChunk &other) const
	{
		if (type_ != other.type_)
			return type_ < other.type_;
		switch (type_)
		{
			case DriveType::NONE:
				return false;
			case DriveType::CONSTANT:
				return constant_ < other.constant_;
			case DriveType::WIRE:
				return wire_ < other.wire_;
			case DriveType::PORT:
				return port_ < other.port_;
			case DriveType::MARKER:
				return marker_ < other.marker_;
			case DriveType::MULTIPLE:
				return multiple_ < other.multiple_;
		}
		log_abort();
	}

	DriveType type() const { return type_; }

	bool is_none() const { return type_ == DriveType::NONE; }
	bool is_constant() const { return type_ == DriveType::CONSTANT; }
	bool is_wire() const { return type_ == DriveType::WIRE; }
	bool is_port() const { return type_ == DriveType::PORT; }
	bool is_marker() const { return type_ == DriveType::MARKER; }
	bool is_multiple() const { return type_ == DriveType::MULTIPLE; }

	Const &constant() { log_assert(is_constant()); return constant_; }
	Const const &constant() const { log_assert(is_constant()); return constant_; }
	DriveChunkWire &wire() { log_assert(is_wire()); return wire_; }
	DriveChunkWire const &wire() const { log_assert(is_wire()); return wire_; }
	DriveChunkPort &port() { log_assert(is_port()); return port_; }
	DriveChunkPort const &port() const { log_assert(is_port()); return port_; }
	DriveChunkMarker &marker() { log_assert(is_marker()); return marker_; }
	DriveChunkMarker const &marker() const { log_assert(is_marker()); return marker_; }
	DriveChunkMultiple &multiple() { log_assert(is_multiple()); return multiple_; }
	DriveChunkMultiple const &multiple() const { log_assert(is_multiple()); return multiple_; }


	int size() const
	{
		switch (type_)
		{
			case DriveType::NONE:
				return none_;
			case DriveType::CONSTANT:
				return constant_.size();
			case DriveType::WIRE:
				return wire_.size();
			case DriveType::PORT:
				return port_.size();
			case DriveType::MARKER:
				return marker_.size();
			case DriveType::MULTIPLE:
				return multiple_.size();
		}
		log_abort();
	}
};

inline DriveChunkMultiple::DriveChunkMultiple(DriveBitMultiple const &bit)
	: width_(1)
{
	for (auto const &bit : bit.multiple())
		multiple_.emplace(bit);
}

struct DriveSpec
{
private:
	int width_ = 0;
	mutable std::vector<DriveChunk> chunks_;
	mutable std::vector<DriveBit> bits_;
	mutable unsigned int hash_ = 0;
public:

	inline bool packed() const {
		return bits_.empty();
	}

	DriveSpec() {}

	DriveSpec(DriveChunk const &chunk) { *this = chunk; }
	DriveSpec(DriveChunkWire const &chunk) { *this = chunk; }
	DriveSpec(DriveChunkPort const &chunk) { *this = chunk; }
	DriveSpec(DriveChunkMarker const &chunk) { *this = chunk; }
	DriveSpec(DriveChunkMultiple const &chunk) { *this = chunk; }

	DriveSpec(DriveBit const &bit) { *this = bit; }
	DriveSpec(DriveBitWire const &bit) { *this = bit; }
	DriveSpec(DriveBitPort const &bit) { *this = bit; }
	DriveSpec(DriveBitMarker const &bit) { *this = bit; }
	DriveSpec(DriveBitMultiple const &bit) { *this = bit; }

	DriveSpec(std::vector<DriveChunk> const &chunks) : chunks_(chunks) { compute_width(); }

	DriveSpec(std::vector<DriveBit> const &bits)
	{
		for (auto const &bit : bits)
			append(bit);
	}

	DriveSpec(SigSpec const &sig)
	{
		// TODO: converting one chunk at a time would be faster
		for (auto const &bit : sig.bits())
			append(bit);
	}

	std::vector<DriveChunk> const &chunks() const { pack(); return chunks_; }
	std::vector<DriveBit> const &bits() const { unpack(); return bits_; }

	int size() const { return width_; }

	void append(DriveBit const &bit);

	void append(DriveChunk const &chunk);

	void pack() const;

	void unpack() const;

	DriveBit &operator[](int index)
	{
		log_assert(index >= 0 && index < size());
		unpack();
		return bits_[index];
	}

	const DriveBit &operator[](int index) const
	{
		log_assert(index >= 0 && index < size());
		unpack();
		return bits_[index];
	}

	void clear()
	{
		chunks_.clear();
		bits_.clear();
		width_ = 0;
	}

	DriveSpec &operator=(DriveChunk const &chunk)
	{
		chunks_.clear();
		bits_.clear();
		append(chunk);
		return *this;
	}

	DriveSpec &operator=(DriveChunkWire const &chunk) { return *this = DriveChunk(chunk); }
	DriveSpec &operator=(DriveChunkPort const &chunk) { return *this = DriveChunk(chunk); }
	DriveSpec &operator=(DriveChunkMarker const &chunk) { return *this = DriveChunk(chunk); }
	DriveSpec &operator=(DriveChunkMultiple const &chunk) { return *this = DriveChunk(chunk); }

	DriveSpec &operator=(DriveBit const &bit)
	{
		chunks_.clear();
		bits_.clear();
		append(bit);
		return *this;
	}

	DriveSpec &operator=(DriveBitWire const &bit) { return *this = DriveBit(bit); }
	DriveSpec &operator=(DriveBitPort const &bit) { return *this = DriveBit(bit); }
	DriveSpec &operator=(DriveBitMarker const &bit) { return *this = DriveBit(bit); }
	DriveSpec &operator=(DriveBitMultiple const &bit) { return *this = DriveBit(bit); }

	void updhash() const {
		if (hash_ != 0)
			return;
		pack();
		hash_ = run_hash(chunks_);
		hash_ |= (hash_ == 0);
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const;

	bool operator==(DriveSpec const &other) const {
		updhash();
		other.updhash();
		if (size() != other.size() || hash_ != other.hash_)
			return false;
		return chunks() == other.chunks();
	}

private:
	void compute_width();
};



struct DriverMap
{
	CellTypes celltypes;

	DriverMap() { celltypes.setup(); }
	DriverMap(Design *design) { celltypes.setup(); celltypes.setup_design(design); }

private:

	// Internally we represent all DriveBits by mapping them to DriveBitIds
	// which use less memory and are cheaper to compare.
	struct DriveBitId
	{
		int id = -1;

		DriveBitId() {};

		DriveBitId(int id) : id(id) { }

		bool operator==(const DriveBitId &other) const { return id == other.id; }
		bool operator!=(const DriveBitId &other) const { return id != other.id; }
		bool operator<(const DriveBitId &other) const { return id < other.id; }
		[[nodiscard]] Hasher hash_into(Hasher h) const;
	};
	// Essentially a dict<DriveBitId, pool<DriveBitId>> but using less memory
	// and fewer allocations
	struct DriveBitGraph {
		dict<DriveBitId, DriveBitId> first_edges;
		dict<DriveBitId, DriveBitId> second_edges;
		dict<DriveBitId, pool<DriveBitId>> more_edges;

		void add_edge(DriveBitId src, DriveBitId dst);
		DriveBitId pop_edge(DriveBitId src);
		void clear(DriveBitId src);
		bool contains(DriveBitId src);
		int count(DriveBitId src);

		DriveBitId at(DriveBitId src, int index);
	};

	// The following two maps maintain a sparse DriveBit to DriveBitId mapping.
	// This saves a lot of memory compared to a \`dict<DriveBit, DriveBitId>\` or
	// \`idict<DriveBit>\`.

	// Maps wires to the first DriveBitId of the consecutive range used for
	// that wire.
	dict<Wire *, DriveBitId> wire_offsets;

	// Maps cell ports to a the first DriveBitId of the consecutive range used
	// for that cell port.
	dict<pair<Cell *, IdString>, DriveBitId> port_offsets;

	// For the inverse map that maps DriveBitIds back to DriveBits we use a
	// sorted map containing only the first DriveBit for each wire and cell
	// port.
	std::map<DriveBitId, DriveBit> drive_bits;

	// As a memory optimization for gate level net lists we store single-bit
	// wires and cell ports in a \`dict\` which requires less memory and fewer
	// allocations than \`std::map\` but doesn't support the kind of lookups we
	// need for a sparse coarse grained mapping.
	dict<DriveBitId, DriveBit> isolated_drive_bits;

	// Used for allocating DriveBitIds, none and constant states use a fixewd
	// mapping to the first few ids, which we need to skip.
	int next_offset = 1 + (int)State::Sm;

	// Union-Find over directly connected bits that share the same single
	// driver or are undriven. We never merge connections between drivers
	// and/or kept wires.
	mfp<DriveBitId> same_driver;

	// For each bit, store a set of connected driver bits for which the
	// explicit connection should be preserved and the driving direction is
	// locally unambiguous (one side only drives or requires a driven value).
	DriveBitGraph connected_drivers;

	// For each bit, store a set of connected driver bits for which the
	// explicit connection should be preserved and the driving direction is
	// locally ambiguous. Every such ambiguous connection is also present in
	// the reverse direction and has to be resolved when querying drivers.
	DriveBitGraph connected_undirected;

	// Subset of \`connected_undirected\` for caching the resolved driving
	// direction. In case multiple drivers are present this can still contain
	// both orientations of a single connection, but for a single driver only
	// one will be present.
	DriveBitGraph connected_oriented;

	// Stores for which bits we already resolved the orientation (cached in
	// \`connected_oriented\`).
	pool<DriveBitId> oriented_present;


	enum class BitMode {
		NONE = 0, // Not driven, no need to keep wire
		DRIVEN = 1, // Not driven, uses a value driven elsewhere
		DRIVEN_UNIQUE = 2, // Uses a value driven elsewhere, has at most one direct connection
		KEEP = 3, // Wire that should be kept
		TRISTATE = 4, // Can drive a value but can also use a value driven elsewhere
		DRIVER = 5, // Drives a value
	};

	BitMode bit_mode(DriveBit const &bit);
	DriveBitId id_from_drive_bit(DriveBit const &bit);
	DriveBit drive_bit_from_id(DriveBitId id);

	void connect_directed_merge(DriveBitId driven_id, DriveBitId driver_id);
	void connect_directed_buffer(DriveBitId driven_id, DriveBitId driver_id);
	void connect_undirected(DriveBitId a_id, DriveBitId b_id);

public:

	void add(Module *module);

	// Add a single bit connection to the driver map.
	void add(DriveBit const &a, DriveBit const &b);

	template<typename T>
	static constexpr bool is_sig_type() {
		return
			std::is_same<T, SigSpec>::value ||
			std::is_same<T, SigChunk>::value ||
			std::is_same<T, DriveSpec>::value ||
			std::is_same<T, DriveChunk>::value ||
			std::is_same<T, DriveChunkPort>::value ||
			std::is_same<T, DriveChunkWire>::value ||
			std::is_same<T, Const>::value;
	}

	// We use the enable_if to produce better compiler errors when unsupported
	// types are used
	template<typename T, typename U>
	typename std::enable_if<is_sig_type<T>() && is_sig_type<U>()>::type
	add(T const &a, U const &b)
	{
		log_assert(a.size() == b.size());
		for (int i = 0; i != GetSize(a); ++i)
			add(DriveBit(a[i]), DriveBit(b[i]));
	}


	// Specialized version that avoids unpacking
	void add(SigSpec const &a, SigSpec const &b);

private:
	void add_port(Cell *cell, IdString const &port, SigSpec const &b);

	// Only used a local variables in \`orient_undirected\`, always cleared, only
	// stored to reduce allocations.
	pool<DriveBitId> orient_undirected_seen;
	pool<DriveBitId> orient_undirected_drivers;
	dict<DriveBitId, int> orient_undirected_distance;

	void orient_undirected(DriveBitId id);

public:
	DriveBit operator()(DriveBit const &bit);

	DriveSpec operator()(DriveSpec spec);

private:
	bool keep_wire(Wire *wire) {
		// TODO configurable
		return wire->has_attribute(ID(keep));
	}
};

inline Hasher DriveBitWire::hash_into(Hasher h) const
{
	h.eat(wire->name);
	h.eat(offset);
	return h;
}

inline Hasher DriveBitPort::hash_into(Hasher h) const
{
	h.eat(cell->name);
	h.eat(port);
	h.eat(offset);
	return h;
}

inline Hasher DriveBitMarker::hash_into(Hasher h) const
{
	h.eat(marker);
	h.eat(offset);
	return h;
}

inline Hasher DriveBitMultiple::hash_into(Hasher h) const
{
	h.eat(multiple_);
	return h;
}

inline Hasher DriveBit::hash_into(Hasher h) const
{
	switch (type_) {
	case DriveType::NONE:
		h.eat(0);
		break;
	case DriveType::CONSTANT:
		h.eat(constant_);
		break;
	case DriveType::WIRE:
		h.eat(wire_);
		break;
	case DriveType::PORT:
		h.eat(port_);
		break;
	case DriveType::MARKER:
		h.eat(marker_);
		break;
	case DriveType::MULTIPLE:
		h.eat(multiple_);
		break;
	}
	h.eat(type_);
	return h;
}

inline Hasher DriveChunkWire::hash_into(Hasher h) const
{
	h.eat(wire->name);
	h.eat(width);
	h.eat(offset);
	return h;
}

inline Hasher DriveChunkPort::hash_into(Hasher h) const
{
	h.eat(cell->name);
	h.eat(port);
	h.eat(width);
	h.eat(offset);
	return h;
}

inline Hasher DriveChunkMarker::hash_into(Hasher h) const
{
	h.eat(marker);
	h.eat(width);
	h.eat(offset);
	return h;
}

inline Hasher DriveChunkMultiple::hash_into(Hasher h) const
{
	h.eat(width_);
	h.eat(multiple_);
	return h;
}

inline Hasher DriveChunk::hash_into(Hasher h) const
{
	switch (type_) {
	case DriveType::NONE:
		h.eat(0);
		break;
	case DriveType::CONSTANT:
		h.eat(constant_);
		break;
	case DriveType::WIRE:
		h.eat(wire_);
		break;
	case DriveType::PORT:
		h.eat(port_);
		break;
	case DriveType::MARKER:
		h.eat(marker_);
		break;
	case DriveType::MULTIPLE:
		h.eat(multiple_);
		break;
	}
	h.eat(type_);
	return h;
}

inline Hasher DriveSpec::hash_into(Hasher h) const
{
	updhash();
	h.eat(hash_);
	return h;
}

inline Hasher DriverMap::DriveBitId::hash_into(Hasher h) const
{
	h.eat(id);
	return h;
}

YOSYS_NAMESPACE_END

#endif
`,"ff.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FF_H
#define FF_H

#include "kernel/yosys.h"
#include "kernel/ffinit.h"

YOSYS_NAMESPACE_BEGIN

// Describes a flip-flop or a latch.
//
// If has_gclk, this is a formal verification FF with implicit global clock:
// Q is simply previous cycle's D. Additionally if is_anyinit is true, this is
// an $anyinit cell which always has an undefined initialization value. Note
// that $anyinit is not considered to be among the FF celltypes, so a pass has
// to explicitly opt-in to process $anyinit cells with FfData.
//
// Otherwise, the FF/latch can have any number of features selected by has_*
// attributes that determine Q's value (in order of decreasing priority):
//
// - on start, register is initialized to val_init
// - if has_sr is present:
//   - sig_clr is per-bit async clear, and sets the corresponding bit to 0
//     if active
//   - sig_set is per-bit async set, and sets the corresponding bit to 1
//     if active
// - if has_arst is present:
//   - sig_arst is whole-reg async reset, and sets the whole register to val_arst
// - if has_aload is present:
//   - sig_aload is whole-reg async load (aka latch gate enable), and sets the whole
//     register to sig_ad
// - if has_clk is present, and we're currently on a clock edge:
//   - if has_ce is present and ce_over_srst is true:
//     - ignore clock edge (don't change value) unless sig_ce is active
//   - if has_srst is present:
//     - sig_srst is whole-reg sync reset and sets the register to val_srst
//   - if has_ce is present and ce_over_srst is false:
//     - ignore clock edge (don't change value) unless sig_ce is active
//   - set whole reg to sig_d
// - if nothing of the above applies, the reg value remains unchanged
//
// Since the yosys FF cell library isn't fully generic, not all combinations
// of the features above can be supported:
//
// - only one of has_srst, has_arst, has_sr can be used
// - if has_clk is used together with has_aload, then has_srst, has_arst,
//   has_sr cannot be used
//
// The valid feature combinations are thus:
//
// - has_clk + optional has_ce [dff/dffe]
// - has_clk + optional has_ce + has_arst [adff/adffe]
// - has_clk + optional has_ce + has_aload [aldff/aldffe]
// - has_clk + optional has_ce + has_sr [dffsr/dffsre]
// - has_clk + optional has_ce + has_srst [sdff/sdffe/sdffce]
// - has_aload [dlatch]
// - has_aload + has_arst [adlatch]
// - has_aload + has_sr [dlatchsr]
// - has_sr [sr]
// - has_arst [does not correspond to a native cell, represented as dlatch with const D input]
// - empty set [not a cell \u2014 will be emitted as a simple direct connection]

struct FfData {
	Module *module;
	FfInitVals *initvals;
	Cell *cell;
	IdString name;
	// The FF output.
	SigSpec sig_q;
	// The sync data input, present if has_clk or has_gclk.
	SigSpec sig_d;
	// The async data input, present if has_aload.
	SigSpec sig_ad;
	// The sync clock, present if has_clk.
	SigSpec sig_clk;
	// The clock enable, present if has_ce.
	SigSpec sig_ce;
	// The async load enable, present if has_aload.
	SigSpec sig_aload;
	// The async reset, preset if has_arst.
	SigSpec sig_arst;
	// The sync reset, preset if has_srst.
	SigSpec sig_srst;
	// The async clear (per-lane), present if has_sr.
	SigSpec sig_clr;
	// The async set (per-lane), present if has_sr.
	SigSpec sig_set;
	// True if this is a clocked (edge-sensitive) flip-flop.
	bool has_clk;
	// True if this is a $ff, exclusive with every other has_*.
	bool has_gclk;
	// True if this FF has a clock enable.  Depends on has_clk.
	bool has_ce;
	// True if this FF has async load function \u2014 this includes D latches.
	// If this and has_clk are both set, has_arst and has_sr cannot be set.
	bool has_aload;
	// True if this FF has sync set/reset.  Depends on has_clk, exclusive
	// with has_arst, has_sr, has_aload.
	bool has_srst;
	// True if this FF has async set/reset.  Exclusive with has_srst,
	// has_sr.  If this and has_clk are both set, has_aload cannot be set.
	bool has_arst;
	// True if this FF has per-bit async set + clear.  Exclusive with
	// has_srst, has_arst.  If this and has_clk are both set, has_aload
	// cannot be set.
	bool has_sr;
	// If has_ce and has_srst are both set, determines their relative
	// priorities: if true, inactive ce disables srst; if false, srst
	// operates independent of ce.
	bool ce_over_srst;
	// True if this FF is a fine cell, false if it is a coarse cell.
	// If true, width must be 1.
	bool is_fine;
	// True if this FF is an $anyinit cell.  Depends on has_gclk.
	bool is_anyinit;
	// Polarities, corresponding to sig_*.
	// True means rising edge, false means falling edge.
	bool pol_clk;
	// True means active-high, false
	// means active-low.
	bool pol_ce;
	bool pol_aload;
	bool pol_arst;
	bool pol_srst;
	bool pol_clr;
	bool pol_set;
	// The value loaded by sig_arst.
	Const val_arst;
	// The value loaded by sig_srst.
	Const val_srst;
	// The initial value at power-up.
	Const val_init;
	// The FF data width in bits.
	int width;
	dict<IdString, Const> attributes;

	FfData(Module *module = nullptr, FfInitVals *initvals = nullptr, IdString name = IdString()) : module(module), initvals(initvals), cell(nullptr), name(name) {
		width = 0;
		has_clk = false;
		has_gclk = false;
		has_ce = false;
		has_aload = false;
		has_srst = false;
		has_arst = false;
		has_sr = false;
		ce_over_srst = false;
		is_fine = false;
		is_anyinit = false;
		pol_clk = false;
		pol_aload = false;
		pol_ce = false;
		pol_arst = false;
		pol_srst = false;
		pol_clr = false;
		pol_set = false;
	}

	FfData(FfInitVals *initvals, Cell *cell_);

	// Returns a FF identical to this one, but only keeping bit indices from the argument.
	FfData slice(const std::vector<int> &bits);

	void add_dummy_ce();
	void add_dummy_srst();
	void add_dummy_arst();
	void add_dummy_aload();
	void add_dummy_sr();
	void add_dummy_clk();

	void arst_to_aload();
	void arst_to_sr();

	void aload_to_sr();

	// Given a FF with both has_ce and has_srst, sets ce_over_srst to the given value and
	// fixes up control signals appropriately to preserve semantics.
	void convert_ce_over_srst(bool val);

	void unmap_ce();
	void unmap_srst();

	void unmap_ce_srst() {
		unmap_ce();
		unmap_srst();
	}

	Cell *emit();

	// Removes init attribute from the Q output, but keeps val_init unchanged.
	// It will be automatically reattached on emit.  Use this before changing sig_q.
	void remove_init() {
		if (initvals)
			initvals->remove_init(sig_q);
	}

	void remove();

	// Flip the sense of the given bit slices of the FF: insert inverters on data
	// inputs and output, flip the corresponding init/reset bits, swap clr/set
	// inputs with proper priority fix.
	void flip_bits(const pool<int> &bits);

	void flip_rst_bits(const pool<int> &bits);
};

YOSYS_NAMESPACE_END

#endif
`,"ffinit.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FFINIT_H
#define FFINIT_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"

YOSYS_NAMESPACE_BEGIN

struct FfInitVals
{
	const SigMap *sigmap;
	dict<SigBit, std::pair<State,SigBit>> initbits;

	void set(const SigMap *sigmap_, RTLIL::Module *module)
	{
		sigmap = sigmap_;
		initbits.clear();
		for (auto wire : module->wires())
		{
			if (wire->attributes.count(ID::init) == 0)
				continue;

			SigSpec wirebits = (*sigmap)(wire);
			Const initval = wire->attributes.at(ID::init);

			for (int i = 0; i < GetSize(wirebits) && i < GetSize(initval); i++)
			{
				SigBit bit = wirebits[i];
				State val = initval[i];

				if (val != State::S0 && val != State::S1 && bit.wire != nullptr)
					continue;

				if (initbits.count(bit)) {
					if (initbits.at(bit).first != val)
						log_error("Conflicting init values for signal %s (%s = %s != %s).\\n",
								log_signal(bit), log_signal(SigBit(wire, i)),
								log_signal(val), log_signal(initbits.at(bit).first));
					continue;
				}

				initbits[bit] = std::make_pair(val,SigBit(wire,i));
			}
		}
	}

	RTLIL::State operator()(RTLIL::SigBit bit) const
	{
		auto it = initbits.find((*sigmap)(bit));
		if (it != initbits.end())
			return it->second.first;
		else
			return State::Sx;
	}

	RTLIL::Const operator()(const RTLIL::SigSpec &sig) const
	{
		RTLIL::Const res;
		for (auto bit : sig)
			res.bits().push_back((*this)(bit));
		return res;
	}

	void set_init(RTLIL::SigBit bit, RTLIL::State val)
	{
		SigBit mbit = (*sigmap)(bit);
		SigBit abit = bit;
		auto it = initbits.find(mbit);
		if (it != initbits.end())
			abit = it->second.second;
		else if (val == State::Sx)
			return;
		log_assert(abit.wire);
		initbits[mbit] = std::make_pair(val,abit);
		auto it2 = abit.wire->attributes.find(ID::init);
		if (it2 != abit.wire->attributes.end()) {
			it2->second.bits()[abit.offset] = val;
			if (it2->second.is_fully_undef())
				abit.wire->attributes.erase(it2);
		} else if (val != State::Sx) {
			Const cval(State::Sx, GetSize(abit.wire));
			cval.bits()[abit.offset] = val;
			abit.wire->attributes[ID::init] = cval;
		}
	}

	void set_init(const RTLIL::SigSpec &sig, RTLIL::Const val)
	{
		log_assert(GetSize(sig) == GetSize(val));
		for (int i = 0; i < GetSize(sig); i++)
			set_init(sig[i], val[i]);
	}

	void remove_init(RTLIL::SigBit bit)
	{
		set_init(bit, State::Sx);
	}

	void remove_init(const RTLIL::SigSpec &sig)
	{
		for (auto bit : sig)
			remove_init(bit);
	}

	void clear()
	{
		initbits.clear();
	}

	FfInitVals (const SigMap *sigmap, RTLIL::Module *module)
	{
		set(sigmap, module);
	}

	FfInitVals () {}
};


YOSYS_NAMESPACE_END

#endif
`,"ffmerge.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FFMERGE_H
#define FFMERGE_H

#include "kernel/ffinit.h"
#include "kernel/ff.h"

YOSYS_NAMESPACE_BEGIN

// A helper class for passes that want to merge FFs on the input or output
// of a cell into the cell itself.
//
// The procedure is:
//
// 1. Construct this class (at beginning of processing for a given module).
// 2. For every considered cell:
//
//    a. Call find_output_ff for every considered output.
//    b. Call find_input_ff for every considered input.
//    c. Look at the FF description returned (if any) from each call, reject
//       results that cannot be merged into given cell for any reason.
//       If both inputs and outputs are being merged, take care of FF bits that
//       are returned in both input and output results (a FF bit cannot be
//       merged to both).  Decide on the final set of FF bits to merge.
//    d. Call remove_output_ff for every find_output_ff result that will be used
//       for merging.  This removes the actual FF bits from design and from index.
//    e. Call mark_input_ff for every find_input_ff result that will be used
//       for merging.  This updates the index disallowing further usage of these
//       FF bits for output FF merging, if they were eligible before.  The actual
//       FF bits are still left in the design and can be merged into other inputs.
//       If the FF bits are not otherwise used, they will be removed by later
//       opt passes.
//    f. Merge the FFs into the cell.
//
// Note that, if both inputs and outputs are being considered for merging in
// a single pass, the result may be nondeterministic (depending on cell iteration
// order) because a given FF bit could be eligible for both input and output merge,
// perhaps in different cells.  For this reason, it may be a good idea to separate
// input and output merging.

struct FfMergeHelper
{
	const SigMap *sigmap;
	RTLIL::Module *module;
	FfInitVals *initvals;

	dict<SigBit, std::pair<Cell*, int>> dff_driver;
	dict<SigBit, pool<std::pair<Cell*, int>>> dff_sink;
	dict<SigBit, int> sigbit_users_count;

	// Returns true if all bits in sig are completely unused.
	bool is_output_unused(RTLIL::SigSpec sig);

	// Finds the FF to merge into a given cell output.  Takes sig, which
	// is the current cell output \u2014 it will be the sig_d of the found FF.
	// If found, returns true, and fills the two output arguments.
	//
	// For every bit of sig, this function finds a FF bit that has
	// the same sig_d, and fills the output FfData according to the FF
	// bits found.  This function will only consider FF bits that are
	// the only user of the given sig bits \u2014 if any bit in sig is used
	// by anything other than a single FF, this function will return false.
	//
	// The returned FfData structure does not correspond to any actual FF
	// cell in the design \u2014 it is the amalgamation of extracted FF bits,
	// possibly coming from several FF cells.
	//
	// If some of the bits in sig have no users at all, this function
	// will accept them as well (and fill returned FfData with dummy values
	// for the given bit, effectively synthesizing an unused FF bit of the
	// appropriate type).  However, if all bits in sig are completely
	// unused, this function will fail and return false (having no idea
	// what kind of FF to produce) \u2014 use the above helper if that case
	// is important to handle.
	//
	// Note that this function does not remove the FF bits returned from
	// the design \u2014 this is so that the caller can decide whether to accept
	// this FF for merging or not.  If the result is accepted,
	// remove_output_ff should be called on the second output argument.
	bool find_output_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);

	// Like above, but returns a FF to merge into a given cell input.  Takes
	// sig_q, which is the current cell input \u2014 it will search for FFs with
	// matching sig_q.
	//
	// As opposed to find_output_ff, this function doesn't care about usage
	// counts, and may return FF bits that also have other fanout.  This
	// should not be a problem for input FF merging.
	//
	// As a special case, if some of the bits in sig_q are constant, this
	// function will accept them as well, by synthesizing in-place
	// a constant-input FF bit (with matching initial value and reset value).
	// However, this will not work if the input is all-constant \u2014 if the caller
	// cares about this case, it needs to check for it explicitely.
	bool find_input_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);

	// To be called on find_output_ff result that will be merged.  This
	// marks the given FF bits as used up (and not to be considered for
	// further merging as inputs), and reconnects their Q ports to a dummy
	// wire (since the wire previously connected there will now be driven
	// by the merged-to cell instead).
	void remove_output_ff(const pool<std::pair<Cell *, int>> &bits);

	// To be called on find_input_ff result that will be merged.  This
	// marks the given FF bits as used, and disallows merging them as
	// outputs.  They can, however, still be merged as inputs again
	// (perhaps for another cell).
	void mark_input_ff(const pool<std::pair<Cell *, int>> &bits);

	void set(FfInitVals *initvals_, RTLIL::Module *module_);

	void clear();

	FfMergeHelper(FfInitVals *initvals, RTLIL::Module *module) {
		set(initvals, module);
	}

	FfMergeHelper() {}
};

YOSYS_NAMESPACE_END

#endif
`,"fmt.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FMT_H
#define FMT_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

// Verilog format argument, such as the arguments in:
//   $display("foo %d bar %01x", 4'b0, $signed(2'b11))
struct VerilogFmtArg {
	enum {
		STRING  = 0,
		INTEGER = 1,
		TIME    = 2,
	} type;

	// All types
	std::string filename;
	unsigned first_line;

	// STRING type
	std::string str;

	// INTEGER type
	RTLIL::SigSpec sig;
	bool signed_ = false;

	// TIME type
	bool realtime = false;
};

// RTLIL format part, such as the substitutions in:
//   "foo {4:> 4du} bar {2:<01hs}"
// Must be kept in sync with \`struct fmt_part\` in backends/cxxrtl/runtime/cxxrtl/cxxrtl.h!
struct FmtPart {
	enum {
		LITERAL  	= 0,
		INTEGER 	= 1,
		STRING    = 2,
		UNICHAR   = 3,
		VLOG_TIME = 4,
	} type;

	// LITERAL type
	std::string str;

	// INTEGER/STRING/UNICHAR types
	RTLIL::SigSpec sig;

	// INTEGER/STRING/VLOG_TIME types
	enum {
		RIGHT	= 0,
		LEFT	= 1,
		NUMERIC	= 2,
	} justify = RIGHT;
	char padding = '\\0';
	size_t width = 0;

	// INTEGER type
	unsigned base = 10;
	bool signed_ = false;
	enum {
		MINUS		= 0,
		PLUS_MINUS	= 1,
		SPACE_MINUS	= 2,
	} sign = MINUS;
	bool hex_upper = false;
	bool show_base = false;
	bool group = false;

	// VLOG_TIME type
	bool realtime = false;
};

struct Fmt {
public:
	std::vector<FmtPart> parts;

	void append_literal(const std::string &str);

	void parse_rtlil(const RTLIL::Cell *cell);
	void emit_rtlil(RTLIL::Cell *cell) const;

	void parse_verilog(const std::vector<VerilogFmtArg> &args, bool sformat_like, int default_base, RTLIL::IdString task_name, RTLIL::IdString module_name);
	std::vector<VerilogFmtArg> emit_verilog() const;

	void emit_cxxrtl(std::ostream &os, std::string indent, std::function<void(const RTLIL::SigSpec &)> emit_sig, const std::string &context) const;

	std::string render() const;

private:
	void apply_verilog_automatic_sizing_and_add(FmtPart &part);
};

YOSYS_NAMESPACE_END

#endif
`,"gzip.h":`#include <string>
#include "kernel/yosys_common.h"

#ifndef YOSYS_GZIP_H
#define YOSYS_GZIP_H

YOSYS_NAMESPACE_BEGIN

#ifdef YOSYS_ENABLE_ZLIB

namespace Zlib {
#include <zlib.h>
}

/*
An output stream that uses a stringbuf to buffer data internally,
using zlib to write gzip-compressed data every time the stream is flushed.
*/
class gzip_ostream : public std::ostream {
public:
	gzip_ostream(): std::ostream(nullptr) {
		rdbuf(&outbuf);
	}
	bool open(const std::string &filename) {
		return outbuf.open(filename);
	}
private:
	class obuf : public std::stringbuf {
	public:
		obuf();
		bool open(const std::string &filename);
		virtual int sync() override;
		virtual ~obuf();
	private:
		static const int buffer_size = 4096;
		char buffer[buffer_size];             // Internal buffer for compressed data
		Zlib::gzFile gzf = nullptr;                 // Handle to the gzip file
	};

	obuf outbuf;  // The stream buffer instance
};

/*
An input stream that uses zlib to read gzip-compressed data from a file,
buffering the decompressed data internally using its own buffer.
*/
class gzip_istream final : public std::istream {
public:
	gzip_istream() : std::istream(&inbuf) {}
	bool open(const std::string& filename) {
		return inbuf.open(filename);
	}
private:
	class ibuf final : public std::streambuf {
	public:
		ibuf() : gzf(nullptr) {}
		bool open(const std::string& filename);
		virtual ~ibuf();

	protected:
		// Called when the buffer is empty and more input is needed
		virtual int_type underflow() override;
	private:
		static const int buffer_size = 8192;
		char buffer[buffer_size];
		Zlib::gzFile gzf;
	};

	ibuf inbuf;  // The stream buffer instance
};

#endif // YOSYS_ENABLE_ZLIB

std::istream* uncompressed(const std::string filename, std::ios_base::openmode mode = std::ios_base::in);

YOSYS_NAMESPACE_END

#endif // YOSYS_GZIP_H
`,"hashlib.h":`// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.

// -------------------------------------------------------
// Written by Claire Xenia Wolf <claire@yosyshq.com> in 2014
// -------------------------------------------------------

#ifndef HASHLIB_H
#define HASHLIB_H

#include <stdexcept>
#include <algorithm>
#include <optional>
#include <string>
#include <variant>
#include <vector>
#include <type_traits>
#include <stdint.h>

#define YS_HASHING_VERSION 1

namespace hashlib {

/**
 * HASHING
 *
 * Also refer to docs/source/yosys_internals/hashing.rst
 *
 * The Hasher knows how to hash 32 and 64-bit integers. That's it.
 * In the future, it could be expanded to do vectors with SIMD.
 *
 * The Hasher doesn't know how to hash common standard containers
 * and compositions. However, hashlib provides centralized wrappers.
 *
 * Hashlib doesn't know how to hash silly Yosys-specific types.
 * Hashlib doesn't depend on Yosys and can be used standalone.
 * Please don't use hashlib standalone for new projects.
 * Never directly include kernel/hashlib.h in Yosys code.
 * Instead include kernel/yosys_common.h
 *
 * The hash_ops type is now always left to its default value, derived
 * from templated functions through SFINAE. Providing custom ops is
 * still supported.
 *
 * HASH TABLES
 *
 * We implement associative data structures with separate chaining.
 * Linked lists use integers into the indirection hashtable array
 * instead of pointers.
 */

const int hashtable_size_trigger = 2;
const int hashtable_size_factor = 3;

namespace legacy {
	inline uint32_t djb2_add(uint32_t a, uint32_t b) {
		return ((a << 5) + a) + b;
	}
};

template<typename T>
struct hash_ops;

inline unsigned int mkhash_xorshift(unsigned int a) {
	if (sizeof(a) == 4) {
		a ^= a << 13;
		a ^= a >> 17;
		a ^= a << 5;
	} else if (sizeof(a) == 8) {
		a ^= a << 13;
		a ^= a >> 7;
		a ^= a << 17;
	} else
		throw std::runtime_error("mkhash_xorshift() only implemented for 32 bit and 64 bit ints");
	return a;
}

class HasherDJB32 {
public:
	using hash_t = uint32_t;

	HasherDJB32() {
		// traditionally 5381 is used as starting value for the djb2 hash
		state = 5381;
	}
	static void set_fudge(hash_t f) {
		fudge = f;
	}

private:
	uint32_t state;
	static uint32_t fudge;
	// The XOR version of DJB2
	[[nodiscard]]
	static uint32_t djb2_xor(uint32_t a, uint32_t b) {
		uint32_t hash = ((a << 5) + a) ^ b;
		return hash;
	}
	public:
	void hash32(uint32_t i) {
		state = djb2_xor(i, state);
		state = mkhash_xorshift(fudge ^ state);
		return;
	}
	void hash64(uint64_t i) {
		state = djb2_xor((uint32_t)(i & 0xFFFFFFFFULL), state);
		state = djb2_xor((uint32_t)(i >> 32ULL), state);
		state = mkhash_xorshift(fudge ^ state);
		return;
	}
	[[nodiscard]]
	hash_t yield() {
		return (hash_t)state;
	}

	template<typename T>
	void eat(T&& t) {
		*this = hash_ops<std::remove_cv_t<std::remove_reference_t<T>>>::hash_into(std::forward<T>(t), *this);
	}

	template<typename T>
	void eat(const T& t) {
		*this = hash_ops<T>::hash_into(t, *this);
	}

	void commutative_eat(hash_t t) {
		state ^= t;
	}

	void force(hash_t new_state) {
		state = new_state;
	}
};

using Hasher = HasherDJB32;

// Boilerplate compressor for trivially implementing
// top-level hash method with hash_into
#define HASH_TOP_LOOP_FST [[nodiscard]] static inline Hasher hash
#define HASH_TOP_LOOP_SND { \\
	Hasher h; \\
	h = hash_into(a, h); \\
	return h; \\
}

template<typename T>
struct hash_ops {
	static inline bool cmp(const T &a, const T &b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(const T &a, Hasher h) {
		if constexpr (std::is_integral_v<T>) {
			static_assert(sizeof(T) <= sizeof(uint64_t));
			if (sizeof(T) == sizeof(uint64_t))
				h.hash64(a);
			else
				h.hash32(a);
			return h;
		} else if constexpr (std::is_enum_v<T>) {
			using u_type = std::underlying_type_t<T>;
			return hash_ops<u_type>::hash_into((u_type) a, h);
		} else if constexpr (std::is_pointer_v<T>) {
			return hash_ops<uintptr_t>::hash_into((uintptr_t) a, h);
		} else if constexpr (std::is_same_v<T, std::string>) {
			for (auto c : a)
				h.hash32(c);
			return h;
		} else {
			return a.hash_into(h);
		}
	}
	HASH_TOP_LOOP_FST (const T &a) HASH_TOP_LOOP_SND
};

template<typename P, typename Q> struct hash_ops<std::pair<P, Q>> {
	static inline bool cmp(std::pair<P, Q> a, std::pair<P, Q> b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(std::pair<P, Q> a, Hasher h) {
		h = hash_ops<P>::hash_into(a.first, h);
		h = hash_ops<Q>::hash_into(a.second, h);
		return h;
	}
	HASH_TOP_LOOP_FST (std::pair<P, Q> a) HASH_TOP_LOOP_SND
};

template<typename... T> struct hash_ops<std::tuple<T...>> {
	static inline bool cmp(std::tuple<T...> a, std::tuple<T...> b) {
		return a == b;
	}
	template<size_t I = 0>
	static inline typename std::enable_if<I == sizeof...(T), Hasher>::type hash_into(std::tuple<T...>, Hasher h) {
		return h;
	}
	template<size_t I = 0>
	static inline typename std::enable_if<I != sizeof...(T), Hasher>::type hash_into(std::tuple<T...> a, Hasher h) {
		typedef hash_ops<typename std::tuple_element<I, std::tuple<T...>>::type> element_ops_t;
		h = hash_into<I+1>(a, h);
		h = element_ops_t::hash_into(std::get<I>(a), h);
		return h;
	}
	HASH_TOP_LOOP_FST (std::tuple<T...> a) HASH_TOP_LOOP_SND
};

template<typename T> struct hash_ops<std::vector<T>> {
	static inline bool cmp(std::vector<T> a, std::vector<T> b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(std::vector<T> a, Hasher h) {
		h.eat((uint32_t)a.size());
		for (auto k : a)
			h.eat(k);
		return h;
	}
	HASH_TOP_LOOP_FST (std::vector<T> a) HASH_TOP_LOOP_SND
};

template<typename T, size_t N> struct hash_ops<std::array<T, N>> {
    static inline bool cmp(std::array<T, N> a, std::array<T, N> b) {
        return a == b;
    }
    [[nodiscard]] static inline Hasher hash_into(std::array<T, N> a, Hasher h) {
        for (const auto& k : a)
            h = hash_ops<T>::hash_into(k, h);
        return h;
    }
	HASH_TOP_LOOP_FST (std::array<T, N> a) HASH_TOP_LOOP_SND
};

struct hash_cstr_ops {
	static inline bool cmp(const char *a, const char *b) {
		return strcmp(a, b) == 0;
	}
	[[nodiscard]] static inline Hasher hash_into(const char *a, Hasher h) {
		while (*a)
			h.hash32(*(a++));
		return h;
	}
	HASH_TOP_LOOP_FST (const char *a) HASH_TOP_LOOP_SND
};

template <> struct hash_ops<char*> : hash_cstr_ops {};

struct hash_ptr_ops {
	static inline bool cmp(const void *a, const void *b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(const void *a, Hasher h) {
		return hash_ops<uintptr_t>::hash_into((uintptr_t)a, h);
	}
	HASH_TOP_LOOP_FST (const void *a) HASH_TOP_LOOP_SND
};

struct hash_obj_ops {
	static inline bool cmp(const void *a, const void *b) {
		return a == b;
	}
	template<typename T>
	[[nodiscard]] static inline Hasher hash_into(const T *a, Hasher h) {
		if (a)
			h = a->hash_into(h);
		else
			h.eat(0);
		return h;
	}
	template<typename T>
	HASH_TOP_LOOP_FST (const T *a) HASH_TOP_LOOP_SND
};
/**
 * If you find yourself using this function, think hard
 * about if it's the right thing to do. Mixing finalized
 * hashes together with XORs or worse can destroy
 * desirable qualities of the hash function
 */
template<typename T>
[[nodiscard]]
Hasher::hash_t run_hash(const T& obj) {
	return hash_ops<T>::hash(obj).yield();
}

/** Refer to docs/source/yosys_internals/hashing.rst */
template<typename T>
[[nodiscard]]
[[deprecated]]
inline unsigned int mkhash(const T &v) {
	return (unsigned int) run_hash<T>(v);
}

template<> struct hash_ops<std::monostate> {
	static inline bool cmp(std::monostate a, std::monostate b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(std::monostate, Hasher h) {
		return h;
	}
};

template<typename... T> struct hash_ops<std::variant<T...>> {
	static inline bool cmp(std::variant<T...> a, std::variant<T...> b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(std::variant<T...> a, Hasher h) {
		std::visit([& h](const auto &v) { h.eat(v); }, a);
		h.eat(a.index());
		return h;
	}
};

template<typename T> struct hash_ops<std::optional<T>> {
	static inline bool cmp(std::optional<T> a, std::optional<T> b) {
		return a == b;
	}
	[[nodiscard]] static inline Hasher hash_into(std::optional<T> a, Hasher h) {
		if(a.has_value())
			h.eat(*a);
		else
			h.eat(0);
		return h;
	}
};

inline unsigned int hashtable_size(unsigned int min_size)
{
	// Primes as generated by https://oeis.org/A175953
	static std::vector<unsigned int> zero_and_some_primes = {
		0, 23, 29, 37, 47, 59, 79, 101, 127, 163, 211, 269, 337, 431, 541, 677,
		853, 1069, 1361, 1709, 2137, 2677, 3347, 4201, 5261, 6577, 8231, 10289,
		12889, 16127, 20161, 25219, 31531, 39419, 49277, 61603, 77017, 96281,
		120371, 150473, 188107, 235159, 293957, 367453, 459317, 574157, 717697,
		897133, 1121423, 1401791, 1752239, 2190299, 2737937, 3422429, 4278037,
		5347553, 6684443, 8355563, 10444457, 13055587, 16319519, 20399411,
		25499291, 31874149, 39842687, 49803361, 62254207, 77817767, 97272239,
		121590311, 151987889, 189984863, 237481091, 296851369, 371064217,
		463830313, 579787991, 724735009, 905918777, 1132398479, 1415498113,
		1769372713, 2211715897, 2764644887, 3455806139
	};

	for (auto p : zero_and_some_primes)
		if (p >= min_size) return p;

	if (sizeof(unsigned int) == 4)
		throw std::length_error("hash table exceeded maximum size.\\nDesign is likely too large for yosys to handle, if possible try not to flatten the design.");

	for (auto p : zero_and_some_primes)
		if (100129 * p > min_size) return 100129 * p;

	throw std::length_error("hash table exceeded maximum size.");
}

template<typename K, typename T, typename OPS = hash_ops<K>> class dict;
template<typename K, int offset = 0, typename OPS = hash_ops<K>> class idict;
template<typename K, typename OPS = hash_ops<K>> class pool;
template<typename K, typename OPS = hash_ops<K>> class mfp;

template<typename K, typename T, typename OPS>
class dict {
	struct entry_t
	{
		std::pair<K, T> udata;
		int next;

		entry_t() { }
		entry_t(const std::pair<K, T> &udata, int next) : udata(udata), next(next) { }
		entry_t(std::pair<K, T> &&udata, int next) : udata(std::move(udata)), next(next) { }
		bool operator<(const entry_t &other) const { return udata.first < other.udata.first; }
	};

	std::vector<int> hashtable;
	std::vector<entry_t> entries;
	OPS ops;

#ifdef NDEBUG
	static inline void do_assert(bool) { }
#else
	static inline void do_assert(bool cond) {
		if (!cond) throw std::runtime_error("dict<> assert failed.");
	}
#endif

	Hasher::hash_t do_hash(const K &key) const
	{
		Hasher::hash_t hash = 0;
		if (!hashtable.empty())
			hash = ops.hash(key).yield() % (unsigned int)(hashtable.size());
		return hash;
	}

	void do_rehash()
	{
		hashtable.clear();
		hashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);

		for (int i = 0; i < int(entries.size()); i++) {
			do_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));
			Hasher::hash_t hash = do_hash(entries[i].udata.first);
			entries[i].next = hashtable[hash];
			hashtable[hash] = i;
		}
	}

	int do_erase(int index, Hasher::hash_t hash)
	{
		do_assert(index < int(entries.size()));
		if (hashtable.empty() || index < 0)
			return 0;

		int k = hashtable[hash];
		do_assert(0 <= k && k < int(entries.size()));

		if (k == index) {
			hashtable[hash] = entries[index].next;
		} else {
			while (entries[k].next != index) {
				k = entries[k].next;
				do_assert(0 <= k && k < int(entries.size()));
			}
			entries[k].next = entries[index].next;
		}

		int back_idx = entries.size()-1;

		if (index != back_idx)
		{
			Hasher::hash_t back_hash = do_hash(entries[back_idx].udata.first);

			k = hashtable[back_hash];
			do_assert(0 <= k && k < int(entries.size()));

			if (k == back_idx) {
				hashtable[back_hash] = index;
			} else {
				while (entries[k].next != back_idx) {
					k = entries[k].next;
					do_assert(0 <= k && k < int(entries.size()));
				}
				entries[k].next = index;
			}

			entries[index] = std::move(entries[back_idx]);
		}

		entries.pop_back();

		if (entries.empty())
			hashtable.clear();

		return 1;
	}

	int do_lookup(const K &key, Hasher::hash_t &hash) const
	{
		if (hashtable.empty())
			return -1;

		if (entries.size() * hashtable_size_trigger > hashtable.size()) {
			((dict*)this)->do_rehash();
			hash = do_hash(key);
		}

		int index = hashtable[hash];

		while (index >= 0 && !ops.cmp(entries[index].udata.first, key)) {
			index = entries[index].next;
			do_assert(-1 <= index && index < int(entries.size()));
		}

		return index;
	}

	int do_insert(const K &key, Hasher::hash_t &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(std::pair<K, T>(key, T()), -1);
			do_rehash();
			hash = do_hash(key);
		} else {
			entries.emplace_back(std::pair<K, T>(key, T()), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(const std::pair<K, T> &value, Hasher::hash_t &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(value, -1);
			do_rehash();
			hash = do_hash(value.first);
		} else {
			entries.emplace_back(value, hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(std::pair<K, T> &&rvalue, Hasher::hash_t &hash)
	{
		if (hashtable.empty()) {
			auto key = rvalue.first;
			entries.emplace_back(std::forward<std::pair<K, T>>(rvalue), -1);
			do_rehash();
			hash = do_hash(key);
		} else {
			entries.emplace_back(std::forward<std::pair<K, T>>(rvalue), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

public:
	class const_iterator
	{
		friend class dict;
	protected:
		const dict *ptr;
		int index;
		const_iterator(const dict *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef std::pair<K, T> value_type;
		typedef ptrdiff_t difference_type;
		typedef std::pair<K, T>* pointer;
		typedef std::pair<K, T>& reference;
		const_iterator() { }
		const_iterator operator++() { index--; return *this; }
		const_iterator operator+=(int amt) { index -= amt; return *this; }
		bool operator<(const const_iterator &other) const { return index > other.index; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }
		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }
	};

	class iterator
	{
		friend class dict;
	protected:
		dict *ptr;
		int index;
		iterator(dict *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef std::pair<K, T> value_type;
		typedef ptrdiff_t difference_type;
		typedef std::pair<K, T>* pointer;
		typedef std::pair<K, T>& reference;
		iterator() { }
		iterator operator++() { index--; return *this; }
		iterator operator+=(int amt) { index -= amt; return *this; }
		bool operator<(const iterator &other) const { return index > other.index; }
		bool operator==(const iterator &other) const { return index == other.index; }
		bool operator!=(const iterator &other) const { return index != other.index; }
		std::pair<K, T> &operator*() { return ptr->entries[index].udata; }
		std::pair<K, T> *operator->() { return &ptr->entries[index].udata; }
		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }
		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }
		operator const_iterator() const { return const_iterator(ptr, index); }
	};

	constexpr dict()
	{
	}

	dict(const dict &other)
	{
		entries = other.entries;
		do_rehash();
	}

	dict(dict &&other)
	{
		swap(other);
	}

	dict &operator=(const dict &other) {
		entries = other.entries;
		do_rehash();
		return *this;
	}

	dict &operator=(dict &&other) {
		clear();
		swap(other);
		return *this;
	}

	dict(const std::initializer_list<std::pair<K, T>> &list)
	{
		for (auto &it : list)
			insert(it);
	}

	template<class InputIterator>
	dict(InputIterator first, InputIterator last)
	{
		insert(first, last);
	}

	template<class InputIterator>
	void insert(InputIterator first, InputIterator last)
	{
		for (; first != last; ++first)
			insert(*first);
	}

	std::pair<iterator, bool> insert(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(key, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(const std::pair<K, T> &value)
	{
		Hasher::hash_t hash = do_hash(value.first);
		int i = do_lookup(value.first, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(value, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(std::pair<K, T> &&rvalue)
	{
		Hasher::hash_t hash = do_hash(rvalue.first);
		int i = do_lookup(rvalue.first, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::forward<std::pair<K, T>>(rvalue), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K const &key, T const &value)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(key, value), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K const &key, T &&rvalue)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(key, std::forward<T>(rvalue)), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K &&rkey, T const &value)
	{
		Hasher::hash_t hash = do_hash(rkey);
		int i = do_lookup(rkey, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(std::forward<K>(rkey), value), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K &&rkey, T &&rvalue)
	{
		Hasher::hash_t hash = do_hash(rkey);
		int i = do_lookup(rkey, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(std::forward<K>(rkey), std::forward<T>(rvalue)), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	int erase(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int index = do_lookup(key, hash);
		return do_erase(index, hash);
	}

	iterator erase(iterator it)
	{
		Hasher::hash_t hash = do_hash(it->first);
		do_erase(it.index, hash);
		return ++it;
	}

	int count(const K &key) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	int count(const K &key, const_iterator it) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 || i > it.index ? 0 : 1;
	}

	iterator find(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return iterator(this, i);
	}

	const_iterator find(const K &key) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return const_iterator(this, i);
	}

	T& at(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("dict::at()");
		return entries[i].udata.second;
	}

	const T& at(const K &key) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("dict::at()");
		return entries[i].udata.second;
	}

	const T& at(const K &key, const T &defval) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return defval;
		return entries[i].udata.second;
	}

	T& operator[](const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			i = do_insert(std::pair<K, T>(key, T()), hash);
		return entries[i].udata.second;
	}

	template<typename Compare = std::less<K>>
	void sort(Compare comp = Compare())
	{
		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata.first, a.udata.first); });
		do_rehash();
	}

	void swap(dict &other)
	{
		hashtable.swap(other.hashtable);
		entries.swap(other.entries);
	}

	bool operator==(const dict &other) const {
		if (size() != other.size())
			return false;
		for (auto &it : entries) {
			auto oit = other.find(it.udata.first);
			if (oit == other.end() || !(oit->second == it.udata.second))
				return false;
		}
		return true;
	}

	bool operator!=(const dict &other) const {
		return !operator==(other);
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const {
		for (auto &it : entries) {
			Hasher entry_hash;
			entry_hash.eat(it.udata.first);
			entry_hash.eat(it.udata.second);
			h.commutative_eat(entry_hash.yield());
		}
		h.eat(entries.size());
		return h;
	}

	void reserve(size_t n) { entries.reserve(n); }
	size_t size() const { return entries.size(); }
	bool empty() const { return entries.empty(); }
	void clear() { hashtable.clear(); entries.clear(); }

	iterator begin() { return iterator(this, int(entries.size())-1); }
	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }
	iterator end() { return iterator(nullptr, -1); }

	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }
	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }
	const_iterator end() const { return const_iterator(nullptr, -1); }
};

template<typename K, typename OPS>
class pool
{
	template<typename, int, typename> friend class idict;

protected:
	struct entry_t
	{
		K udata;
		int next;

		entry_t() { }
		entry_t(const K &udata, int next) : udata(udata), next(next) { }
		entry_t(K &&udata, int next) : udata(std::move(udata)), next(next) { }
	};

	std::vector<int> hashtable;
	std::vector<entry_t> entries;
	OPS ops;

#ifdef NDEBUG
	static inline void do_assert(bool) { }
#else
	static inline void do_assert(bool cond) {
		if (!cond) throw std::runtime_error("pool<> assert failed.");
	}
#endif

	Hasher::hash_t do_hash(const K &key) const
	{
		Hasher::hash_t hash = 0;
		if (!hashtable.empty())
			hash = ops.hash(key).yield() % (unsigned int)(hashtable.size());
		return hash;
	}

	void do_rehash()
	{
		hashtable.clear();
		hashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);

		for (int i = 0; i < int(entries.size()); i++) {
			do_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));
			Hasher::hash_t hash = do_hash(entries[i].udata);
			entries[i].next = hashtable[hash];
			hashtable[hash] = i;
		}
	}

	int do_erase(int index, Hasher::hash_t hash)
	{
		do_assert(index < int(entries.size()));
		if (hashtable.empty() || index < 0)
			return 0;

		int k = hashtable[hash];
		if (k == index) {
			hashtable[hash] = entries[index].next;
		} else {
			while (entries[k].next != index) {
				k = entries[k].next;
				do_assert(0 <= k && k < int(entries.size()));
			}
			entries[k].next = entries[index].next;
		}

		int back_idx = entries.size()-1;

		if (index != back_idx)
		{
			Hasher::hash_t back_hash = do_hash(entries[back_idx].udata);

			k = hashtable[back_hash];
			if (k == back_idx) {
				hashtable[back_hash] = index;
			} else {
				while (entries[k].next != back_idx) {
					k = entries[k].next;
					do_assert(0 <= k && k < int(entries.size()));
				}
				entries[k].next = index;
			}

			entries[index] = std::move(entries[back_idx]);
		}

		entries.pop_back();

		if (entries.empty())
			hashtable.clear();

		return 1;
	}

	int do_lookup(const K &key, Hasher::hash_t &hash) const
	{
		if (hashtable.empty())
			return -1;

		if (entries.size() * hashtable_size_trigger > hashtable.size()) {
			((pool*)this)->do_rehash();
			hash = do_hash(key);
		}

		int index = hashtable[hash];

		while (index >= 0 && !ops.cmp(entries[index].udata, key)) {
			index = entries[index].next;
			do_assert(-1 <= index && index < int(entries.size()));
		}

		return index;
	}

	int do_insert(const K &value, Hasher::hash_t &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(value, -1);
			do_rehash();
			hash = do_hash(value);
		} else {
			entries.emplace_back(value, hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(K &&rvalue, Hasher::hash_t &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(std::forward<K>(rvalue), -1);
			do_rehash();
			hash = do_hash(rvalue);
		} else {
			entries.emplace_back(std::forward<K>(rvalue), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

public:
	class const_iterator
	{
		friend class pool;
	protected:
		const pool *ptr;
		int index;
		const_iterator(const pool *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		const_iterator() { }
		const_iterator operator++() { index--; return *this; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const K &operator*() const { return ptr->entries[index].udata; }
		const K *operator->() const { return &ptr->entries[index].udata; }
	};

	class iterator
	{
		friend class pool;
	protected:
		pool *ptr;
		int index;
		iterator(pool *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		iterator() { }
		iterator operator++() { index--; return *this; }
		bool operator==(const iterator &other) const { return index == other.index; }
		bool operator!=(const iterator &other) const { return index != other.index; }
		K &operator*() { return ptr->entries[index].udata; }
		K *operator->() { return &ptr->entries[index].udata; }
		const K &operator*() const { return ptr->entries[index].udata; }
		const K *operator->() const { return &ptr->entries[index].udata; }
		operator const_iterator() const { return const_iterator(ptr, index); }
	};

	constexpr pool()
	{
	}

	pool(const pool &other)
	{
		entries = other.entries;
		do_rehash();
	}

	pool(pool &&other)
	{
		swap(other);
	}

	pool &operator=(const pool &other) {
		entries = other.entries;
		do_rehash();
		return *this;
	}

	pool &operator=(pool &&other) {
		clear();
		swap(other);
		return *this;
	}

	pool(const std::initializer_list<K> &list)
	{
		for (auto &it : list)
			insert(it);
	}

	template<class InputIterator>
	pool(InputIterator first, InputIterator last)
	{
		insert(first, last);
	}

	template<class InputIterator>
	void insert(InputIterator first, InputIterator last)
	{
		for (; first != last; ++first)
			insert(*first);
	}

	std::pair<iterator, bool> insert(const K &value)
	{
		Hasher::hash_t hash = do_hash(value);
		int i = do_lookup(value, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(value, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(K &&rvalue)
	{
		Hasher::hash_t hash = do_hash(rvalue);
		int i = do_lookup(rvalue, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::forward<K>(rvalue), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	template<typename... Args>
	std::pair<iterator, bool> emplace(Args&&... args)
	{
		return insert(K(std::forward<Args>(args)...));
	}

	int erase(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int index = do_lookup(key, hash);
		return do_erase(index, hash);
	}

	iterator erase(iterator it)
	{
		Hasher::hash_t hash = do_hash(*it);
		do_erase(it.index, hash);
		return ++it;
	}

	int count(const K &key) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	int count(const K &key, const_iterator it) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 || i > it.index ? 0 : 1;
	}

	iterator find(const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return iterator(this, i);
	}

	const_iterator find(const K &key) const
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return const_iterator(this, i);
	}

	bool operator[](const K &key)
	{
		Hasher::hash_t hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i >= 0;
	}

	template<typename Compare = std::less<K>>
	void sort(Compare comp = Compare())
	{
		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata, a.udata); });
		do_rehash();
	}

	K pop()
	{
		iterator it = begin();
		K ret = *it;
		erase(it);
		return ret;
	}

	void swap(pool &other)
	{
		hashtable.swap(other.hashtable);
		entries.swap(other.entries);
	}

	bool operator==(const pool &other) const {
		if (size() != other.size())
			return false;
		for (auto &it : entries)
			if (!other.count(it.udata))
				return false;
		return true;
	}

	bool operator!=(const pool &other) const {
		return !operator==(other);
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const {
		for (auto &it : entries) {
			h.commutative_eat(ops.hash(it.udata).yield());
		}
		h.eat(entries.size());
		return h;
	}

	void reserve(size_t n) { entries.reserve(n); }
	size_t size() const { return entries.size(); }
	bool empty() const { return entries.empty(); }
	void clear() { hashtable.clear(); entries.clear(); }

	iterator begin() { return iterator(this, int(entries.size())-1); }
	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }
	iterator end() { return iterator(nullptr, -1); }

	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }
	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }
	const_iterator end() const { return const_iterator(nullptr, -1); }
};

template<typename K, int offset, typename OPS>
class idict
{
	pool<K, OPS> database;

public:
	class const_iterator
	{
		friend class idict;
	protected:
		const idict &container;
		int index;
		const_iterator(const idict &container, int index) : container(container), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		const_iterator() { }
		const_iterator operator++() { index++; return *this; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const K &operator*() const { return container[index]; }
		const K *operator->() const { return &container[index]; }
	};

	constexpr idict()
	{
	}

	int operator()(const K &key)
	{
		Hasher::hash_t hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			i = database.do_insert(key, hash);
		return i + offset;
	}

	int at(const K &key) const
	{
		Hasher::hash_t hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("idict::at()");
		return i + offset;
	}

	int at(const K &key, int defval) const
	{
		Hasher::hash_t hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			return defval;
		return i + offset;
	}

	int count(const K &key) const
	{
		Hasher::hash_t hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	void expect(const K &key, int i)
	{
		int j = (*this)(key);
		if (i != j)
			throw std::out_of_range("idict::expect()");
	}

	const K &operator[](int index) const
	{
		return database.entries.at(index - offset).udata;
	}

	void swap(idict &other)
	{
		database.swap(other.database);
	}

	void reserve(size_t n) { database.reserve(n); }
	size_t size() const { return database.size(); }
	bool empty() const { return database.empty(); }
	void clear() { database.clear(); }

	const_iterator begin() const { return const_iterator(*this, offset); }
	const_iterator element(int n) const { return const_iterator(*this, n); }
	const_iterator end() const { return const_iterator(*this, offset + size()); }
};

/**
 * Union-find data structure with a promotion method
 * mfp stands for "merge, find, promote"
 * i-prefixed methods operate on indices in parents
*/
template<typename K, typename OPS>
class mfp
{
	mutable idict<K, 0, OPS> database;
	mutable std::vector<int> parents;

public:
	typedef typename idict<K, 0>::const_iterator const_iterator;

	constexpr mfp()
	{
	}

	// Finds a given element's index. If it isn't in the data structure,
	// it is added as its own set
	int operator()(const K &key) const
	{
		int i = database(key);
		// If the lookup caused the database to grow,
		// also add a corresponding entry in parents initialized to -1 (no parent)
		parents.resize(database.size(), -1);
		return i;
	}

	// Finds an element at given index
	const K &operator[](int index) const
	{
		return database[index];
	}

	int ifind(int i) const
	{
		int p = i, k = i;

		while (parents[p] != -1)
			p = parents[p];

		// p is now the representative of i
		// Now we traverse from i up to the representative again
		// and make p the parent of all the nodes along the way.
		// This is a side effect and doesn't affect the return value.
		// It speeds up future find operations
		while (k != p) {
			int next_k = parents[k];
			parents[k] = p;
			k = next_k;
		}

		return p;
	}

	// Merge sets if the given indices belong to different sets
	void imerge(int i, int j)
	{
		i = ifind(i);
		j = ifind(j);

		if (i != j)
			parents[i] = j;
	}

	void ipromote(int i)
	{
		int k = i;

		while (k != -1) {
			int next_k = parents[k];
			parents[k] = i;
			k = next_k;
		}

		parents[i] = -1;
	}

	int lookup(const K &a) const
	{
		return ifind((*this)(a));
	}

	const K &find(const K &a) const
	{
		int i = database.at(a, -1);
		if (i < 0)
			return a;
		return (*this)[ifind(i)];
	}

	void merge(const K &a, const K &b)
	{
		imerge((*this)(a), (*this)(b));
	}

	void promote(const K &a)
	{
		int i = database.at(a, -1);
		if (i >= 0)
			ipromote(i);
	}

	void swap(mfp &other)
	{
		database.swap(other.database);
		parents.swap(other.parents);
	}

	void reserve(size_t n) { database.reserve(n); }
	size_t size() const { return database.size(); }
	bool empty() const { return database.empty(); }
	void clear() { database.clear(); parents.clear(); }

	const_iterator begin() const { return database.begin(); }
	const_iterator element(int n) const { return database.element(n); }
	const_iterator end() const { return database.end(); }
};

} /* namespace hashlib */

#endif
`,"io.h":`#include <string>
#include <stdarg.h>
#include "kernel/yosys_common.h"

#ifndef YOSYS_IO_H
#define YOSYS_IO_H

YOSYS_NAMESPACE_BEGIN

inline std::string vstringf(const char *fmt, va_list ap)
{
	// For the common case of strings shorter than 128, save a heap
	// allocation by using a stack allocated buffer.
	const int kBufSize = 128;
	char buf[kBufSize];
	buf[0] = '\\0';
	va_list apc;
	va_copy(apc, ap);
	int n = vsnprintf(buf, kBufSize, fmt, apc);
	va_end(apc);
	if (n < kBufSize)
		return std::string(buf);

	std::string string;
	char *str = NULL;
#if defined(_WIN32) || defined(__CYGWIN__)
	int sz = 2 * kBufSize, rc;
	while (1) {
		va_copy(apc, ap);
		str = (char *)realloc(str, sz);
		rc = vsnprintf(str, sz, fmt, apc);
		va_end(apc);
		if (rc >= 0 && rc < sz)
			break;
		sz *= 2;
	}
	if (str != NULL) {
		string = str;
		free(str);
	}
	return string;
#else
	if (vasprintf(&str, fmt, ap) < 0)
		str = NULL;
	if (str != NULL) {
		string = str;
		free(str);
	}
	return string;
#endif
}

std::string stringf(const char *fmt, ...) YS_ATTRIBUTE(format(printf, 1, 2));

inline std::string stringf(const char *fmt, ...)
{
	std::string string;
	va_list ap;

	va_start(ap, fmt);
	string = vstringf(fmt, ap);
	va_end(ap);

	return string;
}

int readsome(std::istream &f, char *s, int n);
std::string next_token(std::string &text, const char *sep = " \\t\\r\\n", bool long_strings = false);
std::vector<std::string> split_tokens(const std::string &text, const char *sep = " \\t\\r\\n");
bool patmatch(const char *pattern, const char *string);
#if !defined(YOSYS_DISABLE_SPAWN)
int run_command(const std::string &command, std::function<void(const std::string&)> process_line = std::function<void(const std::string&)>());
#endif
std::string get_base_tmpdir();
std::string make_temp_file(std::string template_str = get_base_tmpdir() + "/yosys_XXXXXX");
std::string make_temp_dir(std::string template_str = get_base_tmpdir() + "/yosys_XXXXXX");
bool check_file_exists(const std::string& filename, bool is_exec = false);
bool check_directory_exists(const std::string& dirname, bool is_exec = false);
bool is_absolute_path(std::string filename);
void remove_directory(std::string dirname);
bool create_directory(const std::string& dirname);
std::string escape_filename_spaces(const std::string& filename);

YOSYS_NAMESPACE_END

#endif // YOSYS_IO_H
`,"json.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef JSON_H
#define JSON_H

#include "kernel/yosys.h"
#include "libs/json11/json11.hpp"
#include <functional>

YOSYS_NAMESPACE_BEGIN

using json11::Json;

class PrettyJson
{
    enum Scope {
        VALUE,
        OBJECT_FIRST,
        OBJECT,
        ARRAY_FIRST,
        ARRAY,
    };

    struct Target {
        virtual void emit(const char *data) = 0;
        virtual void flush() {};
        virtual ~Target() {};
    };

    std::string newline_indent = "\\n";
    std::vector<std::unique_ptr<Target>> targets;
    std::vector<Scope> state = {VALUE};
    int compact_depth = INT_MAX;
public:

    void emit_to_log();
    void append_to_string(std::string &target);
    bool write_to_file(const std::string &path);

    bool active() { return !targets.empty(); }

    void compact() { compact_depth = GetSize(state); }

    void line(bool space_if_inline = true);
    void raw(const char *raw_json);
    void flush();
    void begin_object();
    void begin_array();
    void end_object();
    void end_array();
    void name(const char *name);
    void begin_value();
    void end_value();
    void value_json(const Json &value);
    void value(unsigned int value) { value_json(Json((int)value)); }
    template<typename T>
    void value(T &&value) { value_json(Json(std::forward<T>(value))); };

    void entry_json(const char *name, const Json &value);
    void entry(const char *name, unsigned int value) { entry_json(name, Json((int)value)); }
    template<typename T>
    void entry(const char *name, T &&value) { entry_json(name, Json(std::forward<T>(value))); };

    template<typename T>
    void object(const T &&values)
    {
        begin_object();
        for (auto &item : values)
            entry(item.first, item.second);
        end_object();
    }

    template<typename T>
    void array(const T &&values)
    {
        begin_object();
        for (auto &item : values)
            value(item);
        end_object();
    }
};



YOSYS_NAMESPACE_END

#endif
`,"log.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef LOG_H
#define LOG_H

#include "kernel/yosys_common.h"

#include <time.h>

#include <regex>
#define YS_REGEX_COMPILE(param) std::regex(param, \\
				std::regex_constants::nosubs | \\
				std::regex_constants::optimize | \\
				std::regex_constants::egrep)
#define YS_REGEX_COMPILE_WITH_SUBS(param) std::regex(param, \\
				std::regex_constants::optimize | \\
				std::regex_constants::egrep)

#if defined(_WIN32)
#  include <intrin.h>
#else
#  include <sys/time.h>
#  include <sys/resource.h>
#  if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
#    include <signal.h>
#  endif
#endif

#if defined(_MSC_VER)
// At least this is not in MSVC++ 2013.
#  define __PRETTY_FUNCTION__ __FUNCTION__
#endif

// from libs/sha1/sha1.h
class SHA1;

YOSYS_NAMESPACE_BEGIN

#define S__LINE__sub2(x) #x
#define S__LINE__sub1(x) S__LINE__sub2(x)
#define S__LINE__ S__LINE__sub1(__LINE__)

// YS_DEBUGTRAP is a macro that is functionally equivalent to a breakpoint
// if the platform provides such functionality, and does nothing otherwise.
// If no debugger is attached, it starts a just-in-time debugger if available,
// and crashes the process otherwise.
#if defined(_WIN32)
# define YS_DEBUGTRAP __debugbreak()
#else
# ifndef __has_builtin
// __has_builtin is a GCC/Clang extension; on a different compiler (or old enough GCC/Clang)
// that does not have it, using __has_builtin(...) is a syntax error.
#  define __has_builtin(x) 0
# endif
# if __has_builtin(__builtin_debugtrap)
#  define YS_DEBUGTRAP __builtin_debugtrap()
# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
#  define YS_DEBUGTRAP raise(SIGTRAP)
# else
#  define YS_DEBUGTRAP do {} while(0)
# endif
#endif

// YS_DEBUGTRAP_IF_DEBUGGING is a macro that is functionally equivalent to a breakpoint
// if a debugger is attached, and does nothing otherwise.
#if defined(_WIN32)
# define YS_DEBUGTRAP_IF_DEBUGGING do { if (IsDebuggerPresent()) DebugBreak(); } while(0)
# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
// There is no reliable (or portable) *nix equivalent of IsDebuggerPresent(). However,
// debuggers will stop when SIGTRAP is raised, even if the action is set to ignore.
# define YS_DEBUGTRAP_IF_DEBUGGING do { \\
		auto old = signal(SIGTRAP, SIG_IGN); raise(SIGTRAP); signal(SIGTRAP, old); \\
	} while(0)
#else
# define YS_DEBUGTRAP_IF_DEBUGGING do {} while(0)
#endif

struct log_cmd_error_exception { };

extern std::vector<FILE*> log_files;
extern std::vector<std::ostream*> log_streams;
extern std::vector<std::string> log_scratchpads;
extern std::map<std::string, std::set<std::string>> log_hdump;
extern std::vector<std::regex> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;
extern std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;
extern int log_warnings_count;
extern int log_warnings_count_noexpect;
extern bool log_expect_no_warnings;
extern bool log_hdump_all;
extern FILE *log_errfile;
extern SHA1 *log_hasher;

extern bool log_time;
extern bool log_error_stderr;
extern bool log_cmd_error_throw;
extern bool log_quiet_warnings;
extern int log_verbose_level;
extern string log_last_error;
extern void (*log_error_atexit)();

extern int log_make_debug;
extern int log_force_debug;
extern int log_debug_suppressed;

void logv(const char *format, va_list ap);
void logv_header(RTLIL::Design *design, const char *format, va_list ap);
void logv_warning(const char *format, va_list ap);
void logv_warning_noprefix(const char *format, va_list ap);
[[noreturn]] void logv_error(const char *format, va_list ap);
[[noreturn]] void logv_file_error(const string &filename, int lineno, const char *format, va_list ap);

void log(const char *format, ...)  YS_ATTRIBUTE(format(printf, 1, 2));
void log_header(RTLIL::Design *design, const char *format, ...) YS_ATTRIBUTE(format(printf, 2, 3));
void log_warning(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
void log_experimental(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));

void set_verific_logging(void (*cb)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg));
extern void (*log_verific_callback)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg);

// Log with filename to report a problem in a source file.
void log_file_warning(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));
void log_file_info(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));

void log_warning_noprefix(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
[[noreturn]] void log_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
[[noreturn]] void log_file_error(const string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));
[[noreturn]] void log_cmd_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));

#ifndef NDEBUG
static inline bool ys_debug(int n = 0) { if (log_force_debug) return true; log_debug_suppressed += n; return false; }
#else
static inline bool ys_debug(int = 0) { return false; }
#endif
#  define log_debug(...) do { if (ys_debug(1)) log(__VA_ARGS__); } while (0)

static inline void log_suppressed() {
	if (log_debug_suppressed && !log_make_debug) {
		log("<suppressed ~%d debug messages>\\n", log_debug_suppressed);
		log_debug_suppressed = 0;
	}
}

struct LogMakeDebugHdl {
	bool status = false;
	LogMakeDebugHdl(bool start_on = false) {
		if (start_on)
			on();
	}
	~LogMakeDebugHdl() {
		off();
	}
	void on() {
		if (status) return;
		status=true;
		log_make_debug++;
	}
	void off_silent() {
		if (!status) return;
		status=false;
		log_make_debug--;
	}
	void off() {
		off_silent();
	}
};

void log_spacer();
void log_push();
void log_pop();

void log_backtrace(const char *prefix, int levels);
void log_reset_stack();
void log_flush();

struct LogExpectedItem
{
	LogExpectedItem(const std::regex &pat, int expected) :
			pattern(pat), expected_count(expected), current_count(0) {}
	LogExpectedItem() : expected_count(0), current_count(0) {}

	std::regex pattern;
	int expected_count;
	int current_count;
};

extern dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;
void log_check_expected();

const char *log_signal(const RTLIL::SigSpec &sig, bool autoint = true);
const char *log_const(const RTLIL::Const &value, bool autoint = true);
const char *log_id(const RTLIL::IdString &id);
const char *log_str(const char *str);
const char *log_str(std::string const &str);

template<typename T> static inline const char *log_id(T *obj, const char *nullstr = nullptr) {
	if (nullstr && obj == nullptr)
		return nullstr;
	return log_id(obj->name);
}

void log_module(RTLIL::Module *module, std::string indent = "");
void log_cell(RTLIL::Cell *cell, std::string indent = "");
void log_wire(RTLIL::Wire *wire, std::string indent = "");

#ifndef NDEBUG
static inline void log_assert_worker(bool cond, const char *expr, const char *file, int line) {
	if (!cond) log_error("Assert \`%s' failed in %s:%d.\\n", expr, file, line);
}
#  define log_assert(_assert_expr_) YOSYS_NAMESPACE_PREFIX log_assert_worker(_assert_expr_, #_assert_expr_, __FILE__, __LINE__)
#else
#  define log_assert(_assert_expr_) do { if (0) { (void)(_assert_expr_); } } while(0)
#endif

#define log_abort() YOSYS_NAMESPACE_PREFIX log_error("Abort in %s:%d.\\n", __FILE__, __LINE__)
#define log_ping() YOSYS_NAMESPACE_PREFIX log("-- %s:%d %s --\\n", __FILE__, __LINE__, __PRETTY_FUNCTION__)


// ---------------------------------------------------
// This is the magic behind the code coverage counters
// ---------------------------------------------------

#if defined(YOSYS_ENABLE_COVER) && (defined(__linux__) || defined(__FreeBSD__))

#define cover(_id) do { \\
    static CoverData __d __attribute__((section("yosys_cover_list"), aligned(1), used)) = { __FILE__, __FUNCTION__, _id, __LINE__, 0 }; \\
    __d.counter++; \\
} while (0)

struct CoverData {
	const char *file, *func, *id;
	int line, counter;
} YS_ATTRIBUTE(packed);

// this two symbols are created by the linker for the "yosys_cover_list" ELF section
extern "C" struct CoverData __start_yosys_cover_list[];
extern "C" struct CoverData __stop_yosys_cover_list[];

extern dict<std::string, std::pair<std::string, int>> extra_coverage_data;

void cover_extra(std::string parent, std::string id, bool increment = true);
dict<std::string, std::pair<std::string, int>> get_coverage_data();

#define cover_list(_id, ...) do { cover(_id); \\
	std::string r = cover_list_worker(_id, __VA_ARGS__); \\
	log_assert(r.empty()); \\
} while (0)

static inline std::string cover_list_worker(std::string, std::string last) {
	return last;
}

template<typename... T>
std::string cover_list_worker(std::string prefix, std::string first, T... rest) {
	std::string selected = cover_list_worker(prefix, rest...);
	cover_extra(prefix, prefix + "." + first, first == selected);
	return first == selected ? "" : selected;
}

#else
#  define cover(...) do { } while (0)
#  define cover_list(...) do { } while (0)
#endif


// ------------------------------------------------------------
// everything below this line are utilities for troubleshooting
// ------------------------------------------------------------

// simple timer for performance measurements
// toggle the '#if 1' to get a baseline for the performance penalty added by the measurement
struct PerformanceTimer
{
#if 1
	int64_t total_ns;

	PerformanceTimer() {
		total_ns = 0;
	}

	static int64_t query() {
#  ifdef _WIN32
		return 0;
#  elif defined(RUSAGE_SELF)
		struct rusage rusage;
		int64_t t = 0;
		for (int who : {RUSAGE_SELF, RUSAGE_CHILDREN}) {
			if (getrusage(who, &rusage) == -1) {
				log_cmd_error("getrusage failed!\\n");
				log_abort();
			}
			t += 1000000000ULL * (int64_t) rusage.ru_utime.tv_sec + (int64_t) rusage.ru_utime.tv_usec * 1000ULL;
			t += 1000000000ULL * (int64_t) rusage.ru_stime.tv_sec + (int64_t) rusage.ru_stime.tv_usec * 1000ULL;
		}
		return t;
#  else
#    error "Don't know how to measure per-process CPU time. Need alternative method (times()/clocks()/gettimeofday()?)."
#  endif
	}

	void reset() {
		total_ns = 0;
	}

	void begin() {
		total_ns -= query();
	}

	void end() {
		total_ns += query();
	}

	float sec() const {
		return total_ns * 1e-9f;
	}
#else
	static int64_t query() { return 0; }
	void reset() { }
	void begin() { }
	void end() { }
	float sec() const { return 0; }
#endif
};

// simple API for quickly dumping values when debugging

static inline void log_dump_val_worker(short v) { log("%d", v); }
static inline void log_dump_val_worker(unsigned short v) { log("%u", v); }
static inline void log_dump_val_worker(int v) { log("%d", v); }
static inline void log_dump_val_worker(unsigned int v) { log("%u", v); }
static inline void log_dump_val_worker(long int v) { log("%ld", v); }
static inline void log_dump_val_worker(unsigned long int v) { log("%lu", v); }
#ifndef _WIN32
static inline void log_dump_val_worker(long long int v) { log("%lld", v); }
static inline void log_dump_val_worker(unsigned long long int v) { log("%lld", v); }
#endif
static inline void log_dump_val_worker(char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\\\x%02x'", c); }
static inline void log_dump_val_worker(unsigned char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\\\x%02x'", c); }
static inline void log_dump_val_worker(bool v) { log("%s", v ? "true" : "false"); }
static inline void log_dump_val_worker(double v) { log("%f", v); }
static inline void log_dump_val_worker(char *v) { log("%s", v); }
static inline void log_dump_val_worker(const char *v) { log("%s", v); }
static inline void log_dump_val_worker(std::string v) { log("%s", v.c_str()); }
static inline void log_dump_val_worker(PerformanceTimer p) { log("%f seconds", p.sec()); }
static inline void log_dump_args_worker(const char *p) { log_assert(*p == 0); }
void log_dump_val_worker(RTLIL::IdString v);
void log_dump_val_worker(RTLIL::SigSpec v);
void log_dump_val_worker(RTLIL::State v);

template<typename K, typename T> static inline void log_dump_val_worker(dict<K, T> &v);
template<typename K> static inline void log_dump_val_worker(pool<K> &v);
template<typename K> static inline void log_dump_val_worker(std::vector<K> &v);
template<typename T> static inline void log_dump_val_worker(T *ptr);

template<typename K, typename T>
static inline void log_dump_val_worker(dict<K, T> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it.first);
		log(": ");
		log_dump_val_worker(it.second);
		first = false;
	}
	log(" }");
}

template<typename K>
static inline void log_dump_val_worker(pool<K> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it);
		first = false;
	}
	log(" }");
}

template<typename K>
static inline void log_dump_val_worker(std::vector<K> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it);
		first = false;
	}
	log(" }");
}

template<typename T>
static inline void log_dump_val_worker(T *ptr) { log("%p", ptr); }

template<typename T, typename ... Args>
void log_dump_args_worker(const char *p, T first, Args ... args)
{
	int next_p_state = 0;
	const char *next_p = p;
	while (*next_p && (next_p_state != 0 || *next_p != ',')) {
		if (*next_p == '"')
			do {
				next_p++;
				while (*next_p == '\\\\' && *(next_p + 1))
					next_p += 2;
			} while (*next_p && *next_p != '"');
		if (*next_p == '\\'') {
			next_p++;
			if (*next_p == '\\\\')
				next_p++;
			if (*next_p)
				next_p++;
		}
		if (*next_p == '(' || *next_p == '[' || *next_p == '{')
			next_p_state++;
		if ((*next_p == ')' || *next_p == ']' || *next_p == '}') && next_p_state > 0)
			next_p_state--;
		next_p++;
	}
	log("\\n\\t%.*s => ", int(next_p - p), p);
	if (*next_p == ',')
		next_p++;
	while (*next_p == ' ' || *next_p == '\\t' || *next_p == '\\r' || *next_p == '\\n')
		next_p++;
	log_dump_val_worker(first);
	log_dump_args_worker(next_p, args ...);
}

#define log_dump(...) do { \\
	log("DEBUG DUMP IN %s AT %s:%d:", __PRETTY_FUNCTION__, __FILE__, __LINE__); \\
	log_dump_args_worker(#__VA_ARGS__, __VA_ARGS__); \\
	log("\\n"); \\
} while (0)

YOSYS_NAMESPACE_END

#include "kernel/yosys.h"

#endif
`,"macc.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MACC_H
#define MACC_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct Macc
{
	struct term_t {
		RTLIL::SigSpec in_a, in_b;
		bool is_signed, do_subtract;
	};
	std::vector<term_t> terms;

	void optimize(int width)
	{
		std::vector<term_t> new_terms;
		RTLIL::Const off(0, width);

		for (auto &port : terms)
		{
			if (GetSize(port.in_a) == 0 && GetSize(port.in_b) == 0)
				continue;

			if (GetSize(port.in_a) < GetSize(port.in_b))
				std::swap(port.in_a, port.in_b);

			if (port.in_a.is_fully_const() && port.in_b.is_fully_const()) {
				RTLIL::Const v = port.in_a.as_const();
				if (GetSize(port.in_b))
					v = const_mul(v, port.in_b.as_const(), port.is_signed, port.is_signed, width);
				if (port.do_subtract)
					off = const_sub(off, v, port.is_signed, port.is_signed, width);
				else
					off = const_add(off, v, port.is_signed, port.is_signed, width);
				continue;
			}

			if (port.is_signed) {
				while (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == port.in_a[GetSize(port.in_a)-2])
					port.in_a.remove(GetSize(port.in_a)-1);
				while (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == port.in_b[GetSize(port.in_b)-2])
					port.in_b.remove(GetSize(port.in_b)-1);
			} else {
				while (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == State::S0)
					port.in_a.remove(GetSize(port.in_a)-1);
				while (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == State::S0)
					port.in_b.remove(GetSize(port.in_b)-1);
			}

			new_terms.push_back(port);
		}

		if (off.as_bool()) {
			term_t port;
			port.in_a = off;
			port.is_signed = false;
			port.do_subtract = false;
			new_terms.push_back(port);
		}

		new_terms.swap(terms);
	}

	void from_cell_v1(RTLIL::Cell *cell)
	{
		RTLIL::SigSpec port_a = cell->getPort(ID::A);

		terms.clear();

		auto config_bits = cell->getParam(ID::CONFIG);
		int config_cursor = 0;

		int config_width = cell->getParam(ID::CONFIG_WIDTH).as_int();
		log_assert(GetSize(config_bits) >= config_width);

		int num_bits = 0;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 1;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 2;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 4;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 8;

		int port_a_cursor = 0;
		while (port_a_cursor < GetSize(port_a))
		{
			log_assert(config_cursor + 2 + 2*num_bits <= config_width);

			term_t this_port;
			this_port.is_signed = config_bits[config_cursor++] == State::S1;
			this_port.do_subtract = config_bits[config_cursor++] == State::S1;

			int size_a = 0;
			for (int i = 0; i < num_bits; i++)
				if (config_bits[config_cursor++] == State::S1)
					size_a |= 1 << i;

			this_port.in_a = port_a.extract(port_a_cursor, size_a);
			port_a_cursor += size_a;

			int size_b = 0;
			for (int i = 0; i < num_bits; i++)
				if (config_bits[config_cursor++] == State::S1)
					size_b |= 1 << i;

			this_port.in_b = port_a.extract(port_a_cursor, size_b);
			port_a_cursor += size_b;

			if (size_a || size_b)
				terms.push_back(this_port);
		}

		for (auto bit : cell->getPort(ID::B))
			terms.push_back(term_t{{bit}, {}, false, false});

		log_assert(config_cursor == config_width);
		log_assert(port_a_cursor == GetSize(port_a));
	}

	void from_cell(RTLIL::Cell *cell)
	{
		if (cell->type == ID($macc)) {
			from_cell_v1(cell);
			return;
		}
		log_assert(cell->type == ID($macc_v2));

		RTLIL::SigSpec port_a = cell->getPort(ID::A);
		RTLIL::SigSpec port_b = cell->getPort(ID::B);
		RTLIL::SigSpec port_c = cell->getPort(ID::C);

		terms.clear();

		int nproducts = cell->getParam(ID::NPRODUCTS).as_int();
		const Const &product_neg = cell->getParam(ID::PRODUCT_NEGATED);
		const Const &a_widths = cell->getParam(ID::A_WIDTHS);
		const Const &b_widths = cell->getParam(ID::B_WIDTHS);
		const Const &a_signed = cell->getParam(ID::A_SIGNED);
		const Const &b_signed = cell->getParam(ID::B_SIGNED);
		int ai = 0, bi = 0;
		for (int i = 0; i < nproducts; i++) {
			term_t term;

			log_assert(a_signed[i] == b_signed[i]);
			term.is_signed = (a_signed[i] == State::S1);
			int a_width = a_widths.extract(16 * i, 16).as_int(false);
			int b_width = b_widths.extract(16 * i, 16).as_int(false);

			term.in_a = port_a.extract(ai, a_width);
			ai += a_width;
			term.in_b = port_b.extract(bi, b_width);
			bi += b_width;
			term.do_subtract = (product_neg[i] == State::S1);

			terms.push_back(term);
		}
		log_assert(port_a.size() == ai);
		log_assert(port_b.size() == bi);

		int naddends = cell->getParam(ID::NADDENDS).as_int();
		const Const &addend_neg = cell->getParam(ID::ADDEND_NEGATED);
		const Const &c_widths = cell->getParam(ID::C_WIDTHS);
		const Const &c_signed = cell->getParam(ID::C_SIGNED);
		int ci = 0;
		for (int i = 0; i < naddends; i++) {
			term_t term;

			term.is_signed = (c_signed[i] == State::S1);
			int c_width = c_widths.extract(16 * i, 16).as_int(false);

			term.in_a = port_c.extract(ci, c_width);
			ci += c_width;
			term.do_subtract = (addend_neg[i] == State::S1);

			terms.push_back(term);
		}
		log_assert(port_c.size() == ci);
	}

	void to_cell(RTLIL::Cell *cell)
	{
		cell->type = ID($macc_v2);

		int nproducts = 0, naddends = 0;
		Const a_signed, b_signed, a_widths, b_widths, product_negated;
		Const c_signed, c_widths, addend_negated;
		SigSpec a, b, c;

		for (int i = 0; i < (int) terms.size(); i++) {
			SigSpec term_a = terms[i].in_a, term_b = terms[i].in_b;

			if (term_b.empty()) {
				// addend
				c_widths.append(Const(term_a.size(), 16));
				c_signed.append(terms[i].is_signed ? RTLIL::S1 : RTLIL::S0);
				addend_negated.append(terms[i].do_subtract ? RTLIL::S1 : RTLIL::S0);
				c.append(term_a);
				naddends++;
			} else {
				// product
				a_widths.append(Const(term_a.size(), 16));
				b_widths.append(Const(term_b.size(), 16));
				a_signed.append(terms[i].is_signed ? RTLIL::S1 : RTLIL::S0);
				b_signed.append(terms[i].is_signed ? RTLIL::S1 : RTLIL::S0);
				product_negated.append(terms[i].do_subtract ? RTLIL::S1 : RTLIL::S0);
				a.append(term_a);
				b.append(term_b);
				nproducts++;
			}
		}

		if (a_signed.empty())
			a_signed = {RTLIL::Sx};
		if (b_signed.empty())
			b_signed = {RTLIL::Sx};
		if (c_signed.empty())
			c_signed = {RTLIL::Sx};
		if (a_widths.empty())
			a_widths = {RTLIL::Sx};
		if (b_widths.empty())
			b_widths = {RTLIL::Sx};
		if (c_widths.empty())
			c_widths = {RTLIL::Sx};
		if (product_negated.empty())
			product_negated = {RTLIL::Sx};
		if (addend_negated.empty())
			addend_negated = {RTLIL::Sx};

		cell->setParam(ID::NPRODUCTS, nproducts);
		cell->setParam(ID::PRODUCT_NEGATED, product_negated);
		cell->setParam(ID::NADDENDS, naddends);
		cell->setParam(ID::ADDEND_NEGATED, addend_negated);
		cell->setParam(ID::A_SIGNED, a_signed);
		cell->setParam(ID::B_SIGNED, b_signed);
		cell->setParam(ID::C_SIGNED, c_signed);
		cell->setParam(ID::A_WIDTHS, a_widths);
		cell->setParam(ID::B_WIDTHS, b_widths);
		cell->setParam(ID::C_WIDTHS, c_widths);
		cell->setPort(ID::A, a);
		cell->setPort(ID::B, b);
		cell->setPort(ID::C, c);
	}

	bool eval(RTLIL::Const &result) const
	{
		for (auto &bit : result.bits())
			bit = State::S0;

		for (auto &port : terms)
		{
			if (!port.in_a.is_fully_const() || !port.in_b.is_fully_const())
				return false;

			RTLIL::Const summand;
			if (GetSize(port.in_b) == 0)
				summand = const_pos(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));
			else
				summand = const_mul(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));

			if (port.do_subtract)
				result = const_sub(result, summand, port.is_signed, port.is_signed, GetSize(result));
			else
				result = const_add(result, summand, port.is_signed, port.is_signed, GetSize(result));
		}

		return true;
	}

	bool is_simple_product()
	{
		return terms.size() == 1 &&
				!terms[0].in_b.empty() &&
				!terms[0].do_subtract;
	}

	Macc(RTLIL::Cell *cell = nullptr)
	{
		if (cell != nullptr)
			from_cell(cell);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"mem.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MEM_H
#define MEM_H

#include "kernel/yosys.h"
#include "kernel/ffinit.h"
#include "kernel/utils.h"

YOSYS_NAMESPACE_BEGIN

struct MemRd : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	int wide_log2;
	bool clk_enable, clk_polarity, ce_over_srst;
	Const arst_value, srst_value, init_value;
	// One bit for every write port, true iff simultanous read on this
	// port and write on the other port will bypass the written data
	// to this port's output (default behavior is to read old value).
	// Can only be set for write ports that have the same clock domain.
	std::vector<bool> transparency_mask;
	// One bit for every write port, true iff simultanous read on this
	// port and write on the other port will return an all-X (don't care)
	// value.  Mutually exclusive with transparency_mask.
	// Can only be set for write ports that have the same clock domain.
	// For optimization purposes, this will also be set if we can
	// determine that the two ports can never be active simultanously
	// (making the above vacuously true).
	std::vector<bool> collision_x_mask;
	SigSpec clk, en, arst, srst, addr, data;

	MemRd() : removed(false), cell(nullptr), wide_log2(0), clk_enable(false), clk_polarity(true), ce_over_srst(false), clk(State::Sx), en(State::S1), arst(State::S0), srst(State::S0) {}

	// Returns the address of given subword index accessed by this port.
	SigSpec sub_addr(int sub) {
		SigSpec res = addr;
		for (int i = 0; i < wide_log2; i++)
			res[i] = State(sub >> i & 1);
		return res;
	}
};

struct MemWr : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	int wide_log2;
	bool clk_enable, clk_polarity;
	std::vector<bool> priority_mask;
	SigSpec clk, en, addr, data;

	MemWr() : removed(false), cell(nullptr) {}

	// Returns the address of given subword index accessed by this port.
	SigSpec sub_addr(int sub) {
		SigSpec res = addr;
		for (int i = 0; i < wide_log2; i++)
			res[i] = State(sub >> i & 1);
		return res;
	}

	std::pair<SigSpec, std::vector<int>> compress_en();
	SigSpec decompress_en(const std::vector<int> &swizzle, SigSpec sig);
};

struct MemInit : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	Const addr;
	Const data;
	Const en;
	MemInit() : removed(false), cell(nullptr) {}
};

struct Mem : RTLIL::AttrObject {
	Module *module;
	IdString memid;
	bool packed;
	RTLIL::Memory *mem;
	Cell *cell;
	int width, start_offset, size;
	std::vector<MemInit> inits;
	std::vector<MemRd> rd_ports;
	std::vector<MemWr> wr_ports;

	// Removes this memory from the module.  The data in helper structures
	// is unaffected except for the cell/mem fields.
	void remove();

	// Commits all changes in helper structures into the module \u2014 ports and
	// inits marked as removed are actually removed, new ports/inits create
	// new cells, modified port/inits are commited into their existing
	// cells.  Note that this reindexes the ports and inits array (actually
	// removing the ports/inits marked as removed).
	void emit();

	// Marks all inits as removed.
	void clear_inits();

	// Coalesces inits: whenever two inits have overlapping or touching
	// address ranges, they are combined into one, with the higher-priority
	// one's data overwriting the other.  Running this results in
	// an inits list equivalent to the original, in which all entries
	// cover disjoint (and non-touching) address ranges, and all enable
	// masks are all-1.
	void coalesce_inits();

	// Checks consistency of this memory and all its ports/inits, using
	// log_assert.
	void check();

	// Gathers all initialization data into a single big const covering
	// the whole memory.  For all non-initialized bits, Sx will be returned.
	Const get_init_data() const;

	// Constructs and returns the helper structures for all memories
	// in a module.
	static std::vector<Mem> get_all_memories(Module *module);

	// Constructs and returns the helper structures for all selected
	// memories in a module.
	static std::vector<Mem> get_selected_memories(Module *module);

	// Converts a synchronous read port into an asynchronous one by
	// extracting the data (or, in some rare cases, address) register
	// into a separate cell, together with any soft-transparency
	// logic necessary to preserve its semantics.  Returns the created
	// register cell, if any.  Note that in some rare cases this function
	// may succeed and perform a conversion without creating a new
	// register \u2014 a nullptr result doesn't imply nothing was done.
	Cell *extract_rdff(int idx, FfInitVals *initvals);

	// Splits all wide ports in this memory into equivalent narrow ones.
	// This function performs no modifications at all to the actual
	// netlist unless and until emit() is called.
	void narrow();

	// If write port idx2 currently has priority over write port idx1,
	// inserts extra logic on idx1's enable signal to disable writes
	// when idx2 is writing to the same address, then removes the priority
	// from the priority mask.  If there is a memory port that is
	// transparent with idx1, but not with idx2, that port is converted
	// to use soft transparency logic.
	void emulate_priority(int idx1, int idx2, FfInitVals *initvals);

	// Creates soft-transparency logic on read port ridx, bypassing the
	// data from write port widx.  Should only be called when ridx is
	// transparent wrt widx in the first place.  Once we're done, the
	// transparency_mask bit will be cleared, and the collision_x_mask
	// bit will be set instead (since whatever value is read will be
	// replaced by the soft transparency logic).
	void emulate_transparency(int widx, int ridx, FfInitVals *initvals);

	// Prepares for merging write port idx2 into idx1 (where idx1 < idx2).
	// Specifically, takes care of priority masks: any priority relations
	// that idx2 had are replicated onto idx1, unless they conflict with
	// priorities already present on idx1, in which case emulate_priority
	// is called.  Likewise, ensures transparency and undefined collision
	// masks of all read ports have the same values for both ports,
	// calling emulate_transparency if necessary.
	void prepare_wr_merge(int idx1, int idx2, FfInitVals *initvals);

	// Prepares for merging read port idx2 into idx1.
	// Specifically, makes sure the transparency and undefined collision
	// masks of both ports are equal, by changing undefined behavior
	// of one port to the other's defined behavior, or by calling
	// emulate_transparency if necessary.
	void prepare_rd_merge(int idx1, int idx2, FfInitVals *initvals);

	// Prepares the memory for widening a port to a given width.  This
	// involves ensuring that start_offset and size are aligned to the
	// target width.
	void widen_prep(int wide_log2);

	// Widens a write port up to a given width.  The newly port is
	// equivalent to the original, made by replicating enable/data bits
	// and masking enable bits with decoders on the low part of the
	// original address.
	void widen_wr_port(int idx, int wide_log2);

	// Emulates a sync read port's enable functionality in soft logic,
	// changing the actual read port's enable to be always-on.
	void emulate_rden(int idx, FfInitVals *initvals);

	// Emulates a sync read port's initial/reset value functionality in
	// soft logic, removing it from the actual read port.
	void emulate_reset(int idx, bool emu_init, bool emu_arst, bool emu_srst, FfInitVals *initvals);

	// Given a read port with ce_over_srst set, converts it to a port
	// with ce_over_srst unset without changing its behavior by adding
	// emulation logic.
	void emulate_rd_ce_over_srst(int idx);

	// Given a read port with ce_over_srst unset, converts it to a port
	// with ce_over_srst set without changing its behavior by adding
	// emulation logic.
	void emulate_rd_srst_over_ce(int idx);

	// Returns true iff emulate_read_first makes sense to call.
	bool emulate_read_first_ok();

	// Emulates all read-first read-write port relationships in terms of
	// all-transparent ports, by delaying all write ports by one cycle.
	// This can only be used when all read ports and all write ports are
	// in the same clock domain.
	void emulate_read_first(FfInitVals *initvals);

	Mem(Module *module, IdString memid, int width, int start_offset, int size) : module(module), memid(memid), packed(false), mem(nullptr), cell(nullptr), width(width), start_offset(start_offset), size(size) {}
};

// MemContents efficiently represents the contents of a potentially sparse memory by storing only those segments that are actually defined
class MemContents {
public:
	class range; class iterator;
	using addr_t = uint32_t;
private:
	// we ban _addr_width == sizeof(addr_t) * 8 because it adds too many cornercases
	int _addr_width;
	int _data_width;
	RTLIL::Const _default_value;
	// for each range, store the concatenation of the words at the start address
	// invariants:
	// - no overlapping or adjacent ranges
	// - no empty ranges
	// - all Consts are a multiple of the word size
	std::map<addr_t, RTLIL::Const> _values;
	// returns an iterator to the range containing addr, if it exists, or the first range past addr
	std::map<addr_t, RTLIL::Const>::iterator _range_at(addr_t addr) const;
	addr_t _range_size(std::map<addr_t, RTLIL::Const>::iterator it) const { return it->second.size() / _data_width; }
	addr_t _range_begin(std::map<addr_t, RTLIL::Const>::iterator it) const { return it->first; }
	addr_t _range_end(std::map<addr_t, RTLIL::Const>::iterator it) const { return _range_begin(it) + _range_size(it); }
	// check if the iterator points to a range containing addr
	bool _range_contains(std::map<addr_t, RTLIL::Const>::iterator it, addr_t addr) const;
	// check if the iterator points to a range containing [begin_addr, end_addr). assumes end_addr >= begin_addr.
	bool _range_contains(std::map<addr_t, RTLIL::Const>::iterator it, addr_t begin_addr, addr_t end_addr) const;
	// check if the iterator points to a range overlapping with [begin_addr, end_addr)
	bool _range_overlaps(std::map<addr_t, RTLIL::Const>::iterator it, addr_t begin_addr, addr_t end_addr) const;
	// return the offset the addr would have in the range at \`it\`
	size_t _range_offset(std::map<addr_t, RTLIL::Const>::iterator it, addr_t addr) const { return (addr - it->first) * _data_width; }
	// assuming _range_contains(it, addr), return an iterator pointing to the data at addr
	std::vector<State>::iterator _range_data(std::map<addr_t, RTLIL::Const>::iterator it, addr_t addr) { return it->second.bits().begin() + _range_offset(it, addr); }
	// internal version of reserve_range that returns an iterator to the range
	std::map<addr_t, RTLIL::Const>::iterator _reserve_range(addr_t begin_addr, addr_t end_addr);
	// write a single word at addr, return iterator to next word
	std::vector<State>::iterator _range_write(std::vector<State>::iterator it, RTLIL::Const const &data);
public:
	class range {
		int _data_width;
		addr_t _base;
		RTLIL::Const const &_values;
		friend class iterator;
		range(int data_width, addr_t base, RTLIL::Const const &values)
		: _data_width(data_width), _base(base), _values(values) {}
	public:
		addr_t base() const { return _base; }
		addr_t size() const { return ((addr_t) _values.size()) / _data_width; }
		addr_t limit() const { return _base + size(); }
		RTLIL::Const const &concatenated() const { return _values; }
		RTLIL::Const operator[](addr_t addr) const {
			log_assert(addr - _base < size());
			return _values.extract((addr - _base) * _data_width, _data_width);
		}
		RTLIL::Const at_offset(addr_t offset) const { return (*this)[_base + offset]; }
	};
	class iterator {
		MemContents const *_memory;
		// storing addr instead of an iterator gives more well-defined behaviour under insertions/deletions
		// use ~0 for end so that all end iterators compare the same
		addr_t _addr;
		friend class MemContents;
		iterator(MemContents const *memory, addr_t addr) : _memory(memory), _addr(addr) {}
	public:
		using iterator_category = std::input_iterator_tag;
		using value_type = range;
		using pointer = arrow_proxy<range>;
		using reference = range;
		using difference_type = addr_t;
		reference operator *() const { return range(_memory->_data_width, _addr, _memory->_values.at(_addr)); }
		pointer operator->() const { return arrow_proxy<range>(**this); }
		bool operator !=(iterator const &other) const { return _memory != other._memory || _addr != other._addr; }
		bool operator ==(iterator const &other) const { return !(*this != other); }
		iterator &operator++();
	};
	MemContents(int addr_width, int data_width, RTLIL::Const default_value)
		: _addr_width(addr_width), _data_width(data_width)
		, _default_value((default_value.extu(data_width), std::move(default_value)))
	{ log_assert(_addr_width > 0 && _addr_width < (int)sizeof(addr_t) * 8); log_assert(_data_width > 0); }
	MemContents(int addr_width, int data_width) : MemContents(addr_width, data_width, RTLIL::Const(State::Sx, data_width)) {}
	explicit MemContents(Mem *mem);
	int addr_width() const { return _addr_width; }
	int data_width() const { return _data_width; }
	RTLIL::Const const &default_value() const { return _default_value; }
	// return the value at the address if it exists, the default_value of the memory otherwise. address must not exceed 2**addr_width.
	RTLIL::Const operator [](addr_t addr) const;
	// return the number of defined words in the range [begin_addr, end_addr)
	addr_t count_range(addr_t begin_addr, addr_t end_addr) const;
	// allocate memory for the range [begin_addr, end_addr), but leave the contents undefined.
	void reserve_range(addr_t begin_addr, addr_t end_addr) { _reserve_range(begin_addr, end_addr); }
	// insert multiple words (provided as a single concatenated RTLIL::Const) at the given address, overriding any previous assignment.
	void insert_concatenated(addr_t addr, RTLIL::Const const &values);
	// insert multiple words at the given address, overriding any previous assignment.
	template<typename Iterator> void insert_range(addr_t addr, Iterator begin, Iterator end) {
		auto words = end - begin;
		log_assert(addr < (addr_t)(1<<_addr_width)); log_assert(words <= (addr_t)(1<<_addr_width) - addr);
		auto range = _reserve_range(addr, addr + words);
		auto it = _range_data(range, addr);
		for(; begin != end; ++begin)
			it = _range_write(it, *begin);
	}
	// undefine all words in the range [begin_addr, end_addr)
	void clear_range(addr_t begin_addr, addr_t end_addr);
	// check invariants, abort if invariants failed
	void check();
	iterator end() const { return iterator(nullptr, ~(addr_t) 0); }
	iterator begin() const { return _values.empty() ? end() : iterator(this, _values.begin()->first); }
	bool empty() const { return _values.empty(); }
};

YOSYS_NAMESPACE_END

#endif
`,"modtools.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MODTOOLS_H
#define MODTOOLS_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"

YOSYS_NAMESPACE_BEGIN

struct ModIndex : public RTLIL::Monitor
{
	struct PortInfo {
		RTLIL::Cell* cell;
		RTLIL::IdString port;
		int offset;

		PortInfo() : cell(), port(), offset() { }
		PortInfo(RTLIL::Cell* _c, RTLIL::IdString _p, int _o) : cell(_c), port(_p), offset(_o) { }

		bool operator<(const PortInfo &other) const {
			if (cell != other.cell)
				return cell < other.cell;
			if (offset != other.offset)
				return offset < other.offset;
			return port < other.port;
		}

		bool operator==(const PortInfo &other) const {
			return cell == other.cell && port == other.port && offset == other.offset;
		}

		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(cell->name);
			h.eat(port);
			h.eat(offset);
			return h;
		}
	};

	struct SigBitInfo
	{
		bool is_input, is_output;
		pool<PortInfo> ports;

		SigBitInfo() : is_input(false), is_output(false) { }

		bool operator==(const SigBitInfo &other) const {
			return is_input == other.is_input && is_output == other.is_output && ports == other.ports;
		}

		void merge(const SigBitInfo &other)
		{
			is_input = is_input || other.is_input;
			is_output = is_output || other.is_output;
			ports.insert(other.ports.begin(), other.ports.end());
		}
	};

	SigMap sigmap;
	RTLIL::Module *module;
	std::map<RTLIL::SigBit, SigBitInfo> database;
	int auto_reload_counter;
	bool auto_reload_module;

	void port_add(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)
	{
		for (int i = 0; i < GetSize(sig); i++) {
			RTLIL::SigBit bit = sigmap(sig[i]);
			if (bit.wire)
				database[bit].ports.insert(PortInfo(cell, port, i));
		}
	}

	void port_del(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)
	{
		for (int i = 0; i < GetSize(sig); i++) {
			RTLIL::SigBit bit = sigmap(sig[i]);
			if (bit.wire)
				database[bit].ports.erase(PortInfo(cell, port, i));
		}
	}

	const SigBitInfo &info(RTLIL::SigBit bit)
	{
		return database[sigmap(bit)];
	}

	void reload_module(bool reset_sigmap = true)
	{
		if (reset_sigmap) {
			sigmap.clear();
			sigmap.set(module);
		}

		database.clear();
		for (auto wire : module->wires())
			if (wire->port_input || wire->port_output)
				for (int i = 0; i < GetSize(wire); i++) {
					RTLIL::SigBit bit = sigmap(RTLIL::SigBit(wire, i));
					if (bit.wire && wire->port_input)
						database[bit].is_input = true;
					if (bit.wire && wire->port_output)
						database[bit].is_output = true;
				}
		for (auto cell : module->cells())
			for (auto &conn : cell->connections())
				port_add(cell, conn.first, conn.second);

		if (auto_reload_module) {
			if (++auto_reload_counter > 2)
				log_warning("Auto-reload in ModIndex -- possible performance bug!\\n");
			auto_reload_module = false;
		}
	}

	void check()
	{
#ifndef NDEBUG
		if (auto_reload_module)
			return;

		for (auto it : database)
			log_assert(it.first == sigmap(it.first));

		auto database_bak = std::move(database);
		reload_module(false);

		if (!(database == database_bak))
		{
			for (auto &it : database_bak)
				if (!database.count(it.first))
					log("ModuleIndex::check(): Only in database_bak, not database: %s\\n", log_signal(it.first));

			for (auto &it : database)
				if (!database_bak.count(it.first))
					log("ModuleIndex::check(): Only in database, not database_bak: %s\\n", log_signal(it.first));
				else if (!(it.second == database_bak.at(it.first)))
					log("ModuleIndex::check(): Different content for database[%s].\\n", log_signal(it.first));

			log_assert(database == database_bak);
		}
#endif
	}

	void notify_connect(RTLIL::Cell *cell, const RTLIL::IdString &port, const RTLIL::SigSpec &old_sig, const RTLIL::SigSpec &sig) override
	{
		log_assert(module == cell->module);

		if (auto_reload_module)
			return;

		port_del(cell, port, old_sig);
		port_add(cell, port, sig);
	}

	void notify_connect(RTLIL::Module *mod, const RTLIL::SigSig &sigsig) override
	{
		log_assert(module == mod);

		if (auto_reload_module)
			return;

		for (int i = 0; i < GetSize(sigsig.first); i++)
		{
			RTLIL::SigBit lhs = sigmap(sigsig.first[i]);
			RTLIL::SigBit rhs = sigmap(sigsig.second[i]);
			bool has_lhs = database.count(lhs) != 0;
			bool has_rhs = database.count(rhs) != 0;

			if (!has_lhs && !has_rhs) {
				sigmap.add(lhs, rhs);
			} else
			if (!has_rhs) {
				SigBitInfo new_info = database.at(lhs);
				database.erase(lhs);
				sigmap.add(lhs, rhs);
				lhs = sigmap(lhs);
				if (lhs.wire)
					database[lhs] = new_info;
			} else
			if (!has_lhs) {
				SigBitInfo new_info = database.at(rhs);
				database.erase(rhs);
				sigmap.add(lhs, rhs);
				rhs = sigmap(rhs);
				if (rhs.wire)
					database[rhs] = new_info;
			} else {
				SigBitInfo new_info = database.at(lhs);
				new_info.merge(database.at(rhs));
				database.erase(lhs);
				database.erase(rhs);
				sigmap.add(lhs, rhs);
				rhs = sigmap(rhs);
				if (rhs.wire)
					database[rhs] = new_info;
			}
		}
	}

	void notify_connect(RTLIL::Module *mod, const std::vector<RTLIL::SigSig>&) override
	{
		log_assert(module == mod);
		auto_reload_module = true;
	}

	void notify_blackout(RTLIL::Module *mod) override
	{
		log_assert(module == mod);
		auto_reload_module = true;
	}

	ModIndex(RTLIL::Module *_m) : sigmap(_m), module(_m)
	{
		auto_reload_counter = 0;
		auto_reload_module = true;
		module->monitors.insert(this);
	}

	~ModIndex()
	{
		module->monitors.erase(this);
	}

	SigBitInfo *query(RTLIL::SigBit bit)
	{
		if (auto_reload_module)
			reload_module();

		auto it = database.find(sigmap(bit));
		if (it == database.end())
			return nullptr;
		else
			return &it->second;
	}

	bool query_is_input(RTLIL::SigBit bit)
	{
		const SigBitInfo *info = query(bit);
		if (info == nullptr)
			return false;
		return info->is_input;
	}

	bool query_is_output(RTLIL::SigBit bit)
	{
		const SigBitInfo *info = query(bit);
		if (info == nullptr)
			return false;
		return info->is_output;
	}

	pool<PortInfo> &query_ports(RTLIL::SigBit bit)
	{
		static pool<PortInfo> empty_result_set;
		SigBitInfo *info = query(bit);
		if (info == nullptr)
			return empty_result_set;
		return info->ports;
	}

	void dump_db()
	{
		log("--- ModIndex Dump ---\\n");

		if (auto_reload_module) {
			log("AUTO-RELOAD\\n");
			reload_module();
		}

		for (auto &it : database) {
			log("BIT %s:\\n", log_signal(it.first));
			if (it.second.is_input)
				log("  PRIMARY INPUT\\n");
			if (it.second.is_output)
				log("  PRIMARY OUTPUT\\n");
			for (auto &port : it.second.ports)
				log("  PORT: %s.%s[%d] (%s)\\n", log_id(port.cell),
						log_id(port.port), port.offset, log_id(port.cell->type));
		}
	}
};

struct ModWalker
{
	struct PortBit
	{
		RTLIL::Cell *cell;
		RTLIL::IdString port;
		int offset;
		PortBit(Cell* c, IdString p, int o) : cell(c), port(p), offset(o) {}

		bool operator<(const PortBit &other) const {
			if (cell != other.cell)
				return cell < other.cell;
			if (port != other.port)
				return port < other.port;
			return offset < other.offset;
		}

		bool operator==(const PortBit &other) const {
			return cell == other.cell && port == other.port && offset == other.offset;
		}

		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(cell->name);
			h.eat(port);
			h.eat(offset);
			return h;
		}
	};

	RTLIL::Design *design;
	RTLIL::Module *module;

	CellTypes ct;
	SigMap sigmap;

	dict<RTLIL::SigBit, pool<PortBit>> signal_drivers;
	dict<RTLIL::SigBit, pool<PortBit>> signal_consumers;
	pool<RTLIL::SigBit> signal_inputs, signal_outputs;

	dict<RTLIL::Cell*, pool<RTLIL::SigBit>> cell_outputs, cell_inputs;

	void add_wire(RTLIL::Wire *wire)
	{
		if (wire->port_input) {
			std::vector<RTLIL::SigBit> bits = sigmap(wire);
			for (auto bit : bits)
				if (bit.wire != NULL)
					signal_inputs.insert(bit);
		}

		if (wire->port_output) {
			std::vector<RTLIL::SigBit> bits = sigmap(wire);
			for (auto bit : bits)
				if (bit.wire != NULL)
					signal_outputs.insert(bit);
		}
	}

	void add_cell_port(RTLIL::Cell *cell, RTLIL::IdString port, std::vector<RTLIL::SigBit> bits, bool is_output, bool is_input)
	{
		for (int i = 0; i < int(bits.size()); i++)
			if (bits[i].wire != NULL) {
				PortBit pbit {cell, port, i};
				if (is_output) {
					signal_drivers[bits[i]].insert(pbit);
					cell_outputs[cell].insert(bits[i]);
				}
				if (is_input) {
					signal_consumers[bits[i]].insert(pbit);
					cell_inputs[cell].insert(bits[i]);
				}
			}
	}

	void add_cell(RTLIL::Cell *cell)
	{
		if (ct.cell_known(cell->type)) {
			for (auto &conn : cell->connections())
				add_cell_port(cell, conn.first, sigmap(conn.second),
						ct.cell_output(cell->type, conn.first),
						ct.cell_input(cell->type, conn.first));
		} else {
			for (auto &conn : cell->connections())
				add_cell_port(cell, conn.first, sigmap(conn.second), true, true);
		}
	}

	ModWalker(RTLIL::Design *design, RTLIL::Module *module = nullptr) : design(design), module(NULL)
	{
		ct.setup(design);
		if (module)
			setup(module);
	}

	void setup(RTLIL::Module *module, CellTypes *filter_ct = NULL)
	{
		this->module = module;

		sigmap.set(module);

		signal_drivers.clear();
		signal_consumers.clear();
		signal_inputs.clear();
		signal_outputs.clear();
		cell_inputs.clear();
		cell_outputs.clear();

		for (auto &it : module->wires_)
			add_wire(it.second);
		for (auto &it : module->cells_)
			if (filter_ct == NULL || filter_ct->cell_known(it.second->type))
				add_cell(it.second);
	}

	// get_* methods -- single RTLIL::SigBit

	inline bool get_drivers(pool<PortBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_drivers.count(bit)) {
			const pool<PortBit> &r = signal_drivers.at(bit);
			result.insert(r.begin(), r.end());
			found = true;
		}
		return found;
	}

	inline bool get_consumers(pool<PortBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_consumers.count(bit)) {
			const pool<PortBit> &r = signal_consumers.at(bit);
			result.insert(r.begin(), r.end());
			found = true;
		}
		return found;
	}

	inline bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_inputs.count(bit))
			result.insert(bit), found = true;
		return found;
	}

	inline bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_outputs.count(bit))
			result.insert(bit), found = true;
		return found;
	}

	// get_* methods -- container of RTLIL::SigBit's (always by reference)

	template<typename T>
	inline bool get_drivers(pool<PortBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_drivers.count(bit)) {
				const pool<PortBit> &r = signal_drivers.at(bit);
				result.insert(r.begin(), r.end());
				found = true;
			}
		return found;
	}

	template<typename T>
	inline bool get_consumers(pool<PortBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_consumers.count(bit)) {
				const pool<PortBit> &r = signal_consumers.at(bit);
				result.insert(r.begin(), r.end());
				found = true;
			}
		return found;
	}

	template<typename T>
	inline bool get_inputs(pool<RTLIL::SigBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_inputs.count(bit))
				result.insert(bit), found = true;
		return found;
	}

	template<typename T>
	inline bool get_outputs(pool<RTLIL::SigBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_outputs.count(bit))
				result.insert(bit), found = true;
		return found;
	}

	// get_* methods -- call by RTLIL::SigSpec (always by value)

	bool get_drivers(pool<PortBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_drivers(result, bits);
	}

	bool get_consumers(pool<PortBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_consumers(result, bits);
	}

	bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_inputs(result, bits);
	}

	bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_outputs(result, bits);
	}

	// has_* methods -- call by reference

	template<typename T>
	inline bool has_drivers(const T &sig) const {
		pool<PortBit> result;
		return get_drivers(result, sig);
	}

	template<typename T>
	inline bool has_consumers(const T &sig) const {
		pool<PortBit> result;
		return get_consumers(result, sig);
	}

	template<typename T>
	inline bool has_inputs(const T &sig) const {
		pool<RTLIL::SigBit> result;
		return get_inputs(result, sig);
	}

	template<typename T>
	inline bool has_outputs(const T &sig) const {
		pool<RTLIL::SigBit> result;
		return get_outputs(result, sig);
	}

	// has_* methods -- call by value

	inline bool has_drivers(RTLIL::SigSpec sig) const {
		pool<PortBit> result;
		return get_drivers(result, sig);
	}

	inline bool has_consumers(RTLIL::SigSpec sig) const {
		pool<PortBit> result;
		return get_consumers(result, sig);
	}

	inline bool has_inputs(RTLIL::SigSpec sig) const {
		pool<RTLIL::SigBit> result;
		return get_inputs(result, sig);
	}

	inline bool has_outputs(RTLIL::SigSpec sig) const {
		pool<RTLIL::SigBit> result;
		return get_outputs(result, sig);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"qcsat.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef QCSAT_H
#define QCSAT_H

#include "kernel/satgen.h"
#include "kernel/modtools.h"

YOSYS_NAMESPACE_BEGIN

// This is a helper class meant for easy construction of quick SAT queries
// to a combinatorial input cone of some set of signals, meant for SAT-based
// optimizations.  Various knobs are provided to set just how much of the
// cone should be included in the model \u2014 since this class is meant for
// optimization, it should not be a correctness problem when some cells are
// skipped and the solver spuriously returns SAT with a solution that
// cannot exist in reality due to skipped constraints (ie. only UNSAT results
// from this class should be considered binding).
struct QuickConeSat {
	ModWalker &modwalker;
	ezSatPtr ez;
	SatGen satgen;

	// The effort level knobs.

	// The maximum "complexity level" of cells that will be imported.
	// - 1: bitwise operations, muxes, equality comparisons, lut, sop, fa
	// - 2: addition, subtraction, greater/less than comparisons, lcu
	// - 3: shifts
	// - 4: multiplication, division, power
	int max_cell_complexity = 2;
	// The maximum number of cells to import, or 0 for no limit.
	int max_cell_count = 0;
	// If non-0, skip importing cells with more than this number of output bits.
	int max_cell_outs = 0;

	// Internal state.
	pool<RTLIL::Cell*> imported_cells;
	pool<RTLIL::Wire*> imported_onehot;
	pool<RTLIL::SigBit> bits_queue;

	QuickConeSat(ModWalker &modwalker) : modwalker(modwalker), ez(), satgen(ez.get(), &modwalker.sigmap) {}

	// Imports a signal into the SAT solver, queues its input cone to be
	// imported in the next prepare() call.
	std::vector<int> importSig(SigSpec sig);
	int importSigBit(SigBit bit);

	// Imports the input cones of all previously importSig'd signals into
	// the SAT solver.
	void prepare();

	// Returns the "complexity level" of a given cell.
	static int cell_complexity(RTLIL::Cell *cell);
};

YOSYS_NAMESPACE_END

#endif
`,"register.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef REGISTER_H
#define REGISTER_H

#include "kernel/yosys_common.h"
#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct Pass
{
	std::string pass_name, short_help;
	Pass(std::string name, std::string short_help = "** document me **");
	// Prefer overriding 'Pass::on_shutdown()' if possible
	virtual ~Pass();

	virtual void help();
	virtual void clear_flags();
	virtual void execute(std::vector<std::string> args, RTLIL::Design *design) = 0;

	int call_counter;
	int64_t runtime_ns;
	bool experimental_flag = false;

	void experimental() {
		experimental_flag = true;
	}

	struct pre_post_exec_state_t {
		Pass *parent_pass;
		int64_t begin_ns;
	};

	pre_post_exec_state_t pre_execute();
	void post_execute(pre_post_exec_state_t state);

	void cmd_log_args(const std::vector<std::string> &args);
	void cmd_error(const std::vector<std::string> &args, size_t argidx, std::string msg);
	void extra_args(std::vector<std::string> args, size_t argidx, RTLIL::Design *design, bool select = true);

	static void call(RTLIL::Design *design, std::string command);
	static void call(RTLIL::Design *design, std::vector<std::string> args);

	static void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::string command);
	static void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::vector<std::string> args);

	static void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::string command);
	static void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::vector<std::string> args);

	Pass *next_queued_pass;
	virtual void run_register();
	static void init_register();
	static void done_register();

	virtual void on_register();
	virtual void on_shutdown();
	virtual bool replace_existing_pass() const { return false; }
};

struct ScriptPass : Pass
{
	bool block_active, help_mode;
	RTLIL::Design *active_design;
	std::string active_run_from, active_run_to;

	ScriptPass(std::string name, std::string short_help = "** document me **") : Pass(name, short_help) { }

	virtual void script() = 0;

	bool check_label(std::string label, std::string info = std::string());
	void run(std::string command, std::string info = std::string());
	void run_nocheck(std::string command, std::string info = std::string());
	void run_script(RTLIL::Design *design, std::string run_from = std::string(), std::string run_to = std::string());
	void help_script();
};

struct Frontend : Pass
{
	// for reading of here documents
	static FILE *current_script_file;
	static std::string last_here_document;

	std::string frontend_name;
	Frontend(std::string name, std::string short_help = "** document me **");
	void run_register() override;
	~Frontend() override;
	void execute(std::vector<std::string> args, RTLIL::Design *design) override final;
	virtual void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) = 0;

	static std::vector<std::string> next_args;
	void extra_args(std::istream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_input = false);

	static void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::string command);
	static void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::vector<std::string> args);
};

struct Backend : Pass
{
	std::string backend_name;
	Backend(std::string name, std::string short_help = "** document me **");
	void run_register() override;
	~Backend() override;
	void execute(std::vector<std::string> args, RTLIL::Design *design) override final;
	virtual void execute(std::ostream *&f, std::string filename,  std::vector<std::string> args, RTLIL::Design *design) = 0;

	void extra_args(std::ostream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_output = false);

	static void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::string command);
	static void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::vector<std::string> args);
};

// implemented in passes/cmds/select.cc
extern void handle_extra_select_args(Pass *pass, const std::vector<std::string> &args, size_t argidx, size_t args_size, RTLIL::Design *design);
extern RTLIL::Selection eval_select_args(const vector<string> &args, RTLIL::Design *design);
extern void eval_select_op(vector<RTLIL::Selection> &work, const string &op, RTLIL::Design *design);

extern std::map<std::string, Pass*> pass_register;
extern std::map<std::string, Frontend*> frontend_register;
extern std::map<std::string, Backend*> backend_register;

YOSYS_NAMESPACE_END

#endif
`,"rtlil.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef RTLIL_H
#define RTLIL_H

#include "kernel/yosys_common.h"
#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

namespace RTLIL
{
	enum State : unsigned char {
		S0 = 0,
		S1 = 1,
		Sx = 2, // undefined value or conflict
		Sz = 3, // high-impedance / not-connected
		Sa = 4, // don't care (used only in cases)
		Sm = 5  // marker (used internally by some passes)
	};

	enum SyncType : unsigned char {
		ST0 = 0, // level sensitive: 0
		ST1 = 1, // level sensitive: 1
		STp = 2, // edge sensitive: posedge
		STn = 3, // edge sensitive: negedge
		STe = 4, // edge sensitive: both edges
		STa = 5, // always active
		STg = 6, // global clock
		STi = 7  // init
	};

	// Semantic metadata - how can this constant be interpreted?
	// Values may be generally non-exclusive
	enum ConstFlags : unsigned char {
		CONST_FLAG_NONE   = 0,
		CONST_FLAG_STRING = 1,
		CONST_FLAG_SIGNED = 2,  // only used for parameters
		CONST_FLAG_REAL   = 4   // only used for parameters
	};

	enum SelectPartials : unsigned char {
		SELECT_ALL = 0,          // include partial modules
		SELECT_WHOLE_ONLY = 1,   // ignore partial modules
		SELECT_WHOLE_WARN = 2,   // call log_warning on partial module
		SELECT_WHOLE_ERR = 3,    // call log_error on partial module
		SELECT_WHOLE_CMDERR = 4  // call log_cmd_error on partial module
	};

	enum SelectBoxes : unsigned char {
		SB_ALL = 0,            // include boxed modules
		SB_WARN = 1,           // helper for log_warning (not for direct use)
		SB_ERR = 2,            // helper for log_error (not for direct use)
		SB_CMDERR = 3,         // helper for log_cmd_error (not for direct use)
		SB_UNBOXED_ONLY = 4,   // ignore boxed modules
		SB_UNBOXED_WARN = 5,   // call log_warning on boxed module
		SB_UNBOXED_ERR = 6,    // call log_error on boxed module
		SB_UNBOXED_CMDERR = 7, // call log_cmd_error on boxed module
		SB_INCL_WB = 8,        // helper for white boxes (not for direct use)
		SB_EXCL_BB_ONLY = 12,  // ignore black boxes, but not white boxes
		SB_EXCL_BB_WARN = 13,  // call log_warning on black boxed module
		SB_EXCL_BB_ERR = 14,   // call log_error on black boxed module
		SB_EXCL_BB_CMDERR = 15 // call log_cmd_error on black boxed module
	};

	struct Const;
	struct AttrObject;
	struct NamedObject;
	struct Selection;
	struct Monitor;
	struct Design;
	struct Module;
	struct Wire;
	struct Memory;
	struct Cell;
	struct SigChunk;
	struct SigBit;
	struct SigSpecIterator;
	struct SigSpecConstIterator;
	struct SigSpec;
	struct CaseRule;
	struct SwitchRule;
	struct MemWriteAction;
	struct SyncRule;
	struct Process;
	struct Binding;
	struct IdString;

	typedef std::pair<SigSpec, SigSpec> SigSig;
};

struct RTLIL::IdString
{
	#undef YOSYS_XTRACE_GET_PUT
	#undef YOSYS_SORT_ID_FREE_LIST
	#undef YOSYS_USE_STICKY_IDS
	#undef YOSYS_NO_IDS_REFCNT

	// the global id string cache

	static bool destruct_guard_ok; // POD, will be initialized to zero
	static struct destruct_guard_t {
		destruct_guard_t() { destruct_guard_ok = true; }
		~destruct_guard_t() { destruct_guard_ok = false; }
	} destruct_guard;

	static std::vector<char*> global_id_storage_;
	static dict<char*, int> global_id_index_;
#ifndef YOSYS_NO_IDS_REFCNT
	static std::vector<int> global_refcount_storage_;
	static std::vector<int> global_free_idx_list_;
#endif

#ifdef YOSYS_USE_STICKY_IDS
	static int last_created_idx_ptr_;
	static int last_created_idx_[8];
#endif

	static inline void xtrace_db_dump()
	{
	#ifdef YOSYS_XTRACE_GET_PUT
		for (int idx = 0; idx < GetSize(global_id_storage_); idx++)
		{
			if (global_id_storage_.at(idx) == nullptr)
				log("#X# DB-DUMP index %d: FREE\\n", idx);
			else
				log("#X# DB-DUMP index %d: '%s' (ref %d)\\n", idx, global_id_storage_.at(idx), global_refcount_storage_.at(idx));
		}
	#endif
	}

	static inline void checkpoint()
	{
	#ifdef YOSYS_USE_STICKY_IDS
		last_created_idx_ptr_ = 0;
		for (int i = 0; i < 8; i++) {
			if (last_created_idx_[i])
				put_reference(last_created_idx_[i]);
			last_created_idx_[i] = 0;
		}
	#endif
	#ifdef YOSYS_SORT_ID_FREE_LIST
		std::sort(global_free_idx_list_.begin(), global_free_idx_list_.end(), std::greater<int>());
	#endif
	}

	static inline int get_reference(int idx)
	{
		if (idx) {
	#ifndef YOSYS_NO_IDS_REFCNT
			global_refcount_storage_[idx]++;
	#endif
	#ifdef YOSYS_XTRACE_GET_PUT
			if (yosys_xtrace)
				log("#X# GET-BY-INDEX '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
	#endif
		}
		return idx;
	}

	static int get_reference(const char *p)
	{
		log_assert(destruct_guard_ok);

		if (!p[0])
			return 0;

		auto it = global_id_index_.find((char*)p);
		if (it != global_id_index_.end()) {
	#ifndef YOSYS_NO_IDS_REFCNT
			global_refcount_storage_.at(it->second)++;
	#endif
	#ifdef YOSYS_XTRACE_GET_PUT
			if (yosys_xtrace)
				log("#X# GET-BY-NAME '%s' (index %d, refcount %d)\\n", global_id_storage_.at(it->second), it->second, global_refcount_storage_.at(it->second));
	#endif
			return it->second;
		}

		log_assert(p[0] == '$' || p[0] == '\\\\');
		log_assert(p[1] != 0);
		for (const char *c = p; *c; c++)
			if ((unsigned)*c <= (unsigned)' ')
				log_error("Found control character or space (0x%02x) in string '%s' which is not allowed in RTLIL identifiers\\n", *c, p);

	#ifndef YOSYS_NO_IDS_REFCNT
		if (global_free_idx_list_.empty()) {
			if (global_id_storage_.empty()) {
				global_refcount_storage_.push_back(0);
				global_id_storage_.push_back((char*)"");
				global_id_index_[global_id_storage_.back()] = 0;
			}
			log_assert(global_id_storage_.size() < 0x40000000);
			global_free_idx_list_.push_back(global_id_storage_.size());
			global_id_storage_.push_back(nullptr);
			global_refcount_storage_.push_back(0);
		}

		int idx = global_free_idx_list_.back();
		global_free_idx_list_.pop_back();
		global_id_storage_.at(idx) = strdup(p);
		global_id_index_[global_id_storage_.at(idx)] = idx;
		global_refcount_storage_.at(idx)++;
	#else
		if (global_id_storage_.empty()) {
			global_id_storage_.push_back((char*)"");
			global_id_index_[global_id_storage_.back()] = 0;
		}
		int idx = global_id_storage_.size();
		global_id_storage_.push_back(strdup(p));
		global_id_index_[global_id_storage_.back()] = idx;
	#endif

		if (yosys_xtrace) {
			log("#X# New IdString '%s' with index %d.\\n", p, idx);
			log_backtrace("-X- ", yosys_xtrace-1);
		}

	#ifdef YOSYS_XTRACE_GET_PUT
		if (yosys_xtrace)
			log("#X# GET-BY-NAME '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
	#endif

	#ifdef YOSYS_USE_STICKY_IDS
		// Avoid Create->Delete->Create pattern
		if (last_created_idx_[last_created_idx_ptr_])
			put_reference(last_created_idx_[last_created_idx_ptr_]);
		last_created_idx_[last_created_idx_ptr_] = idx;
		get_reference(last_created_idx_[last_created_idx_ptr_]);
		last_created_idx_ptr_ = (last_created_idx_ptr_ + 1) & 7;
	#endif

		return idx;
	}

#ifndef YOSYS_NO_IDS_REFCNT
	static inline void put_reference(int idx)
	{
		// put_reference() may be called from destructors after the destructor of
		// global_refcount_storage_ has been run. in this case we simply do nothing.
		if (!destruct_guard_ok || !idx)
			return;

	#ifdef YOSYS_XTRACE_GET_PUT
		if (yosys_xtrace) {
			log("#X# PUT '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
		}
	#endif

		int &refcount = global_refcount_storage_[idx];

		if (--refcount > 0)
			return;

		log_assert(refcount == 0);
		free_reference(idx);
	}
	static inline void free_reference(int idx)
	{
		if (yosys_xtrace) {
			log("#X# Removed IdString '%s' with index %d.\\n", global_id_storage_.at(idx), idx);
			log_backtrace("-X- ", yosys_xtrace-1);
		}

		global_id_index_.erase(global_id_storage_.at(idx));
		free(global_id_storage_.at(idx));
		global_id_storage_.at(idx) = nullptr;
		global_free_idx_list_.push_back(idx);
	}
#else
	static inline void put_reference(int) { }
#endif

	// the actual IdString object is just is a single int

	int index_;

	inline IdString() : index_(0) { }
	inline IdString(const char *str) : index_(get_reference(str)) { }
	inline IdString(const IdString &str) : index_(get_reference(str.index_)) { }
	inline IdString(IdString &&str) : index_(str.index_) { str.index_ = 0; }
	inline IdString(const std::string &str) : index_(get_reference(str.c_str())) { }
	inline ~IdString() { put_reference(index_); }

	inline void operator=(const IdString &rhs) {
		put_reference(index_);
		index_ = get_reference(rhs.index_);
	}

	inline void operator=(const char *rhs) {
		IdString id(rhs);
		*this = id;
	}

	inline void operator=(const std::string &rhs) {
		IdString id(rhs);
		*this = id;
	}

	inline const char *c_str() const {
		return global_id_storage_.at(index_);
	}

	inline std::string str() const {
		return std::string(global_id_storage_.at(index_));
	}

	inline bool operator<(const IdString &rhs) const {
		return index_ < rhs.index_;
	}

	inline bool operator==(const IdString &rhs) const { return index_ == rhs.index_; }
	inline bool operator!=(const IdString &rhs) const { return index_ != rhs.index_; }

	// The methods below are just convenience functions for better compatibility with std::string.

	bool operator==(const std::string &rhs) const { return c_str() == rhs; }
	bool operator!=(const std::string &rhs) const { return c_str() != rhs; }

	bool operator==(const char *rhs) const { return strcmp(c_str(), rhs) == 0; }
	bool operator!=(const char *rhs) const { return strcmp(c_str(), rhs) != 0; }

	char operator[](size_t i) const {
					const char *p = c_str();
#ifndef NDEBUG
		for (; i != 0; i--, p++)
			log_assert(*p != 0);
		return *p;
#else
		return *(p + i);
#endif
	}

	std::string substr(size_t pos = 0, size_t len = std::string::npos) const {
		if (len == std::string::npos || len >= strlen(c_str() + pos))
			return std::string(c_str() + pos);
		else
			return std::string(c_str() + pos, len);
	}

	int compare(size_t pos, size_t len, const char* s) const {
		return strncmp(c_str()+pos, s, len);
	}

	bool begins_with(const char* prefix) const {
		size_t len = strlen(prefix);
		if (size() < len) return false;
		return compare(0, len, prefix) == 0;
	}

	bool ends_with(const char* suffix) const {
		size_t len = strlen(suffix);
		if (size() < len) return false;
		return compare(size()-len, len, suffix) == 0;
	}

	bool contains(const char* str) const {
		return strstr(c_str(), str);
	}

	size_t size() const {
		return strlen(c_str());
	}

	bool empty() const {
		return c_str()[0] == 0;
	}

	void clear() {
		*this = IdString();
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const { return hash_ops<int>::hash_into(index_, h); }

	[[nodiscard]] Hasher hash_top() const {
		Hasher h;
		h.force((Hasher::hash_t) index_);
		return h;
	}

	// The following is a helper key_compare class. Instead of for example std::set<Cell*>
	// use std::set<Cell*, IdString::compare_ptr_by_name<Cell>> if the order of cells in the
	// set has an influence on the algorithm.

	template<typename T> struct compare_ptr_by_name {
		bool operator()(const T *a, const T *b) const {
			return (a == nullptr || b == nullptr) ? (a < b) : (a->name < b->name);
		}
	};

	// often one needs to check if a given IdString is part of a list (for example a list
	// of cell types). the following functions helps with that.
	template<typename... Args>
	bool in(Args... args) const {
		return (... || in(args));
	}

	bool in(const IdString &rhs) const { return *this == rhs; }
	bool in(const char *rhs) const { return *this == rhs; }
	bool in(const std::string &rhs) const { return *this == rhs; }
	inline bool in(const pool<IdString> &rhs) const;
	inline bool in(const pool<IdString> &&rhs) const;

	bool isPublic() const { return begins_with("\\\\"); }
};

namespace hashlib {
	template <>
	struct hash_ops<RTLIL::IdString> {
		static inline bool cmp(const RTLIL::IdString &a, const RTLIL::IdString &b) {
			return a == b;
		}
		[[nodiscard]] static inline Hasher hash(const RTLIL::IdString id) {
			return id.hash_top();
		}
		[[nodiscard]] static inline Hasher hash_into(const RTLIL::IdString id, Hasher h) {
			return id.hash_into(h);
		}
	};
};

/**
 * How to not use these methods:
 * 1. if(celltype.in({...})) -> if(celltype.in(...))
 * 2. pool<IdString> p; ... a.in(p) -> (bool)p.count(a)
 */
[[deprecated]]
inline bool RTLIL::IdString::in(const pool<IdString> &rhs) const { return rhs.count(*this) != 0; }
[[deprecated]]
inline bool RTLIL::IdString::in(const pool<IdString> &&rhs) const { return rhs.count(*this) != 0; }

namespace RTLIL {
	namespace ID {
#define X(_id) extern IdString _id;
#include "kernel/constids.inc"
#undef X
	};
	extern dict<std::string, std::string> constpad;

	const pool<IdString> &builtin_ff_cell_types();

	static inline std::string escape_id(const std::string &str) {
		if (str.size() > 0 && str[0] != '\\\\' && str[0] != '$')
			return "\\\\" + str;
		return str;
	}

	static inline std::string unescape_id(const std::string &str) {
		if (str.size() < 2)
			return str;
		if (str[0] != '\\\\')
			return str;
		if (str[1] == '$' || str[1] == '\\\\')
			return str;
		if (str[1] >= '0' && str[1] <= '9')
			return str;
		return str.substr(1);
	}

	static inline std::string unescape_id(const RTLIL::IdString &str) {
		return unescape_id(str.str());
	}

	static inline const char *id2cstr(const RTLIL::IdString &str) {
		return log_id(str);
	}

	template <typename T> struct sort_by_name_id {
		bool operator()(T *a, T *b) const {
			return a->name < b->name;
		}
	};

	template <typename T> struct sort_by_name_str {
		bool operator()(T *a, T *b) const {
			return strcmp(a->name.c_str(), b->name.c_str()) < 0;
		}
	};

	struct sort_by_id_str {
		bool operator()(const RTLIL::IdString &a, const RTLIL::IdString &b) const {
			return strcmp(a.c_str(), b.c_str()) < 0;
		}
	};

	static inline std::string encode_filename(const std::string &filename)
	{
		std::stringstream val;
		if (!std::any_of(filename.begin(), filename.end(), [](char c) {
			return static_cast<unsigned char>(c) < 33 || static_cast<unsigned char>(c) > 126;
		})) return filename;
		for (unsigned char const c : filename) {
			if (c < 33 || c > 126)
				val << stringf("$%02x", c);
			else
				val << c;
		}
		return val.str();
	}

	// see calc.cc for the implementation of this functions
	RTLIL::Const const_not         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_and         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_or          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_xor         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_xnor        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_reduce_and  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_or   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_xor  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_xnor (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_bool (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_logic_not   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_logic_and   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_logic_or    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_shl         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shr         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sshl        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sshr        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shift       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shiftx      (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_lt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_le          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_eq          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_ne          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_eqx         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_nex         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_ge          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_gt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_add         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sub         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_mul         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_div         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_divfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_modfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_mod         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_pow         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_pos         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_buf         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_neg         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_mux         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);
	RTLIL::Const const_pmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);
	RTLIL::Const const_bmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2);
	RTLIL::Const const_demux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);

	RTLIL::Const const_bweqx       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);
	RTLIL::Const const_bwmux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);


	// This iterator-range-pair is used for Design::modules(), Module::wires() and Module::cells().
	// It maintains a reference counter that is used to make sure that the container is not modified while being iterated over.

	template<typename T>
	struct ObjIterator {
		using iterator_category = std::forward_iterator_tag;
		using value_type = T;
		using difference_type = ptrdiff_t;
		using pointer = T*;
		using reference = T&;
		typename dict<RTLIL::IdString, T>::iterator it;
		dict<RTLIL::IdString, T> *list_p;
		int *refcount_p;

		ObjIterator() : list_p(nullptr), refcount_p(nullptr) {
		}

		ObjIterator(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) {
			if (list_p->empty()) {
				this->list_p = nullptr;
				this->refcount_p = nullptr;
			} else {
				it = list_p->begin();
				(*refcount_p)++;
			}
		}

		ObjIterator(const RTLIL::ObjIterator<T> &other) {
			it = other.it;
			list_p = other.list_p;
			refcount_p = other.refcount_p;
			if (refcount_p)
				(*refcount_p)++;
		}

		ObjIterator &operator=(const RTLIL::ObjIterator<T> &other) {
			if (refcount_p)
				(*refcount_p)--;
			it = other.it;
			list_p = other.list_p;
			refcount_p = other.refcount_p;
			if (refcount_p)
				(*refcount_p)++;
			return *this;
		}

		~ObjIterator() {
			if (refcount_p)
				(*refcount_p)--;
		}

		inline T operator*() const {
			log_assert(list_p != nullptr);
			return it->second;
		}

		inline bool operator!=(const RTLIL::ObjIterator<T> &other) const {
			if (list_p == nullptr || other.list_p == nullptr)
				return list_p != other.list_p;
			return it != other.it;
		}


		inline bool operator==(const RTLIL::ObjIterator<T> &other) const {
			return !(*this != other);
		}

		inline ObjIterator<T>& operator++() {
			log_assert(list_p != nullptr);
			if (++it == list_p->end()) {
				(*refcount_p)--;
				list_p = nullptr;
				refcount_p = nullptr;
			}
			return *this;
		}

		inline ObjIterator<T>& operator+=(int amt) {
			log_assert(list_p != nullptr);
			it += amt;
			if (it == list_p->end()) {
				(*refcount_p)--;
				list_p = nullptr;
				refcount_p = nullptr;
			}
			return *this;
		}

		inline ObjIterator<T> operator+(int amt) {
			log_assert(list_p != nullptr);
			ObjIterator<T> new_obj(*this);
			new_obj.it += amt;
			if (new_obj.it == list_p->end()) {
				(*(new_obj.refcount_p))--;
				new_obj.list_p = nullptr;
				new_obj.refcount_p = nullptr;
			}
			return new_obj;
		}

		inline const ObjIterator<T> operator++(int) {
			ObjIterator<T> result(*this);
			++(*this);
			return result;
		}
	};

	template<typename T>
	struct ObjRange
	{
		dict<RTLIL::IdString, T> *list_p;
		int *refcount_p;

		ObjRange(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) { }
		RTLIL::ObjIterator<T> begin() { return RTLIL::ObjIterator<T>(list_p, refcount_p); }
		RTLIL::ObjIterator<T> end() { return RTLIL::ObjIterator<T>(); }

		size_t size() const {
			return list_p->size();
		}

		operator pool<T>() const {
			pool<T> result;
			for (auto &it : *list_p)
				result.insert(it.second);
			return result;
		}

		operator std::vector<T>() const {
			std::vector<T> result;
			result.reserve(list_p->size());
			for (auto &it : *list_p)
				result.push_back(it.second);
			return result;
		}

		pool<T> to_pool() const { return *this; }
		std::vector<T> to_vector() const { return *this; }
	};
};

struct RTLIL::Const
{
	short int flags;
private:
	friend class KernelRtlilTest;
	FRIEND_TEST(KernelRtlilTest, ConstStr);
	using bitvectype = std::vector<RTLIL::State>;
	enum class backing_tag: bool { bits, string };
	// Do not access the union or tag even in Const methods unless necessary
	mutable backing_tag tag;
	union {
		mutable bitvectype bits_;
		mutable std::string str_;
	};

	// Use these private utilities instead
	bool is_bits() const { return tag == backing_tag::bits; }
	bool is_str() const { return tag == backing_tag::string; }

	bitvectype* get_if_bits() const { return is_bits() ? &bits_ : NULL; }
	std::string* get_if_str() const { return is_str() ? &str_ : NULL; }

	bitvectype& get_bits() const;
	std::string& get_str() const;
public:
	Const() : flags(RTLIL::CONST_FLAG_NONE), tag(backing_tag::bits), bits_(std::vector<RTLIL::State>()) {}
	Const(const std::string &str);
	Const(long long val, int width = 32);
	Const(RTLIL::State bit, int width = 1);
	Const(const std::vector<RTLIL::State> &bits) : flags(RTLIL::CONST_FLAG_NONE), tag(backing_tag::bits), bits_(bits) {}
	Const(const std::vector<bool> &bits);
	Const(const RTLIL::Const &other);
	Const(RTLIL::Const &&other);
	RTLIL::Const &operator =(const RTLIL::Const &other);
	~Const();

	bool operator <(const RTLIL::Const &other) const;
	bool operator ==(const RTLIL::Const &other) const;
	bool operator !=(const RTLIL::Const &other) const;

	std::vector<RTLIL::State>& bits();
	bool as_bool() const;

	// Convert the constant value to a C++ int.
	// NOTE: If the constant is too wide to fit in int (32 bits) this will
	// truncate any higher bits, potentially over/underflowing. Consider using
	// try_as_int, as_int_saturating, or guarding behind convertible_to_int
	// instead.
	int as_int(bool is_signed = false) const;

	// Returns true iff the constant can be converted to an int without
	// over/underflow.
	bool convertible_to_int(bool is_signed = false) const;

	// Returns the constant's value as an int if it can be represented without
	// over/underflow, or std::nullopt otherwise.
	std::optional<int> try_as_int(bool is_signed = false) const;

	// Returns the constant's value as an int if it can be represented without
	// over/underflow, otherwise the max/min value for int depending on the sign.
	int as_int_saturating(bool is_signed = false) const;

	std::string as_string(const char* any = "-") const;
	static Const from_string(const std::string &str);
	std::vector<RTLIL::State> to_bits() const;

	std::string decode_string() const;
	int size() const;
	bool empty() const;
	void bitvectorize() const;

	void append(const RTLIL::Const &other);

	class const_iterator {
	private:
		const Const& parent;
		size_t idx;

	public:
		using iterator_category = std::input_iterator_tag;
		using value_type = State;
		using difference_type = std::ptrdiff_t;
		using pointer = const State*;
		using reference = const State&;

		const_iterator(const Const& c, size_t i) : parent(c), idx(i) {}

		State operator*() const;

		const_iterator& operator++() { ++idx; return *this; }
		const_iterator& operator--() { --idx; return *this; }
		const_iterator& operator++(int) { ++idx; return *this; }
		const_iterator& operator--(int) { --idx; return *this; }
		const_iterator& operator+=(int i) { idx += i; return *this; }

		const_iterator operator+(int add) {
			return const_iterator(parent, idx + add);
		}
		const_iterator operator-(int sub) {
			return const_iterator(parent, idx - sub);
		}
		int operator-(const const_iterator& other) {
			return idx - other.idx;
		}

		bool operator==(const const_iterator& other) const {
			return idx == other.idx;
		}

		bool operator!=(const const_iterator& other) const {
			return !(*this == other);
		}
	};

	const_iterator begin() const {
		return const_iterator(*this, 0);
	}
	const_iterator end() const {
		return const_iterator(*this, size());
	}
	State back() const {
		return *(end() - 1);
	}
	State front() const {
		return *begin();
	}
	State at(size_t i) const {
		return *const_iterator(*this, i);
	}
	State operator[](size_t i) const {
		return *const_iterator(*this, i);
	}

	bool is_fully_zero() const;
	bool is_fully_ones() const;
	bool is_fully_def() const;
	bool is_fully_undef() const;
	bool is_fully_undef_x_only() const;
	bool is_onehot(int *pos = nullptr) const;

	RTLIL::Const extract(int offset, int len = 1, RTLIL::State padding = RTLIL::State::S0) const;

	// find the MSB without redundant leading bits
	int get_min_size(bool is_signed) const;

	// compress representation to the minimum required bits
	void compress(bool is_signed = false);

	std::optional<int> as_int_compress(bool is_signed) const;

	void extu(int width) {
		bits().resize(width, RTLIL::State::S0);
	}

	void exts(int width) {
		bitvectype& bv = bits();
		bv.resize(width, bv.empty() ? RTLIL::State::Sx : bv.back());
	}

	[[nodiscard]] Hasher hash_into(Hasher h) const {
		h.eat(size());
		for (auto b : *this)
			h.eat(b);
		return h;
	}
};

struct RTLIL::AttrObject
{
	dict<RTLIL::IdString, RTLIL::Const> attributes;

	bool has_attribute(const RTLIL::IdString &id) const;

	void set_bool_attribute(const RTLIL::IdString &id, bool value=true);
	bool get_bool_attribute(const RTLIL::IdString &id) const;

	[[deprecated("Use Module::get_blackbox_attribute() instead.")]]
	bool get_blackbox_attribute(bool ignore_wb=false) const {
		return get_bool_attribute(ID::blackbox) || (!ignore_wb && get_bool_attribute(ID::whitebox));
	}

	void set_string_attribute(const RTLIL::IdString& id, string value);
	string get_string_attribute(const RTLIL::IdString &id) const;

	void set_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);
	void add_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);
	pool<string> get_strpool_attribute(const RTLIL::IdString &id) const;

	void set_src_attribute(const std::string &src) {
		set_string_attribute(ID::src, src);
	}
	std::string get_src_attribute() const {
		return get_string_attribute(ID::src);
	}

	void set_hdlname_attribute(const vector<string> &hierarchy);
	vector<string> get_hdlname_attribute() const;

	void set_intvec_attribute(const RTLIL::IdString& id, const vector<int> &data);
	vector<int> get_intvec_attribute(const RTLIL::IdString &id) const;
};

struct RTLIL::NamedObject : public RTLIL::AttrObject
{
	RTLIL::IdString name;
};

struct RTLIL::SigChunk
{
	RTLIL::Wire *wire;
	std::vector<RTLIL::State> data; // only used if wire == NULL, LSB at index 0
	int width, offset;

	SigChunk() : wire(nullptr), width(0), offset(0) {}
	SigChunk(const RTLIL::Const &value) : wire(nullptr), data(value.to_bits()), width(GetSize(data)), offset(0) {}
	SigChunk(RTLIL::Const &&value) : wire(nullptr), data(value.to_bits()), width(GetSize(data)), offset(0) {}
	SigChunk(RTLIL::Wire *wire) : wire(wire), width(GetSize(wire)), offset(0) {}
	SigChunk(RTLIL::Wire *wire, int offset, int width = 1) : wire(wire), width(width), offset(offset) {}
	SigChunk(const std::string &str) : SigChunk(RTLIL::Const(str)) {}
	SigChunk(int val, int width = 32) : SigChunk(RTLIL::Const(val, width)) {}
	SigChunk(RTLIL::State bit, int width = 1) : SigChunk(RTLIL::Const(bit, width)) {}
	SigChunk(const RTLIL::SigBit &bit);

	RTLIL::SigChunk extract(int offset, int length) const;
	RTLIL::SigBit operator[](int offset) const;
	inline int size() const { return width; }
	inline bool is_wire() const { return wire != NULL; }

	bool operator <(const RTLIL::SigChunk &other) const;
	bool operator ==(const RTLIL::SigChunk &other) const;
	bool operator !=(const RTLIL::SigChunk &other) const;
};

struct RTLIL::SigBit
{
	RTLIL::Wire *wire;
	union {
		RTLIL::State data; // used if wire == NULL
		int offset;        // used if wire != NULL
	};

	SigBit();
	SigBit(RTLIL::State bit);
	explicit SigBit(bool bit);
	SigBit(RTLIL::Wire *wire);
	SigBit(RTLIL::Wire *wire, int offset);
	SigBit(const RTLIL::SigChunk &chunk);
	SigBit(const RTLIL::SigChunk &chunk, int index);
	SigBit(const RTLIL::SigSpec &sig);
	SigBit(const RTLIL::SigBit &sigbit) = default;
	RTLIL::SigBit &operator =(const RTLIL::SigBit &other) = default;

	inline bool is_wire() const { return wire != NULL; }

	bool operator <(const RTLIL::SigBit &other) const;
	bool operator ==(const RTLIL::SigBit &other) const;
	bool operator !=(const RTLIL::SigBit &other) const;
	[[nodiscard]] Hasher hash_into(Hasher h) const;
	[[nodiscard]] Hasher hash_top() const;
};

namespace hashlib {
	template <>
	struct hash_ops<RTLIL::SigBit> {
		static inline bool cmp(const RTLIL::SigBit &a, const RTLIL::SigBit &b) {
			return a == b;
		}
		[[nodiscard]] static inline Hasher hash(const RTLIL::SigBit sb) {
			return sb.hash_top();
		}
		[[nodiscard]] static inline Hasher hash_into(const RTLIL::SigBit sb, Hasher h) {
			return sb.hash_into(h);
		}
	};
};

struct RTLIL::SigSpecIterator
{
	typedef std::input_iterator_tag iterator_category;
	typedef RTLIL::SigBit value_type;
	typedef ptrdiff_t difference_type;
	typedef RTLIL::SigBit* pointer;
	typedef RTLIL::SigBit& reference;

	RTLIL::SigSpec *sig_p;
	int index;

	inline RTLIL::SigBit &operator*() const;
	inline bool operator!=(const RTLIL::SigSpecIterator &other) const { return index != other.index; }
	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }
	inline void operator++() { index++; }
};

struct RTLIL::SigSpecConstIterator
{
	typedef std::input_iterator_tag iterator_category;
	typedef RTLIL::SigBit value_type;
	typedef ptrdiff_t difference_type;
	typedef RTLIL::SigBit* pointer;
	typedef RTLIL::SigBit& reference;

	const RTLIL::SigSpec *sig_p;
	int index;

	inline const RTLIL::SigBit &operator*() const;
	inline bool operator!=(const RTLIL::SigSpecConstIterator &other) const { return index != other.index; }
	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }
	inline void operator++() { index++; }
};

struct RTLIL::SigSpec
{
private:
	int width_;
	Hasher::hash_t hash_;
	std::vector<RTLIL::SigChunk> chunks_; // LSB at index 0
	std::vector<RTLIL::SigBit> bits_; // LSB at index 0

	void pack() const;
	void unpack() const;
	void updhash() const;

	inline bool packed() const {
		return bits_.empty();
	}

	inline void inline_unpack() const {
		if (!chunks_.empty())
			unpack();
	}

	// Only used by Module::remove(const pool<Wire*> &wires)
	// but cannot be more specific as it isn't yet declared
	friend struct RTLIL::Module;

public:
	SigSpec() : width_(0), hash_(0) {}
	SigSpec(std::initializer_list<RTLIL::SigSpec> parts);

	SigSpec(const RTLIL::Const &value);
	SigSpec(RTLIL::Const &&value);
	SigSpec(const RTLIL::SigChunk &chunk);
	SigSpec(RTLIL::SigChunk &&chunk);
	SigSpec(RTLIL::Wire *wire);
	SigSpec(RTLIL::Wire *wire, int offset, int width = 1);
	SigSpec(const std::string &str);
	SigSpec(int val, int width = 32);
	SigSpec(RTLIL::State bit, int width = 1);
	SigSpec(const RTLIL::SigBit &bit, int width = 1);
	SigSpec(const std::vector<RTLIL::SigChunk> &chunks);
	SigSpec(const std::vector<RTLIL::SigBit> &bits);
	SigSpec(const pool<RTLIL::SigBit> &bits);
	SigSpec(const std::set<RTLIL::SigBit> &bits);
	explicit SigSpec(bool bit);

	inline const std::vector<RTLIL::SigChunk> &chunks() const { pack(); return chunks_; }
	inline const std::vector<RTLIL::SigBit> &bits() const { inline_unpack(); return bits_; }

	inline int size() const { return width_; }
	inline bool empty() const { return width_ == 0; }

	inline RTLIL::SigBit &operator[](int index) { inline_unpack(); return bits_.at(index); }
	inline const RTLIL::SigBit &operator[](int index) const { inline_unpack(); return bits_.at(index); }

	inline RTLIL::SigSpecIterator begin() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = 0; return it; }
	inline RTLIL::SigSpecIterator end() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = width_; return it; }

	inline RTLIL::SigSpecConstIterator begin() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = 0; return it; }
	inline RTLIL::SigSpecConstIterator end() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = width_; return it; }

	void sort();
	void sort_and_unify();

	void replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with);
	void replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with, RTLIL::SigSpec *other) const;

	void replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules);
	void replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;

	void replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules);
	void replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;

	void replace(int offset, const RTLIL::SigSpec &with);

	void remove(const RTLIL::SigSpec &pattern);
	void remove(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other) const;
	void remove2(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other);

	void remove(const pool<RTLIL::SigBit> &pattern);
	void remove(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other) const;
	void remove2(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);
	void remove2(const std::set<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);
	void remove2(const pool<RTLIL::Wire*> &pattern, RTLIL::SigSpec *other);

	void remove(int offset, int length = 1);
	void remove_const();

	RTLIL::SigSpec extract(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec *other = NULL) const;
	RTLIL::SigSpec extract(const pool<RTLIL::SigBit> &pattern, const RTLIL::SigSpec *other = NULL) const;
	RTLIL::SigSpec extract(int offset, int length = 1) const;
	RTLIL::SigSpec extract_end(int offset) const { return extract(offset, width_ - offset); }

	RTLIL::SigBit lsb() const { log_assert(width_); return (*this)[0]; };
	RTLIL::SigBit msb() const { log_assert(width_); return (*this)[width_ - 1]; };

	void append(const RTLIL::SigSpec &signal);
	inline void append(Wire *wire) { append(RTLIL::SigSpec(wire)); }
	inline void append(const RTLIL::SigChunk &chunk) { append(RTLIL::SigSpec(chunk)); }
	inline void append(const RTLIL::Const &const_) { append(RTLIL::SigSpec(const_)); }

	void append(const RTLIL::SigBit &bit);
	inline void append(RTLIL::State state) { append(RTLIL::SigBit(state)); }
	inline void append(bool bool_) { append(RTLIL::SigBit(bool_)); }

	void extend_u0(int width, bool is_signed = false);

	RTLIL::SigSpec repeat(int num) const;

	void reverse() { inline_unpack(); std::reverse(bits_.begin(), bits_.end()); }

	bool operator <(const RTLIL::SigSpec &other) const;
	bool operator ==(const RTLIL::SigSpec &other) const;
	inline bool operator !=(const RTLIL::SigSpec &other) const { return !(*this == other); }

	bool is_wire() const;
	bool is_chunk() const;
	inline bool is_bit() const { return width_ == 1; }

	bool is_fully_const() const;
	bool is_fully_zero() const;
	bool is_fully_ones() const;
	bool is_fully_def() const;
	bool is_fully_undef() const;
	bool has_const() const;
	bool has_marked_bits() const;
	bool is_onehot(int *pos = nullptr) const;

	bool as_bool() const;

	// Convert the SigSpec to a C++ int, assuming all bits are constant.
	// NOTE: If the value is too wide to fit in int (32 bits) this will
	// truncate any higher bits, potentially over/underflowing. Consider using
	// try_as_int, as_int_saturating, or guarding behind convertible_to_int
	// instead.
	int as_int(bool is_signed = false) const;

	// Returns true iff the SigSpec is constant and can be converted to an int
	// without over/underflow.
	bool convertible_to_int(bool is_signed = false) const;

	// Returns the SigSpec's value as an int if it is a constant and can be
	// represented without over/underflow, or std::nullopt otherwise.
	std::optional<int> try_as_int(bool is_signed = false) const;

	// Returns an all constant SigSpec's value as an int if it can be represented
	// without over/underflow, otherwise the max/min value for int depending on
	// the sign.
	int as_int_saturating(bool is_signed = false) const;

	std::string as_string() const;
	RTLIL::Const as_const() const;
	RTLIL::Wire *as_wire() const;
	RTLIL::SigChunk as_chunk() const;
	RTLIL::SigBit as_bit() const;

	bool match(const char* pattern) const;

	std::set<RTLIL::SigBit> to_sigbit_set() const;
	pool<RTLIL::SigBit> to_sigbit_pool() const;
	std::vector<RTLIL::SigBit> to_sigbit_vector() const;
	std::map<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_map(const RTLIL::SigSpec &other) const;
	dict<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_dict(const RTLIL::SigSpec &other) const;

	static bool parse(RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);
	static bool parse_sel(RTLIL::SigSpec &sig, RTLIL::Design *design, RTLIL::Module *module, std::string str);
	static bool parse_rhs(const RTLIL::SigSpec &lhs, RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);

	operator std::vector<RTLIL::SigChunk>() const { return chunks(); }
	operator std::vector<RTLIL::SigBit>() const { return bits(); }
	const RTLIL::SigBit &at(int offset, const RTLIL::SigBit &defval) { return offset < width_ ? (*this)[offset] : defval; }

	[[nodiscard]] Hasher hash_into(Hasher h) const { if (!hash_) updhash(); h.eat(hash_); return h; }

#ifndef NDEBUG
	void check(Module *mod = nullptr) const;
#else
	void check(Module *mod = nullptr) const { (void)mod; }
#endif
};

struct RTLIL::Selection
{
	// selection includes boxed modules
	bool selects_boxes;
	// selection covers full design, including boxed modules
	bool complete_selection;
	// selection covers full design, not including boxed modules
	bool full_selection;
	pool<RTLIL::IdString> selected_modules;
	dict<RTLIL::IdString, pool<RTLIL::IdString>> selected_members;
	RTLIL::Design *current_design;

	// create a new selection
	Selection(
		// should the selection cover the full design
		bool full = true,
		// should the selection include boxed modules
		bool boxes = false,
		// the design to select from
		RTLIL::Design *design = nullptr
	) :
		selects_boxes(boxes), complete_selection(full && boxes), full_selection(full && !boxes), current_design(design) { }

	// checks if the given module exists in the current design and is a
	// boxed module, warning the user if the current design is not set
	bool boxed_module(const RTLIL::IdString &mod_name) const;

	// checks if the given module is included in this selection
	bool selected_module(const RTLIL::IdString &mod_name) const;

	// checks if the given module is wholly included in this selection,
	// i.e. not partially selected
	bool selected_whole_module(const RTLIL::IdString &mod_name) const;

	// checks if the given member from the given module is included in this
	// selection
	bool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;

	// optimizes this selection for the given design by:
	// - removing non-existent modules and members, any boxed modules and
	//   their members (if selection does not include boxes), and any
	//   partially selected modules with no selected members;
	// - marking partially selected modules as wholly selected if all
	//   members of that module are selected; and
	// - marking selection as a complete_selection if all modules in the
	//   given design are selected, or a full_selection if it does not
	//   include boxes.
	void optimize(RTLIL::Design *design);

	// checks if selection covers full design (may or may not include
	// boxed-modules)
	bool selects_all() const {
		return full_selection || complete_selection;
	}

	// add whole module to this selection
	template<typename T1> void select(T1 *module) {
		if (!selects_all() && selected_modules.count(module->name) == 0) {
			selected_modules.insert(module->name);
			selected_members.erase(module->name);
			if (module->get_blackbox_attribute())
				selects_boxes = true;
		}
	}

	// add member of module to this selection
	template<typename T1, typename T2> void select(T1 *module, T2 *member) {
		if (!selects_all() && selected_modules.count(module->name) == 0) {
			selected_members[module->name].insert(member->name);
			if (module->get_blackbox_attribute())
				selects_boxes = true;
		}
	}

	// checks if selection is empty
	bool empty() const {
		return !selects_all() && selected_modules.empty() && selected_members.empty();
	}

	// clear this selection, leaving it empty
	void clear();

	// create a new selection which is empty
	static Selection EmptySelection(RTLIL::Design *design = nullptr) { return Selection(false, false, design); };

	// create a new selection with all non-boxed modules
	static Selection FullSelection(RTLIL::Design *design = nullptr) { return Selection(true, false, design); };

	// create a new selection with all modules, including boxes
	static Selection CompleteSelection(RTLIL::Design *design = nullptr) { return Selection(true, true, design); };
};

struct RTLIL::Monitor
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

	Monitor() {
		static unsigned int hashidx_count = 123456789;
		hashidx_count = mkhash_xorshift(hashidx_count);
		hashidx_ = hashidx_count;
	}

	virtual ~Monitor() { }
	virtual void notify_module_add(RTLIL::Module*) { }
	virtual void notify_module_del(RTLIL::Module*) { }
	virtual void notify_connect(RTLIL::Cell*, const RTLIL::IdString&, const RTLIL::SigSpec&, const RTLIL::SigSpec&) { }
	virtual void notify_connect(RTLIL::Module*, const RTLIL::SigSig&) { }
	virtual void notify_connect(RTLIL::Module*, const std::vector<RTLIL::SigSig>&) { }
	virtual void notify_blackout(RTLIL::Module*) { }
};

// Forward declaration; defined in preproc.h.
struct define_map_t;

struct RTLIL::Design
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

	pool<RTLIL::Monitor*> monitors;
	dict<std::string, std::string> scratchpad;

	bool flagBufferedNormalized = false;
	void bufNormalize(bool enable=true);

	int refcount_modules_;
	dict<RTLIL::IdString, RTLIL::Module*> modules_;
	std::vector<RTLIL::Binding*> bindings_;

	std::vector<AST::AstNode*> verilog_packages, verilog_globals;
	std::unique_ptr<define_map_t> verilog_defines;

	std::vector<RTLIL::Selection> selection_stack;
	dict<RTLIL::IdString, RTLIL::Selection> selection_vars;
	std::string selected_active_module;

	Design();
	~Design();

	RTLIL::ObjRange<RTLIL::Module*> modules();
	RTLIL::Module *module(const RTLIL::IdString &name);
	const RTLIL::Module *module(const RTLIL::IdString &name) const;
	RTLIL::Module *top_module() const;

	bool has(const RTLIL::IdString &id) const {
		return modules_.count(id) != 0;
	}

	void add(RTLIL::Module *module);
	void add(RTLIL::Binding *binding);

	RTLIL::Module *addModule(RTLIL::IdString name);
	void remove(RTLIL::Module *module);
	void rename(RTLIL::Module *module, RTLIL::IdString new_name);

	void scratchpad_unset(const std::string &varname);

	void scratchpad_set_int(const std::string &varname, int value);
	void scratchpad_set_bool(const std::string &varname, bool value);
	void scratchpad_set_string(const std::string &varname, std::string value);

	int scratchpad_get_int(const std::string &varname, int default_value = 0) const;
	bool scratchpad_get_bool(const std::string &varname, bool default_value = false) const;
	std::string scratchpad_get_string(const std::string &varname, const std::string &default_value = std::string()) const;

	void sort();
	void check();
	void optimize();

	// checks if the given module is included in the current selection
	bool selected_module(const RTLIL::IdString &mod_name) const;

	// checks if the given module is wholly included in the current
	// selection, i.e. not partially selected
	bool selected_whole_module(const RTLIL::IdString &mod_name) const;

	// checks if the given member from the given module is included in the
	// current selection
	bool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;

	// checks if the given module is included in the current selection
	bool selected_module(RTLIL::Module *mod) const;

	// checks if the given module is wholly included in the current
	// selection, i.e. not partially selected
	bool selected_whole_module(RTLIL::Module *mod) const;

	// push the given selection to the selection stack
	void push_selection(RTLIL::Selection sel);
	// push a new selection to the selection stack, with nothing selected
	void push_empty_selection();
	// push a new selection to the selection stack, with all non-boxed
	// modules selected
	void push_full_selection();
	// push a new selection to the selection stack, with all modules
	// selected including boxes
	void push_complete_selection();
	// pop the current selection from the stack, returning to a full
	// selection (no boxes) if the stack is empty
	void pop_selection();

	// get the current selection
	RTLIL::Selection &selection() {
		return selection_stack.back();
	}

	// get the current selection
	const RTLIL::Selection &selection() const {
		return selection_stack.back();
	}

	// is the current selection a full selection (no boxes)
	bool full_selection() const {
		return selection().full_selection;
	}

	// is the given module in the current selection
	template<typename T1> bool selected(T1 *module) const {
		return selected_module(module->name);
	}

	// is the given member of the given module in the current selection
	template<typename T1, typename T2> bool selected(T1 *module, T2 *member) const {
		return selected_member(module->name, member->name);
	}

	// add whole module to the current selection
	template<typename T1> void select(T1 *module) {
		RTLIL::Selection &sel = selection();
		sel.select(module);
	}

	// add member of module to the current selection
	template<typename T1, typename T2> void select(T1 *module, T2 *member) {
		RTLIL::Selection &sel = selection();
		sel.select(module, member);
	}


	// returns all selected modules
	std::vector<RTLIL::Module*> selected_modules(
		// controls if partially selected modules are included
		RTLIL::SelectPartials partials = SELECT_ALL,
		// controls if boxed modules are included
		RTLIL::SelectBoxes boxes = SB_UNBOXED_WARN
	) const;

	// returns all selected modules, and may include boxes
	std::vector<RTLIL::Module*> all_selected_modules() const { return selected_modules(SELECT_ALL, SB_ALL); }
	// returns all selected unboxed modules, silently ignoring any boxed
	// modules in the selection
	std::vector<RTLIL::Module*> selected_unboxed_modules() const { return selected_modules(SELECT_ALL, SB_UNBOXED_ONLY); }
	// returns all selected unboxed modules, warning the user if any boxed
	// modules have been ignored
	std::vector<RTLIL::Module*> selected_unboxed_modules_warn() const { return selected_modules(SELECT_ALL, SB_UNBOXED_WARN); }

	[[deprecated("Use select_unboxed_whole_modules() to maintain prior behaviour, or consider one of the other selected whole module helpers.")]]
	std::vector<RTLIL::Module*> selected_whole_modules() const { return selected_modules(SELECT_WHOLE_ONLY, SB_UNBOXED_WARN); }
	// returns all selected whole modules, silently ignoring partially
	// selected modules, and may include boxes
	std::vector<RTLIL::Module*> all_selected_whole_modules() const { return selected_modules(SELECT_WHOLE_ONLY, SB_ALL); }
	// returns all selected whole modules, warning the user if any partially
	// selected or boxed modules have been ignored; optionally includes
	// selected whole modules with the 'whitebox' attribute
	std::vector<RTLIL::Module*> selected_whole_modules_warn(
		// should whole modules with the 'whitebox' attribute be
		// included
		bool include_wb = false
	) const { return selected_modules(SELECT_WHOLE_WARN, include_wb ? SB_EXCL_BB_WARN : SB_UNBOXED_WARN); }
	// returns all selected unboxed whole modules, silently ignoring
	// partially selected or boxed modules
	std::vector<RTLIL::Module*> selected_unboxed_whole_modules() const { return selected_modules(SELECT_WHOLE_ONLY, SB_UNBOXED_ONLY); }
	// returns all selected unboxed whole modules, warning the user if any
	// partially selected or boxed modules have been ignored
	std::vector<RTLIL::Module*> selected_unboxed_whole_modules_warn() const { return selected_modules(SELECT_WHOLE_WARN, SB_UNBOXED_WARN); }
#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Design*> *get_all_designs(void);
#endif
};

struct RTLIL::Module : public RTLIL::NamedObject
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

protected:
	void add(RTLIL::Wire *wire);
	void add(RTLIL::Cell *cell);
	void add(RTLIL::Process *process);

public:
	RTLIL::Design *design;
	pool<RTLIL::Monitor*> monitors;

	int refcount_wires_;
	int refcount_cells_;

	dict<RTLIL::IdString, RTLIL::Wire*> wires_;
	dict<RTLIL::IdString, RTLIL::Cell*> cells_;

	std::vector<RTLIL::SigSig>   connections_;
	std::vector<RTLIL::Binding*> bindings_;

	idict<RTLIL::IdString> avail_parameters;
	dict<RTLIL::IdString, RTLIL::Const> parameter_default_values;
	dict<RTLIL::IdString, RTLIL::Memory*> memories;
	dict<RTLIL::IdString, RTLIL::Process*> processes;

	Module();
	virtual ~Module();
	virtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail = false);
	virtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail = false);
	virtual size_t count_id(const RTLIL::IdString& id);
	virtual void expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces);
	virtual bool reprocess_if_necessary(RTLIL::Design *design);

	virtual void sort();
	virtual void check();
	virtual void optimize();
	virtual void makeblackbox();

	bool get_blackbox_attribute(bool ignore_wb=false) const {
		return get_bool_attribute(ID::blackbox) || (!ignore_wb && get_bool_attribute(ID::whitebox));
	}

	void connect(const RTLIL::SigSig &conn);
	void connect(const RTLIL::SigSpec &lhs, const RTLIL::SigSpec &rhs);
	void new_connections(const std::vector<RTLIL::SigSig> &new_conn);
	const std::vector<RTLIL::SigSig> &connections() const;

	std::vector<RTLIL::IdString> ports;
	void fixup_ports();

	pool<pair<RTLIL::Cell*, RTLIL::IdString>> bufNormQueue;
	void bufNormalize();

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	void cloneInto(RTLIL::Module *new_mod) const;
	virtual RTLIL::Module *clone() const;

	bool has_memories() const;
	bool has_processes() const;

	bool has_memories_warn() const;
	bool has_processes_warn() const;

	bool is_selected() const;
	bool is_selected_whole() const;

	std::vector<RTLIL::Wire*> selected_wires() const;
	std::vector<RTLIL::Cell*> selected_cells() const;
	std::vector<RTLIL::Memory*> selected_memories() const;
	std::vector<RTLIL::Process*> selected_processes() const;
	std::vector<RTLIL::NamedObject*> selected_members() const;

	template<typename T> bool selected(T *member) const {
		return design->selected_member(name, member->name);
	}

	RTLIL::Wire* wire(const RTLIL::IdString &id) {
		auto it = wires_.find(id);
		return it == wires_.end() ? nullptr : it->second;
	}
	RTLIL::Cell* cell(const RTLIL::IdString &id) {
		auto it = cells_.find(id);
		return it == cells_.end() ? nullptr : it->second;
	}

	const RTLIL::Wire* wire(const RTLIL::IdString &id) const{
		auto it = wires_.find(id);
		return it == wires_.end() ? nullptr : it->second;
	}
	const RTLIL::Cell* cell(const RTLIL::IdString &id) const {
		auto it = cells_.find(id);
		return it == cells_.end() ? nullptr : it->second;
	}

	RTLIL::ObjRange<RTLIL::Wire*> wires() { return RTLIL::ObjRange<RTLIL::Wire*>(&wires_, &refcount_wires_); }
	RTLIL::ObjRange<RTLIL::Cell*> cells() { return RTLIL::ObjRange<RTLIL::Cell*>(&cells_, &refcount_cells_); }

	void add(RTLIL::Binding *binding);

	// Removing wires is expensive. If you have to remove wires, remove them all at once.
	void remove(const pool<RTLIL::Wire*> &wires);
	void remove(RTLIL::Cell *cell);
	void remove(RTLIL::Process *process);

	void rename(RTLIL::Wire *wire, RTLIL::IdString new_name);
	void rename(RTLIL::Cell *cell, RTLIL::IdString new_name);
	void rename(RTLIL::IdString old_name, RTLIL::IdString new_name);

	void swap_names(RTLIL::Wire *w1, RTLIL::Wire *w2);
	void swap_names(RTLIL::Cell *c1, RTLIL::Cell *c2);

	RTLIL::IdString uniquify(RTLIL::IdString name);
	RTLIL::IdString uniquify(RTLIL::IdString name, int &index);

	RTLIL::Wire *addWire(RTLIL::IdString name, int width = 1);
	RTLIL::Wire *addWire(RTLIL::IdString name, const RTLIL::Wire *other);

	RTLIL::Cell *addCell(RTLIL::IdString name, RTLIL::IdString type);
	RTLIL::Cell *addCell(RTLIL::IdString name, const RTLIL::Cell *other);

	RTLIL::Memory *addMemory(RTLIL::IdString name, const RTLIL::Memory *other);

	RTLIL::Process *addProcess(RTLIL::IdString name);
	RTLIL::Process *addProcess(RTLIL::IdString name, const RTLIL::Process *other);

	// The add* methods create a cell and return the created cell. All signals must exist in advance.

	RTLIL::Cell* addNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addPos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addBuf (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNeg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addShl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addLt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addEq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addEqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addGe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addGt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addAdd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addMul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	// truncating division
	RTLIL::Cell* addDiv (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	// truncating modulo
	RTLIL::Cell* addMod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addDivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addPow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool a_signed = false, bool b_signed = false, const std::string &src = "");

	RTLIL::Cell* addFa (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_x, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addLogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addMux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addPmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addBmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addDemux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addBweqx  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addBwmux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addSlice  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const offset, const std::string &src = "");
	RTLIL::Cell* addConcat (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addLut    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const lut, const std::string &src = "");
	RTLIL::Cell* addTribuf (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addAssert (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addAssume (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addLive   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addFair   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addCover  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addEquiv  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addSr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, const RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addFf    (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");
	RTLIL::Cell* addDff   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d,   const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsre (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffce (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");

	RTLIL::Cell* addBufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addXorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addXnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addMuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = "");

	RTLIL::Cell* addSrGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			const RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addFfGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");
	RTLIL::Cell* addDffGate    (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffeGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsreGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffceGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdlatchGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");

	RTLIL::Cell* addAnyinit(RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");

	// The methods without the add* prefix create a cell and an output signal. They return the newly created output signal.

	RTLIL::SigSpec Not (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Pos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Buf (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Neg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec And  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Or   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Xor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Xnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec ReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Shl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Lt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Le  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Eq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Ne  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Eqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Nex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Ge  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Gt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Add (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Mul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	// truncating division
	RTLIL::SigSpec Div (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	// truncating modulo
	RTLIL::SigSpec Mod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec DivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Pow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool a_signed = false, bool b_signed = false, const std::string &src = "");

	RTLIL::SigSpec LogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec LogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec LogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Mux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Pmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Bmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Demux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = "");

	RTLIL::SigSpec Bweqx      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const std::string &src = "");
	RTLIL::SigSpec Bwmux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");

	RTLIL::SigBit BufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = "");
	RTLIL::SigBit NotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = "");
	RTLIL::SigBit AndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit NandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit OrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit NorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit XorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit XnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit AndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit OrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit MuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = "");
	RTLIL::SigBit NmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = "");
	RTLIL::SigBit Aoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = "");
	RTLIL::SigBit Oai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = "");
	RTLIL::SigBit Aoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = "");
	RTLIL::SigBit Oai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = "");

	RTLIL::SigSpec Anyconst  (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Anyseq    (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Allconst  (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Allseq    (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Initstate (RTLIL::IdString name, const std::string &src = "");

	RTLIL::SigSpec SetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = "");
	RTLIL::Cell*   addSetTag       (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::SigSpec GetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = "");
	RTLIL::Cell*   addOverwriteTag (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = "");
	RTLIL::SigSpec OriginalTag     (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = "");
	RTLIL::SigSpec FutureFF        (RTLIL::IdString name, const RTLIL::SigSpec &sig_e, const std::string &src = "");

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Module*> *get_all_modules(void);
#endif
};

namespace RTLIL_BACKEND {
void dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire);
}

struct RTLIL::Wire : public RTLIL::NamedObject
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

protected:
	// use module->addWire() and module->remove() to create or destroy wires
	friend struct RTLIL::Module;
	Wire();
	~Wire();

	friend struct RTLIL::Design;
	friend struct RTLIL::Cell;
	friend void RTLIL_BACKEND::dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire);
	RTLIL::Cell *driverCell_ = nullptr;
	RTLIL::IdString driverPort_;

public:
	// do not simply copy wires
	Wire(RTLIL::Wire &other) = delete;
	void operator=(RTLIL::Wire &other) = delete;

	RTLIL::Module *module;
	int width, start_offset, port_id;
	bool port_input, port_output, upto, is_signed;

	RTLIL::Cell *driverCell() const    { log_assert(driverCell_); return driverCell_; };
	RTLIL::IdString driverPort() const { log_assert(driverCell_); return driverPort_; };

	int from_hdl_index(int hdl_index) {
		int zero_index = hdl_index - start_offset;
		int rtlil_index = upto ? width - 1 - zero_index : zero_index;
		return rtlil_index >= 0 && rtlil_index < width ? rtlil_index : INT_MIN;
	}

	int to_hdl_index(int rtlil_index) {
		if (rtlil_index < 0 || rtlil_index >= width)
			return INT_MIN;
		int zero_index = upto ? width - 1 - rtlil_index : rtlil_index;
		return zero_index + start_offset;
	}

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Wire*> *get_all_wires(void);
#endif
};

inline int GetSize(RTLIL::Wire *wire) {
	return wire->width;
}

struct RTLIL::Memory : public RTLIL::NamedObject
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

	Memory();

	int width, start_offset, size;
#ifdef WITH_PYTHON
	~Memory();
	static std::map<unsigned int, RTLIL::Memory*> *get_all_memorys(void);
#endif
};

struct RTLIL::Cell : public RTLIL::NamedObject
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

protected:
	// use module->addCell() and module->remove() to create or destroy cells
	friend struct RTLIL::Module;
	Cell();
	~Cell();

public:
	// do not simply copy cells
	Cell(RTLIL::Cell &other) = delete;
	void operator=(RTLIL::Cell &other) = delete;

	RTLIL::Module *module;
	RTLIL::IdString type;
	dict<RTLIL::IdString, RTLIL::SigSpec> connections_;
	dict<RTLIL::IdString, RTLIL::Const> parameters;

	// access cell ports
	bool hasPort(const RTLIL::IdString &portname) const;
	void unsetPort(const RTLIL::IdString &portname);
	void setPort(const RTLIL::IdString &portname, RTLIL::SigSpec signal);
	const RTLIL::SigSpec &getPort(const RTLIL::IdString &portname) const;
	const dict<RTLIL::IdString, RTLIL::SigSpec> &connections() const;

	// information about cell ports
	bool known() const;
	bool input(const RTLIL::IdString &portname) const;
	bool output(const RTLIL::IdString &portname) const;

	// access cell parameters
	bool hasParam(const RTLIL::IdString &paramname) const;
	void unsetParam(const RTLIL::IdString &paramname);
	void setParam(const RTLIL::IdString &paramname, RTLIL::Const value);
	const RTLIL::Const &getParam(const RTLIL::IdString &paramname) const;

	void sort();
	void check();
	void fixup_parameters(bool set_a_signed = false, bool set_b_signed = false);

	bool has_keep_attr() const {
		return get_bool_attribute(ID::keep) || (module && module->design && module->design->module(type) &&
				module->design->module(type)->get_bool_attribute(ID::keep));
	}

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Cell*> *get_all_cells(void);
#endif

	bool has_memid() const;
	bool is_mem_cell() const;
};

struct RTLIL::CaseRule : public RTLIL::AttrObject
{
	std::vector<RTLIL::SigSpec> compare;
	std::vector<RTLIL::SigSig> actions;
	std::vector<RTLIL::SwitchRule*> switches;

	~CaseRule();

	bool empty() const;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::CaseRule *clone() const;
};

struct RTLIL::SwitchRule : public RTLIL::AttrObject
{
	RTLIL::SigSpec signal;
	std::vector<RTLIL::CaseRule*> cases;

	~SwitchRule();

	bool empty() const;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::SwitchRule *clone() const;
};

struct RTLIL::MemWriteAction : RTLIL::AttrObject
{
	RTLIL::IdString memid;
	RTLIL::SigSpec address;
	RTLIL::SigSpec data;
	RTLIL::SigSpec enable;
	RTLIL::Const priority_mask;
};

struct RTLIL::SyncRule
{
	RTLIL::SyncType type;
	RTLIL::SigSpec signal;
	std::vector<RTLIL::SigSig> actions;
	std::vector<RTLIL::MemWriteAction> mem_write_actions;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::SyncRule *clone() const;
};

struct RTLIL::Process : public RTLIL::NamedObject
{
	Hasher::hash_t hashidx_;
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(hashidx_); return h; }

protected:
	// use module->addProcess() and module->remove() to create or destroy processes
	friend struct RTLIL::Module;
	Process();
	~Process();

public:
	RTLIL::Module *module;
	RTLIL::CaseRule root_case;
	std::vector<RTLIL::SyncRule*> syncs;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::Process *clone() const;
};


inline RTLIL::SigBit::SigBit() : wire(NULL), data(RTLIL::State::S0) { }
inline RTLIL::SigBit::SigBit(RTLIL::State bit) : wire(NULL), data(bit) { }
inline RTLIL::SigBit::SigBit(bool bit) : wire(NULL), data(bit ? State::S1 : State::S0) { }
inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire) : wire(wire), offset(0) { log_assert(wire && wire->width == 1); }
inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire, int offset) : wire(wire), offset(offset) { log_assert(wire != nullptr); }
inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk) : wire(chunk.wire) { log_assert(chunk.width == 1); if (wire) offset = chunk.offset; else data = chunk.data[0]; }
inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk, int index) : wire(chunk.wire) { if (wire) offset = chunk.offset + index; else data = chunk.data[index]; }

inline bool RTLIL::SigBit::operator<(const RTLIL::SigBit &other) const {
	if (wire == other.wire)
		return wire ? (offset < other.offset) : (data < other.data);
	if (wire != nullptr && other.wire != nullptr)
		return wire->name < other.wire->name;
	return (wire != nullptr) < (other.wire != nullptr);
}

inline bool RTLIL::SigBit::operator==(const RTLIL::SigBit &other) const {
	return (wire == other.wire) && (wire ? (offset == other.offset) : (data == other.data));
}

inline bool RTLIL::SigBit::operator!=(const RTLIL::SigBit &other) const {
	return (wire != other.wire) || (wire ? (offset != other.offset) : (data != other.data));
}

inline Hasher RTLIL::SigBit::hash_into(Hasher h) const {
	if (wire) {
		h.eat(offset);
		h.eat(wire->name);
		return h;
	}
	h.eat(data);
	return h;
}


inline Hasher RTLIL::SigBit::hash_top() const {
	Hasher h;
	if (wire) {
		h.force(hashlib::legacy::djb2_add(wire->name.index_, offset));
		return h;
	}
	h.force(data);
	return h;
}

inline RTLIL::SigBit &RTLIL::SigSpecIterator::operator*() const {
	return (*sig_p)[index];
}

inline const RTLIL::SigBit &RTLIL::SigSpecConstIterator::operator*() const {
	return (*sig_p)[index];
}

inline RTLIL::SigBit::SigBit(const RTLIL::SigSpec &sig) {
	log_assert(sig.size() == 1 && sig.chunks().size() == 1);
	*this = SigBit(sig.chunks().front());
}

template<typename T>
void RTLIL::Module::rewrite_sigspecs(T &functor)
{
	for (auto &it : cells_)
		it.second->rewrite_sigspecs(functor);
	for (auto &it : processes)
		it.second->rewrite_sigspecs(functor);
	for (auto &it : connections_) {
		functor(it.first);
		functor(it.second);
	}
}

template<typename T>
void RTLIL::Module::rewrite_sigspecs2(T &functor)
{
	for (auto &it : cells_)
		it.second->rewrite_sigspecs2(functor);
	for (auto &it : processes)
		it.second->rewrite_sigspecs2(functor);
	for (auto &it : connections_) {
		functor(it.first, it.second);
	}
}

template<typename T>
void RTLIL::Cell::rewrite_sigspecs(T &functor) {
	for (auto &it : connections_)
		functor(it.second);
}

template<typename T>
void RTLIL::Cell::rewrite_sigspecs2(T &functor) {
	for (auto &it : connections_)
		functor(it.second);
}

template<typename T>
void RTLIL::CaseRule::rewrite_sigspecs(T &functor) {
	for (auto &it : compare)
		functor(it);
	for (auto &it : actions) {
		functor(it.first);
		functor(it.second);
	}
	for (auto it : switches)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::CaseRule::rewrite_sigspecs2(T &functor) {
	for (auto &it : compare)
		functor(it);
	for (auto &it : actions) {
		functor(it.first, it.second);
	}
	for (auto it : switches)
		it->rewrite_sigspecs2(functor);
}

template<typename T>
void RTLIL::SwitchRule::rewrite_sigspecs(T &functor)
{
	functor(signal);
	for (auto it : cases)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::SwitchRule::rewrite_sigspecs2(T &functor)
{
	functor(signal);
	for (auto it : cases)
		it->rewrite_sigspecs2(functor);
}

template<typename T>
void RTLIL::SyncRule::rewrite_sigspecs(T &functor)
{
	functor(signal);
	for (auto &it : actions) {
		functor(it.first);
		functor(it.second);
	}
	for (auto &it : mem_write_actions) {
		functor(it.address);
		functor(it.data);
		functor(it.enable);
	}
}

template<typename T>
void RTLIL::SyncRule::rewrite_sigspecs2(T &functor)
{
	functor(signal);
	for (auto &it : actions) {
		functor(it.first, it.second);
	}
	for (auto &it : mem_write_actions) {
		functor(it.address);
		functor(it.data);
		functor(it.enable);
	}
}

template<typename T>
void RTLIL::Process::rewrite_sigspecs(T &functor)
{
	root_case.rewrite_sigspecs(functor);
	for (auto it : syncs)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::Process::rewrite_sigspecs2(T &functor)
{
	root_case.rewrite_sigspecs2(functor);
	for (auto it : syncs)
		it->rewrite_sigspecs2(functor);
}

YOSYS_NAMESPACE_END

#endif
`,"satgen.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SATGEN_H
#define SATGEN_H

#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"
#include "kernel/macc.h"

#include "libs/ezsat/ezminisat.h"

YOSYS_NAMESPACE_BEGIN

// defined in kernel/register.cc
extern struct SatSolver *yosys_satsolver_list;
extern struct SatSolver *yosys_satsolver;

struct SatSolver
{
	string name;
	SatSolver *next;
	virtual ezSAT *create() = 0;

	SatSolver(string name) : name(name) {
		next = yosys_satsolver_list;
		yosys_satsolver_list = this;
	}

	virtual ~SatSolver() {
		auto p = &yosys_satsolver_list;
		while (*p) {
			if (*p == this)
				*p = next;
			else
				p = &(*p)->next;
		}
		if (yosys_satsolver == this)
			yosys_satsolver = yosys_satsolver_list;
	}
};

struct ezSatPtr : public std::unique_ptr<ezSAT> {
	ezSatPtr() : unique_ptr<ezSAT>(yosys_satsolver->create()) { }
};

struct SatGen
{
	ezSAT *ez;
	SigMap *sigmap;
	std::string prefix;
	SigPool initial_state;
	std::map<std::string, RTLIL::SigSpec> asserts_a, asserts_en;
	std::map<std::string, RTLIL::SigSpec> assumes_a, assumes_en;
	std::map<std::string, std::map<RTLIL::SigBit, int>> imported_signals;
	std::map<std::pair<std::string, int>, bool> initstates;
	bool ignore_div_by_zero;
	bool model_undef;
	bool def_formal = false;

	SatGen(ezSAT *ez, SigMap *sigmap, std::string prefix = std::string()) :
			ez(ez), sigmap(sigmap), prefix(prefix), ignore_div_by_zero(false), model_undef(false)
	{
	}

	void setContext(SigMap *sigmap, std::string prefix = std::string())
	{
		this->sigmap = sigmap;
		this->prefix = prefix;
	}

	std::vector<int> importSigSpecWorker(RTLIL::SigSpec sig, std::string &pf, bool undef_mode, bool dup_undef)
	{
		log_assert(!undef_mode || model_undef);
		sigmap->apply(sig);

		std::vector<int> vec;
		vec.reserve(GetSize(sig));

		for (auto &bit : sig)
			if (bit.wire == NULL) {
				if (model_undef && dup_undef && bit == RTLIL::State::Sx)
					vec.push_back(ez->frozen_literal());
				else
					vec.push_back(bit == (undef_mode ? RTLIL::State::Sx : RTLIL::State::S1) ? ez->CONST_TRUE : ez->CONST_FALSE);
			} else {
				std::string name = pf + (bit.wire->width == 1 ? stringf("%s", log_id(bit.wire)) : stringf("%s [%d]", log_id(bit.wire->name), bit.offset));
				vec.push_back(ez->frozen_literal(name));
				imported_signals[pf][bit] = vec.back();
			}
		return vec;
	}

	std::vector<int> importSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, false, false);
	}

	std::vector<int> importDefSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, false, true);
	}

	std::vector<int> importUndefSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = "undef:" + prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, true, false);
	}

	int importSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, false, false).front();
	}

	int importDefSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, false, true).front();
	}

	int importUndefSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = "undef:" + prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, true, false).front();
	}

	bool importedSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return imported_signals[pf].count(bit) != 0;
	}

	void getAsserts(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)
	{
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		sig_a = asserts_a[pf];
		sig_en = asserts_en[pf];
	}

	void getAssumes(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)
	{
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		sig_a = assumes_a[pf];
		sig_en = assumes_en[pf];
	}

	int importAsserts(int timestep = -1)
	{
		std::vector<int> check_bits, enable_bits;
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		if (model_undef) {
			check_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_a[pf], timestep)), importDefSigSpec(asserts_a[pf], timestep));
			enable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_en[pf], timestep)), importDefSigSpec(asserts_en[pf], timestep));
		} else {
			check_bits = importDefSigSpec(asserts_a[pf], timestep);
			enable_bits = importDefSigSpec(asserts_en[pf], timestep);
		}
		return ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));
	}

	int importAssumes(int timestep = -1)
	{
		std::vector<int> check_bits, enable_bits;
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		if (model_undef) {
			check_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_a[pf], timestep)), importDefSigSpec(assumes_a[pf], timestep));
			enable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_en[pf], timestep)), importDefSigSpec(assumes_en[pf], timestep));
		} else {
			check_bits = importDefSigSpec(assumes_a[pf], timestep);
			enable_bits = importDefSigSpec(assumes_en[pf], timestep);
		}
		return ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));
	}

	int signals_eq(RTLIL::SigSpec lhs, RTLIL::SigSpec rhs, int timestep_lhs = -1, int timestep_rhs = -1)
	{
		if (timestep_rhs < 0)
			timestep_rhs = timestep_lhs;

		log_assert(lhs.size() == rhs.size());

		std::vector<int> vec_lhs = importSigSpec(lhs, timestep_lhs);
		std::vector<int> vec_rhs = importSigSpec(rhs, timestep_rhs);

		if (!model_undef)
			return ez->vec_eq(vec_lhs, vec_rhs);

		std::vector<int> undef_lhs = importUndefSigSpec(lhs, timestep_lhs);
		std::vector<int> undef_rhs = importUndefSigSpec(rhs, timestep_rhs);

		std::vector<int> eq_bits;
		for (int i = 0; i < lhs.size(); i++)
			eq_bits.push_back(ez->AND(ez->IFF(undef_lhs.at(i), undef_rhs.at(i)),
					ez->IFF(ez->OR(vec_lhs.at(i), undef_lhs.at(i)), ez->OR(vec_rhs.at(i), undef_rhs.at(i)))));
		return ez->expression(ezSAT::OpAnd, eq_bits);
	}

	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, RTLIL::Cell *cell, size_t y_width = 0, bool forced_signed = false)
	{
		bool is_signed = forced_signed;
		if (!forced_signed && cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters.count(ID::B_SIGNED) > 0)
			is_signed = cell->parameters[ID::A_SIGNED].as_bool() && cell->parameters[ID::B_SIGNED].as_bool();
		while (vec_a.size() < vec_b.size() || vec_a.size() < y_width)
			vec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);
		while (vec_b.size() < vec_a.size() || vec_b.size() < y_width)
			vec_b.push_back(is_signed && vec_b.size() > 0 ? vec_b.back() : ez->CONST_FALSE);
	}

	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)
	{
		extendSignalWidth(vec_a, vec_b, cell, vec_y.size(), forced_signed);
		while (vec_y.size() < vec_a.size())
			vec_y.push_back(ez->literal());
	}

	void extendSignalWidthUnary(std::vector<int> &vec_a, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)
	{
		bool is_signed = forced_signed || (cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool());
		while (vec_a.size() < vec_y.size())
			vec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);
		while (vec_y.size() < vec_a.size())
			vec_y.push_back(ez->literal());
	}

	void undefGating(std::vector<int> &vec_y, std::vector<int> &vec_yy, std::vector<int> &vec_undef)
	{
		log_assert(model_undef);
		log_assert(vec_y.size() == vec_yy.size());
		if (vec_y.size() > vec_undef.size()) {
			std::vector<int> trunc_y(vec_y.begin(), vec_y.begin() + vec_undef.size());
			std::vector<int> trunc_yy(vec_yy.begin(), vec_yy.begin() + vec_undef.size());
			ez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(trunc_y, trunc_yy))));
		} else {
			log_assert(vec_y.size() == vec_undef.size());
			ez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(vec_y, vec_yy))));
		}
	}

	std::pair<std::vector<int>, std::vector<int>> mux(int s, int undef_s, const std::vector<int> &a, const std::vector<int> &undef_a, const std::vector<int> &b, const std::vector<int> &undef_b) {
		std::vector<int> res;
		std::vector<int> undef_res;
		res = ez->vec_ite(s, b, a);
		if (model_undef) {
			std::vector<int> unequal_ab = ez->vec_not(ez->vec_iff(a, b));
			std::vector<int> undef_ab = ez->vec_or(unequal_ab, ez->vec_or(undef_a, undef_b));
			undef_res = ez->vec_ite(undef_s, undef_ab, ez->vec_ite(s, undef_b, undef_a));
		}
		return std::make_pair(res, undef_res);
	}

	void undefGating(int y, int yy, int undef)
	{
		ez->assume(ez->OR(undef, ez->IFF(y, yy)));
	}

	void setInitState(int timestep)
	{
		auto key = make_pair(prefix, timestep);
		log_assert(initstates.count(key) == 0 || initstates.at(key) == true);
		initstates[key] = true;
	}

	bool importCell(RTLIL::Cell *cell, int timestep = -1);
};

YOSYS_NAMESPACE_END

#endif
`,"scopeinfo.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SCOPEINFO_H
#define SCOPEINFO_H

#include <vector>
#include <algorithm>

#include "kernel/yosys.h"
#include "kernel/celltypes.h"

YOSYS_NAMESPACE_BEGIN

template<typename T>
class IdTree
{
public:
	struct Cursor;

protected:
	IdTree *parent = nullptr;
	IdString scope_name;
	int depth = 0;

	pool<IdString> names;
	dict<IdString, T> entries;
public: // XXX
	dict<IdString, std::unique_ptr<IdTree>> subtrees;

	template<typename P, typename T_ref>
	static Cursor do_insert(IdTree *tree, P begin, P end, T_ref &&value)
	{
		log_assert(begin != end && "path must be non-empty");
		while (true) {
			IdString name = *begin;
			++begin;
			log_assert(!name.empty());
			tree->names.insert(name);
			if (begin == end) {
				tree->entries.emplace(name, std::forward<T_ref>(value));
				return Cursor(tree, name);
			}
			auto &unique = tree->subtrees[name];
			if (!unique) {
				unique.reset(new IdTree);
				unique->scope_name = name;
				unique->parent = tree;
				unique->depth = tree->depth + 1;
			}
			tree = unique.get();
		}
	}

public:
	IdTree() = default;
	IdTree(const IdTree &) = delete;
	IdTree(IdTree &&) = delete;

	// A cursor remains valid as long as the (sub-)IdTree it points at is alive
	struct Cursor
	{
		friend class IdTree;
	protected:
	public:
		IdTree *target;
		IdString scope_name;

		Cursor() : target(nullptr) {}
		Cursor(IdTree *target, IdString scope_name) : target(target), scope_name(scope_name) {
			if (scope_name.empty())
				log_assert(target->parent == nullptr);
		}

		Cursor do_first_child() {
			IdTree *tree = nullptr;
			if (scope_name.empty()) {
				tree = target;
			} else {
				auto found = target->subtrees.find(scope_name);
				if (found != target->subtrees.end()) {
					tree = found->second.get();
				} else {
					return Cursor();
				}
			}
			if (tree->names.empty()) {
				return Cursor();
			}
			return Cursor(tree, *tree->names.begin());
		}

		Cursor do_next_sibling() {
			if (scope_name.empty())
				return Cursor();
			auto found = target->names.find(scope_name);
			if (found == target->names.end())
				return Cursor();
			++found;
			if (found == target->names.end())
				return Cursor();
			return Cursor(target, *found);
		}

		Cursor do_parent() {
			if (scope_name.empty())
				return Cursor();
			if (target->parent != nullptr)
				return Cursor(target->parent, target->scope_name);
			return Cursor(target, IdString());
		}

		Cursor do_next_preorder() {
			Cursor current = *this;
			Cursor next = current.do_first_child();
			if (next.valid())
				return next;
			while (current.valid()) {
				if (next.valid())
					return next;
				next = current.do_next_sibling();
				if (next.valid())
					return next;
				current = current.do_parent();
			}
			return current;
		}

		Cursor do_child(IdString name) {
			IdTree *tree = nullptr;
			if (scope_name.empty()) {
				tree = target;
			} else {
				auto found = target->subtrees.find(scope_name);
				if (found != target->subtrees.end()) {
					tree = found->second.get();
				} else {
					return Cursor();
				}
			}
			auto found = tree->names.find(name);
			if (found == tree->names.end()) {
				return Cursor();
			}
			return Cursor(tree, *found);
		}

	public:
		bool operator==(const Cursor &other) const {
			return target == other.target && scope_name == other.scope_name;
		}
		bool operator!=(const Cursor &other) const {
			return !(*this == other);
		}

		[[nodiscard]] Hasher hash_into(Hasher h) const
		{
			h.eat(scope_name);
			h.eat(target);
			return h;
		}

		bool valid() const {
			return target != nullptr;
		}

		int depth() const {
			log_assert(valid());
			return target->depth + !scope_name.empty();
		}

		bool is_root() const {
			return target != nullptr && scope_name.empty();
		}

		bool has_entry() const {
			log_assert(valid());
			return !scope_name.empty() && target->entries.count(scope_name);
		}

		T &entry() {
			log_assert(!scope_name.empty());
			return target->entries.at(scope_name);
		}

		void assign_path_to(std::vector<IdString> &out_path) {
			log_assert(valid());
			out_path.clear();
			if (scope_name.empty())
				return;
			out_path.push_back(scope_name);
			IdTree *current = target;
			while (current->parent) {
				out_path.push_back(current->scope_name);
				current = current->parent;
			}
			std::reverse(out_path.begin(), out_path.end());
		}

		std::vector<IdString> path() {
			std::vector<IdString> result;
			assign_path_to(result);
			return result;
		}

		std::string path_str() {
			std::string result;
			for (const auto &item : path()) {
				if (!result.empty())
					result.push_back(' ');
				result += RTLIL::unescape_id(item);
			}
			return result;
		}

		Cursor first_child() {
			log_assert(valid());
			return do_first_child();
		}

		Cursor next_preorder() {
			log_assert(valid());
			return do_next_preorder();
		}

		Cursor parent() {
			log_assert(valid());
			return do_parent();
		}

		Cursor child(IdString name) {
			log_assert(valid());
			return do_child(name);
		}

		Cursor common_ancestor(Cursor other) {
			Cursor current = *this;

			while (current != other) {
				if (!current.valid() || !other.valid())
					return Cursor();
				int delta = current.depth() - other.depth();
				if (delta >= 0)
					current = current.do_parent();
				if (delta <= 0)
					other = other.do_parent();
			}
			return current;
		}
	};

	template<typename P>
	Cursor insert(P begin, P end, const T &value) {
		return do_insert(this, begin, end, value);
	}

	template<typename P>
	Cursor insert(P begin, P end, T &&value) {
		return do_insert(this, begin, end, std::move(value));
	}

	template<typename P>
	Cursor insert(const P &path, const T &value) {
		return do_insert(this, path.begin(), path.end(), value);
	}

	template<typename P>
	Cursor insert(const P &path, T &&value) {
		return do_insert(this, path.begin(), path.end(), std::move(value));
	}

	Cursor cursor() {
		return parent ? Cursor(this->parent, this->scope_name) : Cursor(this, IdString());
	}

	template<typename P>
	Cursor cursor(P begin, P end) {
		Cursor current = cursor();
		for (; begin != end; ++begin) {
			current = current.do_child(*begin);
			if (!current.valid())
				break;
		}
		return current;
	}

	template<typename P>
	Cursor cursor(const P &path) {
		return cursor(path.begin(), path.end());
	}
};


struct ModuleItem {
	enum class Type {
		Wire,
		Cell,
	};
	Type type;
	void *ptr;

	ModuleItem(Wire *wire) : type(Type::Wire), ptr(wire) {}
	ModuleItem(Cell *cell) : type(Type::Cell), ptr(cell) {}

	bool is_wire() const { return type == Type::Wire; }
	bool is_cell() const { return type == Type::Cell; }

	Wire *wire() const { return type == Type::Wire ? static_cast<Wire *>(ptr) : nullptr; }
	Cell *cell() const { return type == Type::Cell ? static_cast<Cell *>(ptr) : nullptr; }

	bool operator==(const ModuleItem &other) const { return ptr == other.ptr && type == other.type; }
	[[nodiscard]] Hasher hash_into(Hasher h) const { h.eat(ptr); return h; }
};

static inline void log_dump_val_worker(typename IdTree<ModuleItem>::Cursor cursor ) { log("%p %s", cursor.target, log_id(cursor.scope_name)); }

template<typename T>
static inline void log_dump_val_worker(const typename std::unique_ptr<T> &cursor ) { log("unique %p", cursor.get()); }

template<typename O>
std::vector<IdString> parse_hdlname(const O* object)
{
	std::vector<IdString> path;
	for (auto const &item : object->get_hdlname_attribute())
		path.push_back("\\\\" + item);
	if (path.empty() && object->name.isPublic())
		path.push_back(object->name);
	if (!path.empty() && !(object->name.isPublic() || object->name.begins_with("$paramod") || object->name.begins_with("$abstract"))) {
		path.pop_back();
		path.push_back(object->name);
	}
	return path;
}

template<typename O>
std::pair<std::vector<IdString>, IdString> parse_scopename(const O* object)
{
	std::vector<IdString> path;
	IdString trailing = object->name;
	if (object->name.isPublic() || object->name.begins_with("$paramod") || object->name.begins_with("$abstract")) {
		for (auto const &item : object->get_hdlname_attribute())
			path.push_back("\\\\" + item);
		if (!path.empty()) {
			trailing = path.back();
			path.pop_back();
		}
	} else if (object->has_attribute(ID::hdlname)) {
		for (auto const &item : object->get_hdlname_attribute())
			path.push_back("\\\\" + item);
		if (!path.empty()) {
			path.pop_back();
		}
	} else {
		for (auto const &item : split_tokens(object->get_string_attribute(ID(scopename)), " "))
			path.push_back("\\\\" + item);
	}
	return {path, trailing};
}

struct ModuleHdlnameIndex {
	typedef IdTree<ModuleItem>::Cursor Cursor;

	RTLIL::Module *module;
	IdTree<ModuleItem> tree;
	dict<ModuleItem, Cursor> lookup;

	ModuleHdlnameIndex(RTLIL::Module *module) : module(module) {}

private:
	template<typename I, typename Filter>
	void index_items(I begin, I end, Filter filter);

public:
	// Index all wires and cells of the module
	void index();

	// Index all wires of the module
	void index_wires();

	// Index all cells of the module
	void index_cells();

	// Index only the $scopeinfo cells of the module.
	// This is sufficient when using \`containing_scope\`.
	void index_scopeinfo_cells();


	// Return the cursor for the containing scope of some RTLIL object (Wire/Cell/...)
	template<typename O>
	std::pair<Cursor, IdString> containing_scope(O *object) {
		auto pair = parse_scopename(object);
		return {tree.cursor(pair.first), pair.second};
	}

	// Return a vector of source locations starting from the indexed module to
	// the scope represented by the cursor. The vector alternates module and
	// module item source locations, using empty strings for missing src
	// attributes.
	std::vector<std::string> scope_sources(Cursor cursor);

	// Return a vector of source locations starting from the indexed module to
	// the passed RTLIL object (Wire/Cell/...). The vector alternates module
	// and module item source locations, using empty strings for missing src
	// attributes.
	template<typename O>
	std::vector<std::string> sources(O *object) {
		auto pair = parse_scopename(object);
		std::vector<std::string> result = scope_sources(tree.cursor(pair.first));
		result.push_back(object->get_src_attribute());
		return result;
	}
};

enum class ScopeinfoAttrs {
	Module,
	Cell,
};

// Check whether the flattened module or flattened cell corresponding to a $scopeinfo cell had a specific attribute.
bool scopeinfo_has_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);

// Get a specific attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.
RTLIL::Const scopeinfo_get_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);

// Get all attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.
dict<RTLIL::IdString, RTLIL::Const> scopeinfo_attributes(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs);

YOSYS_NAMESPACE_END

#endif
`,"sexpr.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Emily Schmidt <emily@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SEXPR_H
#define SEXPR_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

class SExpr {
public:
	std::variant<std::vector<SExpr>, std::string> _v;
public:
	SExpr(std::string a) : _v(std::move(a)) {}
    SExpr(const char *a) : _v(a) {}
    // FIXME: should maybe be defined for all integral types
	SExpr(int n) : _v(std::to_string(n)) {}
	SExpr(std::vector<SExpr> const &l) : _v(l) {}
	SExpr(std::vector<SExpr> &&l) : _v(std::move(l)) {}
    // It would be nicer to have an std::initializer_list constructor,
    // but that causes confusing issues with overload resolution sometimes.
    template<typename... Args> static SExpr list(Args&&... args) {
	    return SExpr(std::vector<SExpr>{std::forward<Args>(args)...});
    }
    bool is_atom() const { return std::holds_alternative<std::string>(_v); }
    std::string const &atom() const { return std::get<std::string>(_v); }
    bool is_list() const { return std::holds_alternative<std::vector<SExpr>>(_v); }
    std::vector<SExpr> const &list() const { return std::get<std::vector<SExpr>>(_v); }
	std::string to_string() const;
};

std::ostream &operator<<(std::ostream &os, SExpr const &sexpr);

namespace SExprUtil {
    // A little hack so that \`using SExprUtil::list\` lets you import a shortcut to \`SExpr::list\`
    template<typename... Args> SExpr list(Args&&... args) {
	    return SExpr(std::vector<SExpr>{std::forward<Args>(args)...});
    }
}

// SExprWriter is a pretty printer for s-expr. It does not try very hard to get a good layout.
class SExprWriter {
    std::ostream &os;
    int _max_line_width;
    int _indent = 0;
    int _pos = 0;
    // If _pending_nl is set, print a newline before the next character.
    // This lets us "undo" the last newline so we can put
    // closing parentheses or a hanging comment on the same line.
    bool _pending_nl = false;
    // Unclosed parentheses (boolean stored is indent_rest)
	vector<bool> _unclosed;
    // Used only for push() and pop() (stores _unclosed.size())
	vector<size_t> _unclosed_stack;
	void nl_if_pending();
    void puts(std::string_view s);
    int check_fit(SExpr const &sexpr, int space);
    void print(SExpr const &sexpr, bool close = true, bool indent_rest = true);
public:
    SExprWriter(std::ostream &os, int max_line_width = 80)
        : os(os)
        , _max_line_width(max_line_width)
    {}
    // Print an s-expr.
    SExprWriter &operator <<(SExpr const &sexpr) {
        print(sexpr);
        _pending_nl = true;
        return *this;
    }
    // Print an s-expr (which must be a list), but leave room for extra elements
    // which may be printed using either << or further calls to open.
    // If indent_rest = false, the remaining elements are not intended
    // (for avoiding unreasonable indentation on deeply nested structures).
    void open(SExpr const &sexpr, bool indent_rest = true) {
        log_assert(sexpr.is_list());
        print(sexpr, false, indent_rest);
    }
    // Close the s-expr opened with the last call to open
    // (if an argument is given, close that many s-exprs).
    void close(size_t n = 1);
    // push() remembers how many s-exprs are currently open
	void push() {
		_unclosed_stack.push_back(_unclosed.size());
	}
    // pop() closes all s-expr opened since the corresponding call to push()
	void pop() {
		auto t = _unclosed_stack.back();
		log_assert(_unclosed.size() >= t);
		close(_unclosed.size() - t);
		_unclosed_stack.pop_back();
	}
    // Print a comment.
    // If hanging = true, append it to the end of the last printed s-expr.
	void comment(std::string const &str, bool hanging = false);
    // Flush any unprinted characters to the std::ostream, but does not close unclosed parentheses.
    void flush() {
        nl_if_pending();
    }
    // Destructor closes any unclosed parentheses and flushes.
    ~SExprWriter();
};

YOSYS_NAMESPACE_END

#endif
`,"sigtools.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SIGTOOLS_H
#define SIGTOOLS_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct SigPool
{
	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {
		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }
		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }
		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(first->name);
			h.eat(second);
			return h;
		}
	};

	pool<bitDef_t> bits;

	void clear()
	{
		bits.clear();
	}

	void add(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL)
				bits.insert(bit);
	}

	void add(const SigPool &other)
	{
		for (auto &bit : other.bits)
			bits.insert(bit);
	}

	void del(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL)
				bits.erase(bit);
	}

	void del(const SigPool &other)
	{
		for (auto &bit : other.bits)
			bits.erase(bit);
	}

	void expand(const RTLIL::SigSpec &from, const RTLIL::SigSpec &to)
	{
		log_assert(GetSize(from) == GetSize(to));
		for (int i = 0; i < GetSize(from); i++) {
			bitDef_t bit_from(from[i]), bit_to(to[i]);
			if (bit_from.first != NULL && bit_to.first != NULL && bits.count(bit_from) > 0)
				bits.insert(bit_to);
		}
	}

	RTLIL::SigSpec extract(const RTLIL::SigSpec &sig) const
	{
		RTLIL::SigSpec result;
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				result.append(bit);
		return result;
	}

	RTLIL::SigSpec remove(const RTLIL::SigSpec &sig) const
	{
		RTLIL::SigSpec result;
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit) == 0)
				result.append(bit);
		return result;
	}

	bool check(const RTLIL::SigBit &bit) const
	{
		return bit.wire != NULL && bits.count(bit);
	}

	bool check_any(const RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				return true;
		return false;
	}

	bool check_all(const RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit) == 0)
				return false;
		return true;
	}

	RTLIL::SigSpec export_one() const
	{
		for (auto &bit : bits)
			return RTLIL::SigSpec(bit.first, bit.second);
		return RTLIL::SigSpec();
	}

	RTLIL::SigSpec export_all() const
	{
		pool<RTLIL::SigBit> sig;
		for (auto &bit : bits)
			sig.insert(RTLIL::SigBit(bit.first, bit.second));
		return sig;
	}

	size_t size() const
	{
		return bits.size();
	}
};

template <typename T, class Compare = void>
struct SigSet
{
	static_assert(!std::is_same<Compare,void>::value, "Default value for \`Compare' class not found for SigSet<T>. Please specify.");

	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {
		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }
		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }
		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(first->name);
			h.eat(second);
			return h;
		}
	};

	dict<bitDef_t, std::set<T, Compare>> bits;

	void clear()
	{
		bits.clear();
	}

	void insert(const RTLIL::SigSpec &sig, T data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].insert(data);
	}

	void insert(const RTLIL::SigSpec& sig, const std::set<T> &data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].insert(data.begin(), data.end());
	}

	void erase(const RTLIL::SigSpec& sig)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].clear();
	}

	void erase(const RTLIL::SigSpec &sig, T data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].erase(data);
	}

	void erase(const RTLIL::SigSpec &sig, const std::set<T> &data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].erase(data.begin(), data.end());
	}

	void find(const RTLIL::SigSpec &sig, std::set<T> &result)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL) {
				auto &data = bits[bit];
				result.insert(data.begin(), data.end());
			}
	}

	void find(const RTLIL::SigSpec &sig, pool<T> &result)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL) {
				auto &data = bits[bit];
				result.insert(data.begin(), data.end());
			}
	}

	std::set<T> find(const RTLIL::SigSpec &sig)
	{
		std::set<T> result;
		find(sig, result);
		return result;
	}

	bool has(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				return true;
		return false;
	}
};

template<typename T>
class SigSet<T, typename std::enable_if<!std::is_pointer<T>::value>::type> : public SigSet<T, std::less<T>> {};
template<typename T>
using sort_by_name_id_guard = typename std::enable_if<std::is_same<T,RTLIL::Cell*>::value>::type;
template<typename T>
class SigSet<T, sort_by_name_id_guard<T>> : public SigSet<T, RTLIL::sort_by_name_id<typename std::remove_pointer<T>::type>> {};

/**
 * SigMap wraps a union-find "database"
 * to map SigBits of a module to canonical representative SigBits.
 * SigBits that are connected share a set in the underlying database.
 * If a SigBit has a const state (impl: bit.wire is nullptr),
 * it's promoted to a representative.
 */
struct SigMap
{
	mfp<SigBit> database;

	SigMap(RTLIL::Module *module = NULL)
	{
		if (module != NULL)
			set(module);
	}

	void swap(SigMap &other)
	{
		database.swap(other.database);
	}

	void clear()
	{
		database.clear();
	}

	// Rebuild SigMap for all connections in module
	void set(RTLIL::Module *module)
	{
		int bitcount = 0;
		for (auto &it : module->connections())
			bitcount += it.first.size();

		database.clear();
		database.reserve(bitcount);

		for (auto &it : module->connections())
			add(it.first, it.second);
	}

	// Add connections from "from" to "to", bit-by-bit
	void add(const RTLIL::SigSpec& from, const RTLIL::SigSpec& to)
	{
		log_assert(GetSize(from) == GetSize(to));

		for (int i = 0; i < GetSize(from); i++)
		{
			int bfi = database.lookup(from[i]);
			int bti = database.lookup(to[i]);

			const RTLIL::SigBit &bf = database[bfi];
			const RTLIL::SigBit &bt = database[bti];

			if (bf.wire || bt.wire)
			{
				database.imerge(bfi, bti);

				if (bf.wire == nullptr)
					database.ipromote(bfi);

				if (bt.wire == nullptr)
					database.ipromote(bti);
			}
		}
	}

	// Add sig as disconnected from anything
	void add(const RTLIL::SigBit &bit)
	{
		const auto &b = database.find(bit);
		if (b.wire != nullptr)
			database.promote(bit);
	}

	void add(const RTLIL::SigSpec &sig)
	{
		for (const auto &bit : sig)
			add(bit);
	}

	inline void add(Wire *wire) { return add(RTLIL::SigSpec(wire)); }

	// Modify bit to its representative
	void apply(RTLIL::SigBit &bit) const
	{
		bit = database.find(bit);
	}

	void apply(RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			apply(bit);
	}

	RTLIL::SigBit operator()(RTLIL::SigBit bit) const
	{
		apply(bit);
		return bit;
	}

	RTLIL::SigSpec operator()(RTLIL::SigSpec sig) const
	{
		apply(sig);
		return sig;
	}

	RTLIL::SigSpec operator()(RTLIL::Wire *wire) const
	{
		SigSpec sig(wire);
		apply(sig);
		return sig;
	}

	// All non-const bits
	RTLIL::SigSpec allbits() const
	{
		RTLIL::SigSpec sig;
		for (const auto &bit : database)
			if (bit.wire != nullptr)
				sig.append(bit);
		return sig;
	}
};

YOSYS_NAMESPACE_END

#endif /* SIGTOOLS_H */
`,"timinginfo.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *            (C) 2020  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef TIMINGINFO_H
#define TIMINGINFO_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct TimingInfo
{
	struct NameBit
	{
		RTLIL::IdString name;
		int offset;
		NameBit() : offset(0) {}
		NameBit(const RTLIL::IdString name, int offset) : name(name), offset(offset) {}
		explicit NameBit(const RTLIL::SigBit &b) : name(b.wire->name), offset(b.offset) {}
		bool operator==(const NameBit& nb) const { return nb.name == name && nb.offset == offset; }
		bool operator!=(const NameBit& nb) const { return !operator==(nb); }
		std::optional<SigBit> get_connection(RTLIL::Cell *cell) {
			if (!cell->hasPort(name))
				return {};
			auto &port = cell->getPort(name);
			if (offset >= port.size())
				return {};
			return port[offset];
		}
		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(name);
			h.eat(offset);
			return h;
		}
	};
	struct BitBit
	{
		NameBit first, second;
		BitBit(const NameBit &first, const NameBit &second) : first(first), second(second) {}
		BitBit(const SigBit &first, const SigBit &second) : first(first), second(second) {}
		bool operator==(const BitBit& bb) const { return bb.first == first && bb.second == second; }
		[[nodiscard]] Hasher hash_into(Hasher h) const {
			h.eat(first);
			h.eat(second);
			return h;
		}
	};

	struct ModuleTiming
	{
		dict<BitBit, int> comb;
		dict<NameBit, std::pair<int,NameBit>> arrival, required;
		bool has_inputs;
	};

	dict<RTLIL::IdString, ModuleTiming> data;

	TimingInfo()
	{
	}

	TimingInfo(RTLIL::Design *design)
	{
		setup(design);
	}

	void setup(RTLIL::Design *design)
	{
		for (auto module : design->modules()) {
			if (!module->get_blackbox_attribute())
				continue;
			setup_module(module);
		}
	}

	const ModuleTiming& setup_module(RTLIL::Module *module)
	{
		auto r = data.insert(module->name);
		log_assert(r.second);
		auto &t = r.first->second;

		for (auto cell : module->cells()) {
			if (cell->type == ID($specify2)) {
				auto en = cell->getPort(ID::EN);
				if (en.is_fully_const() && !en.as_bool())
					continue;
				auto src = cell->getPort(ID::SRC);
				auto dst = cell->getPort(ID::DST);
				for (const auto &c : src.chunks())
					if (!c.wire || !c.wire->port_input)
						log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				for (const auto &c : dst.chunks())
					if (!c.wire || !c.wire->port_output)
						log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\n", log_id(module), log_id(cell), log_signal(dst));
				int rise_max = cell->getParam(ID::T_RISE_MAX).as_int();
				int fall_max = cell->getParam(ID::T_FALL_MAX).as_int();
				int max = std::max(rise_max,fall_max);
				if (max < 0)
					log_error("Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0.\\n", log_id(module), log_id(cell));
				if (cell->getParam(ID::FULL).as_bool()) {
					for (const auto &s : src)
						for (const auto &d : dst) {
							auto r = t.comb.insert(BitBit(s,d));
							if (!r.second)
								log_error("Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\n", log_id(module), log_signal(s), log_signal(d));
							r.first->second = max;
						}
				}
				else {
					log_assert(GetSize(src) == GetSize(dst));
					for (auto i = 0; i < GetSize(src); i++) {
						const auto &s = src[i];
						const auto &d = dst[i];
						auto r = t.comb.insert(BitBit(s,d));
						if (!r.second)
							log_error("Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\n", log_id(module), log_signal(s), log_signal(d));
						r.first->second = max;
					}
				}
			}
			else if (cell->type == ID($specify3)) {
				auto src = cell->getPort(ID::SRC).as_bit();
				auto dst = cell->getPort(ID::DST);
				if (!src.wire || !src.wire->port_input)
					log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				for (const auto &c : dst.chunks())
					if (!c.wire->port_output)
						log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\n", log_id(module), log_id(cell), log_signal(dst));
				int rise_max = cell->getParam(ID::T_RISE_MAX).as_int();
				int fall_max = cell->getParam(ID::T_FALL_MAX).as_int();
				int max = std::max(rise_max,fall_max);
				if (max < 0) {
					log_warning("Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0 which is currently unsupported. Clamping to 0.\\n", log_id(module), log_id(cell));
					max = 0;
				}
				for (const auto &d : dst) {
					auto r = t.arrival.insert(NameBit(d));
					auto &v = r.first->second;
					if (r.second || v.first < max) {
						v.first = max;
						v.second = NameBit(src);
					}
				}
			}
			else if (cell->type == ID($specrule)) {
				IdString type = cell->getParam(ID::TYPE).decode_string();
				if (type != ID($setup) && type != ID($setuphold))
					continue;
				auto src = cell->getPort(ID::SRC);
				auto dst = cell->getPort(ID::DST).as_bit();
				for (const auto &c : src.chunks())
					if (!c.wire || !c.wire->port_input)
						log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				if (!dst.wire || !dst.wire->port_input)
					log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(dst));
				int max = cell->getParam(ID::T_LIMIT_MAX).as_int();
				if (max < 0) {
					log_warning("Module '%s' contains specify cell '%s' with T_LIMIT_MAX < 0 which is currently unsupported. Clamping to 0.\\n", log_id(module), log_id(cell));
					max = 0;
				}
				for (const auto &s : src) {
					auto r = t.required.insert(NameBit(s));
					auto &v = r.first->second;
					if (r.second || v.first < max) {
						v.first = max;
						v.second = NameBit(dst);
					}
				}
			}
		}

		for (auto port_name : module->ports) {
			auto wire = module->wire(port_name);
			if (wire->port_input) {
				t.has_inputs = true;
				break;
			}
		}

		return t;
	}

	decltype(data)::const_iterator find(RTLIL::IdString module_name) const { return data.find(module_name); }
	decltype(data)::const_iterator end() const { return data.end(); }
	int count(RTLIL::IdString module_name) const { return data.count(module_name); }
	const ModuleTiming& at(RTLIL::IdString module_name) const { return data.at(module_name); }
};

YOSYS_NAMESPACE_END

#endif
`,"utils.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file contains various c++ utility routines and helper classes that
// do not depend on any other components of yosys (except stuff like log_*).

#include "kernel/yosys.h"

#ifndef UTILS_H
#define UTILS_H

YOSYS_NAMESPACE_BEGIN

// ------------------------------------------------
// A map-like container, but you can save and restore the state
// ------------------------------------------------

template<typename Key, typename T>
struct stackmap
{
private:
	std::vector<dict<Key, T*>> backup_state;
	dict<Key, T> current_state;
	static T empty_tuple;

public:
	stackmap() { }
	stackmap(const dict<Key, T> &other) : current_state(other) { }

	template<typename Other>
	void operator=(const Other &other)
	{
		for (auto &it : current_state)
			if (!backup_state.empty() && backup_state.back().count(it.first) == 0)
				backup_state.back()[it.first] = new T(it.second);
		current_state.clear();

		for (auto &it : other)
			set(it.first, it.second);
	}

	bool has(const Key &k)
	{
		return current_state.count(k) != 0;
	}

	void set(const Key &k, const T &v)
	{
		if (!backup_state.empty() && backup_state.back().count(k) == 0)
			backup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;
		current_state[k] = v;
	}

	void unset(const Key &k)
	{
		if (!backup_state.empty() && backup_state.back().count(k) == 0)
			backup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;
		current_state.erase(k);
	}

	const T &get(const Key &k)
	{
		if (current_state.count(k) == 0)
			return empty_tuple;
		return current_state.at(k);
	}

	void reset(const Key &k)
	{
		for (int i = GetSize(backup_state)-1; i >= 0; i--)
			if (backup_state[i].count(k) != 0) {
				if (backup_state[i].at(k) == nullptr)
					current_state.erase(k);
				else
					current_state[k] = *backup_state[i].at(k);
				return;
			}
		current_state.erase(k);
	}

	const dict<Key, T> &stdmap()
	{
		return current_state;
	}

	void save()
	{
		backup_state.resize(backup_state.size()+1);
	}

	void restore()
	{
		log_assert(!backup_state.empty());
		for (auto &it : backup_state.back())
			if (it.second != nullptr) {
				current_state[it.first] = *it.second;
				delete it.second;
			} else
				current_state.erase(it.first);
		backup_state.pop_back();
	}

	~stackmap()
	{
		while (!backup_state.empty())
			restore();
	}
};


// ------------------------------------------------
// A simple class for topological sorting
// ------------------------------------------------

template <typename T, typename C = std::less<T>> class TopoSort
{
      public:
	// We use this ordering of the edges in the adjacency matrix for
	// exact compatibility with an older implementation.
	struct IndirectCmp {
                IndirectCmp(const std::vector<T> &nodes) : node_cmp_(), nodes_(nodes) {}
		bool operator()(int a, int b) const
		{
                        log_assert(static_cast<size_t>(a) < nodes_.size());
			log_assert(static_cast<size_t>(b) < nodes_.size());
			return node_cmp_(nodes_[a], nodes_[b]);
		}
		const C node_cmp_;
		const std::vector<T> &nodes_;
	};

	bool analyze_loops;
	std::map<T, int, C> node_to_index;
	std::vector<std::set<int, IndirectCmp>> edges;
	std::vector<T> sorted;
	std::set<std::vector<T>> loops;

	TopoSort() : indirect_cmp(nodes)
	{
		analyze_loops = true;
		found_loops = false;
	}

	int node(T n)
	{
                auto rv = node_to_index.emplace(n, static_cast<int>(nodes.size()));
                if (rv.second) {
      	              nodes.push_back(n);
		      edges.push_back(std::set<int, IndirectCmp>(indirect_cmp));
		}
		return rv.first->second;
	}

	void edge(int l_index, int r_index) { edges[r_index].insert(l_index); }

	void edge(T left, T right) { edge(node(left), node(right)); }

	bool has_node(const T &node) { return node_to_index.find(node) != node_to_index.end(); }

	bool sort()
	{
		log_assert(GetSize(node_to_index) == GetSize(edges));
		log_assert(GetSize(nodes) == GetSize(edges));

		loops.clear();
		sorted.clear();
		found_loops = false;

		std::vector<bool> marked_cells(edges.size(), false);
		std::vector<bool> active_cells(edges.size(), false);
		std::vector<int> active_stack;
		sorted.reserve(edges.size());

		for (const auto &it : node_to_index)
			sort_worker(it.second, marked_cells, active_cells, active_stack);

		log_assert(GetSize(sorted) == GetSize(nodes));

		return !found_loops;
	}

	// Build the more expensive representation of edges for
	// a few passes that use it directly.
	std::map<T, std::set<T, C>, C> get_database()
	{
		std::map<T, std::set<T, C>, C> database;
		for (size_t i = 0; i < nodes.size(); ++i) {
			std::set<T, C> converted_edge_set;
			for (int other_node : edges[i]) {
				converted_edge_set.insert(nodes[other_node]);
			}
			database.emplace(nodes[i], converted_edge_set);
		}
		return database;
	}

      private:
	bool found_loops;
	std::vector<T> nodes;
	const IndirectCmp indirect_cmp;

	void sort_worker(const int root_index, std::vector<bool> &marked_cells, std::vector<bool> &active_cells, std::vector<int> &active_stack)
	{
		if (active_cells[root_index]) {
			found_loops = true;
			if (analyze_loops) {
				std::vector<T> loop;
				for (int i = GetSize(active_stack) - 1; i >= 0; i--) {
					const int index = active_stack[i];
					loop.push_back(nodes[index]);
					if (index == root_index)
						break;
				}
				loops.insert(loop);
			}
			return;
		}

		if (marked_cells[root_index])
			return;

		if (!edges[root_index].empty()) {
			if (analyze_loops)
				active_stack.push_back(root_index);
			active_cells[root_index] = true;

			for (int left_n : edges[root_index])
				sort_worker(left_n, marked_cells, active_cells, active_stack);

			if (analyze_loops)
				active_stack.pop_back();
			active_cells[root_index] = false;
		}

		marked_cells[root_index] = true;
		sorted.push_back(nodes[root_index]);
	}
};

// this class is used for implementing operator-> on iterators that return values rather than references
// it's necessary because in C++ operator-> is called recursively until a raw pointer is obtained
template<class T>
struct arrow_proxy {
	T v;
	explicit arrow_proxy(T const & v) : v(v) {}
	T* operator->() { return &v; }
};

inline int ceil_log2(int x)
{
#if defined(__GNUC__)
        return x > 1 ? (8*sizeof(int)) - __builtin_clz(x-1) : 0;
#else
	if (x <= 0)
		return 0;
	for (int i = 0; i < 32; i++)
		if (((x-1) >> i) == 0)
			return i;
	log_abort();
#endif
}

YOSYS_NAMESPACE_END

#endif
`,"yosys.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */


// *** NOTE TO THE READER ***
//
// Maybe you have just opened this file in the hope to learn more about the
// Yosys API. Let me congratulate you on this great decision!  ;)
//
// If you want to know how the design is represented by Yosys in the memory,
// you should read "kernel/rtlil.h".
//
// If you want to know how to register a command with Yosys, you could read
// "kernel/register.h", but it would be easier to just look at a simple
// example instead. A simple one would be "passes/cmds/log.cc".
//
// This header is very boring. It just defines some general things that
// belong nowhere else and includes the interesting headers.


#ifndef YOSYS_H
#define YOSYS_H

#include "kernel/yosys_common.h"

#include "kernel/log.h"
#include "kernel/rtlil.h"
#include "kernel/register.h"

#ifdef YOSYS_ENABLE_TCL
struct Tcl_Interp;
#endif

YOSYS_NAMESPACE_BEGIN

void yosys_setup();

#ifdef WITH_PYTHON
bool yosys_already_setup();
#endif

void yosys_shutdown();

#ifdef YOSYS_ENABLE_TCL
Tcl_Interp *yosys_get_tcl_interp();
#endif

extern RTLIL::Design *yosys_design;

RTLIL::Design *yosys_get_design();
std::string proc_self_dirname();
std::string proc_share_dirname();
std::string proc_program_prefix();
const char *create_prompt(RTLIL::Design *design, int recursion_counter);
std::vector<std::string> glob_filename(const std::string &filename_pattern);
void rewrite_filename(std::string &filename);

void run_pass(std::string command, RTLIL::Design *design = nullptr);
bool run_frontend(std::string filename, std::string command, RTLIL::Design *design = nullptr, std::string *from_to_label = nullptr);
void run_backend(std::string filename, std::string command, RTLIL::Design *design = nullptr);
void shell(RTLIL::Design *design);

// journal of all input and output files read (for "yosys -E")
extern std::set<std::string> yosys_input_files, yosys_output_files;

// from kernel/version_*.o (cc source generated from Makefile)
extern const char *yosys_version_str;
const char* yosys_maybe_version();

// from passes/cmds/design.cc
extern std::map<std::string, RTLIL::Design*> saved_designs;
extern std::vector<RTLIL::Design*> pushed_designs;

// from passes/cmds/pluginc.cc
extern std::map<std::string, void*> loaded_plugins;
#ifdef WITH_PYTHON
extern std::map<std::string, void*> loaded_python_plugins;
#endif
extern std::map<std::string, std::string> loaded_plugin_aliases;
void load_plugin(std::string filename, std::vector<std::string> aliases);

extern std::string yosys_share_dirname;
extern std::string yosys_abc_executable;

YOSYS_NAMESPACE_END

#endif
`,"yosys_common.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef YOSYS_COMMON_H
#define YOSYS_COMMON_H

#include <map>
#include <set>
#include <tuple>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include <initializer_list>
#include <variant>
#include <optional>
#include <stdexcept>
#include <memory>
#include <cmath>
#include <cstddef>

#include <sstream>
#include <fstream>
#include <istream>
#include <ostream>
#include <iostream>

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <limits.h>
#include <sys/stat.h>
#include <errno.h>

#ifdef WITH_PYTHON
#include <Python.h>
#endif

#ifndef _YOSYS_
#  error It looks like you are trying to build Yosys without the config defines set. \\
         When building Yosys with a custom make system, make sure you set all the \\
         defines the Yosys Makefile would set for your build configuration.
#endif

#define FRIEND_TEST(test_case_name, test_name) \\
  friend class test_case_name##_##test_name##_Test

#ifdef _WIN32
#  undef NOMINMAX
#  define NOMINMAX 1
#  undef YY_NO_UNISTD_H
#  define YY_NO_UNISTD_H 1

#  include <windows.h>
#  include <io.h>
#  include <direct.h>

#  define strtok_r strtok_s
#  define strdup _strdup
#  define snprintf _snprintf
#  define getcwd _getcwd
#  define mkdir _mkdir
#  define popen _popen
#  define pclose _pclose

#  ifndef __MINGW32__
#    define PATH_MAX MAX_PATH
#    define isatty _isatty
#    define fileno _fileno
#  endif

// The following defines conflict with our identifiers:
#  undef CONST
// \`wingdi.h\` defines a TRANSPARENT macro that conflicts with X(TRANSPARENT) entry in kernel/constids.inc
#  undef TRANSPARENT
#endif

#ifndef PATH_MAX
#  define PATH_MAX 4096
#endif


#define YOSYS_NAMESPACE          Yosys
#define PRIVATE_NAMESPACE_BEGIN  namespace {
#define PRIVATE_NAMESPACE_END    }
#define YOSYS_NAMESPACE_BEGIN    namespace Yosys {
#define YOSYS_NAMESPACE_END      }
#define YOSYS_NAMESPACE_PREFIX   Yosys::
#define USING_YOSYS_NAMESPACE    using namespace Yosys;

#if defined(__GNUC__) || defined(__clang__)
#  define YS_ATTRIBUTE(...) __attribute__((__VA_ARGS__))
#elif defined(_MSC_VER)
#  define YS_ATTRIBUTE(...)
#else
#  define YS_ATTRIBUTE(...)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define YS_MAYBE_UNUSED __attribute__((__unused__))
#else
#  define YS_MAYBE_UNUSED
#endif

#if __cplusplus >= 201703L
#  define YS_FALLTHROUGH [[fallthrough]];
#else
#  error "C++17 or later compatible compiler is required"
#endif

#if defined(__has_cpp_attribute) && __has_cpp_attribute(gnu::cold)
#  define YS_COLD [[gnu::cold]]
#else
#  define YS_COLD
#endif

#include "kernel/io.h"

YOSYS_NAMESPACE_BEGIN

// Note: All headers included in hashlib.h must be included
// outside of YOSYS_NAMESPACE before this or bad things will happen.
#ifdef HASHLIB_H
#  error "You've probably included hashlib.h under two namespace paths. Bad idea."
#else
#  include "kernel/hashlib.h"
#  undef HASHLIB_H
#endif


using std::vector;
using std::string;
using std::tuple;
using std::pair;

using std::make_tuple;
using std::make_pair;
using std::get;
using std::min;
using std::max;

using hashlib::Hasher;
using hashlib::run_hash;
using hashlib::hash_ops;
using hashlib::mkhash_xorshift;
using hashlib::dict;
using hashlib::idict;
using hashlib::pool;
using hashlib::mfp;

// A primitive shared string implementation that does not
// move its .c_str() when the object is copied or moved.
struct shared_str {
	std::shared_ptr<string> content;
	shared_str() { }
	shared_str(string s) { content = std::shared_ptr<string>(new string(s)); }
	shared_str(const char *s) { content = std::shared_ptr<string>(new string(s)); }
	const char *c_str() const { return content->c_str(); }
	const string &str() const { return *content; }
	bool operator==(const shared_str &other) const { return *content == *other.content; }
	[[nodiscard]] Hasher hash_into(Hasher h) const {
		h.eat(*content);
		return h;
	}
};

namespace RTLIL {
	struct IdString;
	struct Const;
	struct SigBit;
	struct SigSpec;
	struct Wire;
	struct Cell;
	struct Memory;
	struct Process;
	struct Module;
	struct Design;
	struct Monitor;
    struct Selection;
	struct SigChunk;
	enum State : unsigned char;

	typedef std::pair<SigSpec, SigSpec> SigSig;

    namespace ID {}
}

namespace AST {
	struct AstNode;
}

using RTLIL::IdString;
using RTLIL::Const;
using RTLIL::SigBit;
using RTLIL::SigSpec;
using RTLIL::Wire;
using RTLIL::Cell;
using RTLIL::Module;
using RTLIL::Design;

using RTLIL::State;
using RTLIL::SigChunk;
using RTLIL::SigSig;

namespace hashlib {
	template<> struct hash_ops<RTLIL::Wire*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Cell*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Memory*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Process*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Module*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Design*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Monitor*> : hash_obj_ops {};
	template<> struct hash_ops<AST::AstNode*> : hash_obj_ops {};

	template<> struct hash_ops<const RTLIL::Wire*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Cell*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Memory*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Process*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Module*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Design*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Monitor*> : hash_obj_ops {};
	template<> struct hash_ops<const AST::AstNode*> : hash_obj_ops {};
}

void memhasher_on();
void memhasher_off();
void memhasher_do();

extern bool memhasher_active;
inline void memhasher() { if (memhasher_active) memhasher_do(); }

void yosys_banner();
int ceil_log2(int x) YS_ATTRIBUTE(const);

template<typename T> int GetSize(const T &obj) { return obj.size(); }
inline int GetSize(RTLIL::Wire *wire);

extern int autoidx;
extern int yosys_xtrace;
extern bool yosys_write_versions;

RTLIL::IdString new_id(std::string file, int line, std::string func);
RTLIL::IdString new_id_suffix(std::string file, int line, std::string func, std::string suffix);

#define NEW_ID \\
	YOSYS_NAMESPACE_PREFIX new_id(__FILE__, __LINE__, __FUNCTION__)
#define NEW_ID_SUFFIX(suffix) \\
	YOSYS_NAMESPACE_PREFIX new_id_suffix(__FILE__, __LINE__, __FUNCTION__, suffix)

// Create a statically allocated IdString object, using for example ID::A or ID($add).
//
// Recipe for Converting old code that is using conversion of strings like ID::A and
// "$add" for creating IdStrings: Run below SED command on the .cc file and then use for
// example "meld foo.cc foo.cc.orig" to manually compile errors, if necessary.
//
//  sed -i.orig -r 's/"\\\\\\\\([a-zA-Z0-9_]+)"/ID(\\1)/g; s/"(\\$[a-zA-Z0-9_]+)"/ID(\\1)/g;' <filename>
//
#define ID(_id) ([]() { const char *p = "\\\\" #_id, *q = p[1] == '$' ? p+1 : p; \\
        static const YOSYS_NAMESPACE_PREFIX RTLIL::IdString id(q); return id; })()
namespace ID = RTLIL::ID;


YOSYS_NAMESPACE_END

#endif
`,"yw.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef YW_H
#define YW_H

#include "kernel/yosys.h"
#include "kernel/mem.h"

YOSYS_NAMESPACE_BEGIN

struct IdPath : public std::vector<RTLIL::IdString>
{
	template<typename... T>
	IdPath(T&&... args) : std::vector<RTLIL::IdString>(std::forward<T>(args)...) { }
	IdPath prefix() const { return {begin(), end() - !empty()}; }
	std::string str() const;

	bool has_address() const { int tmp; return get_address(tmp); };
	bool get_address(int &addr) const;

	[[nodiscard]] Hasher hash_into(Hasher h) const {
		h.eat(static_cast<const std::vector<RTLIL::IdString>&&>(*this));
		return h;
	}
};

struct WitnessHierarchyItem {
	RTLIL::Module *module;
	RTLIL::Wire *wire = nullptr;
	RTLIL::Cell *cell = nullptr;
	Mem *mem = nullptr;

	WitnessHierarchyItem(RTLIL::Module *module, RTLIL::Wire *wire) : module(module), wire(wire) {}
	WitnessHierarchyItem(RTLIL::Module *module, RTLIL::Cell *cell) : module(module), cell(cell) {}
	WitnessHierarchyItem(RTLIL::Module *module, Mem *mem) : module(module), mem(mem) {}
};

template<typename D, typename T>
void witness_hierarchy(RTLIL::Module *module, D data, T callback);

template<class T> static std::vector<std::string> witness_path(T *obj) {
	std::vector<std::string> path;
	if (obj->name.isPublic()) {
		auto hdlname = obj->get_string_attribute(ID::hdlname);
		for (auto token : split_tokens(hdlname))
			path.push_back("\\\\" + token);
	}
	if (path.empty())
		path.push_back(obj->name.str());
	return path;
}

struct ReadWitness
{
	struct Clock {
		IdPath path;
		int offset;
		bool is_posedge = false;
		bool is_negedge = false;
	};

	struct Signal {
		IdPath path;
		int offset;
		int width;
		bool init_only;

		int bits_offset;
	};

	struct Step {
		std::string bits;
	};

	std::string filename;
	std::vector<Clock> clocks;
	std::vector<Signal> signals;
	std::vector<Step> steps;

	ReadWitness(const std::string &filename);

	RTLIL::Const get_bits(int t, int bits_offset, int width) const;
};

template<typename D, typename T>
void witness_hierarchy_recursion(IdPath &path, int hdlname_mode, RTLIL::Module *module, D data, T &callback)
{
	auto const &const_path = path;
	size_t path_size = path.size();
	for (auto wire : module->wires())
	{
		auto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : wire->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == wire->name)
			hdlname.clear();
		if (!hdlname.empty())
			callback(const_path, WitnessHierarchyItem(module, wire), data);
		path.resize(path_size);
		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(wire->name);
			callback(const_path, WitnessHierarchyItem(module, wire), data);
			path.pop_back();
		}
	}

	for (auto cell : module->cells())
	{
		Module *child = module->design->module(cell->type);
		if (child == nullptr)
			continue;

		auto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : cell->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == cell->name)
			hdlname.clear();
		if (!hdlname.empty()) {
			D child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);
			witness_hierarchy_recursion<D, T>(path, 1, child, child_data, callback);
		}
		path.resize(path_size);
		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(cell->name);
			D child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);
			witness_hierarchy_recursion<D, T>(path, hdlname.empty() ? hdlname_mode : -1, child, child_data, callback);
			path.pop_back();
		}
	}

	for (auto mem : Mem::get_all_memories(module)) {
		std::vector<std::string> hdlname;

		if (hdlname_mode >= 0 && mem.cell != nullptr)
			hdlname = mem.cell->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == mem.cell->name)
			hdlname.clear();
		if (!hdlname.empty()) {
			callback(const_path, WitnessHierarchyItem(module, &mem), data);
		}
		path.resize(path_size);

		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(mem.memid);
			callback(const_path, WitnessHierarchyItem(module, &mem), data);
			path.pop_back();

			if (mem.cell != nullptr && mem.cell->name != mem.memid) {
				path.push_back(mem.cell->name);
				callback(const_path, WitnessHierarchyItem(module, &mem), data);
				path.pop_back();
			}
		}
	}
}

template<typename D, typename T>
void witness_hierarchy(RTLIL::Module *module, D data, T callback)
{
	IdPath path;
	witness_hierarchy_recursion<D, T>(path, 0, module, data, callback);
}

YOSYS_NAMESPACE_END

#endif
`},libs:{ezsat:{"ezminisat.h":`/*
 *  ezSAT -- A simple and easy to use CNF generator for SAT solvers
 *
 *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef EZMINISAT_H
#define EZMINISAT_H

#define EZMINISAT_SIMPSOLVER 1
#define EZMINISAT_VERBOSITY 0
#define EZMINISAT_INCREMENTAL 1

#include "ezsat.h"
#include <time.h>

// minisat is using limit macros and format macros in their headers that
// can be the source of some troubles when used from c++11. therefore we
// don't force ezSAT users to use minisat headers..
namespace Minisat {
	class Solver;
	class SimpSolver;
}

class ezMiniSAT : public ezSAT
{
private:
#if EZMINISAT_SIMPSOLVER
	typedef Minisat::SimpSolver Solver;
#else
	typedef Minisat::Solver Solver;
#endif
	Solver *minisatSolver;
	std::vector<int> minisatVars;
	bool foundContradiction;

#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL
	std::set<int> cnfFrozenVars;
#endif

#ifndef _WIN32
	static ezMiniSAT *alarmHandlerThis;
	static clock_t alarmHandlerTimeout;
	static void alarmHandler(int);
#endif

public:
	ezMiniSAT();
	virtual ~ezMiniSAT();
	virtual void clear();
#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL
	virtual void freeze(int id);
	virtual bool eliminated(int idx);
#endif
	virtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);
};

#endif
`,"ezsat.h":`/*
 *  ezSAT -- A simple and easy to use CNF generator for SAT solvers
 *
 *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef EZSAT_H
#define EZSAT_H

#include <set>
#include <map>
#include <vector>
#include <string>
#include <stdio.h>
#include <stdint.h>

class ezSAT
{
	// each token (terminal or non-terminal) is represented by an integer number
	//
	// the zero token:
	// the number zero is not used as valid token number and is used to encode
	// unused parameters for the functions.
	//
	// positive numbers are literals, with 1 = CONST_TRUE and 2 = CONST_FALSE;
	//
	// negative numbers are non-literal expressions. each expression is represented
	// by an operator id and a list of expressions (literals or non-literals).

public:
	enum OpId {
		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE
	};

	static const int CONST_TRUE;
	static const int CONST_FALSE;

private:
	bool flag_keep_cnf;
	bool flag_non_incremental;

	bool non_incremental_solve_used_up;

	std::map<std::string, int> literalsCache;
	std::vector<std::string> literals;

	std::map<std::pair<OpId, std::vector<int>>, int> expressionsCache;
	std::vector<std::pair<OpId, std::vector<int>>> expressions;

	bool cnfConsumed;
	int cnfVariableCount, cnfClausesCount;
	std::vector<int> cnfLiteralVariables, cnfExpressionVariables;
	std::vector<std::vector<int>> cnfClauses, cnfClausesBackup;

	void add_clause(const std::vector<int> &args);
	void add_clause(const std::vector<int> &args, bool argsPolarity, int a = 0, int b = 0, int c = 0);
	void add_clause(int a, int b = 0, int c = 0);

	int bind_cnf_not(const std::vector<int> &args);
	int bind_cnf_and(const std::vector<int> &args);
	int bind_cnf_or(const std::vector<int> &args);

protected:
	void preSolverCallback();

public:
	int solverTimeout;
	bool solverTimoutStatus;

	ezSAT();
	virtual ~ezSAT();

	unsigned int statehash;
	void addhash(unsigned int);

	void keep_cnf() { flag_keep_cnf = true; }
	void non_incremental() { flag_non_incremental = true; }

	bool mode_keep_cnf() const { return flag_keep_cnf; }
	bool mode_non_incremental() const { return flag_non_incremental; }

	// manage expressions

	int value(bool val);
	int literal();
	int literal(const std::string &name);
	int frozen_literal();
	int frozen_literal(const std::string &name);
	int expression(OpId op, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0);
	int expression(OpId op, const std::vector<int> &args);

	void lookup_literal(int id, std::string &name) const;
	const std::string &lookup_literal(int id) const;

	void lookup_expression(int id, OpId &op, std::vector<int> &args) const;
	const std::vector<int> &lookup_expression(int id, OpId &op) const;

	int parse_string(const std::string &text);
	std::string to_string(int id) const;

	int numLiterals() const { return literals.size(); }
	int numExpressions() const { return expressions.size(); }

	int eval(int id, const std::vector<int> &values) const;

	// SAT solver interface
	// If you are planning on using the solver API (and not simply create a CNF) you must use a child class
	// of ezSAT that actually implements a solver backend, such as ezMiniSAT (see ezminisat.h).

	virtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);

	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions) {
		return solver(modelExpressions, modelValues, assumptions);
	}

	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {
		std::vector<int> assumptions;
		if (a != 0) assumptions.push_back(a);
		if (b != 0) assumptions.push_back(b);
		if (c != 0) assumptions.push_back(c);
		if (d != 0) assumptions.push_back(d);
		if (e != 0) assumptions.push_back(e);
		if (f != 0) assumptions.push_back(f);
		return solver(modelExpressions, modelValues, assumptions);
	}

	bool solve(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {
		std::vector<int> assumptions, modelExpressions;
		std::vector<bool> modelValues;
		if (a != 0) assumptions.push_back(a);
		if (b != 0) assumptions.push_back(b);
		if (c != 0) assumptions.push_back(c);
		if (d != 0) assumptions.push_back(d);
		if (e != 0) assumptions.push_back(e);
		if (f != 0) assumptions.push_back(f);
		return solver(modelExpressions, modelValues, assumptions);
	}

	void setSolverTimeout(int newTimeoutSeconds) {
		solverTimeout = newTimeoutSeconds;
	}

	bool getSolverTimoutStatus() {
		return solverTimoutStatus;
	}

	// manage CNF (usually only accessed by SAT solvers)

	virtual void clear();
	virtual void freeze(int id);
	virtual bool eliminated(int idx);
	void assume(int id);
	void assume(int id, int context_id) { assume(OR(id, NOT(context_id))); }
	int bind(int id, bool auto_freeze = true);
	int bound(int id) const;

	int numCnfVariables() const { return cnfVariableCount; }
	int numCnfClauses() const { return cnfClausesCount; }
	const std::vector<std::vector<int>> &cnf() const { return cnfClauses; }

	void consumeCnf();
	void consumeCnf(std::vector<std::vector<int>> &cnf);

	// use this function to get the full CNF in keep_cnf mode
	void getFullCnf(std::vector<std::vector<int>> &full_cnf) const;

	std::string cnfLiteralInfo(int idx) const;

	// simple helpers for build expressions easily

	struct _V {
		int id;
		std::string name;
		_V(int id) : id(id) { }
		_V(const char *name) : id(0), name(name) { }
		_V(const std::string &name) : id(0), name(name) { }
		int get(ezSAT *that) {
			if (name.empty())
				return id;
			return that->frozen_literal(name);
		}
	};

	int VAR(_V a) {
		return a.get(this);
	}

	int NOT(_V a) {
		return expression(OpNot, a.get(this));
	}

	int AND(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpAnd, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int OR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpOr, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int XOR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpXor, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int IFF(_V a, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpIFF, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int ITE(_V a, _V b, _V c) {
		return expression(OpITE, a.get(this), b.get(this), c.get(this));
	}

	void SET(_V a, _V b) {
		assume(IFF(a.get(this), b.get(this)));
	}

	// simple helpers for building expressions with bit vectors

	std::vector<int> vec_const(const std::vector<bool> &bits);
	std::vector<int> vec_const_signed(int64_t value, int numBits);
	std::vector<int> vec_const_unsigned(uint64_t value, int numBits);
	std::vector<int> vec_var(int numBits);
	std::vector<int> vec_var(std::string name, int numBits);
	std::vector<int> vec_cast(const std::vector<int> &vec1, int toBits, bool signExtend = false);

	std::vector<int> vec_not(const std::vector<int> &vec1);
	std::vector<int> vec_and(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_or(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_xor(const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_iff(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_ite(const std::vector<int> &vec1, const std::vector<int> &vec2, const std::vector<int> &vec3);
	std::vector<int> vec_ite(int sel, const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_count(const std::vector<int> &vec, int numBits, bool clip = true);
	std::vector<int> vec_add(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_sub(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_neg(const std::vector<int> &vec);

	void vec_cmp(const std::vector<int> &vec1, const std::vector<int> &vec2, int &carry, int &overflow, int &sign, int &zero);

	int vec_lt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_le_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ge_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_gt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);

	int vec_lt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_le_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ge_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_gt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);

	int vec_eq(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ne(const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_shl(const std::vector<int> &vec1, int shift, bool signExtend = false);
	std::vector<int> vec_srl(const std::vector<int> &vec1, int shift);

	std::vector<int> vec_shr(const std::vector<int> &vec1, int shift, bool signExtend = false) { return vec_shl(vec1, -shift, signExtend); }
	std::vector<int> vec_srr(const std::vector<int> &vec1, int shift) { return vec_srl(vec1, -shift); }

	std::vector<int> vec_shift(const std::vector<int> &vec1, int shift, int extend_left, int extend_right);
	std::vector<int> vec_shift_right(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);
	std::vector<int> vec_shift_left(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);

	void vec_append(std::vector<int> &vec, const std::vector<int> &vec1) const;
	void vec_append_signed(std::vector<int> &vec, const std::vector<int> &vec1, int64_t value);
	void vec_append_unsigned(std::vector<int> &vec, const std::vector<int> &vec1, uint64_t value);

	int64_t vec_model_get_signed(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;
	uint64_t vec_model_get_unsigned(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;

	int vec_reduce_and(const std::vector<int> &vec1);
	int vec_reduce_or(const std::vector<int> &vec1);

	void vec_set(const std::vector<int> &vec1, const std::vector<int> &vec2);
	void vec_set_signed(const std::vector<int> &vec1, int64_t value);
	void vec_set_unsigned(const std::vector<int> &vec1, uint64_t value);

	// helpers for generating ezSATbit and ezSATvec objects

	struct ezSATbit bit(_V a);
	struct ezSATvec vec(const std::vector<int> &vec);

	// printing CNF and internal state

	void printDIMACS(FILE *f, bool verbose = false) const;
	void printInternalState(FILE *f) const;

	// more sophisticated constraints (designed to be used directly with assume(..))

	int onehot(const std::vector<int> &vec, bool max_only = false);
	int manyhot(const std::vector<int> &vec, int min_hot, int max_hot = -1);
	int ordered(const std::vector<int> &vec1, const std::vector<int> &vec2, bool allow_equal = true);
};

// helper classes for using operator overloading when generating complex expressions

struct ezSATbit
{
	ezSAT &sat;
	int id;

	ezSATbit(ezSAT &sat, ezSAT::_V a) : sat(sat), id(sat.VAR(a)) { }

	ezSATbit operator ~() { return ezSATbit(sat, sat.NOT(id)); }
	ezSATbit operator &(const ezSATbit &other) { return ezSATbit(sat, sat.AND(id, other.id)); }
	ezSATbit operator |(const ezSATbit &other) { return ezSATbit(sat, sat.OR(id, other.id)); }
	ezSATbit operator ^(const ezSATbit &other) { return ezSATbit(sat, sat.XOR(id, other.id)); }
	ezSATbit operator ==(const ezSATbit &other) { return ezSATbit(sat, sat.IFF(id, other.id)); }
	ezSATbit operator !=(const ezSATbit &other) { return ezSATbit(sat, sat.NOT(sat.IFF(id, other.id))); }

	operator int() const { return id; }
	operator ezSAT::_V() const { return ezSAT::_V(id); }
	operator std::vector<int>() const { return std::vector<int>(1, id); }
};

struct ezSATvec
{
	ezSAT &sat;
	std::vector<int> vec;

	ezSATvec(ezSAT &sat, const std::vector<int> &vec) : sat(sat), vec(vec) { }

	ezSATvec operator ~() { return ezSATvec(sat, sat.vec_not(vec)); }
	ezSATvec operator -() { return ezSATvec(sat, sat.vec_neg(vec)); }

	ezSATvec operator &(const ezSATvec &other) { return ezSATvec(sat, sat.vec_and(vec, other.vec)); }
	ezSATvec operator |(const ezSATvec &other) { return ezSATvec(sat, sat.vec_or(vec, other.vec)); }
	ezSATvec operator ^(const ezSATvec &other) { return ezSATvec(sat, sat.vec_xor(vec, other.vec)); }

	ezSATvec operator +(const ezSATvec &other) { return ezSATvec(sat, sat.vec_add(vec, other.vec)); }
	ezSATvec operator -(const ezSATvec &other) { return ezSATvec(sat, sat.vec_sub(vec, other.vec)); }

	ezSATbit operator < (const ezSATvec &other) { return ezSATbit(sat, sat.vec_lt_unsigned(vec, other.vec)); }
	ezSATbit operator <=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_le_unsigned(vec, other.vec)); }
	ezSATbit operator ==(const ezSATvec &other) { return ezSATbit(sat, sat.vec_eq(vec, other.vec)); }
	ezSATbit operator !=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ne(vec, other.vec)); }
	ezSATbit operator >=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ge_unsigned(vec, other.vec)); }
	ezSATbit operator > (const ezSATvec &other) { return ezSATbit(sat, sat.vec_gt_unsigned(vec, other.vec)); }

	ezSATvec operator <<(int shift) { return ezSATvec(sat, sat.vec_shl(vec, shift)); }
	ezSATvec operator >>(int shift) { return ezSATvec(sat, sat.vec_shr(vec, shift)); }

	operator std::vector<int>() const { return vec; }
};

#endif
`},json11:{"json11.hpp":`/* json11
 *
 * json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.
 *
 * The core object provided by the library is json11::Json. A Json object represents any JSON
 * value: null, bool, number (int or double), string (std::string), array (std::vector), or
 * object (std::map).
 *
 * Json objects act like values: they can be assigned, copied, moved, compared for equality or
 * order, etc. There are also helper methods Json::dump, to serialize a Json to a string, and
 * Json::parse (static) to parse a std::string as a Json object.
 *
 * Internally, the various types of Json object are represented by the JsonValue class
 * hierarchy.
 *
 * A note on numbers - JSON specifies the syntax of number formatting but not its semantics,
 * so some JSON implementations distinguish between integers and floating-point numbers, while
 * some don't. In json11, we choose the latter. Because some JSON implementations (namely
 * Javascript itself) treat all numbers as the same type, distinguishing the two leads
 * to JSON that will be *silently* changed by a round-trip through those implementations.
 * Dangerous! To avoid that risk, json11 stores all numbers as double internally, but also
 * provides integer helpers.
 *
 * Fortunately, double-precision IEEE754 ('double') can precisely store any integer in the
 * range +/-2^53, which includes every 'int' on most systems. (Timestamps often use int64
 * or long long to avoid the Y2038K problem; a double storing microseconds since some epoch
 * will be exact for +/- 275 years.)
 */

/* Copyright (c) 2013 Dropbox, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <initializer_list>

#ifdef _MSC_VER
    #if _MSC_VER <= 1800 // VS 2013
        #ifndef noexcept
            #define noexcept throw()
        #endif

        #ifndef snprintf
            #define snprintf _snprintf_s
        #endif
    #endif
#endif

namespace json11 {

enum JsonParse {
    STANDARD, COMMENTS
};

class JsonValue;

class Json final {
public:
    // Types
    enum Type {
        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT
    };

    // Array and object typedefs
    typedef std::vector<Json> array;
    typedef std::map<std::string, Json> object;

    // Constructors for the various types of JSON value.
    Json() noexcept;                // NUL
    Json(std::nullptr_t) noexcept;  // NUL
    Json(double value);             // NUMBER
    Json(int value);                // NUMBER
    Json(bool value);               // BOOL
    Json(const std::string &value); // STRING
    Json(std::string &&value);      // STRING
    Json(const char * value);       // STRING
    Json(const array &values);      // ARRAY
    Json(array &&values);           // ARRAY
    Json(const object &values);     // OBJECT
    Json(object &&values);          // OBJECT

    // Implicit constructor: anything with a to_json() function.
    template <class T, class = decltype(&T::to_json)>
    Json(const T & t) : Json(t.to_json()) {}

    // Implicit constructor: map-like objects (std::map, std::unordered_map, etc)
    template <class M, typename std::enable_if<
        std::is_constructible<std::string, decltype(std::declval<M>().begin()->first)>::value
        && std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,
            int>::type = 0>
    Json(const M & m) : Json(object(m.begin(), m.end())) {}

    // Implicit constructor: vector-like objects (std::list, std::vector, std::set, etc)
    template <class V, typename std::enable_if<
        std::is_constructible<Json, decltype(*std::declval<V>().begin())>::value,
            int>::type = 0>
    Json(const V & v) : Json(array(v.begin(), v.end())) {}

    // This prevents Json(some_pointer) from accidentally producing a bool. Use
    // Json(bool(some_pointer)) if that behavior is desired.
    Json(void *) = delete;

    // Accessors
    Type type() const;

    bool is_null()   const { return type() == NUL; }
    bool is_number() const { return type() == NUMBER; }
    bool is_bool()   const { return type() == BOOL; }
    bool is_string() const { return type() == STRING; }
    bool is_array()  const { return type() == ARRAY; }
    bool is_object() const { return type() == OBJECT; }

    // Return the enclosed value if this is a number, 0 otherwise. Note that json11 does not
    // distinguish between integer and non-integer numbers - number_value() and int_value()
    // can both be applied to a NUMBER-typed object.
    double number_value() const;
    int int_value() const;

    // Return the enclosed value if this is a boolean, false otherwise.
    bool bool_value() const;
    // Return the enclosed string if this is a string, "" otherwise.
    const std::string &string_value() const;
    // Return the enclosed std::vector if this is an array, or an empty vector otherwise.
    const array &array_items() const;
    // Return the enclosed std::map if this is an object, or an empty map otherwise.
    const object &object_items() const;

    // Return a reference to arr[i] if this is an array, Json() otherwise.
    const Json & operator[](size_t i) const;
    // Return a reference to obj[key] if this is an object, Json() otherwise.
    const Json & operator[](const std::string &key) const;

    // Serialize.
    void dump(std::string &out) const;
    std::string dump() const {
        std::string out;
        dump(out);
        return out;
    }

    // Parse. If parse fails, return Json() and assign an error message to err.
    static Json parse(const std::string & in,
                      std::string & err,
                      JsonParse strategy = JsonParse::STANDARD);
    static Json parse(const char * in,
                      std::string & err,
                      JsonParse strategy = JsonParse::STANDARD) {
        if (in) {
            return parse(std::string(in), err, strategy);
        } else {
            err = "null input";
            return nullptr;
        }
    }
    // Parse multiple objects, concatenated or separated by whitespace
    static std::vector<Json> parse_multi(
        const std::string & in,
        std::string::size_type & parser_stop_pos,
        std::string & err,
        JsonParse strategy = JsonParse::STANDARD);

    static inline std::vector<Json> parse_multi(
        const std::string & in,
        std::string & err,
        JsonParse strategy = JsonParse::STANDARD) {
        std::string::size_type parser_stop_pos;
        return parse_multi(in, parser_stop_pos, err, strategy);
    }

    bool operator== (const Json &rhs) const;
    bool operator<  (const Json &rhs) const;
    bool operator!= (const Json &rhs) const { return !(*this == rhs); }
    bool operator<= (const Json &rhs) const { return !(rhs < *this); }
    bool operator>  (const Json &rhs) const { return  (rhs < *this); }
    bool operator>= (const Json &rhs) const { return !(*this < rhs); }

    /* has_shape(types, err)
     *
     * Return true if this is a JSON object and, for each item in types, has a field of
     * the given type. If not, return false and set err to a descriptive message.
     */
    typedef std::initializer_list<std::pair<std::string, Type>> shape;
    bool has_shape(const shape & types, std::string & err) const;

private:
    std::shared_ptr<JsonValue> m_ptr;
};

// Internal class hierarchy - JsonValue objects are not exposed to users of this API.
class JsonValue {
protected:
    friend class Json;
    friend class JsonInt;
    friend class JsonDouble;
    virtual Json::Type type() const = 0;
    virtual bool equals(const JsonValue * other) const = 0;
    virtual bool less(const JsonValue * other) const = 0;
    virtual void dump(std::string &out) const = 0;
    virtual double number_value() const;
    virtual int int_value() const;
    virtual bool bool_value() const;
    virtual const std::string &string_value() const;
    virtual const Json::array &array_items() const;
    virtual const Json &operator[](size_t i) const;
    virtual const Json::object &object_items() const;
    virtual const Json &operator[](const std::string &key) const;
    virtual ~JsonValue() {}
};

} // namespace json11
`},sha1:{"sha1.h":`/*
    sha1.h - header of

    ============
    SHA-1 in C++
    ============

    100% Public Domain.

    Original C Code
        -- Steve Reid <steve@edmweb.com>
    Small changes to fit into bglibs
        -- Bruce Guenter <bruce@untroubled.org>
    Translation to simpler C++ Code
        -- Volker Grabsch <vog@notjusthosting.com>
    Fixing bugs and improving style
        -- Eugene Hopkinson <slowriot at voxelstorm dot com>
*/

#ifndef SHA1_HPP
#define SHA1_HPP


#include <iostream>
#include <string>
#include <stdint.h>

class SHA1
{
public:
    SHA1();
    void update(const std::string &s);
    void update(std::istream &is);
    std::string final();
    static std::string from_file(const std::string &filename);

private:
    static constexpr unsigned int DIGEST_INTS = 5;  /* number of 32bit integers per SHA1 digest */
    static constexpr unsigned int BLOCK_INTS = 16;  /* number of 32bit integers per SHA1 block */
    static constexpr unsigned int BLOCK_BYTES = BLOCK_INTS * 4;

    uint32_t digest[DIGEST_INTS];
    std::string buffer;
    uint64_t transforms;

    void reset();
    void transform(uint32_t block[BLOCK_BYTES]);

    static void read(std::istream &is, std::string &s, size_t max);
    static void buffer_to_block(const std::string &buffer, uint32_t block[BLOCK_INTS]);
};

std::string sha1(const std::string &string);



#endif /* SHA1_HPP */
`}},passes:{fsm:{"fsmdata.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FSMDATA_H
#define FSMDATA_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct FsmData
{
	int num_inputs, num_outputs, state_bits, reset_state;
	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };
	std::vector<transition_t> transition_table;
	std::vector<RTLIL::Const> state_table;

	void copy_to_cell(RTLIL::Cell *cell)
	{
		cell->parameters[ID::CTRL_IN_WIDTH] = RTLIL::Const(num_inputs);
		cell->parameters[ID::CTRL_OUT_WIDTH] = RTLIL::Const(num_outputs);

		int state_num_log2 = 0;
		for (int i = state_table.size(); i > 0; i = i >> 1)
			state_num_log2++;
		state_num_log2 = max(state_num_log2, 1);

		cell->parameters[ID::STATE_BITS] = RTLIL::Const(state_bits);
		cell->parameters[ID::STATE_NUM] = RTLIL::Const(state_table.size());
		cell->parameters[ID::STATE_NUM_LOG2] = RTLIL::Const(state_num_log2);
		cell->parameters[ID::STATE_RST] = RTLIL::Const(reset_state);
		cell->parameters[ID::STATE_TABLE] = RTLIL::Const();

		for (int i = 0; i < int(state_table.size()); i++) {
			std::vector<RTLIL::State> &bits_table = cell->parameters[ID::STATE_TABLE].bits();
			std::vector<RTLIL::State> &bits_state = state_table[i].bits();
			bits_table.insert(bits_table.end(), bits_state.begin(), bits_state.end());
		}

		cell->parameters[ID::TRANS_NUM] = RTLIL::Const(transition_table.size());
		cell->parameters[ID::TRANS_TABLE] = RTLIL::Const();
		for (int i = 0; i < int(transition_table.size()); i++)
		{
			std::vector<RTLIL::State> &bits_table = cell->parameters[ID::TRANS_TABLE].bits();
			transition_t &tr = transition_table[i];

			RTLIL::Const const_state_in = RTLIL::Const(tr.state_in, state_num_log2);
			RTLIL::Const const_state_out = RTLIL::Const(tr.state_out, state_num_log2);
			std::vector<RTLIL::State> &bits_state_in = const_state_in.bits();
			std::vector<RTLIL::State> &bits_state_out = const_state_out.bits();

			std::vector<RTLIL::State> &bits_ctrl_in = tr.ctrl_in.bits();
			std::vector<RTLIL::State> &bits_ctrl_out = tr.ctrl_out.bits();

			// append lsb first
			bits_table.insert(bits_table.end(), bits_ctrl_out.begin(), bits_ctrl_out.end());
			bits_table.insert(bits_table.end(), bits_state_out.begin(), bits_state_out.end());
			bits_table.insert(bits_table.end(), bits_ctrl_in.begin(), bits_ctrl_in.end());
			bits_table.insert(bits_table.end(), bits_state_in.begin(), bits_state_in.end());
		}
	}

	void copy_from_cell(RTLIL::Cell *cell)
	{
		num_inputs = cell->parameters[ID::CTRL_IN_WIDTH].as_int();
		num_outputs = cell->parameters[ID::CTRL_OUT_WIDTH].as_int();

		state_bits = cell->parameters[ID::STATE_BITS].as_int();
		reset_state = cell->parameters[ID::STATE_RST].as_int();

		int state_num = cell->parameters[ID::STATE_NUM].as_int();
		int state_num_log2 = cell->parameters[ID::STATE_NUM_LOG2].as_int();
		int trans_num = cell->parameters[ID::TRANS_NUM].as_int();

		if (reset_state < 0 || reset_state >= state_num)
			reset_state = -1;

		const RTLIL::Const &state_table = cell->parameters[ID::STATE_TABLE];
		const RTLIL::Const &trans_table = cell->parameters[ID::TRANS_TABLE];

		for (int i = 0; i < state_num; i++) {
			RTLIL::Const state_code;
			int off_begin = i*state_bits, off_end = off_begin + state_bits;
			state_code.bits().insert(state_code.bits().begin(), state_table.begin()+off_begin, state_table.begin()+off_end);
			this->state_table.push_back(state_code);
		}

		for (int i = 0; i < trans_num; i++)
		{
			auto off_ctrl_out = trans_table.begin() + i*(num_inputs+num_outputs+2*state_num_log2);
			auto off_state_out = off_ctrl_out + num_outputs;
			auto off_ctrl_in = off_state_out + state_num_log2;
			auto off_state_in = off_ctrl_in + num_inputs;
			auto off_end = off_state_in + state_num_log2;

			RTLIL::Const state_in, state_out, ctrl_in, ctrl_out;
			ctrl_out.bits().insert(ctrl_out.bits().begin(), off_ctrl_out, off_state_out);
			state_out.bits().insert(state_out.bits().begin(), off_state_out, off_ctrl_in);
			ctrl_in.bits().insert(ctrl_in.bits().begin(), off_ctrl_in, off_state_in);
			state_in.bits().insert(state_in.bits().begin(), off_state_in, off_end);

			transition_t tr;
			tr.state_in = state_in.as_int();
			tr.state_out = state_out.as_int();
			tr.ctrl_in = ctrl_in;
			tr.ctrl_out = ctrl_out;

			if (tr.state_in < 0 || tr.state_in >= state_num)
				tr.state_in = -1;
			if (tr.state_out < 0 || tr.state_out >= state_num)
				tr.state_out = -1;

			transition_table.push_back(tr);
		}
	}

	void log_info(RTLIL::Cell *cell)
	{
		log("-------------------------------------\\n");
		log("\\n");
		log("  Information on FSM %s (%s):\\n", cell->name.c_str(), cell->parameters[ID::NAME].decode_string().c_str());
		log("\\n");
		log("  Number of input signals:  %3d\\n", num_inputs);
		log("  Number of output signals: %3d\\n", num_outputs);
		log("  Number of state bits:     %3d\\n", state_bits);

		log("\\n");
		log("  Input signals:\\n");
		RTLIL::SigSpec sig_in = cell->getPort(ID::CTRL_IN);
		for (int i = 0; i < GetSize(sig_in); i++)
			log("  %3d: %s\\n", i, log_signal(sig_in[i]));

		log("\\n");
		log("  Output signals:\\n");
		RTLIL::SigSpec sig_out = cell->getPort(ID::CTRL_OUT);
		for (int i = 0; i < GetSize(sig_out); i++)
			log("  %3d: %s\\n", i, log_signal(sig_out[i]));

		log("\\n");
		log("  State encoding:\\n");
		for (int i = 0; i < GetSize(state_table); i++)
			log("  %3d: %10s%s\\n", i, log_signal(state_table[i], false),
					int(i) == reset_state ? "  <RESET STATE>" : "");

		log("\\n");
		log("  Transition Table (state_in, ctrl_in, state_out, ctrl_out):\\n");
		for (int i = 0; i < GetSize(transition_table); i++) {
			transition_t &tr = transition_table[i];
			log("  %5d: %5d %s   -> %5d %s\\n", i, tr.state_in, log_signal(tr.ctrl_in), tr.state_out, log_signal(tr.ctrl_out));
		}

		log("\\n");
		log("-------------------------------------\\n");
	}

	// implemented in fsm_opt.cc
	static void optimize_fsm(RTLIL::Cell *cell, RTLIL::Module *module);
};

YOSYS_NAMESPACE_END

#endif
`}}},intel:{common:{"altpll_bb.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/* No clearbox model */
\`ifdef NO_CLEARBOX
(* blackbox *)
module altpll
  ( inclk,
    fbin,
    pllena,
    clkswitch,
    areset,
    pfdena,
    clkena,
    extclkena,
    scanclk,
    scanaclr,
    scanclkena,
    scanread,
    scanwrite,
    scandata,
    phasecounterselect,
    phaseupdown,
    phasestep,
    configupdate,
    fbmimicbidir,
    clk,
    extclk,
    clkbad,
    enable0,
    enable1,
    activeclock,
    clkloss,
    locked,
    scandataout,
    scandone,
    sclkout0,
    sclkout1,
    phasedone,
    vcooverrange,
    vcounderrange,
    fbout,
    fref,
    icdrclk,
    c0,
    c1,
    c2,
    c3,
    c4);

   parameter   intended_device_family    = "MAX 10";
   parameter   operation_mode            = "NORMAL";
   parameter   pll_type                  = "AUTO";
   parameter   qualify_conf_done         = "OFF";
   parameter   compensate_clock          = "CLK0";
   parameter   scan_chain                = "LONG";
   parameter   primary_clock             = "inclk0";
   parameter   inclk0_input_frequency    = 1000;
   parameter   inclk1_input_frequency    = 0;
   parameter   gate_lock_signal          = "NO";
   parameter   gate_lock_counter         = 0;
   parameter   lock_high                 = 1;
   parameter   lock_low                  = 0;
   parameter   valid_lock_multiplier     = 1;
   parameter   invalid_lock_multiplier   = 5;
   parameter   switch_over_type          = "AUTO";
   parameter   switch_over_on_lossclk    = "OFF" ;
   parameter   switch_over_on_gated_lock = "OFF" ;
   parameter   enable_switch_over_counter = "OFF";
   parameter   switch_over_counter       = 0;
   parameter   feedback_source           = "EXTCLK0" ;
   parameter   bandwidth                 = 0;
   parameter   bandwidth_type            = "UNUSED";
   parameter   lpm_hint                  = "UNUSED";
   parameter   spread_frequency          = 0;
   parameter   down_spread               = "0.0";
   parameter   self_reset_on_gated_loss_lock = "OFF";
   parameter   self_reset_on_loss_lock = "OFF";
   parameter   lock_window_ui           = "0.05";
   parameter   width_clock              = 6;
   parameter   width_phasecounterselect = 4;
   parameter   charge_pump_current_bits = 9999;
   parameter   loop_filter_c_bits = 9999;
   parameter   loop_filter_r_bits = 9999;
   parameter   scan_chain_mif_file = "UNUSED";
   parameter   clk9_multiply_by        = 1;
   parameter   clk8_multiply_by        = 1;
   parameter   clk7_multiply_by        = 1;
   parameter   clk6_multiply_by        = 1;
   parameter   clk5_multiply_by        = 1;
   parameter   clk4_multiply_by        = 1;
   parameter   clk3_multiply_by        = 1;
   parameter   clk2_multiply_by        = 1;
   parameter   clk1_multiply_by        = 1;
   parameter   clk0_multiply_by        = 1;
   parameter   clk9_divide_by          = 1;
   parameter   clk8_divide_by          = 1;
   parameter   clk7_divide_by          = 1;
   parameter   clk6_divide_by          = 1;
   parameter   clk5_divide_by          = 1;
   parameter   clk4_divide_by          = 1;
   parameter   clk3_divide_by          = 1;
   parameter   clk2_divide_by          = 1;
   parameter   clk1_divide_by          = 1;
   parameter   clk0_divide_by          = 1;
   parameter   clk9_phase_shift        = "0";
   parameter   clk8_phase_shift        = "0";
   parameter   clk7_phase_shift        = "0";
   parameter   clk6_phase_shift        = "0";
   parameter   clk5_phase_shift        = "0";
   parameter   clk4_phase_shift        = "0";
   parameter   clk3_phase_shift        = "0";
   parameter   clk2_phase_shift        = "0";
   parameter   clk1_phase_shift        = "0";
   parameter   clk0_phase_shift        = "0";

   parameter   clk9_duty_cycle         = 50;
   parameter   clk8_duty_cycle         = 50;
   parameter   clk7_duty_cycle         = 50;
   parameter   clk6_duty_cycle         = 50;
   parameter   clk5_duty_cycle         = 50;
   parameter   clk4_duty_cycle         = 50;
   parameter   clk3_duty_cycle         = 50;
   parameter   clk2_duty_cycle         = 50;
   parameter   clk1_duty_cycle         = 50;
   parameter   clk0_duty_cycle         = 50;

   parameter   clk9_use_even_counter_mode    = "OFF";
   parameter   clk8_use_even_counter_mode    = "OFF";
   parameter   clk7_use_even_counter_mode    = "OFF";
   parameter   clk6_use_even_counter_mode    = "OFF";
   parameter   clk5_use_even_counter_mode    = "OFF";
   parameter   clk4_use_even_counter_mode    = "OFF";
   parameter   clk3_use_even_counter_mode    = "OFF";
   parameter   clk2_use_even_counter_mode    = "OFF";
   parameter   clk1_use_even_counter_mode    = "OFF";
   parameter   clk0_use_even_counter_mode    = "OFF";
   parameter   clk9_use_even_counter_value   = "OFF";
   parameter   clk8_use_even_counter_value   = "OFF";
   parameter   clk7_use_even_counter_value   = "OFF";
   parameter   clk6_use_even_counter_value   = "OFF";
   parameter   clk5_use_even_counter_value   = "OFF";
   parameter   clk4_use_even_counter_value   = "OFF";
   parameter   clk3_use_even_counter_value   = "OFF";
   parameter   clk2_use_even_counter_value   = "OFF";
   parameter   clk1_use_even_counter_value   = "OFF";
   parameter   clk0_use_even_counter_value   = "OFF";

   parameter   clk2_output_frequency   = 0;
   parameter   clk1_output_frequency   = 0;
   parameter   clk0_output_frequency   = 0;

   parameter   vco_min             = 0;
   parameter   vco_max             = 0;
   parameter   vco_center          = 0;
   parameter   pfd_min             = 0;
   parameter   pfd_max             = 0;
   parameter   m_initial           = 1;
   parameter   m                   = 0;
   parameter   n                   = 1;
   parameter   m2                  = 1;
   parameter   n2                  = 1;
   parameter   ss                  = 0;
   parameter   l0_high             = 1;
   parameter   l1_high             = 1;
   parameter   g0_high             = 1;
   parameter   g1_high             = 1;
   parameter   g2_high             = 1;
   parameter   g3_high             = 1;
   parameter   e0_high             = 1;
   parameter   e1_high             = 1;
   parameter   e2_high             = 1;
   parameter   e3_high             = 1;
   parameter   l0_low              = 1;
   parameter   l1_low              = 1;
   parameter   g0_low              = 1;
   parameter   g1_low              = 1;
   parameter   g2_low              = 1;
   parameter   g3_low              = 1;
   parameter   e0_low              = 1;
   parameter   e1_low              = 1;
   parameter   e2_low              = 1;
   parameter   e3_low              = 1;
   parameter   l0_initial          = 1;
   parameter   l1_initial          = 1;
   parameter   g0_initial          = 1;
   parameter   g1_initial          = 1;
   parameter   g2_initial          = 1;
   parameter   g3_initial          = 1;
   parameter   e0_initial          = 1;
   parameter   e1_initial          = 1;
   parameter   e2_initial          = 1;
   parameter   e3_initial          = 1;
   parameter   l0_mode             = "bypass";
   parameter   l1_mode             = "bypass";
   parameter   g0_mode             = "bypass";
   parameter   g1_mode             = "bypass";
   parameter   g2_mode             = "bypass";
   parameter   g3_mode             = "bypass";
   parameter   e0_mode             = "bypass";
   parameter   e1_mode             = "bypass";
   parameter   e2_mode             = "bypass";
   parameter   e3_mode             = "bypass";
   parameter   l0_ph               = 0;
   parameter   l1_ph               = 0;
   parameter   g0_ph               = 0;
   parameter   g1_ph               = 0;
   parameter   g2_ph               = 0;
   parameter   g3_ph               = 0;
   parameter   e0_ph               = 0;
   parameter   e1_ph               = 0;
   parameter   e2_ph               = 0;
   parameter   e3_ph               = 0;
   parameter   m_ph                = 0;
   parameter   l0_time_delay       = 0;
   parameter   l1_time_delay       = 0;
   parameter   g0_time_delay       = 0;
   parameter   g1_time_delay       = 0;
   parameter   g2_time_delay       = 0;
   parameter   g3_time_delay       = 0;
   parameter   e0_time_delay       = 0;
   parameter   e1_time_delay       = 0;
   parameter   e2_time_delay       = 0;
   parameter   e3_time_delay       = 0;
   parameter   m_time_delay        = 0;
   parameter   n_time_delay        = 0;
   parameter   extclk3_counter     = "e3" ;
   parameter   extclk2_counter     = "e2" ;
   parameter   extclk1_counter     = "e1" ;
   parameter   extclk0_counter     = "e0" ;
   parameter   clk9_counter        = "c9" ;
   parameter   clk8_counter        = "c8" ;
   parameter   clk7_counter        = "c7" ;
   parameter   clk6_counter        = "c6" ;
   parameter   clk5_counter        = "l1" ;
   parameter   clk4_counter        = "l0" ;
   parameter   clk3_counter        = "g3" ;
   parameter   clk2_counter        = "g2" ;
   parameter   clk1_counter        = "g1" ;
   parameter   clk0_counter        = "g0" ;
   parameter   enable0_counter     = "l0";
   parameter   enable1_counter     = "l0";
   parameter   charge_pump_current = 2;
   parameter   loop_filter_r       = "1.0";
   parameter   loop_filter_c       = 5;
   parameter   vco_post_scale      = 0;
   parameter   vco_frequency_control = "AUTO";
   parameter   vco_phase_shift_step = 0;
   parameter   lpm_type            = "altpll";

   parameter port_clkena0 = "PORT_CONNECTIVITY";
   parameter port_clkena1 = "PORT_CONNECTIVITY";
   parameter port_clkena2 = "PORT_CONNECTIVITY";
   parameter port_clkena3 = "PORT_CONNECTIVITY";
   parameter port_clkena4 = "PORT_CONNECTIVITY";
   parameter port_clkena5 = "PORT_CONNECTIVITY";
   parameter port_extclkena0 = "PORT_CONNECTIVITY";
   parameter port_extclkena1 = "PORT_CONNECTIVITY";
   parameter port_extclkena2 = "PORT_CONNECTIVITY";
   parameter port_extclkena3 = "PORT_CONNECTIVITY";
   parameter port_extclk0 = "PORT_CONNECTIVITY";
   parameter port_extclk1 = "PORT_CONNECTIVITY";
   parameter port_extclk2 = "PORT_CONNECTIVITY";
   parameter port_extclk3 = "PORT_CONNECTIVITY";
   parameter port_clk0 = "PORT_CONNECTIVITY";
   parameter port_clk1 = "PORT_CONNECTIVITY";
   parameter port_clk2 = "PORT_CONNECTIVITY";
   parameter port_clk3 = "PORT_CONNECTIVITY";
   parameter port_clk4 = "PORT_CONNECTIVITY";
   parameter port_clk5 = "PORT_CONNECTIVITY";
   parameter port_clk6 = "PORT_CONNECTIVITY";
   parameter port_clk7 = "PORT_CONNECTIVITY";
   parameter port_clk8 = "PORT_CONNECTIVITY";
   parameter port_clk9 = "PORT_CONNECTIVITY";
   parameter port_scandata = "PORT_CONNECTIVITY";
   parameter port_scandataout = "PORT_CONNECTIVITY";
   parameter port_scandone = "PORT_CONNECTIVITY";
   parameter port_sclkout1 = "PORT_CONNECTIVITY";
   parameter port_sclkout0 = "PORT_CONNECTIVITY";
   parameter port_clkbad0 = "PORT_CONNECTIVITY";
   parameter port_clkbad1 = "PORT_CONNECTIVITY";
   parameter port_activeclock = "PORT_CONNECTIVITY";
   parameter port_clkloss = "PORT_CONNECTIVITY";
   parameter port_inclk1 = "PORT_CONNECTIVITY";
   parameter port_inclk0 = "PORT_CONNECTIVITY";
   parameter port_fbin = "PORT_CONNECTIVITY";
   parameter port_fbout = "PORT_CONNECTIVITY";
   parameter port_pllena = "PORT_CONNECTIVITY";
   parameter port_clkswitch = "PORT_CONNECTIVITY";
   parameter port_areset = "PORT_CONNECTIVITY";
   parameter port_pfdena = "PORT_CONNECTIVITY";
   parameter port_scanclk = "PORT_CONNECTIVITY";
   parameter port_scanaclr = "PORT_CONNECTIVITY";
   parameter port_scanread = "PORT_CONNECTIVITY";
   parameter port_scanwrite = "PORT_CONNECTIVITY";
   parameter port_enable0 = "PORT_CONNECTIVITY";
   parameter port_enable1 = "PORT_CONNECTIVITY";
   parameter port_locked = "PORT_CONNECTIVITY";
   parameter port_configupdate = "PORT_CONNECTIVITY";
   parameter port_phasecounterselect = "PORT_CONNECTIVITY";
   parameter port_phasedone = "PORT_CONNECTIVITY";
   parameter port_phasestep = "PORT_CONNECTIVITY";
   parameter port_phaseupdown = "PORT_CONNECTIVITY";
   parameter port_vcooverrange = "PORT_CONNECTIVITY";
   parameter port_vcounderrange = "PORT_CONNECTIVITY";
   parameter port_scanclkena = "PORT_CONNECTIVITY";
   parameter using_fbmimicbidir_port = "ON";

   input [1:0] inclk;
   input       fbin;
   input       pllena;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input       clkena;
   input       extclkena;
   input       scanclk;
   input       scanaclr;
   input       scanclkena;
   input       scanread;
   input       scanwrite;
   input       scandata;
   input       phasecounterselect;
   input       phaseupdown;
   input       phasestep;
   input       configupdate;
   inout       fbmimicbidir;


   output [width_clock-1:0] clk;
   output [3:0]             extclk;
   output [1:0]             clkbad;
   output                   enable0;
   output                   enable1;
   output                   activeclock;
   output                   clkloss;
   output                   locked;
   output                   scandataout;
   output                   scandone;
   output                   sclkout0;
   output                   sclkout1;
   output                   phasedone;
   output                   vcooverrange;
   output                   vcounderrange;
   output                   fbout;
   output                   fref;
   output                   icdrclk;
   output                   c0, c1, c2, c3, c4;

endmodule // altpll
\`endif
`,"brams_m9k.txt":`bram $__M9K_ALTSYNCRAM_SINGLEPORT_FULL
  init   1
  abits  13 @M1
  dbits  1  @M1
  abits  12 @M2
  dbits  2  @M2
  abits  11 @M3
  dbits  4  @M3
  abits  10 @M4
  dbits  8  @M4
  abits  10 @M5
  dbits  9  @M5
  abits  9  @M6
  dbits  16 @M6
  abits  9  @M7
  dbits  18 @M7
  abits  8  @M8
  dbits  32 @M8
  abits  8  @M9
  dbits  36 @M9
  groups 2
  ports  1 1
  wrmode 0 1
  enable 1 1
  transp 0 0
  clocks 2 3
  clkpol 2 3
endbram

match $__M9K_ALTSYNCRAM_SINGLEPORT_FULL
  min efficiency 2
  make_transp
endmatch
`,"brams_map_m9k.v":`module \\$__M9K_ALTSYNCRAM_SINGLEPORT_FULL (CLK2, CLK3, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

   parameter CFG_ABITS = 8;
   parameter CFG_DBITS = 36;
   parameter ABITS = 1;
   parameter DBITS = 1;
   parameter CLKPOL2 = 1;
   parameter CLKPOL3 = 1;

   input CLK2;
   input CLK3;
   //Read data
   output [CFG_DBITS-1:0] A1DATA;
   input [CFG_ABITS-1:0]  A1ADDR;
   input                  A1EN;
   //Write data
   output [CFG_DBITS-1:0] B1DATA;
   input [CFG_ABITS-1:0]  B1ADDR;
   input                  B1EN;

   wire [CFG_DBITS-1:0]   B1DATA_t;

   localparam MODE = CFG_DBITS == 1  ? 1:
                     CFG_DBITS == 2  ? 2:
                     CFG_DBITS == 4  ? 3:
                     CFG_DBITS == 8  ? 4:
                     CFG_DBITS == 9  ? 5:
                     CFG_DBITS == 16 ? 6:
                     CFG_DBITS == 18 ? 7:
                     CFG_DBITS == 32 ? 8:
                     CFG_DBITS == 36 ? 9:
                     'bx;

   localparam NUMWORDS = CFG_DBITS == 1  ? 8192:
                         CFG_DBITS == 2  ? 4096:
                         CFG_DBITS == 4  ? 2048:
                         CFG_DBITS == 8  ? 1024:
                         CFG_DBITS == 9  ? 1024:
                         CFG_DBITS == 16 ?  512:
                         CFG_DBITS == 18 ?  512:
                         CFG_DBITS == 32 ?  256:
                         CFG_DBITS == 36 ?  256:
                         'bx;

   altsyncram  #(.clock_enable_input_b           ("ALTERNATE"   ),
                 .clock_enable_input_a           ("ALTERNATE"   ),
                 .clock_enable_output_b          ("NORMAL"      ),
                 .clock_enable_output_a          ("NORMAL"      ),
                 .wrcontrol_aclr_a               ("NONE"        ),
                 .indata_aclr_a                  ("NONE"        ),
                 .address_aclr_a                 ("NONE"        ),
                 .outdata_aclr_a                 ("NONE"        ),
                 .outdata_reg_a                  ("UNREGISTERED"),
                 .operation_mode                 ("SINGLE_PORT" ),
                 .intended_device_family         ("CYCLONE IVE" ),
                 .outdata_reg_a                  ("UNREGISTERED"),
                 .lpm_type                       ("altsyncram"  ),
                 .init_type                      ("unused"      ),
                 .ram_block_type                 ("AUTO"        ),
                 .lpm_hint                       ("ENABLE_RUNTIME_MOD=NO"), // Forced value
                 .power_up_uninitialized         ("FALSE"),
                 .read_during_write_mode_port_a  ("NEW_DATA_NO_NBE_READ"), // Forced value
                 .width_byteena_a                (1), // Forced value
                 .numwords_b                     ( NUMWORDS     ),
                 .numwords_a                     ( NUMWORDS     ),
                 .widthad_b                      ( CFG_ABITS    ),
                 .width_b                        ( CFG_DBITS    ),
                 .widthad_a                      ( CFG_ABITS    ),
                 .width_a                        ( CFG_DBITS    )
                 ) _TECHMAP_REPLACE_ (
                                      .data_a(B1DATA),
                                      .address_a(B1ADDR),
                                      .wren_a(B1EN),
                                      .rden_a(A1EN),
                                      .q_a(A1DATA),
                                      .data_b(B1DATA),
                                      .address_b(0),
                                      .wren_b(1'b0),
                                      .rden_b(1'b0),
                                      .q_b(),
                                      .clock0(CLK2),
                                      .clock1(1'b1), // Unused in single port mode
                                      .clocken0(1'b1),
                                      .clocken1(1'b1),
                                      .clocken2(1'b1),
                                      .clocken3(1'b1),
                                      .aclr0(1'b0),
                                      .aclr1(1'b0),
                                      .addressstall_a(1'b0),
                                      .addressstall_b(1'b0));

endmodule

`,"ff_map.v":`// Async Active Low Reset DFF
module  \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
   parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
   generate if (_TECHMAP_WIREINIT_Q_ === 1'b1) begin
     dffeas #(.is_wysiwyg("TRUE"), .power_up("high")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));
   end else begin
     dffeas #(.is_wysiwyg("TRUE"), .power_up("low")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));
   end
   endgenerate
   wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
`,"m9k_bb.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
(* blackbox *)
module altsyncram(data_a, address_a, wren_a, rden_a, q_a, data_b, address_b,  wren_b, rden_b,
                  q_b, clock0, clock1, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1,
                  addressstall_a, addressstall_b);

   parameter clock_enable_input_b          = "ALTERNATE";
   parameter clock_enable_input_a          = "ALTERNATE";
   parameter clock_enable_output_b         = "NORMAL";
   parameter clock_enable_output_a         = "NORMAL";
   parameter wrcontrol_aclr_a              = "NONE";
   parameter indata_aclr_a                 = "NONE";
   parameter address_aclr_a                = "NONE";
   parameter outdata_aclr_a                = "NONE";
   parameter outdata_reg_a                 = "UNREGISTERED";
   parameter operation_mode                = "SINGLE_PORT";
   parameter intended_device_family        = "MAX 10 FPGA";
   parameter outdata_reg_b                 = "UNREGISTERED";
   parameter lpm_type                      = "altsyncram";
   parameter init_type                     = "unused";
   parameter ram_block_type                = "AUTO";
   parameter lpm_hint                      = "ENABLE_RUNTIME_MOD=NO";
   parameter power_up_uninitialized        = "FALSE";
   parameter read_during_write_mode_port_a = "NEW_DATA_NO_NBE_READ";
   parameter width_byteena_a               = 1;
   parameter numwords_b                    = 0;
   parameter numwords_a                    = 0;
   parameter widthad_b                     = 1;
   parameter width_b                       = 1;
   parameter widthad_a                     = 1;
   parameter width_a                       = 1;

   // Port A declarations
   output [35:0] q_a;
   input [35:0]  data_a;
   input [7:0]   address_a;
   input         wren_a;
   input         rden_a;
   // Port B declarations
   output [35:0] q_b;
   input [35:0]  data_b;
   input [7:0]   address_b;
   input         wren_b;
   input         rden_b;
   // Control signals
   input         clock0, clock1;
   input         clocken0, clocken1, clocken2, clocken3;
   input         aclr0, aclr1;
   input         addressstall_a;
   input         addressstall_b;
   // TODO: Implement the correct simulation model

endmodule // altsyncram
`},cyclone10lp:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   cyclone10lp_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   cyclone10lp_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
 1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	 assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
        if (WIDTH == 2) begin
           cyclone10lp_lcell_comb #(.lut_mask({4{LUT}}),
                                   .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                .dataa(A[0]),
                                                                                .datab(A[1]),
                                                                                .datac(1'b1),
                                                                                .datad(1'b1));
        end else
          if(WIDTH == 3) begin
	     cyclone10lp_lcell_comb #(.lut_mask({2{LUT}}),
                                     .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                  .dataa(A[0]),
                                                                                  .datab(A[1]),
                                                                                  .datac(A[2]),
                                                                                  .datad(1'b1));
          end else
            if(WIDTH == 4) begin
	       cyclone10lp_lcell_comb #(.lut_mask(LUT),
                                       .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                    .dataa(A[0]),
                                                                                    .datab(A[1]),
                                                                                    .datac(A[2]),
                                                                                    .datad(A[3]));
            end else
	             wire _TECHMAP_FAIL_ = 1;
   endgenerate

endmodule


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone 10 LP devices Input Buffer Primitive */
module cyclone10lp_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // cyclone10lp_io_ibuf

/* Altera Cyclone 10 LP devices Output Buffer Primitive */
module cyclone10lp_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // cyclone10lp_io_obuf

/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */
module cyclone10lp_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask   = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type   = "cyclone10lp_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0]                        lut_type;
   reg                              cout_rt;
   reg                              combout_rt;
   wire                             dataa_w;
   wire                             datab_w;
   wire                             datac_w;
   wire                             datad_w;
   wire                             cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0]                  mask;
      input                         dataa, datab, datac, datad;
      reg [7:0]                     s3;
      reg [3:0]                     s2;
      reg [1:0]                     s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cyclone10lp_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas
`},cycloneiv:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
    cycloneiv_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
    cycloneiv_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
   1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
      if (WIDTH == 2) begin
           cycloneiv_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));
      end else
      if(WIDTH == 3) begin
	   cycloneiv_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));
      end else
      if(WIDTH == 4) begin
	   cycloneiv_lcell_comb #(.lut_mask(LUT), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule //


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone IV (GX) devices Input Buffer Primitive */
module cycloneiv_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera Cyclone IV (GX)  devices Output Buffer Primitive */
module cycloneiv_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera Cyclone IV (GX) 4-input non-fracturable LUT Primitive */
module cycloneiv_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type = "cycloneiv_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0] lut_type;
   reg       cout_rt;
   reg       combout_rt;
   wire      dataa_w;
   wire      datab_w;
   wire      datac_w;
   wire      datad_w;
   wire      cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cycloneiv_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* Cyclone IV GX altpll clearbox model */
(* blackbox *)
module cycloneiv_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange,
   fref,
   icdrclk);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "cycloneiv_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;

   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;
   output                                   fref;
   output                                   icdrclk;

endmodule // cycloneive_pll


`},cycloneive:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   cycloneive_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   cycloneive_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
 1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	 assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
        if (WIDTH == 2) begin
           cycloneive_lcell_comb #(.lut_mask({4{LUT}}),
                                   .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                .dataa(A[0]),
                                                                                .datab(A[1]),
                                                                                .datac(1'b1),
                                                                                .datad(1'b1));
        end else
          if(WIDTH == 3) begin
	     cycloneive_lcell_comb #(.lut_mask({2{LUT}}),
                                     .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                  .dataa(A[0]),
                                                                                  .datab(A[1]),
                                                                                  .datac(A[2]),
                                                                                  .datad(1'b1));
          end else
            if(WIDTH == 4) begin
	       cycloneive_lcell_comb #(.lut_mask(LUT),
                                       .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                    .dataa(A[0]),
                                                                                    .datab(A[1]),
                                                                                    .datac(A[2]),
                                                                                    .datad(A[3]));
            end else
	             wire _TECHMAP_FAIL_ = 1;
   endgenerate

endmodule


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone IV (E) devices Input Buffer Primitive */
module cycloneive_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera Cyclone IV (E)  devices Output Buffer Primitive */
module cycloneive_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */
module cycloneive_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask   = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type   = "cycloneive_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0]                        lut_type;
   reg                              cout_rt;
   reg                              combout_rt;
   wire                             dataa_w;
   wire                             datab_w;
   wire                             datac_w;
   wire                             datad_w;
   wire                             cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0]                  mask;
      input                         dataa, datab, datac, datad;
      reg [7:0]                     s3;
      reg [3:0]                     s2;
      reg [1:0]                     s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cycloneive_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* Cyclone IV E altpll clearbox model */
(* blackbox *)
module cycloneive_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "cycloneive_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;

   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;

endmodule // cycloneive_pll
`},max10:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   fiftyfivenm_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   fiftyfivenm_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
   1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
      if (WIDTH == 2) begin
           fiftyfivenm_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));
      end else
      if(WIDTH == 3) begin
	      fiftyfivenm_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));
      end else
      if(WIDTH == 4) begin
         fiftyfivenm_lcell_comb #(.lut_mask(LUT), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule //


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2024  Richard Herveille <richard.herveille@roalogic.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera MAX10 devices Input Buffer Primitive */
module fiftyfivenm_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera MAX10 devices Output Buffer Primitive */
module fiftyfivenm_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera MAX10 4-input non-fracturable LUT Primitive */
module fiftyfivenm_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type = "fiftyfivenm_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0] lut_type;
   reg       cout_rt;
   reg       combout_rt;
   wire      dataa_w;
   wire      datab_w;
   wire      datac_w;
   wire      datad_w;
   wire      cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // fiftyfivenm_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* MAX10 altpll clearbox model */
(* blackbox *)
module fiftyfivenm_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "fiftyfivenm_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;
   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;

endmodule // max10_pll


/* MAX10 MULT clearbox model */
(* blackbox *)
module fiftyfivenm_mac_mult (
  dataa,
  datab,
  dataout,
  signa,
  signb,

  aclr,
  clk,
  ena
);
  parameter dataa_clock = "none";
  parameter dataa_width = 18;
  parameter datab_clock = "none";
  parameter datab_width = 18;
  parameter signa_clock = "none";
  parameter signb_clock = "none";
  parameter lpm_type    = "fiftyfivenm_mac_mult";

  input  [dataa_width              -1:0] dataa;
  input  [datab_width              -1:0] datab;
  output [(dataa_width+datab_width)-1:0] dataout;
  input                                  signa;
  input                                  signb;
  input                                  aclr;
  input                                  clk;
  input                                  ena;
endmodule //fiftyfivenm_mac_mult

module fiftyfivenm_mac_out (
  dataa,
  dataout,

  aclr,
  clk,
  ena
);

  parameter dataa_width  = 38;
  parameter output_clock = "none";
  parameter lpm_type     = "fiftyfivenm_mac_out";

  input  [dataa_width-1:0] dataa;
  output [dataa_width-1:0] dataout;
  input                    aclr;
  input                    clk;
  input                    ena;
endmodule //fiftyfivenm_mac_out
`}},intel_alm:{common:{"abc9_map.v":`// This file exists to map purely-synchronous flops to ABC9 flops, while 
// mapping flops with asynchronous-clear as boxes, this is because ABC9 
// doesn't support asynchronous-clear flops in sequential synthesis.

module MISTRAL_FF(
    input DATAIN, CLK, ACLR, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

parameter _TECHMAP_CONSTMSK_ACLR_ = 1'b0;

// If the async-clear is constant, we assume it's disabled.
if (_TECHMAP_CONSTMSK_ACLR_ != 1'b0)
    $__MISTRAL_FF_SYNCONLY _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));
else
    wire _TECHMAP_FAIL_ = 1;

endmodule
`,"abc9_model.v":`// This is a purely-synchronous flop, that ABC9 can use for sequential synthesis.
(* abc9_flop, lib_whitebox *)
module $__MISTRAL_FF_SYNCONLY (
    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

MISTRAL_FF ff (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .ACLR(1'b1), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));

endmodule
`,"abc9_unmap.v":`// After performing sequential synthesis, map the synchronous flops back to
// standard MISTRAL_FF flops.

module $__MISTRAL_FF_SYNCONLY (
    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

MISTRAL_FF _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ACLR(1'b1), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));

endmodule
`,"alm_map.v":`module \\$lut (A, Y);

parameter WIDTH = 1;
parameter LUT = 0;

(* force_downto *)
input [WIDTH-1:0] A;
output Y;

generate
    if (WIDTH == 1) begin
        generate
            if (LUT == 2'b00) begin
                assign Y = 1'b0;
            end
            else if (LUT == 2'b01) begin
                MISTRAL_NOT _TECHMAP_REPLACE_(
                    .A(A[0]), .Q(Y)
                );
            end
            else if (LUT == 2'b10) begin
                assign Y = A;
            end
            else if (LUT == 2'b11) begin
                assign Y = 1'b1;
            end
        endgenerate
    end else
    if (WIDTH == 2) begin
        MISTRAL_ALUT2 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .Q(Y)
        );
    end else
    if (WIDTH == 3) begin
        MISTRAL_ALUT3 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .C(A[2]), .Q(Y)
        );
    end else
    if (WIDTH == 4) begin
        MISTRAL_ALUT4 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .Q(Y)
        );
    end else
    if (WIDTH == 5) begin
        MISTRAL_ALUT5 #(.LUT(LUT)) _TECHMAP_REPLACE_ (
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .Q(Y)
        );
    end else
    if (WIDTH == 6) begin
        MISTRAL_ALUT6 #(.LUT(LUT)) _TECHMAP_REPLACE_ (
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .F(A[5]), .Q(Y)
        );
    end else begin
        wire _TECHMAP_FAIL_ = 1'b1;
    end
endgenerate
endmodule
`,"alm_sim.v":`// The core logic primitive of the Cyclone V is the Adaptive Logic Module
// (ALM). Each ALM is made up of an 8-input, 2-output look-up table, covered
// in this file, connected to combinational outputs, a carry chain, and four
// D flip-flops (which are covered as MISTRAL_FF in dff_sim.v).
//
// The ALM is vertically symmetric, so I find it helps to think in terms of
// half-ALMs, as that's predominantly the unit that synth_intel_alm uses.
//
// ALMs are quite flexible, having multiple modes.
//
// Normal (combinational) mode
// ---------------------------
// The ALM can implement:
// - a single 6-input function (with the other inputs usable for flip-flop access)
// - two 5-input functions that share two inputs
// - a 5-input and a 4-input function that share one input
// - a 5-input and a 3-or-less-input function that share no inputs
// - two 4-or-less-input functions that share no inputs
//
// Normal-mode functions are represented as MISTRAL_ALUTN cells with N inputs.
// It would be possible to represent a normal mode function as a single cell -
// the vendor cyclone{v,10gx}_lcell_comb cell does exactly that - but I felt
// it was more user-friendly to print out the specific function sizes
// separately.
//
// With the exception of MISTRAL_ALUT6, you can think of two normal-mode cells
// fitting inside a single ALM.
//
// Extended (7-input) mode
// -----------------------
// The ALM can also fit a 7-input function made of two 5-input functions that
// share four inputs, multiplexed by another input.
//
// Because this can't accept arbitrary 7-input functions, Yosys can't handle
// it, so it doesn't have a cell, but I would likely call it MISTRAL_ALUT7(E?)
// if it did, and it would take up a full ALM.
//
// It might be possible to add an extraction pass to examine all ALUT5 cells
// that feed into ALUT3 cells to see if they can be combined into an extended
// ALM, but I don't think it will be worth it.
//
// Arithmetic mode
// ---------------
// In arithmetic mode, each half-ALM uses its carry chain to perform fast addition
// of two four-input functions that share three inputs. Oddly, the result of
// one of the functions is inverted before being added (you can see this as
// the dot on a full-adder input of Figure 1-8 in the Handbook).
//
// The cell for an arithmetic-mode half-ALM is MISTRAL_ALM_ARITH. One idea
// I've had (or rather was suggested by mwk) is that functions that feed into
// arithmetic-mode cells could be packed directly into the arithmetic-mode
// cell as a function, which reduces the number of ALMs needed.
//
// Shared arithmetic mode
// ----------------------
// Shared arithmetic mode looks a lot like arithmetic mode, but here the
// output of every other four-input function goes to the input of the adder
// the next bit along. What this means is that adding three bits together can
// be done in an ALM, because functions can be used to implement addition that
// then feeds into the carry chain. This means that three bits can be added per
// ALM, as opposed to two in the arithmetic mode.
//
// Shared arithmetic mode doesn't currently have a cell, but I intend to add
// it as MISTRAL_ALM_SHARED, and have it occupy a full ALM. Because it adds
// three bits per cell, it makes addition shorter and use less ALMs, but
// I don't know enough to tell whether it's more efficient to use shared
// arithmetic mode to shorten the carry chain, or plain arithmetic mode with
// the functions packed in.

\`default_nettype none

// Cyclone V LUT output timings (picoseconds):
//
//          CARRY   A    B    C   D   E    F   G
//  COMBOUT    -  605  583  510 512   -   97 400 (LUT6)
//  COMBOUT    -  602  583  457 510 302   93 483 (LUT7)
//   SUMOUT  368 1342 1323  887 927   -  785   -
// CARRYOUT   71 1082 1062  866 813   - 1198   -

(* abc9_lut=2, lib_whitebox *)
module MISTRAL_ALUT6(input A, B, C, D, E, F, output Q);

parameter [63:0] LUT = 64'h0000_0000_0000_0000;

\`ifdef cyclonev
specify
    (A => Q) = 605;
    (B => Q) = 583;
    (C => Q) = 510;
    (D => Q) = 512;
    (E => Q) = 400;
    (F => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {F, E, D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT5(input A, B, C, D, E, output Q);

parameter [31:0] LUT = 32'h0000_0000;

\`ifdef cyclonev
specify
    (A => Q) = 583;
    (B => Q) = 510;
    (C => Q) = 512;
    (D => Q) = 400;
    (E => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {E, D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT4(input A, B, C, D, output Q);

parameter [15:0] LUT = 16'h0000;

\`ifdef cyclonev
specify
    (A => Q) = 510;
    (B => Q) = 512;
    (C => Q) = 400;
    (D => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT3(input A, B, C, output Q);

parameter [7:0] LUT = 8'h00;

\`ifdef cyclonev
specify
    (A => Q) = 510;
    (B => Q) = 400;
    (C => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT2(input A, B, output Q);

parameter [3:0] LUT = 4'h0;

\`ifdef cyclonev
specify
    (A => Q) = 400;
    (B => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_NOT(input A, output Q);

\`ifdef cyclonev
specify
    (A => Q) = 97;
endspecify
\`endif

assign Q = ~A;

endmodule

(* abc9_box, lib_whitebox *)
module MISTRAL_ALUT_ARITH(input A, B, C, D0, D1, (* abc9_carry *) input CI, output SO, (* abc9_carry *) output CO);

parameter LUT0 = 16'h0000;
parameter LUT1 = 16'h0000;

\`ifdef cyclonev
specify
    (A  => SO) = 1342;
    (B  => SO) = 1323;
    (C  => SO) = 927;
    (D0 => SO) = 887;
    (D1 => SO) = 785;
    (CI => SO) = 368;

    (A  => CO) = 1082;
    (B  => CO) = 1062;
    (C  => CO) = 813;
    (D0 => CO) = 866;
    (D1 => CO) = 1198;
    (CI => CO) = 36; // Divided by 2 to account for there being two ALUT_ARITHs in an ALM)
endspecify
\`endif

wire q0, q1;

assign q0 = LUT0 >> {D0, C, B, A};
assign q1 = LUT1 >> {D1, C, B, A};

assign {CO, SO} = q0 + !q1 + CI;

endmodule
`,"arith_alm_map.v":`\`default_nettype none

module \\$alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

parameter _TECHMAP_CONSTMSK_CI_ = 0;
parameter _TECHMAP_CONSTVAL_CI_ = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
input CI, BI;
(* force_downto *)
output [Y_WIDTH-1:0] X, Y, CO;

(* force_downto *)
wire [Y_WIDTH-1:0] A_buf, B_buf;
\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

(* force_downto *)
wire [Y_WIDTH-1:0] AA = A_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BX = B_buf;
wire [Y_WIDTH:0] ALM_CARRY;

// Start of carry chain
generate
    if (_TECHMAP_CONSTMSK_CI_ == 1 && _TECHMAP_CONSTVAL_CI_ == 1'b0) begin
        assign ALM_CARRY[0] = _TECHMAP_CONSTVAL_CI_;
    end else begin
        MISTRAL_ALUT_ARITH #(
            .LUT0(16'b1010_1010_1010_1010), // Q = A
            .LUT1(16'b0000_0000_0000_0000), // Q = 0 (LUT1's input to the adder is inverted)
        ) alm_start (
            .A(CI), .B(1'b1), .C(1'b1), .D0(1'b1), .D1(1'b1),
            .CI(1'b0),
            .CO(ALM_CARRY[0])
        );
    end
endgenerate

// Carry chain
genvar i;
generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
    // TODO: mwk suggests that a pass could merge pre-adder logic into this.
    MISTRAL_ALUT_ARITH #(
        .LUT0(16'b1010_1010_1010_1010), // Q = A
        .LUT1(16'b1100_0011_1100_0011), // Q = C ? B : ~B (LUT1's input to the adder is inverted)
    ) alm_i (
        .A(AA[i]), .B(BX[i]), .C(BI), .D0(1'b1), .D1(1'b1),
        .CI(ALM_CARRY[i]),
        .SO(Y[i]),
        .CO(ALM_CARRY[i+1])
    );

    // ALM carry chain is not directly accessible, so calculate the carry through soft logic if really needed.
    assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
end endgenerate

assign X = AA ^ BB;

endmodule
`,"bram_m10k.txt":`bram $__MISTRAL_M10K
    init   1
    abits 13   @D8192x1
    dbits  1   @D8192x1
    abits 12   @D4096x2
    dbits  2   @D4096x2
    abits 11   @D2048x5
    dbits  5   @D2048x5
    abits 10   @D1024x10
    dbits 10   @D1024x10
    abits  9   @D512x20
    dbits 20   @D512x20
    abits  8   @D256x40
    dbits 40   @D256x40
    groups 2
    ports  1 1
    wrmode 1 0
    # read enable; write enable + byte enables (only for multiples of 8)
    enable 1 1
    transp 0 0
    clocks 1 1
    clkpol 1 1
endbram


match $__MISTRAL_M10K
    min efficiency 5
    make_transp
endmatch
`,"bram_m10k_map.v":`// Stub to invert M10K write-enable.

module \\$__MISTRAL_M10K (CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

parameter INIT = 0;

parameter CFG_ABITS = 10;
parameter CFG_DBITS = 10;

input CLK1;
input [CFG_ABITS-1:0] A1ADDR, B1ADDR;
input [CFG_DBITS-1:0] A1DATA;
input A1EN, B1EN;
output reg [CFG_DBITS-1:0] B1DATA;

// Normal M10K configs use WREN[1], which is negative-true.
// However, 8x40-bit mode uses WREN[0], which is positive-true.
wire a1en;
if (CFG_DBITS == 40)
    assign a1en = A1EN;
else
    assign a1en = !A1EN;

MISTRAL_M10K #(.INIT(INIT), .CFG_ABITS(CFG_ABITS), .CFG_DBITS(CFG_DBITS)) _TECHMAP_REPLACE_ (.CLK1(CLK1), .A1ADDR(A1ADDR), .A1DATA(A1DATA), .A1EN(a1en), .B1ADDR(B1ADDR), .B1DATA(B1DATA), .B1EN(B1EN));

endmodule
`,"dff_map.v":`\`default_nettype none

// D flip-flop with async reset and enable
module \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(R), .ENA(E), .SCLR(1'b0), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));
endmodule

// D flip-flop with sync reset and enable (enable has priority)
module \\$_SDFFCE_PP0P_ (input D, C, R, E, output Q);
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(1'b1), .ENA(E), .SCLR(R), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));
endmodule
`,"dff_sim.v":`// The four D flip-flops (DFFs) in a Cyclone V/10GX Adaptive Logic Module (ALM)
// act as one-bit memory cells that can be placed very flexibly (wherever there's
// an ALM); each flop is represented by a MISTRAL_FF cell.
//
// The flops in these chips are rather flexible in some ways, but in practice
// quite crippled by FPGA standards.
//
// What the flops can do
// ---------------------
// The core flop acts as a single-bit memory that initialises to zero at chip
// reset. It takes in data on the rising edge of CLK if ENA is high,
// and outputs it to Q. The ENA (clock enable) pin can therefore be used to
// capture the input only if a condition is true.
//
// The data itself is zero if SCLR (synchronous clear) is high, else it comes
// from SDATA (synchronous data) if SLOAD (synchronous load) is high, or DATAIN
// if SLOAD is low.
//
// If ACLR (asynchronous clear) is low then Q is forced to zero, regardless of
// the synchronous inputs or CLK edge. This is most often used for an FPGA-wide
// power-on reset.
//
// An asynchronous set that sets Q to one can be emulated by inverting the input
// and output of the flop, resulting in ACLR forcing Q to zero, which then gets
// inverted to produce one. Likewise, logic can operate on the falling edge of
// CLK if CLK is inverted before being passed as an input.
//
// What the flops *can't* do
// -------------------------
// The trickiest part of the above capabilities is the lack of configurable
// initialisation state. For example, it isn't possible to implement a flop with
// asynchronous clear that initialises to one, because the hardware initialises
// to zero. Likewise, you can't emulate a flop with asynchronous set that
// initialises to zero, because the inverters mean the flop initialises to one.
//
// If the input design requires one of these cells (which appears to be rare
// in practice) then synth_intel_alm will fail to synthesize the design where
// other Yosys synthesis scripts might succeed.
//
// This stands in notable contrast to e.g. Xilinx flip-flops, which have
// configurable initialisation state and native synchronous/asynchronous
// set/clear (although not at the same time), which means they can generally
// implement a much wider variety of logic.

// DATAIN: synchronous data input
// CLK: clock input (positive edge)
// ACLR: asynchronous clear (negative-true)
// ENA: clock-enable
// SCLR: synchronous clear
// SLOAD: synchronous load
// SDATA: synchronous load data
//
// Q: data output
//
// Note: the DFFEAS primitive is mostly emulated; it does not reflect what the hardware implements.

(* abc9_box, lib_whitebox *)
module MISTRAL_FF(
    input DATAIN,
    (* clkbuf_sink *) input CLK,
    input ACLR, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

\`ifdef cyclonev
specify
    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 731;
    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 890;
    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 618;

    $setup(DATAIN, posedge CLK, /* -196 */ 0);
    $setup(ENA, posedge CLK, /* -196 */ 0);
    $setup(SCLR, posedge CLK, /* -196 */ 0);
    $setup(SLOAD, posedge CLK, /* -196 */ 0);
    $setup(SDATA, posedge CLK, /* -196 */ 0);

    if (ACLR === 1'b0) (ACLR => Q) = 282;
endspecify
\`endif

initial begin
    // Altera flops initialise to zero.
	Q = 0;
end

always @(posedge CLK, negedge ACLR) begin
    // Asynchronous clear
    if (!ACLR) Q <= 0;
    // Clock-enable
	else if (ENA) begin
        // Synchronous clear
        if (SCLR) Q <= 0;
        // Synchronous load
        else if (SLOAD) Q <= SDATA;
        else Q <= DATAIN;
    end
end

endmodule
`,"dsp_map.v":`\`default_nettype none

module __MUL27X27(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 27;
parameter B_WIDTH = 27;
parameter Y_WIDTH = 54;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL27X27 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule


module __MUL18X18(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 18;
parameter B_WIDTH = 18;
parameter Y_WIDTH = 36;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL18X18 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule


module __MUL9X9(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 9;
parameter B_WIDTH = 9;
parameter Y_WIDTH = 18;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL9X9 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule
`,"dsp_sim.v":`\`default_nettype none

(* abc9_box *)
module MISTRAL_MUL27X27(input [26:0] A, input [26:0] B, output [53:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 3732;
    (B *> Y) = 3928;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 3732;
    (B *> Y) = 3928;
endspecify
\`endif

wire [53:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule

(* abc9_box *)
module MISTRAL_MUL18X18(input [17:0] A, input [17:0] B, output [35:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 3180;
    (B *> Y) = 3982;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 3180;
    (B *> Y) = 3982;
endspecify
\`endif

wire [35:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule

(* abc9_box *)
module MISTRAL_MUL9X9(input [8:0] A, input [8:0] B, output [17:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 2818;
    (B *> Y) = 3051;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 2818;
    (B *> Y) = 3051;
endspecify
\`endif

wire [17:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule
`,"lutram_mlab.txt":`bram MISTRAL_MLAB
    init   0   # TODO: Re-enable when Yosys remembers the original filename.
    abits  5
    dbits  1
    groups 2
    ports  1 1
    wrmode 1 0
    # write enable
    enable 1 0
    transp 0 0
    clocks 1 0
    clkpol 1 1
endbram

match MISTRAL_MLAB
    min efficiency 5
    make_outreg
endmatch`,"megafunction_bb.v":`// Intel megafunction declarations, to avoid Yosys complaining.
\`default_nettype none

(* blackbox *)
module altera_pll
#(
    parameter reference_clock_frequency       = "0 ps",
	parameter fractional_vco_multiplier       = "false",
    parameter pll_type                        = "General",
    parameter pll_subtype                     = "General",
    parameter number_of_clocks                   = 1,
    parameter operation_mode                  = "internal feedback",
    parameter deserialization_factor           = 4,
    parameter data_rate                       = 0,
    
    parameter sim_additional_refclk_cycles_to_lock      = 0,
    parameter output_clock_frequency0           = "0 ps",
    parameter phase_shift0                      = "0 ps",
    parameter duty_cycle0                      = 50,
    
    parameter output_clock_frequency1           = "0 ps",
    parameter phase_shift1                      = "0 ps",
    parameter duty_cycle1                      = 50,
    
    parameter output_clock_frequency2           = "0 ps",
    parameter phase_shift2                      = "0 ps",
    parameter duty_cycle2                      = 50,
    
    parameter output_clock_frequency3           = "0 ps",
    parameter phase_shift3                      = "0 ps",
    parameter duty_cycle3                      = 50,
    
    parameter output_clock_frequency4           = "0 ps",
    parameter phase_shift4                      = "0 ps",
    parameter duty_cycle4                      = 50,
    
    parameter output_clock_frequency5           = "0 ps",
    parameter phase_shift5                      = "0 ps",
    parameter duty_cycle5                      = 50,
    
    parameter output_clock_frequency6           = "0 ps",
    parameter phase_shift6                      = "0 ps",
    parameter duty_cycle6                      = 50,
    
    parameter output_clock_frequency7           = "0 ps",
    parameter phase_shift7                      = "0 ps",
    parameter duty_cycle7                      = 50,
    
    parameter output_clock_frequency8           = "0 ps",
    parameter phase_shift8                      = "0 ps",
    parameter duty_cycle8                      = 50,
    
    parameter output_clock_frequency9           = "0 ps",
    parameter phase_shift9                      = "0 ps",
    parameter duty_cycle9                      = 50,    

    
    parameter output_clock_frequency10           = "0 ps",
    parameter phase_shift10                      = "0 ps",
    parameter duty_cycle10                      = 50,
    
    parameter output_clock_frequency11           = "0 ps",
    parameter phase_shift11                      = "0 ps",
    parameter duty_cycle11                      = 50,
    
    parameter output_clock_frequency12           = "0 ps",
    parameter phase_shift12                      = "0 ps",
    parameter duty_cycle12                      = 50,
    
    parameter output_clock_frequency13           = "0 ps",
    parameter phase_shift13                      = "0 ps",
    parameter duty_cycle13                      = 50,
    
    parameter output_clock_frequency14           = "0 ps",
    parameter phase_shift14                      = "0 ps",
    parameter duty_cycle14                      = 50,
    
    parameter output_clock_frequency15           = "0 ps",
    parameter phase_shift15                      = "0 ps",
    parameter duty_cycle15                      = 50,
    
    parameter output_clock_frequency16           = "0 ps",
    parameter phase_shift16                      = "0 ps",
    parameter duty_cycle16                      = 50,
    
    parameter output_clock_frequency17           = "0 ps",
    parameter phase_shift17                      = "0 ps",
    parameter duty_cycle17                      = 50,
    
    parameter clock_name_0 = "",
    parameter clock_name_1 = "",
    parameter clock_name_2 = "",
    parameter clock_name_3 = "",
    parameter clock_name_4 = "",
    parameter clock_name_5 = "",
    parameter clock_name_6 = "",
    parameter clock_name_7 = "",
    parameter clock_name_8 = "",

    parameter clock_name_global_0 = "false",
    parameter clock_name_global_1 = "false",
    parameter clock_name_global_2 = "false",
    parameter clock_name_global_3 = "false",
    parameter clock_name_global_4 = "false",
    parameter clock_name_global_5 = "false",
    parameter clock_name_global_6 = "false",
    parameter clock_name_global_7 = "false",
    parameter clock_name_global_8 = "false",

    parameter m_cnt_hi_div                       = 1,
    parameter m_cnt_lo_div                       = 1,
    parameter m_cnt_bypass_en                   = "false",
    parameter m_cnt_odd_div_duty_en           = "false",
    parameter n_cnt_hi_div                       = 1,
    parameter n_cnt_lo_div                       = 1,
    parameter n_cnt_bypass_en                   = "false",
    parameter n_cnt_odd_div_duty_en           = "false",
    parameter c_cnt_hi_div0                      = 1, 
    parameter c_cnt_lo_div0                      = 1,
    parameter c_cnt_bypass_en0                  = "false",
	parameter c_cnt_in_src0                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en0              = "false",
    parameter c_cnt_prst0                  = 1,
    parameter c_cnt_ph_mux_prst0                  = 0,
    parameter c_cnt_hi_div1                      = 1, 
    parameter c_cnt_lo_div1                      = 1,
    parameter c_cnt_bypass_en1                  = "false",
	parameter c_cnt_in_src1                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en1              = "false",
    parameter c_cnt_prst1                  = 1,
    parameter c_cnt_ph_mux_prst1                  = 0,
    parameter c_cnt_hi_div2                      = 1, 
    parameter c_cnt_lo_div2                                              = 1,
    parameter c_cnt_bypass_en2                  = "false",
	parameter c_cnt_in_src2                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en2 = "false",
    parameter c_cnt_prst2                  = 1,
    parameter c_cnt_ph_mux_prst2                  = 0,
    parameter c_cnt_hi_div3                      = 1, 
    parameter c_cnt_lo_div3                                              = 1,
    parameter c_cnt_bypass_en3                  = "false",
	parameter c_cnt_in_src3                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en3 = "false",
    parameter c_cnt_prst3                  = 1,
    parameter c_cnt_ph_mux_prst3                  = 0,
    parameter c_cnt_hi_div4                      = 1, 
    parameter c_cnt_lo_div4                                              = 1,
    parameter c_cnt_bypass_en4                  = "false",
	parameter c_cnt_in_src4                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en4 = "false",
    parameter c_cnt_prst4                  = 1,
    parameter c_cnt_ph_mux_prst4                  = 0,
    parameter c_cnt_hi_div5                      = 1, 
    parameter c_cnt_lo_div5                                              = 1,
    parameter c_cnt_bypass_en5                  = "false",
	parameter c_cnt_in_src5                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en5 = "false",
    parameter c_cnt_prst5                  = 1,
    parameter c_cnt_ph_mux_prst5                  = 0,
    parameter c_cnt_hi_div6                      = 1, 
    parameter c_cnt_lo_div6                                              = 1,
    parameter c_cnt_bypass_en6                  = "false",
	parameter c_cnt_in_src6                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en6 = "false",
    parameter c_cnt_prst6                  = 1,
    parameter c_cnt_ph_mux_prst6                  = 0,
    parameter c_cnt_hi_div7                      = 1, 
    parameter c_cnt_lo_div7                                              = 1,
    parameter c_cnt_bypass_en7                  = "false",
	parameter c_cnt_in_src7                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en7 = "false",
    parameter c_cnt_prst7                  = 1,
    parameter c_cnt_ph_mux_prst7                  = 0,
    parameter c_cnt_hi_div8                      = 1, 
    parameter c_cnt_lo_div8                                              = 1,
    parameter c_cnt_bypass_en8                  = "false",
	parameter c_cnt_in_src8                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en8 = "false",
    parameter c_cnt_prst8                  = 1,
    parameter c_cnt_ph_mux_prst8                  = 0,
    parameter c_cnt_hi_div9                      = 1, 
    parameter c_cnt_lo_div9                                              = 1,
    parameter c_cnt_bypass_en9                  = "false",
	parameter c_cnt_in_src9                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en9 = "false",
    parameter c_cnt_prst9                  = 1,
    parameter c_cnt_ph_mux_prst9                  = 0,
    parameter c_cnt_hi_div10                      = 1, 
    parameter c_cnt_lo_div10                                              = 1,
    parameter c_cnt_bypass_en10                  = "false",
	parameter c_cnt_in_src10                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en10 = "false",
    parameter c_cnt_prst10                  = 1,
    parameter c_cnt_ph_mux_prst10                  = 0,
    parameter c_cnt_hi_div11                      = 1, 
    parameter c_cnt_lo_div11                                              = 1,
    parameter c_cnt_bypass_en11                  = "false",
	parameter c_cnt_in_src11                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en11 = "false",
    parameter c_cnt_prst11                  = 1,
    parameter c_cnt_ph_mux_prst11                  = 0,
    parameter c_cnt_hi_div12                      = 1, 
    parameter c_cnt_lo_div12                                              = 1,
    parameter c_cnt_bypass_en12                  = "false",
	parameter c_cnt_in_src12                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en12 = "false",
    parameter c_cnt_prst12                  = 1,
    parameter c_cnt_ph_mux_prst12                  = 0,
    parameter c_cnt_hi_div13                      = 1, 
    parameter c_cnt_lo_div13                                              = 1,
    parameter c_cnt_bypass_en13                  = "false",
	parameter c_cnt_in_src13                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en13 = "false",
    parameter c_cnt_prst13                  = 1,
    parameter c_cnt_ph_mux_prst13                  = 0,
    parameter c_cnt_hi_div14                      = 1, 
    parameter c_cnt_lo_div14                                              = 1,
    parameter c_cnt_bypass_en14                  = "false",
	parameter c_cnt_in_src14                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en14 = "false",
    parameter c_cnt_prst14                  = 1,
    parameter c_cnt_ph_mux_prst14                  = 0,
    parameter c_cnt_hi_div15                      = 1, 
    parameter c_cnt_lo_div15                                              = 1,
    parameter c_cnt_bypass_en15                  = "false",
	parameter c_cnt_in_src15                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en15 = "false",
    parameter c_cnt_prst15                  = 1,
    parameter c_cnt_ph_mux_prst15                  = 0,
    parameter c_cnt_hi_div16                      = 1, 
    parameter c_cnt_lo_div16                                              = 1,
    parameter c_cnt_bypass_en16                  = "false",
	parameter c_cnt_in_src16                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en16 = "false",
    parameter c_cnt_prst16                  = 1,
    parameter c_cnt_ph_mux_prst16                  = 0,
    parameter c_cnt_hi_div17                      = 1, 
    parameter c_cnt_lo_div17                                              = 1,
    parameter c_cnt_bypass_en17                  = "false",
	parameter c_cnt_in_src17                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en17 = "false",
    parameter c_cnt_prst17                  = 1,
    parameter c_cnt_ph_mux_prst17                  = 0,
    parameter pll_vco_div = 1,
	parameter pll_slf_rst = "false",
	parameter pll_bw_sel = "low",
    parameter pll_output_clk_frequency = "0 MHz",
    parameter pll_cp_current = 0,
    parameter pll_bwctrl = 0,
    parameter pll_fractional_division = 1,
    parameter pll_fractional_cout = 24,
    parameter pll_dsm_out_sel = "1st_order",
    parameter mimic_fbclk_type = "gclk",
    parameter pll_fbclk_mux_1 = "glb",
    parameter pll_fbclk_mux_2 = "fb_1",
    parameter pll_m_cnt_in_src = "ph_mux_clk",
	parameter pll_vcoph_div = 1,
    parameter refclk1_frequency = "0 MHz",
    parameter pll_clkin_0_src = "clk_0",
    parameter pll_clkin_1_src = "clk_0",
    parameter pll_clk_loss_sw_en = "false",
    parameter pll_auto_clk_sw_en = "false",
    parameter pll_manu_clk_sw_en = "false", 
    parameter pll_clk_sw_dly = 0,
    parameter pll_extclk_0_cnt_src = "pll_extclk_cnt_src_vss",	
    parameter pll_extclk_1_cnt_src = "pll_extclk_cnt_src_vss"
) (
    //input
    input    refclk,
    input    refclk1,
    input    fbclk,
    input    rst,
    input    phase_en,
    input    updn,
    input    [2:0] num_phase_shifts,
    input    scanclk,
    input    [4:0] cntsel,
    input    [63:0] reconfig_to_pll,
    input    extswitch,
    input    adjpllin,
    input    cclk,
    
    //output
    output    [ number_of_clocks -1 : 0] outclk,
    output    fboutclk,
    output    locked,
    output    phase_done,
    output    [63:0]    reconfig_from_pll,
    output    activeclk,
    output    [1:0] clkbad,
	output    [7:0] phout,
	output	  [1:0] lvds_clk,
	output	  [1:0] loaden,
	output    [1:0] extclk_out,
    output    [ number_of_clocks -1 : 0] cascade_out,

    //inout
    inout zdbfbclk
);

endmodule


(* blackbox *)
module altera_std_synchronizer(clk, din, dout, reset_n);

parameter depth = 2;

input clk;
input reset_n;
input din;
output dout;

endmodule

(* blackbox *)
module altddio_in (
    datain,    // required port, DDR input data
    inclock,   // required port, input reference clock to sample data by
    inclocken, // enable data clock
    aset,      // asynchronous set
    aclr,      // asynchronous clear
    sset,      // synchronous set
    sclr,      // synchronous clear
    dataout_h, // data sampled at the rising edge of inclock
    dataout_l  // data sampled at the falling edge of inclock
);

parameter width = 1;
parameter power_up_high = "OFF";
parameter invert_input_clocks = "OFF";
parameter intended_device_family = "Stratix";
parameter lpm_type = "altddio_in";
parameter lpm_hint = "UNUSED";

input [width-1:0] datain;
input inclock;
input inclocken;
input aset;
input aclr;
input sset;
input sclr;

output [width-1:0] dataout_h;
output [width-1:0] dataout_l;

endmodule


(* blackbox *)
module altddio_out (
    datain_h,
    datain_l,
    outclock,
    outclocken,
    aset,
    aclr,
    sset,
    sclr,
    oe,
    dataout,
    oe_out
);

parameter width = 1;
parameter power_up_high = "OFF";
parameter oe_reg = "UNUSED";
parameter extend_oe_disable = "UNUSED";
parameter intended_device_family = "Stratix";
parameter invert_output = "OFF";
parameter lpm_type = "altddio_out";
parameter lpm_hint = "UNUSED";

input [width-1:0] datain_h;
input [width-1:0] datain_l;
input outclock;
input outclocken;
input aset;
input aclr;
input sset;
input sclr;
input oe;

output [width-1:0] dataout;
output [width-1:0] oe_out;

endmodule


(* blackbox *)
module altddio_bidir (
    datain_h,
    datain_l,
    inclock,
    inclocken,
    outclock,
    outclocken,
    aset,
    aclr,
    sset,
    sclr,
    oe,
    dataout_h,
    dataout_l,
    combout,
    oe_out,
    dqsundelayedout,
    padio
);

// GLOBAL PARAMETER DECLARATION
parameter width = 1; // required parameter
parameter power_up_high = "OFF";
parameter oe_reg = "UNUSED";
parameter extend_oe_disable = "UNUSED";
parameter implement_input_in_lcell = "UNUSED";
parameter invert_output = "OFF";
parameter intended_device_family = "Stratix";
parameter lpm_type = "altddio_bidir";
parameter lpm_hint = "UNUSED";

// INPUT PORT DECLARATION
input [width-1:0] datain_h;
input [width-1:0] datain_l;
input inclock;
input inclocken;
input outclock;
input outclocken;
input aset;
input aclr;
input sset;
input sclr;
input oe;

// OUTPUT PORT DECLARATION
output [width-1:0] dataout_h;
output [width-1:0] dataout_l;
output [width-1:0] combout;
output [width-1:0] oe_out;
output [width-1:0] dqsundelayedout;
// BIDIRECTIONAL PORT DECLARATION
inout  [width-1:0] padio;

endmodule


(* blackbox *)
module altiobuf_in(datain, dataout);

parameter enable_bus_hold = "FALSE";
parameter use_differential_mode = "FALSE";
parameter number_of_channels = 1;

input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;

endmodule

(* blackbox *)
module altiobuf_out(datain, dataout);

parameter enable_bus_hold = "FALSE";
parameter use_differential_mode = "FALSE";
parameter use_oe = "FALSE";
parameter number_of_channels = 1;

input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;

endmodule

(* blackbox *)
module altiobuf_bidir(dataio, oe, datain, dataout);

parameter number_of_channels = 1;
parameter enable_bus_hold = "OFF";

inout [number_of_channels-1:0] dataio;
input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;
input [number_of_channels-1:0] oe;

endmodule

(* blackbox *)
module altsyncram(clock0, clock1, address_a, data_a, rden_a, wren_a, byteena_a, q_a, addressstall_a, address_b, data_b, rden_b, wren_b, byteena_b, q_b, addressstall_b, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1, eccstatus);

parameter lpm_type = "altsyncram";
parameter operation_mode = "dual_port";
parameter ram_block_type = "auto";
parameter intended_device_family = "auto";
parameter power_up_uninitialized = "false";
parameter read_during_write_mode_mixed_ports = "dontcare";
parameter byte_size = 8;
parameter widthad_a = 1;
parameter width_a = 1;
parameter width_byteena_a = 1;
parameter numwords_a = 1;
parameter clock_enable_input_a = "clocken0";
parameter widthad_b = 1;
parameter width_b = 1;
parameter numwords_b = 1;
parameter address_aclr_b = "aclr0";
parameter address_reg_b = "";
parameter outdata_aclr_b = "aclr0";
parameter outdata_reg_b = "";
parameter clock_enable_input_b = "clocken0";
parameter clock_enable_output_b = "clocken0";

input clock0, clock1;
input [widthad_a-1:0] address_a;
input [width_a-1:0] data_a;
input rden_a;
input wren_a;
input [(width_a/8)-1:0] byteena_a;
input addressstall_a;

output [width_a-1:0] q_a;

input wren_b;
input rden_b;
input [widthad_b-1:0] address_b;
input [width_b-1:0] data_b;
input [(width_b/8)-1:0] byteena_b;
input addressstall_b;

output [width_b-1:0] q_b;

input clocken0;
input clocken1;
input clocken2;
input clocken3;

input aclr0;
input aclr1;

output eccstatus;

endmodule

(* blackbox *)
module cyclonev_mlab_cell(portaaddr, portadatain, portbaddr, portbdataout, ena0, clk0, clk1);

parameter logical_ram_name = "";
parameter logical_ram_depth = 32;
parameter logical_ram_width = 20;
parameter mixed_port_feed_through_mode = "new";
parameter first_bit_number = 0;
parameter first_address = 0;
parameter last_address = 31;
parameter address_width = 5;
parameter data_width = 1;
parameter byte_enable_mask_width = 1;
parameter port_b_data_out_clock = "NONE";
parameter [639:0] mem_init0 = 640'b0;

input [address_width-1:0] portaaddr, portbaddr;
input [data_width-1:0] portadatain;
output [data_width-1:0] portbdataout;
input ena0, clk0, clk1;

endmodule

(* blackbox *)
module cyclonev_mac(ax, ay, resulta);

parameter ax_width = 9;
parameter signed_max = "true";
parameter ay_scan_in_width = 9;
parameter signed_may = "true";
parameter result_a_width = 18;
parameter operation_mode = "M9x9";

input [ax_width-1:0] ax;
input [ay_scan_in_width-1:0] ay;
output [result_a_width-1:0] resulta;

endmodule

(* blackbox *)
module cyclone10gx_mac(ax, ay, resulta);

parameter ax_width = 18;
parameter signed_max = "true";
parameter ay_scan_in_width = 18;
parameter signed_may = "true";
parameter result_a_width = 36;
parameter operation_mode = "M18X18_FULL";

input [ax_width-1:0] ax;
input [ay_scan_in_width-1:0] ay;
output [result_a_width-1:0] resulta;

endmodule

(* blackbox *)
module cyclonev_ram_block(portaaddr, portadatain, portawe, portbaddr, portbdataout, portbre, clk0);

parameter operation_mode = "dual_port";
parameter logical_ram_name = "";
parameter port_a_address_width = 10;
parameter port_a_data_width = 10;
parameter port_a_logical_ram_depth = 1024;
parameter port_a_logical_ram_width = 10;
parameter port_a_first_address = 0;
parameter port_a_last_address = 1023;
parameter port_a_first_bit_number = 0;
parameter port_b_address_width = 10;
parameter port_b_data_width = 10;
parameter port_b_logical_ram_depth = 1024;
parameter port_b_logical_ram_width = 10;
parameter port_b_first_address = 0;
parameter port_b_last_address = 1023;
parameter port_b_first_bit_number = 0;
parameter port_b_address_clock = "clock0";
parameter port_b_read_enable_clock = "clock0";
parameter mem_init0 = "";
parameter mem_init1 = "";
parameter mem_init2 = "";
parameter mem_init3 = "";
parameter mem_init4 = "";

input [port_a_address_width-1:0] portaaddr;
input [port_b_address_width-1:0] portbaddr;
input [port_a_data_width-1:0] portadatain;
output [port_b_data_width-1:0] portbdataout;
input clk0, portawe, portbre;

endmodule

(* blackbox *)
module cyclone10gx_io_ibuf(i, ibar, dynamicterminationcontrol, o);

parameter differential_mode ="false";
parameter bus_hold = "false";
parameter simulate_z_as = "Z";
parameter lpm_type = "cyclone10gx_io_ibuf";

(* iopad_external_pin *) input i;
(* iopad_external_pin *) input ibar;
input dynamicterminationcontrol;
output o;

endmodule

(* blackbox *)
module cyclone10gx_io_obuf(i, oe, dynamicterminationcontrol, seriesterminationcontrol, parallelterminationcontrol, devoe, o, obar);

parameter open_drain_output = "false";
parameter bus_hold = "false";
parameter shift_series_termination_control = "false";
parameter sim_dynamic_termination_control_is_connected = "false";
parameter lpm_type = "cyclone10gx_io_obuf";

input i;
input oe;
input devoe;
input dynamicterminationcontrol;
input [15:0] seriesterminationcontrol;
input [15:0] parallelterminationcontrol;
(* iopad_external_pin *) output o;
(* iopad_external_pin *) output obar;

endmodule

(* blackbox *)
module cyclonev_clkena(inclk, ena, enaout, outclk);

parameter clock_type = "auto";
parameter ena_register_mode = "always enabled";
parameter lpm_type = "cyclonev_clkena";
parameter ena_register_power_up = "high";
parameter disable_mode = "low";
parameter test_syn = "high";

input inclk;
input ena;
output enaout;
output outclk;

endmodule

(* blackbox *)
module cyclone10gx_clkena(inclk, ena, enaout, outclk);

parameter clock_type = "auto";
parameter ena_register_mode = "always enabled";
parameter lpm_type = "cyclone10gx_clkena";
parameter ena_register_power_up = "high";
parameter disable_mode = "low";
parameter test_syn = "high";

input inclk;
input ena;
output enaout;
output outclk;

endmodule

// Internal interfaces
(* keep *)
module cyclonev_oscillator(oscena, clkout, clkout1);

input oscena;
output clkout;
output clkout1;

endmodule

// HPS interfaces
(* keep *)
module cyclonev_hps_interface_mpu_general_purpose(gp_in, gp_out);

input [31:0] gp_in;
output [31:0] gp_out;

endmodule
`,"mem_sim.v":`// The MLAB
// --------
// In addition to Logic Array Blocks (LABs) that contain ten Adaptive Logic
// Modules (ALMs, see alm_sim.v), the Cyclone V also contains
// Memory/Logic Array Blocks (MLABs) that can act as either ten ALMs, or utilise
// the memory the ALM uses to store the look-up table data for general usage,
// producing a 32 address by 20-bit block of memory. MLABs are spread out
// around the chip, so they can be placed near where they are needed, rather than
// being comparatively limited in placement for a deep but narrow memory such as
// the M10K memory block.
//
// MLABs are used mainly for shallow but wide memories, such as CPU register
// files (which have perhaps 32 registers that are comparatively wide (16/32-bit))
// or shift registers (by using the output of the Nth bit as input for the N+1th
// bit).
//
// For historical reasons a MISTRAL_MLAB cell represents a 32 address by 1-bit cell,
// and 20 of them represent a physical MLAB.
//
// How the MLAB works
// ------------------
// MLABs are poorly documented, so the following information is based mainly
// on the simulation model and my knowledge of how memories like these work.
// Additionally, note that the ports of MISTRAL_MLAB are the ones auto-generated
// by the Yosys \`memory_bram\` pass, and it doesn't make sense to me to use
// \`techmap\` just for the sake of renaming the cell ports.
//
// The MLAB can be initialised to any value.
//
// The MLAB takes in data from A1DATA at the rising edge of CLK1, and if A1EN
// is high, writes it to the address in A1ADDR. A1EN can therefore be used to
// conditionally write data to the MLAB.
//
// Simultaneously, the MLAB reads data from B1ADDR, and outputs it to B1DATA,
// asynchronous to CLK1 and ignoring A1EN. If a synchronous read is needed
// then the output can be fed to embedded flops.

// The vendor sim model outputs 'x for a very short period (a few
// combinational delta cycles) after each write. This has been omitted from
// the following model because it's very difficult to trigger this in practice
// as clock cycles will be much longer than any potential blip of 'x, so the
// model can be treated as always returning a defined result.

(* abc9_box, lib_whitebox *)
module MISTRAL_MLAB(input [4:0] A1ADDR, input A1DATA, A1EN,
    (* clkbuf_sink *) input CLK1,
    input [4:0] B1ADDR, output B1DATA);

reg [31:0] mem = 32'b0;

\`ifdef cyclonev
specify
    $setup(A1ADDR, posedge CLK1, 86);
    $setup(A1DATA, posedge CLK1, 86);
    $setup(A1EN, posedge CLK1, 86);

    (B1ADDR[0] => B1DATA) = 487;
    (B1ADDR[1] => B1DATA) = 475;
    (B1ADDR[2] => B1DATA) = 382;
    (B1ADDR[3] => B1DATA) = 284;
    (B1ADDR[4] => B1DATA) = 96;
endspecify
\`endif

always @(posedge CLK1)
    if (A1EN) mem[A1ADDR] <= A1DATA;

assign B1DATA = mem[B1ADDR];

endmodule

// The M10K
// --------
// TODO

module MISTRAL_M10K(CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

parameter INIT = 0;

parameter CFG_ABITS = 10;
parameter CFG_DBITS = 10;

(* clkbuf_sink *) input CLK1;
input [CFG_ABITS-1:0] A1ADDR, B1ADDR;
input [CFG_DBITS-1:0] A1DATA;
input A1EN, B1EN;
output reg [CFG_DBITS-1:0] B1DATA;

reg [2**CFG_ABITS * CFG_DBITS - 1 : 0] mem = INIT;

\`ifdef cyclonev
specify
    $setup(A1ADDR, posedge CLK1, 125);
    $setup(A1DATA, posedge CLK1, 97);
    $setup(A1EN, posedge CLK1, 140);
    $setup(B1ADDR, posedge CLK1, 125);
    $setup(B1EN, posedge CLK1, 161);

    if (B1EN) (posedge CLK1 => (B1DATA : A1DATA)) = 1004;
endspecify
\`endif

always @(posedge CLK1) begin
    if (!A1EN)
        mem[(A1ADDR + 1) * CFG_DBITS - 1 : A1ADDR * CFG_DBITS] <= A1DATA;

    if (B1EN)
        B1DATA <= mem[(B1ADDR + 1) * CFG_DBITS - 1 : B1ADDR * CFG_DBITS];
end

endmodule
`,"misc_sim.v":`module MISTRAL_IB((* iopad_external_pin *)  input PAD, output O);
	assign O = PAD;
endmodule

module MISTRAL_OB((* iopad_external_pin *)  output PAD, input I);
	assign PAD = I;
endmodule

module MISTRAL_IO((* iopad_external_pin *)  inout PAD, input I, input OE, output O);
	assign PAD = OE ? I : 1'bz;
	assign O = PAD;
endmodule

// Eventually, we should support clock enables and model them here too.
// For now, CLKENA is used as a basic entry point to global routing.
module MISTRAL_CLKBUF (
	input A,
	(* clkbuf_driver *) output Q
);
	assign Q = A;
endmodule`},cyclonev:{"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone V devices Input Buffer Primitive */
module cyclonev_io_ibuf
  (output o,
   (* iopad_external_pin *) input i,
   (* iopad_external_pin *) input ibar,
   input dynamicterminationcontrol);

   parameter differential_mode = "false";
   parameter bus_hold = "false";
   parameter simulate_z_as = "Z";
   parameter lpm_type = "cyclonev_io_ibuf";

   assign o    = i;
endmodule // cyclonev_io_ibuf

/* Altera Cyclone V devices Output Buffer Primitive */
module cyclonev_io_obuf
  ((* iopad_external_pin *) output o,
   input i, oe, dynamicterminationcontrol,
   input [15:0] seriesterminationcontrol, parallelterminationcontrol,
   input devoe,
   (* iopad_external_pin *) output obar);

   parameter open_drain_output = "false";
   parameter bus_hold = "false";
   parameter shift_series_termination_control = "false";
   parameter sim_dynamic_termination_control_is_connected = "false";
   parameter lpm_type = "cyclonev_io_obuf";

   assign o  = oe ? i : 1'bz;
endmodule // cyclonev_io_obuf

/* Altera Cyclone V LUT Primitive */
module cyclonev_lcell_comb
  (output combout, cout, sumout, shareout,
   input dataa, datab, datac, datad,
   input datae, dataf, datag, cin,
   input sharein);

   parameter lut_mask      = 64'hFFFFFFFFFFFFFFFF;
   parameter dont_touch    = "off";
   parameter lpm_type      = "cyclonev_lcell_comb";
   parameter shared_arith  = "off";
   parameter extended_lut  = "off";

   // Internal variables
   // Sub mask for fragmented LUTs
   wire [15:0] mask_a, mask_b, mask_c, mask_d;
   // Independent output for fragmented LUTs
   wire        output_0, output_1, output_2, output_3;
   // Extended mode uses mux to define the output
   wire        mux_0, mux_1;
   // Input for hold the shared LUT mode value
   wire        shared_lut_alm;

   // Simulation model of 4-input LUT
   function lut4;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3   = datad ? mask[15:8] : mask[7:0];
         s2   = datac ?   s3[7:4]  :   s3[3:0];
         s1   = datab ?   s2[3:2]  :   s2[1:0];
         lut4 = dataa ? s1[1] : s1[0];
      end
   endfunction // lut4

   // Simulation model of 5-input LUT
   function lut5;
      input [31:0] mask; // wp-01003.pdf, page 3: "a 5-LUT can be built with two 4-LUTs and a multiplexer.
      input        dataa, datab, datac, datad, datae;
      reg          upper_lut_value;
      reg          lower_lut_value;
      begin
         upper_lut_value = lut4(mask[31:16], dataa, datab, datac, datad);
         lower_lut_value = lut4(mask[15:0], dataa, datab, datac, datad);
         lut5            = (datae) ? upper_lut_value : lower_lut_value;
      end
   endfunction // lut5

   // Simulation model of 6-input LUT
   function lut6;
      input [63:0] mask;
      input        dataa, datab, datac, datad, datae, dataf;
      reg          upper_lut_value;
      reg          lower_lut_value;
      reg          out_0, out_1, out_2, out_3;
      begin
         upper_lut_value = lut5(mask[63:32], dataa, datab, datac, datad, datae);
         lower_lut_value = lut5(mask[31:0], dataa, datab, datac, datad, datae);
         lut6            = (dataf) ?  upper_lut_value : lower_lut_value;
      end
   endfunction // lut6

   assign {mask_a, mask_b, mask_c, mask_d} = {lut_mask[15:0], lut_mask[31:16], lut_mask[47:32], lut_mask[63:48]};
\`ifdef ADVANCED_ALM
   always @(*) begin
      if(extended_lut == "on")
        shared_lut_alm = datag;
      else
        shared_lut_alm = datac;
      // Build the ALM behaviour
      out_0 = lut4(mask_a, dataa, datab, datac, datad);
      out_1 = lut4(mask_b, dataa, datab, shared_lut_alm, datad);
      out_2 = lut4(mask_c, dataa, datab, datac, datad);
      out_3 = lut4(mask_d, dataa, datab, shared_lut_alm, datad);
   end
\`else
   \`ifdef DEBUG
       initial $display("Advanced ALM lut combine is not implemented yet");
   \`endif
\`endif
endmodule // cyclonev_lcell_comb


/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas
`}},lattice:{"arith_map_ccu2c.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ccu2c_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2C #(
			.INIT0(16'b1001011010101010),
			.INIT1(16'b1001011010101010),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
	   ) ccu2c_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"arith_map_ccu2d.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ccu2d_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2D #(
			.INIT0(16'b0101_1010_1001_0110),
			.INIT1(16'b0101_1010_1001_0110),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
		) ccu2d_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b0),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b0),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams_16kd.txt":`ram block $__DP16KD_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		wrbe_separate;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__PDPW16KD_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 36;
		clock anyedge;
		clken;
	}
}
`,"brams_8kc.txt":`ram block $__DP8KC_ {
	abits 13;
	widths 1 2 4 9 per_port;
	cost 64;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__PDPW8KC_ {
	abits 13;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 64;
	init no_undef;
	port sr "R" {
		# width 2 cannot be supported because of quirks
		# of the primitive, and memlib requires us to
		# remove width 1 as well
		width 4 9 18;
		clock posedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 18;
		clock posedge;
		clken;
	}
}
`,"brams_map_16kd.v":`module $__DP16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_A_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "CLKB" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),
	.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.ADA13(PORT_A_ADDR[13]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DIA9(DIA[9]),
	.DIA10(DIA[10]),
	.DIA11(DIA[11]),
	.DIA12(DIA[12]),
	.DIA13(DIA[13]),
	.DIA14(DIA[14]),
	.DIA15(DIA[15]),
	.DIA16(DIA[16]),
	.DIA17(DIA[17]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),
	.DOA9(DOA[9]),
	.DOA10(DOA[10]),
	.DOA11(DOA[11]),
	.DOA12(DOA[12]),
	.DOA13(DOA[13]),
	.DOA14(DOA[14]),
	.DOA15(DOA[15]),
	.DOA16(DOA[16]),
	.DOA17(DOA[17]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),
	.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.ADB13(PORT_B_ADDR[13]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DIB9(DIB[9]),
	.DIB10(DIB[10]),
	.DIB11(DIB[11]),
	.DIB12(DIB[12]),
	.DIB13(DIB[13]),
	.DIB14(DIB[14]),
	.DIB15(DIB[15]),
	.DIB16(DIB[16]),
	.DIB17(DIB[17]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
	.DOB9(DOB[9]),
	.DOB10(DOB[10]),
	.DOB11(DOB[11]),
	.DOB12(DOB[12]),
	.DOB13(DOB[13]),
	.DOB14(DOB[14]),
	.DOB15(DOB[15]),
	.DOB16(DOB[16]),
	.DOB17(DOB[17]),
);

endmodule


module $__PDPW16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 36;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_W_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "CLKB" : "INV"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),
	.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.ADA13(PORT_W_ADDR[13]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIA9(DI[9]),
	.DIA10(DI[10]),
	.DIA11(DI[11]),
	.DIA12(DI[12]),
	.DIA13(DI[13]),
	.DIA14(DI[14]),
	.DIA15(DI[15]),
	.DIA16(DI[16]),
	.DIA17(DI[17]),
	.DIB0(DI[18]),
	.DIB1(DI[19]),
	.DIB2(DI[20]),
	.DIB3(DI[21]),
	.DIB4(DI[22]),
	.DIB5(DI[23]),
	.DIB6(DI[24]),
	.DIB7(DI[25]),
	.DIB8(DI[26]),
	.DIB9(DI[27]),
	.DIB10(DI[28]),
	.DIB11(DI[29]),
	.DIB12(DI[30]),
	.DIB13(DI[31]),
	.DIB14(DI[32]),
	.DIB15(DI[33]),
	.DIB16(DI[34]),
	.DIB17(DI[35]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.ADB13(PORT_R_ADDR[13]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOA9(DO[9]),
	.DOA10(DO[10]),
	.DOA11(DO[11]),
	.DOA12(DO[12]),
	.DOA13(DO[13]),
	.DOA14(DO[14]),
	.DOA15(DO[15]),
	.DOA16(DO[16]),
	.DOA17(DO[17]),
	.DOB0(DO[18]),
	.DOB1(DO[19]),
	.DOB2(DO[20]),
	.DOB3(DO[21]),
	.DOB4(DO[22]),
	.DOB5(DO[23]),
	.DOB6(DO[24]),
	.DOB7(DO[25]),
	.DOB8(DO[26]),
	.DOB9(DO[27]),
	.DOB10(DO[28]),
	.DOB11(DO[29]),
	.DOB12(DO[30]),
	.DOB13(DO[31]),
	.DOB14(DO[32]),
	.DOB15(DO[33]),
	.DOB16(DO[34]),
	.DOB17(DO[35]),
);

endmodule
`,"brams_map_8kc.v":`module $__DP8KC_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [12:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [12:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [8:0] DOA;
wire [8:0] DOB;
wire [8:0] DIA;
wire [8:0] DIB;

case(PORT_A_WIDTH)
	1: assign DIA = {7'bx, PORT_A_WR_DATA[0], 1'bx};
	2: assign DIA = {3'bx, PORT_A_WR_DATA[1], 2'bx, PORT_A_WR_DATA[0], 2'bx};
	default: assign DIA = PORT_A_WR_DATA;
endcase

case(PORT_B_WIDTH)
	1: assign DIB = {7'bx, PORT_B_WR_DATA[0], 1'bx};
	2: assign DIB = {3'bx, PORT_B_WR_DATA[1], 2'bx, PORT_B_WR_DATA[0], 2'bx};
	default: assign DIB = PORT_B_WR_DATA;
endcase

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP8KC #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WR_EN),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 9 ? 1'b1 : PORT_A_ADDR[0]),
	.ADA1(PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WR_EN),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 9 ? 1'b1 : PORT_B_ADDR[0]),
	.ADB1(PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
);

endmodule


module $__PDPW8KC_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 18;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [12:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 18;
parameter PORT_W_WR_EN_WIDTH = 2;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [12:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DI = PORT_W_WR_DATA;
wire [17:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];

DP8KC #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 9 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_ADDR[2]),
	.ADA3(PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIB0(DI[9]),
	.DIB1(DI[10]),
	.DIB2(DI[11]),
	.DIB3(DI[12]),
	.DIB4(DI[13]),
	.DIB5(DI[14]),
	.DIB6(DI[15]),
	.DIB7(DI[16]),
	.DIB8(DI[17]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOB0(DO[9]),
	.DOB1(DO[10]),
	.DOB2(DO[11]),
	.DOB3(DO[12]),
	.DOB4(DO[13]),
	.DOB5(DO[14]),
	.DOB6(DO[15]),
	.DOB7(DO[16]),
	.DOB8(DO[17]),
);

endmodule
`,"ccu2c_sim.vh":`// ---------------------------------------
(* abc9_box, lib_whitebox *)
module CCU2C(
	(* abc9_carry *)
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	(* abc9_carry *)
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);

	specify
		(A0 => S0) = 379;
		(B0 => S0) = 379;
		(C0 => S0) = 275;
		(D0 => S0) = 141;
		(CIN => S0) = 257;
		(A0 => S1) = 630;
		(B0 => S1) = 630;
		(C0 => S1) = 526;
		(D0 => S1) = 392;
		(A1 => S1) = 379;
		(B1 => S1) = 379;
		(C1 => S1) = 275;
		(D1 => S1) = 141;
		(CIN => S1) = 273;
		(A0 => COUT) = 516;
		(B0 => COUT) = 516;
		(C0 => COUT) = 412;
		(D0 => COUT) = 278;
		(A1 => COUT) = 516;
		(B1 => COUT) = 516;
		(C1 => COUT) = 412;
		(D1 => COUT) = 278;
		(CIN => COUT) = 43;
	endspecify
endmodule
`,"ccu2d_sim.vh":`// ---------------------------------------
(* lib_whitebox *)
module CCU2D (
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(~INIT0[15:12])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(~INIT1[15:12])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);
endmodule
`,"cells_bb_ecp5.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *)
module PUR (...);
    parameter RST_PULSE = 1;
    input PUR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP16KD (...);
    parameter DATA_WIDTH_A = 18;
    parameter DATA_WIDTH_B = 18;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter GSR = "ENABLED";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INIT_DATA = "STATIC";
    input DIA17;
    input DIA16;
    input DIA15;
    input DIA14;
    input DIA13;
    input DIA12;
    input DIA11;
    input DIA10;
    input DIA9;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA13;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB17;
    input DIB16;
    input DIB15;
    input DIB14;
    input DIB13;
    input DIB12;
    input DIB11;
    input DIB10;
    input DIB9;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB13;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA17;
    output DOA16;
    output DOA15;
    output DOA14;
    output DOA13;
    output DOA12;
    output DOA11;
    output DOA10;
    output DOA9;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB17;
    output DOB16;
    output DOB15;
    output DOB14;
    output DOB13;
    output DOB12;
    output DOB11;
    output DOB10;
    output DOB9;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW16KD (...);
    parameter DATA_WIDTH_W = 36;
    parameter DATA_WIDTH_R = 36;
    parameter GSR = "ENABLED";
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INIT_DATA = "STATIC";
    input DI35;
    input DI34;
    input DI33;
    input DI32;
    input DI31;
    input DI30;
    input DI29;
    input DI28;
    input DI27;
    input DI26;
    input DI25;
    input DI24;
    input DI23;
    input DI22;
    input DI21;
    input DI20;
    input DI19;
    input DI18;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE3;
    input BE2;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR13;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO35;
    output DO34;
    output DO33;
    output DO32;
    output DO31;
    output DO30;
    output DO29;
    output DO28;
    output DO27;
    output DO26;
    output DO25;
    output DO24;
    output DO23;
    output DO22;
    output DO21;
    output DO20;
    output DO19;
    output DO18;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module MULT18X18D (...);
    parameter REG_INPUTA_CLK = "NONE";
    parameter REG_INPUTA_CE = "CE0";
    parameter REG_INPUTA_RST = "RST0";
    parameter REG_INPUTB_CLK = "NONE";
    parameter REG_INPUTB_CE = "CE0";
    parameter REG_INPUTB_RST = "RST0";
    parameter REG_INPUTC_CLK = "NONE";
    parameter REG_INPUTC_CE = "CE0";
    parameter REG_INPUTC_RST = "RST0";
    parameter REG_PIPELINE_CLK = "NONE";
    parameter REG_PIPELINE_CE = "CE0";
    parameter REG_PIPELINE_RST = "RST0";
    parameter REG_OUTPUT_CLK = "NONE";
    parameter REG_OUTPUT_CE = "CE0";
    parameter REG_OUTPUT_RST = "RST0";
    parameter CLK0_DIV = "ENABLED";
    parameter CLK1_DIV = "ENABLED";
    parameter CLK2_DIV = "ENABLED";
    parameter CLK3_DIV = "ENABLED";
    parameter HIGHSPEED_CLK = "NONE";
    parameter GSR = "ENABLED";
    parameter CAS_MATCH_REG = "FALSE";
    parameter SOURCEB_MODE = "B_SHIFT";
    parameter MULT_BYPASS = "DISABLED";
    parameter RESETMODE = "SYNC";
    input A17;
    input A16;
    input A15;
    input A14;
    input A13;
    input A12;
    input A11;
    input A10;
    input A9;
    input A8;
    input A7;
    input A6;
    input A5;
    input A4;
    input A3;
    input A2;
    input A1;
    input A0;
    input B17;
    input B16;
    input B15;
    input B14;
    input B13;
    input B12;
    input B11;
    input B10;
    input B9;
    input B8;
    input B7;
    input B6;
    input B5;
    input B4;
    input B3;
    input B2;
    input B1;
    input B0;
    input C17;
    input C16;
    input C15;
    input C14;
    input C13;
    input C12;
    input C11;
    input C10;
    input C9;
    input C8;
    input C7;
    input C6;
    input C5;
    input C4;
    input C3;
    input C2;
    input C1;
    input C0;
    input SIGNEDA;
    input SIGNEDB;
    input SOURCEA;
    input SOURCEB;
    input CLK3;
    input CLK2;
    input CLK1;
    input CLK0;
    input CE3;
    input CE2;
    input CE1;
    input CE0;
    input RST3;
    input RST2;
    input RST1;
    input RST0;
    input SRIA17;
    input SRIA16;
    input SRIA15;
    input SRIA14;
    input SRIA13;
    input SRIA12;
    input SRIA11;
    input SRIA10;
    input SRIA9;
    input SRIA8;
    input SRIA7;
    input SRIA6;
    input SRIA5;
    input SRIA4;
    input SRIA3;
    input SRIA2;
    input SRIA1;
    input SRIA0;
    input SRIB17;
    input SRIB16;
    input SRIB15;
    input SRIB14;
    input SRIB13;
    input SRIB12;
    input SRIB11;
    input SRIB10;
    input SRIB9;
    input SRIB8;
    input SRIB7;
    input SRIB6;
    input SRIB5;
    input SRIB4;
    input SRIB3;
    input SRIB2;
    input SRIB1;
    input SRIB0;
    output SROA17;
    output SROA16;
    output SROA15;
    output SROA14;
    output SROA13;
    output SROA12;
    output SROA11;
    output SROA10;
    output SROA9;
    output SROA8;
    output SROA7;
    output SROA6;
    output SROA5;
    output SROA4;
    output SROA3;
    output SROA2;
    output SROA1;
    output SROA0;
    output SROB17;
    output SROB16;
    output SROB15;
    output SROB14;
    output SROB13;
    output SROB12;
    output SROB11;
    output SROB10;
    output SROB9;
    output SROB8;
    output SROB7;
    output SROB6;
    output SROB5;
    output SROB4;
    output SROB3;
    output SROB2;
    output SROB1;
    output SROB0;
    output ROA17;
    output ROA16;
    output ROA15;
    output ROA14;
    output ROA13;
    output ROA12;
    output ROA11;
    output ROA10;
    output ROA9;
    output ROA8;
    output ROA7;
    output ROA6;
    output ROA5;
    output ROA4;
    output ROA3;
    output ROA2;
    output ROA1;
    output ROA0;
    output ROB17;
    output ROB16;
    output ROB15;
    output ROB14;
    output ROB13;
    output ROB12;
    output ROB11;
    output ROB10;
    output ROB9;
    output ROB8;
    output ROB7;
    output ROB6;
    output ROB5;
    output ROB4;
    output ROB3;
    output ROB2;
    output ROB1;
    output ROB0;
    output ROC17;
    output ROC16;
    output ROC15;
    output ROC14;
    output ROC13;
    output ROC12;
    output ROC11;
    output ROC10;
    output ROC9;
    output ROC8;
    output ROC7;
    output ROC6;
    output ROC5;
    output ROC4;
    output ROC3;
    output ROC2;
    output ROC1;
    output ROC0;
    output P35;
    output P34;
    output P33;
    output P32;
    output P31;
    output P30;
    output P29;
    output P28;
    output P27;
    output P26;
    output P25;
    output P24;
    output P23;
    output P22;
    output P21;
    output P20;
    output P19;
    output P18;
    output P17;
    output P16;
    output P15;
    output P14;
    output P13;
    output P12;
    output P11;
    output P10;
    output P9;
    output P8;
    output P7;
    output P6;
    output P5;
    output P4;
    output P3;
    output P2;
    output P1;
    output P0;
    output SIGNEDP;
endmodule

(* blackbox *)
module ALU54B (...);
    parameter REG_INPUTC0_CLK = "NONE";
    parameter REG_INPUTC0_CE = "CE0";
    parameter REG_INPUTC0_RST = "RST0";
    parameter REG_INPUTC1_CLK = "NONE";
    parameter REG_INPUTC1_CE = "CE0";
    parameter REG_INPUTC1_RST = "RST0";
    parameter REG_OPCODEOP0_0_CLK = "NONE";
    parameter REG_OPCODEOP0_0_CE = "CE0";
    parameter REG_OPCODEOP0_0_RST = "RST0";
    parameter REG_OPCODEOP1_0_CLK = "NONE";
    parameter REG_OPCODEOP0_1_CLK = "NONE";
    parameter REG_OPCODEOP0_1_CE = "CE0";
    parameter REG_OPCODEOP0_1_RST = "RST0";
    parameter REG_OPCODEOP1_1_CLK = "NONE";
    parameter REG_OPCODEIN_0_CLK = "NONE";
    parameter REG_OPCODEIN_0_CE = "CE0";
    parameter REG_OPCODEIN_0_RST = "RST0";
    parameter REG_OPCODEIN_1_CLK = "NONE";
    parameter REG_OPCODEIN_1_CE = "CE0";
    parameter REG_OPCODEIN_1_RST = "RST0";
    parameter REG_OUTPUT0_CLK = "NONE";
    parameter REG_OUTPUT0_CE = "CE0";
    parameter REG_OUTPUT0_RST = "RST0";
    parameter REG_OUTPUT1_CLK = "NONE";
    parameter REG_OUTPUT1_CE = "CE0";
    parameter REG_OUTPUT1_RST = "RST0";
    parameter REG_FLAG_CLK = "NONE";
    parameter REG_FLAG_CE = "CE0";
    parameter REG_FLAG_RST = "RST0";
    parameter MCPAT_SOURCE = "STATIC";
    parameter MASKPAT_SOURCE = "STATIC";
    parameter MASK01 = "0x00000000000000";
    parameter REG_INPUTCFB_CLK = "NONE";
    parameter REG_INPUTCFB_CE = "CE0";
    parameter REG_INPUTCFB_RST = "RST0";
    parameter CLK0_DIV = "ENABLED";
    parameter CLK1_DIV = "ENABLED";
    parameter CLK2_DIV = "ENABLED";
    parameter CLK3_DIV = "ENABLED";
    parameter MCPAT = "0x00000000000000";
    parameter MASKPAT = "0x00000000000000";
    parameter RNDPAT = "0x00000000000000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter MULT9_MODE = "DISABLED";
    parameter FORCE_ZERO_BARREL_SHIFT = "DISABLED";
    parameter LEGACY = "DISABLED";
    input CE3;
    input CE2;
    input CE1;
    input CE0;
    input CLK3;
    input CLK2;
    input CLK1;
    input CLK0;
    input RST3;
    input RST2;
    input RST1;
    input RST0;
    input SIGNEDIA;
    input SIGNEDIB;
    input SIGNEDCIN;
    input A35;
    input A34;
    input A33;
    input A32;
    input A31;
    input A30;
    input A29;
    input A28;
    input A27;
    input A26;
    input A25;
    input A24;
    input A23;
    input A22;
    input A21;
    input A20;
    input A19;
    input A18;
    input A17;
    input A16;
    input A15;
    input A14;
    input A13;
    input A12;
    input A11;
    input A10;
    input A9;
    input A8;
    input A7;
    input A6;
    input A5;
    input A4;
    input A3;
    input A2;
    input A1;
    input A0;
    input B35;
    input B34;
    input B33;
    input B32;
    input B31;
    input B30;
    input B29;
    input B28;
    input B27;
    input B26;
    input B25;
    input B24;
    input B23;
    input B22;
    input B21;
    input B20;
    input B19;
    input B18;
    input B17;
    input B16;
    input B15;
    input B14;
    input B13;
    input B12;
    input B11;
    input B10;
    input B9;
    input B8;
    input B7;
    input B6;
    input B5;
    input B4;
    input B3;
    input B2;
    input B1;
    input B0;
    input C53;
    input C52;
    input C51;
    input C50;
    input C49;
    input C48;
    input C47;
    input C46;
    input C45;
    input C44;
    input C43;
    input C42;
    input C41;
    input C40;
    input C39;
    input C38;
    input C37;
    input C36;
    input C35;
    input C34;
    input C33;
    input C32;
    input C31;
    input C30;
    input C29;
    input C28;
    input C27;
    input C26;
    input C25;
    input C24;
    input C23;
    input C22;
    input C21;
    input C20;
    input C19;
    input C18;
    input C17;
    input C16;
    input C15;
    input C14;
    input C13;
    input C12;
    input C11;
    input C10;
    input C9;
    input C8;
    input C7;
    input C6;
    input C5;
    input C4;
    input C3;
    input C2;
    input C1;
    input C0;
    input CFB53;
    input CFB52;
    input CFB51;
    input CFB50;
    input CFB49;
    input CFB48;
    input CFB47;
    input CFB46;
    input CFB45;
    input CFB44;
    input CFB43;
    input CFB42;
    input CFB41;
    input CFB40;
    input CFB39;
    input CFB38;
    input CFB37;
    input CFB36;
    input CFB35;
    input CFB34;
    input CFB33;
    input CFB32;
    input CFB31;
    input CFB30;
    input CFB29;
    input CFB28;
    input CFB27;
    input CFB26;
    input CFB25;
    input CFB24;
    input CFB23;
    input CFB22;
    input CFB21;
    input CFB20;
    input CFB19;
    input CFB18;
    input CFB17;
    input CFB16;
    input CFB15;
    input CFB14;
    input CFB13;
    input CFB12;
    input CFB11;
    input CFB10;
    input CFB9;
    input CFB8;
    input CFB7;
    input CFB6;
    input CFB5;
    input CFB4;
    input CFB3;
    input CFB2;
    input CFB1;
    input CFB0;
    input MA35;
    input MA34;
    input MA33;
    input MA32;
    input MA31;
    input MA30;
    input MA29;
    input MA28;
    input MA27;
    input MA26;
    input MA25;
    input MA24;
    input MA23;
    input MA22;
    input MA21;
    input MA20;
    input MA19;
    input MA18;
    input MA17;
    input MA16;
    input MA15;
    input MA14;
    input MA13;
    input MA12;
    input MA11;
    input MA10;
    input MA9;
    input MA8;
    input MA7;
    input MA6;
    input MA5;
    input MA4;
    input MA3;
    input MA2;
    input MA1;
    input MA0;
    input MB35;
    input MB34;
    input MB33;
    input MB32;
    input MB31;
    input MB30;
    input MB29;
    input MB28;
    input MB27;
    input MB26;
    input MB25;
    input MB24;
    input MB23;
    input MB22;
    input MB21;
    input MB20;
    input MB19;
    input MB18;
    input MB17;
    input MB16;
    input MB15;
    input MB14;
    input MB13;
    input MB12;
    input MB11;
    input MB10;
    input MB9;
    input MB8;
    input MB7;
    input MB6;
    input MB5;
    input MB4;
    input MB3;
    input MB2;
    input MB1;
    input MB0;
    input CIN53;
    input CIN52;
    input CIN51;
    input CIN50;
    input CIN49;
    input CIN48;
    input CIN47;
    input CIN46;
    input CIN45;
    input CIN44;
    input CIN43;
    input CIN42;
    input CIN41;
    input CIN40;
    input CIN39;
    input CIN38;
    input CIN37;
    input CIN36;
    input CIN35;
    input CIN34;
    input CIN33;
    input CIN32;
    input CIN31;
    input CIN30;
    input CIN29;
    input CIN28;
    input CIN27;
    input CIN26;
    input CIN25;
    input CIN24;
    input CIN23;
    input CIN22;
    input CIN21;
    input CIN20;
    input CIN19;
    input CIN18;
    input CIN17;
    input CIN16;
    input CIN15;
    input CIN14;
    input CIN13;
    input CIN12;
    input CIN11;
    input CIN10;
    input CIN9;
    input CIN8;
    input CIN7;
    input CIN6;
    input CIN5;
    input CIN4;
    input CIN3;
    input CIN2;
    input CIN1;
    input CIN0;
    input OP10;
    input OP9;
    input OP8;
    input OP7;
    input OP6;
    input OP5;
    input OP4;
    input OP3;
    input OP2;
    input OP1;
    input OP0;
    output R53;
    output R52;
    output R51;
    output R50;
    output R49;
    output R48;
    output R47;
    output R46;
    output R45;
    output R44;
    output R43;
    output R42;
    output R41;
    output R40;
    output R39;
    output R38;
    output R37;
    output R36;
    output R35;
    output R34;
    output R33;
    output R32;
    output R31;
    output R30;
    output R29;
    output R28;
    output R27;
    output R26;
    output R25;
    output R24;
    output R23;
    output R22;
    output R21;
    output R20;
    output R19;
    output R18;
    output R17;
    output R16;
    output R15;
    output R14;
    output R13;
    output R12;
    output R11;
    output R10;
    output R9;
    output R8;
    output R7;
    output R6;
    output R5;
    output R4;
    output R3;
    output R2;
    output R1;
    output R0;
    output CO53;
    output CO52;
    output CO51;
    output CO50;
    output CO49;
    output CO48;
    output CO47;
    output CO46;
    output CO45;
    output CO44;
    output CO43;
    output CO42;
    output CO41;
    output CO40;
    output CO39;
    output CO38;
    output CO37;
    output CO36;
    output CO35;
    output CO34;
    output CO33;
    output CO32;
    output CO31;
    output CO30;
    output CO29;
    output CO28;
    output CO27;
    output CO26;
    output CO25;
    output CO24;
    output CO23;
    output CO22;
    output CO21;
    output CO20;
    output CO19;
    output CO18;
    output CO17;
    output CO16;
    output CO15;
    output CO14;
    output CO13;
    output CO12;
    output CO11;
    output CO10;
    output CO9;
    output CO8;
    output CO7;
    output CO6;
    output CO5;
    output CO4;
    output CO3;
    output CO2;
    output CO1;
    output CO0;
    output EQZ;
    output EQZM;
    output EQOM;
    output EQPAT;
    output EQPATB;
    output OVER;
    output UNDER;
    output OVERUNDER;
    output SIGNEDR;
endmodule

(* blackbox *)
module CLKDIVF (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input CLKI;
    input RST;
    input ALIGNWD;
    output CDIVX;
endmodule

(* blackbox *)
module PCSCLKDIV (...);
    parameter GSR = "DISABLED";
    input CLKI;
    input RST;
    input SEL2;
    input SEL1;
    input SEL0;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCSC (...);
    parameter DCSMODE = "POS";
    input CLK1;
    input CLK0;
    input SEL1;
    input SEL0;
    input MODESEL;
    output DCSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *)
module ECLKSYNCB (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DELAYF (...);
    parameter DEL_MODE = "USER_DEFINED";
    parameter DEL_VALUE = 0;
    input A;
    input LOADN;
    input MOVE;
    input DIRECTION;
    output Z;
    output CFLAG;
endmodule

(* blackbox *)
module DELAYG (...);
    parameter DEL_MODE = "USER_DEFINED";
    parameter DEL_VALUE = 0;
    input A;
    output Z;
endmodule

(* blackbox *) (* keep *)
module USRMCLK (...);
    input USRMCLKI;
    input USRMCLKTS;
endmodule

(* blackbox *)
module DQSBUFM (...);
    parameter DQS_LI_DEL_VAL = 4;
    parameter DQS_LI_DEL_ADJ = "FACTORYONLY";
    parameter DQS_LO_DEL_VAL = 0;
    parameter DQS_LO_DEL_ADJ = "FACTORYONLY";
    parameter GSR = "ENABLED";
    input DQSI;
    input READ1;
    input READ0;
    input READCLKSEL2;
    input READCLKSEL1;
    input READCLKSEL0;
    input DDRDEL;
    input ECLK;
    input SCLK;
    input RST;
    input DYNDELAY7;
    input DYNDELAY6;
    input DYNDELAY5;
    input DYNDELAY4;
    input DYNDELAY3;
    input DYNDELAY2;
    input DYNDELAY1;
    input DYNDELAY0;
    input PAUSE;
    input RDLOADN;
    input RDMOVE;
    input RDDIRECTION;
    input WRLOADN;
    input WRMOVE;
    input WRDIRECTION;
    output DQSR90;
    output DQSW;
    output DQSW270;
    output RDPNTR2;
    output RDPNTR1;
    output RDPNTR0;
    output WRPNTR2;
    output WRPNTR1;
    output WRPNTR0;
    output DATAVALID;
    output BURSTDET;
    output RDCFLAG;
    output WRCFLAG;
endmodule

(* blackbox *)
module DDRDLLA (...);
    parameter FORCE_MAX_DELAY = "NO";
    parameter GSR = "ENABLED";
    input CLK;
    input RST;
    input UDDCNTLN;
    input FREEZE;
    output DDRDEL;
    output LOCK;
    output DCNTL7;
    output DCNTL6;
    output DCNTL5;
    output DCNTL4;
    output DCNTL3;
    output DCNTL2;
    output DCNTL1;
    output DCNTL0;
endmodule

(* blackbox *)
module DLLDELD (...);
    input A;
    input DDRDEL;
    input LOADN;
    input MOVE;
    input DIRECTION;
    output Z;
    output CFLAG;
endmodule

(* blackbox *)
module IDDRX1F (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input RST;
    output Q0;
    output Q1;
endmodule

(* blackbox *)
module IDDRX2F (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input ECLK;
    input RST;
    input ALIGNWD;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
endmodule

(* blackbox *)
module IDDR71B (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input ECLK;
    input RST;
    input ALIGNWD;
    output Q6;
    output Q5;
    output Q4;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
endmodule

(* blackbox *)
module IDDRX2DQA (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input DQSR90;
    input D;
    input RST;
    input RDPNTR2;
    input RDPNTR1;
    input RDPNTR0;
    input WRPNTR2;
    input WRPNTR1;
    input WRPNTR0;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
    output QWL;
endmodule

(* blackbox *)
module ODDRX1F (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input RST;
    input D0;
    input D1;
    output Q;
endmodule

(* blackbox *)
module ODDRX2F (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input RST;
    input D3;
    input D2;
    input D1;
    input D0;
    output Q;
endmodule

(* blackbox *)
module ODDR71B (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input RST;
    input D6;
    input D5;
    input D4;
    input D3;
    input D2;
    input D1;
    input D0;
    output Q;
endmodule

(* blackbox *)
module OSHX2A (...);
    parameter GSR = "ENABLED";
    input D1;
    input D0;
    input SCLK;
    input ECLK;
    input RST;
    output Q;
endmodule

(* blackbox *)
module TSHX2DQA (...);
    parameter GSR = "ENABLED";
    parameter REGSET = "SET";
    input T1;
    input T0;
    input SCLK;
    input ECLK;
    input DQSW270;
    input RST;
    output Q;
endmodule

(* blackbox *)
module TSHX2DQSA (...);
    parameter GSR = "ENABLED";
    parameter REGSET = "SET";
    input T1;
    input T0;
    input SCLK;
    input ECLK;
    input DQSW;
    input RST;
    output Q;
endmodule

(* blackbox *)
module ODDRX2DQA (...);
    parameter GSR = "ENABLED";
    input D3;
    input D2;
    input D1;
    input D0;
    input DQSW270;
    input SCLK;
    input ECLK;
    input RST;
    output Q;
endmodule

(* blackbox *)
module ODDRX2DQSB (...);
    parameter GSR = "ENABLED";
    input D3;
    input D2;
    input D1;
    input D0;
    input SCLK;
    input ECLK;
    input DQSW;
    input RST;
    output Q;
endmodule

(* blackbox *)
module EHXPLLL (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "DISABLED";
    parameter CLKOS2_ENABLE = "DISABLED";
    parameter CLKOS3_ENABLE = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter OUTDIVIDER_MUXA = "DIVA";
    parameter OUTDIVIDER_MUXB = "DIVB";
    parameter OUTDIVIDER_MUXC = "DIVC";
    parameter OUTDIVIDER_MUXD = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter PLL_LOCK_DELAY = 200;
    parameter STDBY_ENABLE = "DISABLED";
    parameter REFIN_RESET = "DISABLED";
    parameter SYNC_ENABLE = "DISABLED";
    parameter INT_LOCK_STICKY = "ENABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input PHASELOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output CLKINTFB;
endmodule

(* blackbox *)
module DTR (...);
    parameter DTR_TEMP = 25;
    input STARTPULSE;
    output DTROUT7;
    output DTROUT6;
    output DTROUT5;
    output DTROUT4;
    output DTROUT3;
    output DTROUT2;
    output DTROUT1;
    output DTROUT0;
endmodule

(* blackbox *)
module OSCG (...);
    parameter DIV = 128;
    output OSC;
endmodule

(* blackbox *)
module EXTREFB (...);
    parameter REFCK_PWDNB = "DONTCARE";
    parameter REFCK_RTERM = "DONTCARE";
    parameter REFCK_DCBIAS_EN = "DONTCARE";
    (* iopad_external_pin *)
    input REFCLKP;
    (* iopad_external_pin *)
    input REFCLKN;
    output REFCLKO;
endmodule

(* blackbox *) (* keep *)
module JTAGG (...);
    parameter ER1 = "ENABLED";
    parameter ER2 = "ENABLED";
    (* iopad_external_pin *)
    input TCK;
    (* iopad_external_pin *)
    input TMS;
    (* iopad_external_pin *)
    input TDI;
    input JTDO2;
    input JTDO1;
    (* iopad_external_pin *)
    output TDO;
    output JTDI;
    output JTCK;
    output JRTI2;
    output JRTI1;
    output JSHIFT;
    output JUPDATE;
    output JRSTN;
    output JCE2;
    output JCE1;
endmodule

(* blackbox *) (* keep *)
module DCUA (...);
    parameter D_MACROPDB = "DONTCARE";
    parameter D_IB_PWDNB = "DONTCARE";
    parameter D_XGE_MODE = "DONTCARE";
    parameter D_LOW_MARK = "DONTCARE";
    parameter D_HIGH_MARK = "DONTCARE";
    parameter D_BUS8BIT_SEL = "DONTCARE";
    parameter D_CDR_LOL_SET = "DONTCARE";
    parameter D_BITCLK_LOCAL_EN = "DONTCARE";
    parameter D_BITCLK_ND_EN = "DONTCARE";
    parameter D_BITCLK_FROM_ND_EN = "DONTCARE";
    parameter D_SYNC_LOCAL_EN = "DONTCARE";
    parameter D_SYNC_ND_EN = "DONTCARE";
    parameter CH0_UC_MODE = "DONTCARE";
    parameter CH1_UC_MODE = "DONTCARE";
    parameter CH0_PCIE_MODE = "DONTCARE";
    parameter CH1_PCIE_MODE = "DONTCARE";
    parameter CH0_RIO_MODE = "DONTCARE";
    parameter CH1_RIO_MODE = "DONTCARE";
    parameter CH0_WA_MODE = "DONTCARE";
    parameter CH1_WA_MODE = "DONTCARE";
    parameter CH0_INVERT_RX = "DONTCARE";
    parameter CH1_INVERT_RX = "DONTCARE";
    parameter CH0_INVERT_TX = "DONTCARE";
    parameter CH1_INVERT_TX = "DONTCARE";
    parameter CH0_PRBS_SELECTION = "DONTCARE";
    parameter CH1_PRBS_SELECTION = "DONTCARE";
    parameter CH0_GE_AN_ENABLE = "DONTCARE";
    parameter CH1_GE_AN_ENABLE = "DONTCARE";
    parameter CH0_PRBS_LOCK = "DONTCARE";
    parameter CH1_PRBS_LOCK = "DONTCARE";
    parameter CH0_PRBS_ENABLE = "DONTCARE";
    parameter CH1_PRBS_ENABLE = "DONTCARE";
    parameter CH0_ENABLE_CG_ALIGN = "DONTCARE";
    parameter CH1_ENABLE_CG_ALIGN = "DONTCARE";
    parameter CH0_TX_GEAR_MODE = "DONTCARE";
    parameter CH1_TX_GEAR_MODE = "DONTCARE";
    parameter CH0_RX_GEAR_MODE = "DONTCARE";
    parameter CH1_RX_GEAR_MODE = "DONTCARE";
    parameter CH0_PCS_DET_TIME_SEL = "DONTCARE";
    parameter CH1_PCS_DET_TIME_SEL = "DONTCARE";
    parameter CH0_PCIE_EI_EN = "DONTCARE";
    parameter CH1_PCIE_EI_EN = "DONTCARE";
    parameter CH0_TX_GEAR_BYPASS = "DONTCARE";
    parameter CH1_TX_GEAR_BYPASS = "DONTCARE";
    parameter CH0_ENC_BYPASS = "DONTCARE";
    parameter CH1_ENC_BYPASS = "DONTCARE";
    parameter CH0_SB_BYPASS = "DONTCARE";
    parameter CH1_SB_BYPASS = "DONTCARE";
    parameter CH0_RX_SB_BYPASS = "DONTCARE";
    parameter CH1_RX_SB_BYPASS = "DONTCARE";
    parameter CH0_WA_BYPASS = "DONTCARE";
    parameter CH1_WA_BYPASS = "DONTCARE";
    parameter CH0_DEC_BYPASS = "DONTCARE";
    parameter CH1_DEC_BYPASS = "DONTCARE";
    parameter CH0_CTC_BYPASS = "DONTCARE";
    parameter CH1_CTC_BYPASS = "DONTCARE";
    parameter CH0_RX_GEAR_BYPASS = "DONTCARE";
    parameter CH1_RX_GEAR_BYPASS = "DONTCARE";
    parameter CH0_LSM_DISABLE = "DONTCARE";
    parameter CH1_LSM_DISABLE = "DONTCARE";
    parameter CH0_MATCH_2_ENABLE = "DONTCARE";
    parameter CH1_MATCH_2_ENABLE = "DONTCARE";
    parameter CH0_MATCH_4_ENABLE = "DONTCARE";
    parameter CH1_MATCH_4_ENABLE = "DONTCARE";
    parameter CH0_MIN_IPG_CNT = "DONTCARE";
    parameter CH1_MIN_IPG_CNT = "DONTCARE";
    parameter CH0_CC_MATCH_1 = "DONTCARE";
    parameter CH1_CC_MATCH_1 = "DONTCARE";
    parameter CH0_CC_MATCH_2 = "DONTCARE";
    parameter CH1_CC_MATCH_2 = "DONTCARE";
    parameter CH0_CC_MATCH_3 = "DONTCARE";
    parameter CH1_CC_MATCH_3 = "DONTCARE";
    parameter CH0_CC_MATCH_4 = "DONTCARE";
    parameter CH1_CC_MATCH_4 = "DONTCARE";
    parameter CH0_UDF_COMMA_MASK = "DONTCARE";
    parameter CH1_UDF_COMMA_MASK = "DONTCARE";
    parameter CH0_UDF_COMMA_A = "DONTCARE";
    parameter CH1_UDF_COMMA_A = "DONTCARE";
    parameter CH0_UDF_COMMA_B = "DONTCARE";
    parameter CH1_UDF_COMMA_B = "DONTCARE";
    parameter CH0_RX_DCO_CK_DIV = "DONTCARE";
    parameter CH1_RX_DCO_CK_DIV = "DONTCARE";
    parameter CH0_RCV_DCC_EN = "DONTCARE";
    parameter CH1_RCV_DCC_EN = "DONTCARE";
    parameter CH0_REQ_LVL_SET = "DONTCARE";
    parameter CH1_REQ_LVL_SET = "DONTCARE";
    parameter CH0_REQ_EN = "DONTCARE";
    parameter CH1_REQ_EN = "DONTCARE";
    parameter CH0_RTERM_RX = "DONTCARE";
    parameter CH1_RTERM_RX = "DONTCARE";
    parameter CH0_PDEN_SEL = "DONTCARE";
    parameter CH1_PDEN_SEL = "DONTCARE";
    parameter CH0_LDR_RX2CORE_SEL = "DONTCARE";
    parameter CH1_LDR_RX2CORE_SEL = "DONTCARE";
    parameter CH0_LDR_CORE2TX_SEL = "DONTCARE";
    parameter CH1_LDR_CORE2TX_SEL = "DONTCARE";
    parameter CH0_TPWDNB = "DONTCARE";
    parameter CH1_TPWDNB = "DONTCARE";
    parameter CH0_RATE_MODE_TX = "DONTCARE";
    parameter CH1_RATE_MODE_TX = "DONTCARE";
    parameter CH0_RTERM_TX = "DONTCARE";
    parameter CH1_RTERM_TX = "DONTCARE";
    parameter CH0_TX_CM_SEL = "DONTCARE";
    parameter CH1_TX_CM_SEL = "DONTCARE";
    parameter CH0_TDRV_PRE_EN = "DONTCARE";
    parameter CH1_TDRV_PRE_EN = "DONTCARE";
    parameter CH0_TDRV_SLICE0_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE0_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE1_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE1_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE2_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE2_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE3_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE3_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE4_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE4_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE5_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE5_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE0_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE0_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE1_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE1_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE2_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE2_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE3_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE3_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE4_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE4_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE5_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE5_CUR = "DONTCARE";
    parameter CH0_TDRV_DAT_SEL = "DONTCARE";
    parameter CH1_TDRV_DAT_SEL = "DONTCARE";
    parameter CH0_TX_DIV11_SEL = "DONTCARE";
    parameter CH1_TX_DIV11_SEL = "DONTCARE";
    parameter CH0_RPWDNB = "DONTCARE";
    parameter CH1_RPWDNB = "DONTCARE";
    parameter CH0_RATE_MODE_RX = "DONTCARE";
    parameter CH1_RATE_MODE_RX = "DONTCARE";
    parameter CH0_RLOS_SEL = "DONTCARE";
    parameter CH1_RLOS_SEL = "DONTCARE";
    parameter CH0_RX_LOS_LVL = "DONTCARE";
    parameter CH1_RX_LOS_LVL = "DONTCARE";
    parameter CH0_RX_LOS_CEQ = "DONTCARE";
    parameter CH1_RX_LOS_CEQ = "DONTCARE";
    parameter CH0_RX_LOS_HYST_EN = "DONTCARE";
    parameter CH1_RX_LOS_HYST_EN = "DONTCARE";
    parameter CH0_RX_LOS_EN = "DONTCARE";
    parameter CH1_RX_LOS_EN = "DONTCARE";
    parameter CH0_RX_DIV11_SEL = "DONTCARE";
    parameter CH1_RX_DIV11_SEL = "DONTCARE";
    parameter CH0_SEL_SD_RX_CLK = "DONTCARE";
    parameter CH1_SEL_SD_RX_CLK = "DONTCARE";
    parameter CH0_FF_RX_H_CLK_EN = "DONTCARE";
    parameter CH1_FF_RX_H_CLK_EN = "DONTCARE";
    parameter CH0_FF_RX_F_CLK_DIS = "DONTCARE";
    parameter CH1_FF_RX_F_CLK_DIS = "DONTCARE";
    parameter CH0_FF_TX_H_CLK_EN = "DONTCARE";
    parameter CH1_FF_TX_H_CLK_EN = "DONTCARE";
    parameter CH0_FF_TX_F_CLK_DIS = "DONTCARE";
    parameter CH1_FF_TX_F_CLK_DIS = "DONTCARE";
    parameter CH0_RX_RATE_SEL = "DONTCARE";
    parameter CH1_RX_RATE_SEL = "DONTCARE";
    parameter CH0_TDRV_POST_EN = "DONTCARE";
    parameter CH1_TDRV_POST_EN = "DONTCARE";
    parameter CH0_TX_POST_SIGN = "DONTCARE";
    parameter CH1_TX_POST_SIGN = "DONTCARE";
    parameter CH0_TX_PRE_SIGN = "DONTCARE";
    parameter CH1_TX_PRE_SIGN = "DONTCARE";
    parameter CH0_RXTERM_CM = "DONTCARE";
    parameter CH1_RXTERM_CM = "DONTCARE";
    parameter CH0_RXIN_CM = "DONTCARE";
    parameter CH1_RXIN_CM = "DONTCARE";
    parameter CH0_LEQ_OFFSET_SEL = "DONTCARE";
    parameter CH1_LEQ_OFFSET_SEL = "DONTCARE";
    parameter CH0_LEQ_OFFSET_TRIM = "DONTCARE";
    parameter CH1_LEQ_OFFSET_TRIM = "DONTCARE";
    parameter D_TX_MAX_RATE = "DONTCARE";
    parameter CH0_CDR_MAX_RATE = "DONTCARE";
    parameter CH1_CDR_MAX_RATE = "DONTCARE";
    parameter CH0_TXAMPLITUDE = "DONTCARE";
    parameter CH1_TXAMPLITUDE = "DONTCARE";
    parameter CH0_TXDEPRE = "DONTCARE";
    parameter CH1_TXDEPRE = "DONTCARE";
    parameter CH0_TXDEPOST = "DONTCARE";
    parameter CH1_TXDEPOST = "DONTCARE";
    parameter CH0_PROTOCOL = "DONTCARE";
    parameter CH1_PROTOCOL = "DONTCARE";
    parameter D_ISETLOS = "DONTCARE";
    parameter D_SETIRPOLY_AUX = "DONTCARE";
    parameter D_SETICONST_AUX = "DONTCARE";
    parameter D_SETIRPOLY_CH = "DONTCARE";
    parameter D_SETICONST_CH = "DONTCARE";
    parameter D_REQ_ISET = "DONTCARE";
    parameter D_PD_ISET = "DONTCARE";
    parameter D_DCO_CALIB_TIME_SEL = "DONTCARE";
    parameter CH0_DCOCTLGI = "DONTCARE";
    parameter CH1_DCOCTLGI = "DONTCARE";
    parameter CH0_DCOATDDLY = "DONTCARE";
    parameter CH1_DCOATDDLY = "DONTCARE";
    parameter CH0_DCOATDCFG = "DONTCARE";
    parameter CH1_DCOATDCFG = "DONTCARE";
    parameter CH0_DCOBYPSATD = "DONTCARE";
    parameter CH1_DCOBYPSATD = "DONTCARE";
    parameter CH0_DCOSCALEI = "DONTCARE";
    parameter CH1_DCOSCALEI = "DONTCARE";
    parameter CH0_DCOITUNE4LSB = "DONTCARE";
    parameter CH1_DCOITUNE4LSB = "DONTCARE";
    parameter CH0_DCOIOSTUNE = "DONTCARE";
    parameter CH1_DCOIOSTUNE = "DONTCARE";
    parameter CH0_DCODISBDAVOID = "DONTCARE";
    parameter CH1_DCODISBDAVOID = "DONTCARE";
    parameter CH0_DCOCALDIV = "DONTCARE";
    parameter CH1_DCOCALDIV = "DONTCARE";
    parameter CH0_DCONUOFLSB = "DONTCARE";
    parameter CH1_DCONUOFLSB = "DONTCARE";
    parameter CH0_DCOIUPDNX2 = "DONTCARE";
    parameter CH1_DCOIUPDNX2 = "DONTCARE";
    parameter CH0_DCOSTEP = "DONTCARE";
    parameter CH1_DCOSTEP = "DONTCARE";
    parameter CH0_DCOSTARTVAL = "DONTCARE";
    parameter CH1_DCOSTARTVAL = "DONTCARE";
    parameter CH0_DCOFLTDAC = "DONTCARE";
    parameter CH1_DCOFLTDAC = "DONTCARE";
    parameter CH0_DCOITUNE = "DONTCARE";
    parameter CH1_DCOITUNE = "DONTCARE";
    parameter CH0_DCOFTNRG = "DONTCARE";
    parameter CH1_DCOFTNRG = "DONTCARE";
    parameter CH0_CDR_CNT4SEL = "DONTCARE";
    parameter CH1_CDR_CNT4SEL = "DONTCARE";
    parameter CH0_CDR_CNT8SEL = "DONTCARE";
    parameter CH1_CDR_CNT8SEL = "DONTCARE";
    parameter CH0_BAND_THRESHOLD = "DONTCARE";
    parameter CH1_BAND_THRESHOLD = "DONTCARE";
    parameter CH0_AUTO_FACQ_EN = "DONTCARE";
    parameter CH1_AUTO_FACQ_EN = "DONTCARE";
    parameter CH0_AUTO_CALIB_EN = "DONTCARE";
    parameter CH1_AUTO_CALIB_EN = "DONTCARE";
    parameter CH0_CALIB_CK_MODE = "DONTCARE";
    parameter CH1_CALIB_CK_MODE = "DONTCARE";
    parameter CH0_REG_BAND_OFFSET = "DONTCARE";
    parameter CH1_REG_BAND_OFFSET = "DONTCARE";
    parameter CH0_REG_BAND_SEL = "DONTCARE";
    parameter CH1_REG_BAND_SEL = "DONTCARE";
    parameter CH0_REG_IDAC_SEL = "DONTCARE";
    parameter CH1_REG_IDAC_SEL = "DONTCARE";
    parameter CH0_REG_IDAC_EN = "DONTCARE";
    parameter CH1_REG_IDAC_EN = "DONTCARE";
    parameter D_TXPLL_PWDNB = "DONTCARE";
    parameter D_SETPLLRC = "DONTCARE";
    parameter D_REFCK_MODE = "DONTCARE";
    parameter D_TX_VCO_CK_DIV = "DONTCARE";
    parameter D_PLL_LOL_SET = "DONTCARE";
    parameter D_RG_EN = "DONTCARE";
    parameter D_RG_SET = "DONTCARE";
    parameter D_CMUSETISCL4VCO = "DONTCARE";
    parameter D_CMUSETI4VCO = "DONTCARE";
    parameter D_CMUSETINITVCT = "DONTCARE";
    parameter D_CMUSETZGM = "DONTCARE";
    parameter D_CMUSETP2AGM = "DONTCARE";
    parameter D_CMUSETP1GM = "DONTCARE";
    parameter D_CMUSETI4CPZ = "DONTCARE";
    parameter D_CMUSETI4CPP = "DONTCARE";
    parameter D_CMUSETICP4Z = "DONTCARE";
    parameter D_CMUSETICP4P = "DONTCARE";
    parameter D_CMUSETBIASI = "DONTCARE";
    (* iopad_external_pin *)
    (* iopad_external_pin *)
    input CH0_HDINP;
    (* iopad_external_pin *)
    input CH1_HDINP;
    (* iopad_external_pin *)
    input CH0_HDINN;
    (* iopad_external_pin *)
    input CH1_HDINN;
    input D_TXBIT_CLKP_FROM_ND;
    input D_TXBIT_CLKN_FROM_ND;
    input D_SYNC_ND;
    input D_TXPLL_LOL_FROM_ND;
    input CH0_RX_REFCLK;
    input CH1_RX_REFCLK;
    input CH0_FF_RXI_CLK;
    input CH1_FF_RXI_CLK;
    input CH0_FF_TXI_CLK;
    input CH1_FF_TXI_CLK;
    input CH0_FF_EBRD_CLK;
    input CH1_FF_EBRD_CLK;
    input CH0_FF_TX_D_0;
    input CH1_FF_TX_D_0;
    input CH0_FF_TX_D_1;
    input CH1_FF_TX_D_1;
    input CH0_FF_TX_D_2;
    input CH1_FF_TX_D_2;
    input CH0_FF_TX_D_3;
    input CH1_FF_TX_D_3;
    input CH0_FF_TX_D_4;
    input CH1_FF_TX_D_4;
    input CH0_FF_TX_D_5;
    input CH1_FF_TX_D_5;
    input CH0_FF_TX_D_6;
    input CH1_FF_TX_D_6;
    input CH0_FF_TX_D_7;
    input CH1_FF_TX_D_7;
    input CH0_FF_TX_D_8;
    input CH1_FF_TX_D_8;
    input CH0_FF_TX_D_9;
    input CH1_FF_TX_D_9;
    input CH0_FF_TX_D_10;
    input CH1_FF_TX_D_10;
    input CH0_FF_TX_D_11;
    input CH1_FF_TX_D_11;
    input CH0_FF_TX_D_12;
    input CH1_FF_TX_D_12;
    input CH0_FF_TX_D_13;
    input CH1_FF_TX_D_13;
    input CH0_FF_TX_D_14;
    input CH1_FF_TX_D_14;
    input CH0_FF_TX_D_15;
    input CH1_FF_TX_D_15;
    input CH0_FF_TX_D_16;
    input CH1_FF_TX_D_16;
    input CH0_FF_TX_D_17;
    input CH1_FF_TX_D_17;
    input CH0_FF_TX_D_18;
    input CH1_FF_TX_D_18;
    input CH0_FF_TX_D_19;
    input CH1_FF_TX_D_19;
    input CH0_FF_TX_D_20;
    input CH1_FF_TX_D_20;
    input CH0_FF_TX_D_21;
    input CH1_FF_TX_D_21;
    input CH0_FF_TX_D_22;
    input CH1_FF_TX_D_22;
    input CH0_FF_TX_D_23;
    input CH1_FF_TX_D_23;
    input CH0_FFC_EI_EN;
    input CH1_FFC_EI_EN;
    input CH0_FFC_PCIE_DET_EN;
    input CH1_FFC_PCIE_DET_EN;
    input CH0_FFC_PCIE_CT;
    input CH1_FFC_PCIE_CT;
    input CH0_FFC_SB_INV_RX;
    input CH1_FFC_SB_INV_RX;
    input CH0_FFC_ENABLE_CGALIGN;
    input CH1_FFC_ENABLE_CGALIGN;
    input CH0_FFC_SIGNAL_DETECT;
    input CH1_FFC_SIGNAL_DETECT;
    input CH0_FFC_FB_LOOPBACK;
    input CH1_FFC_FB_LOOPBACK;
    input CH0_FFC_SB_PFIFO_LP;
    input CH1_FFC_SB_PFIFO_LP;
    input CH0_FFC_PFIFO_CLR;
    input CH1_FFC_PFIFO_CLR;
    input CH0_FFC_RATE_MODE_RX;
    input CH1_FFC_RATE_MODE_RX;
    input CH0_FFC_RATE_MODE_TX;
    input CH1_FFC_RATE_MODE_TX;
    input CH0_FFC_DIV11_MODE_RX;
    input CH1_FFC_DIV11_MODE_RX;
    input CH0_FFC_RX_GEAR_MODE;
    input CH1_FFC_RX_GEAR_MODE;
    input CH0_FFC_TX_GEAR_MODE;
    input CH1_FFC_TX_GEAR_MODE;
    input CH0_FFC_DIV11_MODE_TX;
    input CH1_FFC_DIV11_MODE_TX;
    input CH0_FFC_LDR_CORE2TX_EN;
    input CH1_FFC_LDR_CORE2TX_EN;
    input CH0_FFC_LANE_TX_RST;
    input CH1_FFC_LANE_TX_RST;
    input CH0_FFC_LANE_RX_RST;
    input CH1_FFC_LANE_RX_RST;
    input CH0_FFC_RRST;
    input CH1_FFC_RRST;
    input CH0_FFC_TXPWDNB;
    input CH1_FFC_TXPWDNB;
    input CH0_FFC_RXPWDNB;
    input CH1_FFC_RXPWDNB;
    input CH0_LDR_CORE2TX;
    input CH1_LDR_CORE2TX;
    input D_SCIWDATA0;
    input D_SCIWDATA1;
    input D_SCIWDATA2;
    input D_SCIWDATA3;
    input D_SCIWDATA4;
    input D_SCIWDATA5;
    input D_SCIWDATA6;
    input D_SCIWDATA7;
    input D_SCIADDR0;
    input D_SCIADDR1;
    input D_SCIADDR2;
    input D_SCIADDR3;
    input D_SCIADDR4;
    input D_SCIADDR5;
    input D_SCIENAUX;
    input D_SCISELAUX;
    input CH0_SCIEN;
    input CH1_SCIEN;
    input CH0_SCISEL;
    input CH1_SCISEL;
    input D_SCIRD;
    input D_SCIWSTN;
    input D_CYAWSTN;
    input D_FFC_SYNC_TOGGLE;
    input D_FFC_DUAL_RST;
    input D_FFC_MACRO_RST;
    input D_FFC_MACROPDB;
    input D_FFC_TRST;
    input CH0_FFC_CDR_EN_BITSLIP;
    input CH1_FFC_CDR_EN_BITSLIP;
    input D_SCAN_ENABLE;
    input D_SCAN_IN_0;
    input D_SCAN_IN_1;
    input D_SCAN_IN_2;
    input D_SCAN_IN_3;
    input D_SCAN_IN_4;
    input D_SCAN_IN_5;
    input D_SCAN_IN_6;
    input D_SCAN_IN_7;
    input D_SCAN_MODE;
    input D_SCAN_RESET;
    input D_CIN0;
    input D_CIN1;
    input D_CIN2;
    input D_CIN3;
    input D_CIN4;
    input D_CIN5;
    input D_CIN6;
    input D_CIN7;
    input D_CIN8;
    input D_CIN9;
    input D_CIN10;
    input D_CIN11;
    output CH0_HDOUTP;
    output CH1_HDOUTP;
    output CH0_HDOUTN;
    output CH1_HDOUTN;
    output D_TXBIT_CLKP_TO_ND;
    output D_TXBIT_CLKN_TO_ND;
    output D_SYNC_PULSE2ND;
    output D_TXPLL_LOL_TO_ND;
    output CH0_FF_RX_F_CLK;
    output CH1_FF_RX_F_CLK;
    output CH0_FF_RX_H_CLK;
    output CH1_FF_RX_H_CLK;
    output CH0_FF_TX_F_CLK;
    output CH1_FF_TX_F_CLK;
    output CH0_FF_TX_H_CLK;
    output CH1_FF_TX_H_CLK;
    output CH0_FF_RX_PCLK;
    output CH1_FF_RX_PCLK;
    output CH0_FF_TX_PCLK;
    output CH1_FF_TX_PCLK;
    output CH0_FF_RX_D_0;
    output CH1_FF_RX_D_0;
    output CH0_FF_RX_D_1;
    output CH1_FF_RX_D_1;
    output CH0_FF_RX_D_2;
    output CH1_FF_RX_D_2;
    output CH0_FF_RX_D_3;
    output CH1_FF_RX_D_3;
    output CH0_FF_RX_D_4;
    output CH1_FF_RX_D_4;
    output CH0_FF_RX_D_5;
    output CH1_FF_RX_D_5;
    output CH0_FF_RX_D_6;
    output CH1_FF_RX_D_6;
    output CH0_FF_RX_D_7;
    output CH1_FF_RX_D_7;
    output CH0_FF_RX_D_8;
    output CH1_FF_RX_D_8;
    output CH0_FF_RX_D_9;
    output CH1_FF_RX_D_9;
    output CH0_FF_RX_D_10;
    output CH1_FF_RX_D_10;
    output CH0_FF_RX_D_11;
    output CH1_FF_RX_D_11;
    output CH0_FF_RX_D_12;
    output CH1_FF_RX_D_12;
    output CH0_FF_RX_D_13;
    output CH1_FF_RX_D_13;
    output CH0_FF_RX_D_14;
    output CH1_FF_RX_D_14;
    output CH0_FF_RX_D_15;
    output CH1_FF_RX_D_15;
    output CH0_FF_RX_D_16;
    output CH1_FF_RX_D_16;
    output CH0_FF_RX_D_17;
    output CH1_FF_RX_D_17;
    output CH0_FF_RX_D_18;
    output CH1_FF_RX_D_18;
    output CH0_FF_RX_D_19;
    output CH1_FF_RX_D_19;
    output CH0_FF_RX_D_20;
    output CH1_FF_RX_D_20;
    output CH0_FF_RX_D_21;
    output CH1_FF_RX_D_21;
    output CH0_FF_RX_D_22;
    output CH1_FF_RX_D_22;
    output CH0_FF_RX_D_23;
    output CH1_FF_RX_D_23;
    output CH0_FFS_PCIE_DONE;
    output CH1_FFS_PCIE_DONE;
    output CH0_FFS_PCIE_CON;
    output CH1_FFS_PCIE_CON;
    output CH0_FFS_RLOS;
    output CH1_FFS_RLOS;
    output CH0_FFS_LS_SYNC_STATUS;
    output CH1_FFS_LS_SYNC_STATUS;
    output CH0_FFS_CC_UNDERRUN;
    output CH1_FFS_CC_UNDERRUN;
    output CH0_FFS_CC_OVERRUN;
    output CH1_FFS_CC_OVERRUN;
    output CH0_FFS_RXFBFIFO_ERROR;
    output CH1_FFS_RXFBFIFO_ERROR;
    output CH0_FFS_TXFBFIFO_ERROR;
    output CH1_FFS_TXFBFIFO_ERROR;
    output CH0_FFS_RLOL;
    output CH1_FFS_RLOL;
    output CH0_FFS_SKP_ADDED;
    output CH1_FFS_SKP_ADDED;
    output CH0_FFS_SKP_DELETED;
    output CH1_FFS_SKP_DELETED;
    output CH0_LDR_RX2CORE;
    output CH1_LDR_RX2CORE;
    output D_SCIRDATA0;
    output D_SCIRDATA1;
    output D_SCIRDATA2;
    output D_SCIRDATA3;
    output D_SCIRDATA4;
    output D_SCIRDATA5;
    output D_SCIRDATA6;
    output D_SCIRDATA7;
    output D_SCIINT;
    output D_SCAN_OUT_0;
    output D_SCAN_OUT_1;
    output D_SCAN_OUT_2;
    output D_SCAN_OUT_3;
    output D_SCAN_OUT_4;
    output D_SCAN_OUT_5;
    output D_SCAN_OUT_6;
    output D_SCAN_OUT_7;
    output D_COUT0;
    output D_COUT1;
    output D_COUT2;
    output D_COUT3;
    output D_COUT4;
    output D_COUT5;
    output D_COUT6;
    output D_COUT7;
    output D_COUT8;
    output D_COUT9;
    output D_COUT10;
    output D_COUT11;
    output D_COUT12;
    output D_COUT13;
    output D_COUT14;
    output D_COUT15;
    output D_COUT16;
    output D_COUT17;
    output D_COUT18;
    output D_COUT19;
    input D_REFCLKI;
    output D_FFS_PLOL;
endmodule

`,"cells_bb_xo2.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCH (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_bb_xo3.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCH (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_bb_xo3d.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCJ (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
    output OSCESB;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_ff.vh":`// Diamond flip-flops
module FD1P3AX(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3AY(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1S3AX(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3AY(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3BX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule
module FD1S3DX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3IX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3JX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule

// TODO: Diamond latches
// module FL1P3AY(); endmodule
// module FL1P3AZ(); endmodule
// module FL1P3BX(); endmodule
// module FL1P3DX(); endmodule
// module FL1P3IY(); endmodule
// module FL1P3JY(); endmodule
// module FL1S3AX(); endmodule
// module FL1S3AY(); endmodule

// Diamond I/O registers
module IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

module OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

// TODO: Diamond I/O latches
// module IFS1S1B(input PD, D, SCLK, output Q); endmodule
// module IFS1S1D(input CD, D, SCLK, output Q); endmodule
// module IFS1S1I(input PD, D, SCLK, output Q); endmodule
// module IFS1S1J(input CD, D, SCLK, output Q); endmodule
`,"cells_io.vh":`// Diamond I/O buffers
module IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule
module OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule
module BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule
module OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule
`,"cells_map.v":`module  \\$_DFF_N_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_P_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module \\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

module \\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`ifndef NO_LUT
module \\$lut (A, Y);
    parameter WIDTH = 0;
    parameter LUT = 0;

    (* force_downto *)
    input [WIDTH-1:0] A;
    output Y;

    generate
        if (WIDTH == 1) begin
            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));
        end else
        if (WIDTH == 2) begin
            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));
        end else
        if (WIDTH == 3) begin
            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));
        end else
        if (WIDTH == 4) begin
            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
        \`ifndef NO_PFUMUX
        end else
        if (WIDTH == 5) begin
            wire f0, f1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));
        end else
        if (WIDTH == 6) begin
            wire f0, f1, f2, f3, g0, g1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));
        end else
        if (WIDTH == 7) begin
            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));
            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));
            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));
            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));
            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));
        \`endif
        end else begin
            wire _TECHMAP_FAIL_ = 1;
        end
    endgenerate
endmodule
\`endif
`,"cells_sim_ecp5.v":`\`include "common_sim.vh"
\`include "ccu2c_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo2.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo3.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo3d.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"common_sim.vh":`// ---------------------------------------

(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
    parameter [15:0] INIT = 16'h0000;
    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
    specify
        (A => Z) = 141;
        (B => Z) = 275;
        (C => Z) = 379;
        (D => Z) = 379;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
// LUT5 = 2x LUT4 + PFUMX
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);
    specify
        (M0 => Z) = 151;
        (D => Z) = 239;
        (C => Z) = 373;
        (B => Z) = 477;
        (A => Z) = 477;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 6-input LUTs and is not intended to be instantiated
// LUT6 = 2x LUT5 + MUX2
(* abc9_lut=4 *)
module \\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);
    specify
        (M1 => Z) = 148;
        (M0 => Z) = 292;
        (D => Z) = 380;
        (C => Z) = 514;
        (B => Z) = 618;
        (A => Z) = 618;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 7-input LUTs and is not intended to be instantiated
// LUT7 = 2x LUT6 + MUX2
(* abc9_lut=8 *)
module \\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);
    specify
        (M2 => Z) = 148;
        (M1 => Z) = 289;
        (M0 => Z) = 433;
        (D => Z) = 521;
        (C => Z) = 655;
        (B => Z) = 759;
        (A => Z) = 759;
    endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module L6MUX21 (input D0, D1, SD, output Z);
	assign Z = SD ? D1 : D0;
	specify
		(D0 => Z) = 140;
		(D1 => Z) = 141;
		(SD => Z) = 148;
	endspecify
endmodule

// ---------------------------------------

module TRELLIS_RAM16X2 (
	input DI0, DI1,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	input RAD0, RAD1, RAD2, RAD3,
	output DO0, DO1
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter INITVAL_0 = 16'h0000;
	parameter INITVAL_1 = 16'h0000;

	reg [1:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= {INITVAL_1[i], INITVAL_0[i]};
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase


	always @(posedge muxwck)
		if (muxwre)
			mem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};

	assign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module PFUMX (input ALUT, BLUT, C0, output Z);
	assign Z = C0 ? ALUT : BLUT;
	specify
		(ALUT => Z) = 98;
		(BLUT => Z) = 98;
		(C0 => Z) = 151;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module TRELLIS_DPR16X4 (
	input  [3:0] DI,
	input  [3:0] WAD,
	input        WRE,
	input        WCK,
	input  [3:0] RAD,
	output [3:0] DO
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter [63:0] INITVAL = 64'h0000000000000000;

	reg [3:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= INITVAL[4*i +: 4];
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase

	always @(posedge muxwck)
		if (muxwre)
			mem[WAD] <= DI;

	assign DO = mem[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* abc9_box, lib_whitebox *)
module DPR16X4C (
		input [3:0] DI,
		input WCK, WRE,
		input [3:0] RAD,
		input [3:0] WAD,
		output [3:0] DO
);
	// For legacy Lattice compatibility, INITIVAL is a hex
	// string rather than a numeric parameter
	parameter INITVAL = "0x0000000000000000";

	function [63:0] convert_initval;
		input [143:0] hex_initval;
		reg done;
		reg [63:0] temp;
		reg [7:0] char;
		integer i;
		begin
			done = 1'b0;
			temp = 0;
			for (i = 0; i < 16; i = i + 1) begin
				if (!done) begin
					char = hex_initval[8*i +: 8];
					if (char == "x") begin
						done = 1'b1;
					end else begin
						if (char >= "0" && char <= "9")
							temp[4*i +: 4] = char - "0";
						else if (char >= "A" && char <= "F")
							temp[4*i +: 4] = 10 + char - "A";
						else if (char >= "a" && char <= "f")
							temp[4*i +: 4] = 10 + char - "a";
					end
				end
			end
			convert_initval = temp;
		end
	endfunction

	localparam conv_initval = convert_initval(INITVAL);

	reg [3:0] ram[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i = i + 1) begin
			ram[i] <= conv_initval[4*i +: 4];
		end
	end

	always @(posedge WCK)
		if (WRE)
			ram[WAD] <= DI;

	assign DO = ram[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* lib_whitebox *)
module LUT2(input A, B, output Z);
    parameter [3:0] INIT = 4'h0;
    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
endmodule

// ---------------------------------------

\`ifdef YOSYS
(* abc9_flop=(SRMODE != "ASYNC"), abc9_box=(SRMODE == "ASYNC"), lib_whitebox *)
\`endif
module TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (SRMODE == "ASYNC") begin
			always @(posedge muxclk, posedge muxlsr)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end else begin
			always @(posedge muxclk)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end
	endgenerate

	specify
		$setup(DI, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(CE, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(LSR, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(DI, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(CE, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(LSR, posedge CLK &&& CLKMUX != "INV", 0);
\`ifndef YOSYS
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX == "INV") (negedge CLK => (Q : srval)) = 0;
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX != "INV") (posedge CLK => (Q : srval)) = 0;
\`else
		if (SRMODE == "ASYNC" && muxlsr) (LSR => Q) = 0; 	// Technically, this should be an edge sensitive path
									// but for facilitating a bypass box, let's pretend it's
									// a simple path
\`endif
		if (!muxlsr && muxce && CLKMUX == "INV") (negedge CLK => (Q : DI)) = 0;
		if (!muxlsr && muxce && CLKMUX != "INV") (posedge CLK => (Q : DI)) = 0;
	endspecify
endmodule

// ---------------------------------------
(* keep *)
module TRELLIS_IO(
	(* iopad_external_pin *)
	inout B,
	input I,
	input T,
	output O
);
	parameter DIR = "INPUT";
	reg T_pd;
	always @(*) if (T === 1'bz) T_pd <= 1'b0; else T_pd <= T;

	generate
		if (DIR == "INPUT") begin
			assign B = 1'bz;
			assign O = B;
		end else if (DIR == "OUTPUT") begin
			assign B = T_pd ? 1'bz : I;
			assign O = 1'bx;
		end else if (DIR == "BIDIR") begin
			assign B = T_pd ? 1'bz : I;
			assign O = B;
		end else begin
			ERROR_UNKNOWN_IO_MODE error();
		end
	endgenerate

endmodule

// ---------------------------------------

module INV(input A, output Z);
	assign Z = !A;
endmodule

// ---------------------------------------

module TRELLIS_COMB(
	input A, B, C, D, M,
	input FCI, F1, FXA, FXB,
	input WD,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	output F, FCO, OFX
);
	parameter MODE = "LOGIC";
	parameter INITVAL = 16'h0;
	parameter CCU2_INJECT1 = "NO";
	parameter WREMUX = "WRE";
	parameter IS_Z1 = 1'b0;

	generate
		if (MODE == "LOGIC") begin: mode_logic
			LUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));
		end else if (MODE == "CCU2") begin: mode_ccu2
			wire l4o, l2o;
			LUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));
			LUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));
			wire gated_cin_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : FCI;
			assign F = l4o ^ gated_cin_0;
			wire gated_lut2_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : l2o;
			wire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);
		end else if (MODE == "DPRAM") begin: mode_dpram
			reg [15:0] ram = INITVAL;
			always @(posedge WCK)
				if (WRE)
					ram[{WAD3, WAD2, WAD1, WAD0}] <= WD;
			assign F = ram[{A, C, B, D}];
		end else begin
			$error("unsupported COMB mode %s", MODE);
		end

 		if (IS_Z1)
			L6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));
		else
			PFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));
	endgenerate

endmodule

// Constants
module VLO(output Z);
	assign Z = 1'b0;
endmodule

module VHI(output Z);
	assign Z = 1'b1;
endmodule

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"dsp_map_18x18.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18D _TECHMAP_REPLACE_ (
		.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),
		.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),
		.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),

		.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lutrams.txt":`ram distributed $__TRELLIS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init any;
	prune_rom;
	port sw "W" {
		clock anyedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__TRELLIS_DPR16X4_(...);

parameter INIT = 64'bx;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input [3:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

localparam WCKMUX = PORT_W_CLK_POL ? "WCK" : "INV";

TRELLIS_DPR16X4 #(
	.INITVAL(INIT),
	.WCKMUX(WCKMUX),
	.WREMUX("WRE")
) _TECHMAP_REPLACE_ (
	.RAD(PORT_R_ADDR),
	.DO(PORT_R_RD_DATA),

	.WAD(PORT_W_ADDR),
	.DI(PORT_W_WR_DATA),
	.WCK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);

endmodule
`},microchip:{"LSRAM.txt":`# ISC License
# 
# Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.




# LSRAM true dual-port
ram block $__LSRAM_TDP_ {

	# Cost of a given cell is assumed to be:
	#   (cost-widthscale) + [widthscale * (used_bits/14)]
	cost 129;

	# INIT is supported
	init any;

	# port A and port B are allowed to have different widths, but they MUST have
	# 	WIDTH values of the same set. 
	#      Example: Port A has a Data Width of 1. Then Port B's Data Width must be either
	#      1, 2, 4, 8, or 16 (both values are in the 'WIDTH_1' set).	
	# 	WIDTH_1 = {1, 2, 4, 8, 16}
	# 	WIDTH_2 = {5, 10, 20}

	# "byte" specifies how many data bits correspond to one write enable bit.
	#		"byte" must be larger than width, or width must be a multipler of "byte"
	#		if "byte" > WIDTH, a single enable wire is inferred
	#		otherwise, WIDTH/byte number of enable wires are inferred
	# 		
	# 		WIDTH = {1, 2, 4, 5, 8, 10} requires 1 enable wire
	# 		WIDTH = {16, 20} requires 2 enable wire

	option "WIDTH_CONFIG" "REGULAR" {

		# Data-Width| Address bits
		# 1 		| 14
		# 2 		| 13
		# 4 		| 12
		# 8 		| 11
		# 16		| 10

		# 14 address bits
		abits 14;

		widths 1 2 4 8 16 per_port;
		byte 8;
	}
	option "WIDTH_CONFIG" "ALIGN" {
		
		# Data-Width| Address bits
		# 5 		| 12
		# 10		| 11
		# 20		| 10

		# Quick "hack" to fix address bit alignment by setting address bits to 12.
		#   If abits=14, tool will think there are 14 bits for width=5, 13 bits for width=10, 12 bits for width=20
		#   THe LSRAM_map.v file detects if this option is being used, and adjusts the address port alignments accordingly.
		abits 12;

		widths 5 10 20 per_port;
		byte 10;
	}
	
	

	port srsw "A" "B" {

		# read & write width must be same
		width tied;
		
		# clock polarity is rising
		clock posedge;

		# A/B read-enable
		rden;


		# initial value of read port data (not supported)
		rdinit none;

		# write modes (<A/B>_WMODE)
		# 	1. Simple Write: read-data port holds prev value (similar to "NO_CHANGE" for RAMB18E1)
		# 	2. Feed-through: read-data port takes new write value (similar to "WRITE_FIRST" for RAMB18E1)
		# 	3. Read-Before-Write: read-data port holds old value while being written (similar to "READ_FIRST" for RAMB18E1)

		portoption "WRITE_MODE" "NO_CHANGE" {

			# Read-write interaction
			rdwr no_change;

			# Write transparency:
			#   For write ports, define behaviour when another synchronous read port 
			#   reads from the same memory cell that said write port is writing to at the same time. 
			wrtrans all old;
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			# bits corresponding to high A/B_WEN are updated
			rdwr new_only;
			wrtrans all new;
		}
		portoption "WRITE_MODE" "READ_FIRST" {
			rdwr old;

			wrtrans all old;
		}

		# generate params to indicate if read or write is used for each port
		optional_rw;
	}
}

# two-port configuration
ram block $__LSRAM_SDP_ {
	
	# since two-port configuration is dedicated for wide-read/write,
	#	we want to prioritize this configuration over TDP to avoid tool picking multiple TDP RAMs 
	#	inplace of a single SDP RAM for wide read/write. This means the cost of a single SDP should
	#	be less than 2 TDP.
	cost 129;
	init any;

	option "WIDTH_CONFIG" "REGULAR" {

		# Data-Width| Address bits
		# 1 		| 14
		# 2 		| 13
		# 4 		| 12
		# 8 		| 11
		# 16		| 10
		# 32		| 9

		abits 14;

		widths 1 2 4 8 16 32 per_port;

		# width = 32, byte-write size is 8, ignore other widths
		byte 8;
		
	}
	option "WIDTH_CONFIG" "ALIGN" {
		
		# Data-Width| Address bits
		# 5 		| 12
		# 10		| 11
		# 20		| 10
		# 40		| 9

		# Same trick as TSP RAM for alignment
		abits 12;
		widths 5 10 20 40 per_port;
		byte 10;
	}

	port sw "W" {

		# only consider wide write
		
		option "WIDTH_CONFIG" "REGULAR" width 32;
		option "WIDTH_CONFIG" "ALIGN" width 40;

		clock posedge;

		# only simple write supported for two-port mode
		wrtrans all old;
		
		optional;
	}
	port sr "R" {

		option "WIDTH_CONFIG" "REGULAR" width 32;
		option "WIDTH_CONFIG" "ALIGN" width 40;


		clock posedge;
		rden;
		rdinit none;
		optional;
	}
}
`,"LSRAM_map.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

// See document PolarFire Family Fabric User Guide
//   section 4.1 for port list.


//LSRAM true dual-port
module $__LSRAM_TDP_ (...);

parameter INIT = 0;
parameter ADDR_BITS = 14;

parameter OPTION_WIDTH_CONFIG = "A";

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 0;
parameter PORT_A_WR_USED = 0;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";


input PORT_A_CLK;
input PORT_A_RD_EN;
input [ADDR_BITS-1:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;


input PORT_B_CLK;
input PORT_B_RD_EN;
input [ADDR_BITS-1:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;


\`include "brams_defs.vh"

// address wires
wire [ADDR_BITS-1:0] A_address;
wire [ADDR_BITS-1:0] B_address;
assign A_address = (OPTION_WIDTH_CONFIG == "REGULAR") ? PORT_A_ADDR : {PORT_A_ADDR, 2'b00};
assign B_address = (OPTION_WIDTH_CONFIG == "REGULAR") ? PORT_B_ADDR : {PORT_B_ADDR, 2'b00};

// if port is not used, set block sel to 0 to disable it (read-data output is set to 0)
parameter PORT_A_RD_USED = 0;
parameter PORT_A_WR_USED = 0;
wire [2:0] A_BLK_SEL = (PORT_A_RD_USED == 1 || PORT_A_WR_USED == 1) ? 3'b111 : 3'b000;
wire [2:0] B_BLK_SEL = (PORT_B_RD_USED == 1 || PORT_B_WR_USED == 1) ? 3'b111 : 3'b000;

// wires for write data 
generate
	wire [19:0] A_write_data;
	wire [19:0] B_write_data;
	if (PORT_A_WIDTH == 16) begin
		assign A_write_data[7:0] = PORT_A_WR_DATA[7:0];
		assign A_write_data[17:10] = PORT_A_WR_DATA[15:8];
		assign A_write_data[9:8] = 2'b0;
		assign A_write_data[19:18] = 2'b0;
	end else begin
		assign A_write_data[PORT_A_WIDTH-1:0] = PORT_A_WR_DATA;
	end

	if (PORT_B_WIDTH == 16) begin
		assign B_write_data[7:0] = PORT_B_WR_DATA[7:0];
		assign B_write_data[17:10] = PORT_B_WR_DATA[15:8];
		assign B_write_data[9:8] = 2'b0;
		assign B_write_data[19:18] = 2'b0;
	end else begin
		assign B_write_data[PORT_B_WIDTH-1:0] = PORT_B_WR_DATA;
	end
endgenerate

// wires for read data
wire [19:0] A_read_data;
assign PORT_A_RD_DATA = A_read_data[PORT_A_WIDTH-1:0];
wire [19:0] B_read_data;
assign PORT_B_RD_DATA = B_read_data[PORT_B_WIDTH-1:0];

// byte-write enables
wire [1:0] A_write_EN = (PORT_A_WR_EN_WIDTH == 1) ? {1'b0, PORT_A_WR_EN} : PORT_A_WR_EN;
wire [1:0] B_write_EN = (PORT_B_WR_EN_WIDTH == 1) ? {1'b0, PORT_B_WR_EN} : PORT_B_WR_EN;

// port width
wire [2:0] A_width = (PORT_A_WIDTH == 1) ? 3'b000 :
					(PORT_A_WIDTH == 2) ? 3'b001 :
					(PORT_A_WIDTH == 4 || PORT_A_WIDTH == 5) ? 3'b010 :
					(PORT_A_WIDTH == 8 || PORT_A_WIDTH == 10) ? 3'b011 : 3'b100;
wire [2:0] B_width = (PORT_B_WIDTH == 1) ? 3'b000 :
					(PORT_B_WIDTH == 2) ? 3'b001 :
					(PORT_B_WIDTH == 4 || PORT_B_WIDTH == 5) ? 3'b010 :
					(PORT_B_WIDTH == 8 || PORT_B_WIDTH == 10) ? 3'b011 : 3'b100;

// write modes
wire [1:0] A_write_mode = PORT_A_OPTION_WRITE_MODE == "NO_CHANGE" ? 2'b00 : 
						PORT_A_OPTION_WRITE_MODE == "WRITE_FIRST" ? 2'b01 : 2'b10;
wire [1:0] B_write_mode = PORT_B_OPTION_WRITE_MODE == "NO_CHANGE" ? 2'b00 : 
						PORT_B_OPTION_WRITE_MODE == "WRITE_FIRST" ? 2'b01 : 2'b10;

RAM1K20 #(
	\`PARAMS_INIT_LSRAM
) _TECHMAP_REPLACE_ (

	// port A
	.A_ADDR(A_address),
	.A_BLK_EN(A_BLK_SEL),
	.A_CLK(PORT_A_CLK),
	.A_DIN(A_write_data),
	.A_DOUT(A_read_data),
	.A_WEN(A_write_EN),
	.A_REN(PORT_A_RD_EN),
	.A_WIDTH(A_width),
	.A_WMODE(A_write_mode),
	.A_BYPASS(1'b1),
	.A_DOUT_EN(1'b1),
	.A_DOUT_SRST_N(1'b1),
	.A_DOUT_ARST_N(1'b1),

	// port B
	.B_ADDR(B_address),
	.B_BLK_EN(B_BLK_SEL),
	.B_CLK(PORT_B_CLK),
	.B_DIN(B_write_data),
	.B_DOUT(B_read_data),
	.B_WEN(B_write_EN),
	.B_REN(PORT_B_RD_EN),
	.B_WIDTH(B_width),
	.B_WMODE(B_write_mode),
	.B_BYPASS(1'b1),
	.B_DOUT_EN(1'b1),
	.B_DOUT_SRST_N(1'b1),
	.B_DOUT_ARST_N(1'b1),

	// Disable ECC for TDP
	.ECC_EN(1'b0), 
	.ECC_BYPASS(1'b1),
	.BUSY_FB(1'b0)

);

endmodule

// single dual port configuration
module $__LSRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_WIDTH_CONFIG = "REGULAR";
parameter ADDR_BITS = 14;

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 4;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;

input PORT_W_CLK;
input [ADDR_BITS-1:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_RD_EN;
input [ADDR_BITS-1:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"


// address wires
wire [ADDR_BITS-1:0] A_address;
wire [ADDR_BITS-1:0] B_address;
assign A_address = (OPTION_WIDTH_CONFIG == "REGULAR") ? PORT_R_ADDR : {PORT_R_ADDR, 2'b00};
assign B_address = (OPTION_WIDTH_CONFIG == "REGULAR") ? PORT_W_ADDR : {PORT_W_ADDR, 2'b00};

// if port is not used, set block sel to 0 to disable it (read-data output is set to 0)
// port A is for read, port B for write
parameter PORT_W_USED = 0;
parameter PORT_R_USED = 0;
wire [2:0] A_BLK_SEL = (PORT_R_USED == 1) ? 3'b111 : 3'b000;
wire [2:0] B_BLK_SEL = (PORT_W_USED == 1) ? 3'b111 : 3'b000;

// read/write data & write enables
// Currently support only wide write, width = {32, 40}
generate
	wire [19:0] A_write_data;
	wire [19:0] B_write_data;
	wire [1:0] A_write_EN;
	wire [1:0] B_write_EN;

	// write port (A provides MSB) 
	if (PORT_W_WIDTH == 32) begin

		assign B_write_data[3:0] = PORT_W_WR_DATA[3:0];
		assign B_write_data[8:5] = PORT_W_WR_DATA[7:4];
		assign B_write_data[13:10] = PORT_W_WR_DATA[11:8];
		assign B_write_data[18:15] = PORT_W_WR_DATA[15:12];
		assign B_write_data[4] = 1'b0;
		assign B_write_data[9] = 1'b0;
		assign B_write_data[14] = 1'b0;
		assign B_write_data[19] = 1'b0;

		assign A_write_data[3:0] = PORT_W_WR_DATA[19:16];
		assign A_write_data[8:5] = PORT_W_WR_DATA[23:20];
		assign A_write_data[13:10] = PORT_W_WR_DATA[27:24];
		assign A_write_data[18:15] = PORT_W_WR_DATA[31:28];
		assign A_write_data[4] = 1'b0;
		assign A_write_data[9] = 1'b0;
		assign A_write_data[14] = 1'b0;
		assign A_write_data[19] = 1'b0;
		
	end else if (PORT_W_WIDTH == 40) begin
		assign B_write_data = PORT_W_WR_DATA[19:0];
		assign A_write_data = PORT_W_WR_DATA[39:20];
	end

	// byte-write enables
	assign A_write_EN = PORT_W_WR_EN[1:0];
	assign B_write_EN = PORT_W_WR_EN[3:2];

	// read ports (A provides MSB)
	wire [19:0] A_read_data;
	wire [19:0] B_read_data;
	if (PORT_R_WIDTH == 32) begin
		assign PORT_R_RD_DATA[3:0] = B_read_data[3:0];
		assign PORT_R_RD_DATA[8:5] = B_read_data[7:4];
		assign PORT_R_RD_DATA[13:10] = B_read_data[11:8];
		assign PORT_R_RD_DATA[18:15] = B_read_data[15:12];

		assign PORT_R_RD_DATA[19:16] = A_read_data[3:0];
		assign PORT_R_RD_DATA[23:20] = A_read_data[8:5];
		assign PORT_R_RD_DATA[27:24] = A_read_data[13:10];
		assign PORT_R_RD_DATA[31:28] = A_read_data[18:15];
	end else if (PORT_R_WIDTH == 40) begin
		assign PORT_R_RD_DATA[19:0] = B_read_data[19:0];
		assign PORT_R_RD_DATA[39:20] = A_read_data[19:0];
	end
endgenerate

// port width
wire [2:0] A_width = (PORT_R_WIDTH == 1) ? 3'b000 :
					(PORT_R_WIDTH == 2) ? 3'b001 :
					(PORT_R_WIDTH == 4 || PORT_R_WIDTH == 5) ? 3'b010 :
					(PORT_R_WIDTH == 8 || PORT_R_WIDTH == 10) ? 3'b011 : 
					(PORT_R_WIDTH == 16 || PORT_R_WIDTH == 20) ? 3'b100 : 3'b101;
wire [2:0] B_width = (PORT_W_WIDTH == 1) ? 3'b000 :
					(PORT_W_WIDTH == 2) ? 3'b001 :
					(PORT_W_WIDTH == 4 || PORT_W_WIDTH == 5) ? 3'b010 :
					(PORT_W_WIDTH == 8 || PORT_W_WIDTH == 10) ? 3'b011 :
					(PORT_W_WIDTH == 16 || PORT_W_WIDTH == 20) ? 3'b100 : 3'b101;

// write modes
wire [1:0] A_write_mode = 2'b00;
wire [1:0] B_write_mode = 2'b00;

RAM1K20 #(
	\`PARAMS_INIT_LSRAM
) _TECHMAP_REPLACE_ (
	// port A - read
	.A_ADDR(A_address),
	.A_BLK_EN(A_BLK_SEL),
	.A_CLK(PORT_R_CLK),
	.A_DIN(A_write_data),
	.A_DOUT(A_read_data),
	.A_WEN(A_write_EN),
	.A_REN(PORT_R_RD_EN),
	.A_WIDTH(A_width),
	.A_WMODE(A_write_mode),
	.A_BYPASS(1'b1),
	.A_DOUT_EN(1'b1),
	.A_DOUT_SRST_N(1'b1),
	.A_DOUT_ARST_N(1'b1),

	// port B - write
	.B_ADDR(B_address),
	.B_BLK_EN(B_BLK_SEL),
	.B_CLK(PORT_W_CLK),
	.B_DIN(B_write_data),
	.B_DOUT(B_read_data),
	.B_WEN(B_write_EN),
	.B_REN(PORT_R_RD_EN),
	.B_WIDTH(B_width),
	.B_WMODE(B_write_mode),
	.B_BYPASS(1'b1),
	.B_DOUT_EN(1'b1),
	.B_DOUT_SRST_N(1'b1),
	.B_DOUT_ARST_N(1'b1),

	// Disable ECC for SDP
	.ECC_EN(1'b0), 
	.ECC_BYPASS(1'b1),
	.BUSY_FB(1'b0)
);


endmodule
`,"arith_map.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

// Based on Macro Library for PolarFire https://coredocs.s3.amazonaws.com/Libero/2021_2/Tool/pf_mlg.pdf
// NOTE: prefix module names with \\$__ so that mapping prioritizes these cells over internal Yosys cells


(* techmap_celltype = "$_MUX4_" *)
module \\$__microchip_MUX4_ (A, B, C, D, S, T, Y);
	input A, B, C, D, S, T;
	output Y;
	MX4 _TECHMAP_REPLACE_.MUX4(.D3(D), .D2(C), .D1(B), .D0(A), .S1(T), .S0(S), .Y(Y));

endmodule


(* techmap_celltype = "$reduce_xor" *)
module \\$__microchip_XOR8_ (A, Y);
	parameter A_SIGNED = 1;
	parameter A_WIDTH = 8;
	parameter Y_WIDTH = 1;

	input [A_WIDTH-1:0] A;
	output [Y_WIDTH-1:0] Y;

	// check if mapping should proceed
	generate
		if (A_WIDTH != 8 || A_SIGNED || Y_WIDTH != 1) begin
			wire _TECHMAP_FAIL_ = 1;
		end
	endgenerate


	XOR8 _TECHMAP_REPLACE_.XOR8 (.A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .F(A[5]), .G(A[6]), .H(A[7]), .Y(Y));

	
endmodule

(* techmap_celltype = "$alu" *)
module \\$__SF2_ALU (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA, BB;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(AA));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(BB));

	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		ARI1 #(
			// See section 1.4 of PolarFire Macro Library

			// G = F1 = A[i] & (B[i]^BI)
			// Y = F0 = A[i]^B[i]^BI
			// P = Y
			//		 ADCB
			.INIT(20'b 01_11_0010_1000_1001_0110)
		) carry (
			.A(1'b0),
			.B(AA[i]),
			.C(BB[i]),
			.D(BI),
			.FCI(C[i]),
			.Y(X[i]),
			.S(Y[i]),
			.FCO(CO[i])
		);
	end endgenerate
endmodule

`,"brams_defs.vh":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

\`define PARAMS_INIT_LSRAM \\
	.INIT0(slice_init_LSRAM(00)), \\
	.INIT1(slice_init_LSRAM(01)), \\
	.INIT2(slice_init_LSRAM(02)), \\
	.INIT3(slice_init_LSRAM(03)), \\
	.INIT4(slice_init_LSRAM(04)), \\
	.INIT5(slice_init_LSRAM(05)), \\
	.INIT6(slice_init_LSRAM(06)), \\
	.INIT7(slice_init_LSRAM(07)), \\
	.INIT8(slice_init_LSRAM(08)), \\
	.INIT9(slice_init_LSRAM(09)), \\
	.INIT10(slice_init_LSRAM(10)), \\
	.INIT11(slice_init_LSRAM(11)), \\
	.INIT12(slice_init_LSRAM(12)), \\
	.INIT13(slice_init_LSRAM(13)), \\
	.INIT14(slice_init_LSRAM(14)), \\
	.INIT15(slice_init_LSRAM(15)), \\
	.INIT16(slice_init_LSRAM(16)), \\
	.INIT17(slice_init_LSRAM(17)), \\
	.INIT18(slice_init_LSRAM(18)), \\
	.INIT19(slice_init_LSRAM(19))

\`define PARAMS_INIT_uSRAM \\
	.INIT0(slice_init_uSRAM(00)), \\
	.INIT1(slice_init_uSRAM(01)), \\
	.INIT2(slice_init_uSRAM(02)), \\
	.INIT3(slice_init_uSRAM(03)), \\
	.INIT4(slice_init_uSRAM(04)), \\
	.INIT5(slice_init_uSRAM(05)), \\
	.INIT6(slice_init_uSRAM(06)), \\
	.INIT7(slice_init_uSRAM(07)), \\
	.INIT8(slice_init_uSRAM(08)), \\
	.INIT9(slice_init_uSRAM(09)), \\
	.INIT10(slice_init_uSRAM(10)), \\
	.INIT11(slice_init_uSRAM(11)) \\

// Helper function for initializing the LSRAM
function [1023:0] slice_init_LSRAM;
	input integer slice_idx;
	integer i;
	for (i = 0; i < 1024; i = i + 1)
		slice_init_LSRAM[i] = INIT[(slice_idx * 1024 + i)];
endfunction

// Helper function for initializing the uSRAM
function [63:0] slice_init_uSRAM;
	input integer slice_idx;
	integer i;
	for (i = 0; i < 64; i = i + 1)
		slice_init_uSRAM[i] = INIT[(slice_idx * 64 + i)];
endfunction`,"cells_map.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

// DFFs
module \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_DFFE_PN1P_ (input D, C, R, E, output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

// for sync set/reset registers, we can pass them into ABC9. So we need to follow the simplification idiom
// and map to intermediate cell types
module \\$_SDFFCE_PN0P_ (input D, C, R, E, output Q);
	MICROCHIP_SYNC_RESET_DFF _TECHMAP_REPLACE_ (.D(D), .CLK(C), .Reset(R), .En(E), .Q(Q));
endmodule

module \\$_SDFFCE_PN1P_ (input D, C, R, E, output Q);
	MICROCHIP_SYNC_SET_DFF _TECHMAP_REPLACE_ (.D(D), .CLK(C), .Set(R), .En(E), .Q(Q));
endmodule


// LATCHES

module \\$_DLATCH_PN0_ (input D, R, E, output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

module \\$_DLATCH_PN1_ (input D, R, E, output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

module \\$_DLATCH_P_ (input D, E, output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(1'b1), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

// map intermediate flops to SLE
\`ifdef FINAL_MAP
module MICROCHIP_SYNC_SET_DFF(
	input D,
	input CLK,
	input Set,
	input En,
	output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(CLK), .EN(En), .ALn(1'b1), .ADn(1'b0), .SLn(Set), .SD(1'b1), .LAT(1'b0), .Q(Q));
endmodule

module MICROCHIP_SYNC_RESET_DFF(
	input D,
	input CLK,
	input Reset,
	input En,
	output Q);
	SLE _TECHMAP_REPLACE_ (.D(D), .CLK(CLK), .EN(En), .ALn(1'b1), .ADn(1'b0), .SLn(Reset), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule
\`endif


// LUT

\`ifndef NO_LUT
module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	(* force_downto *)
	input [WIDTH-1:0] A;
	output Y;

	generate
	if (WIDTH == 1) begin
		CFG1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]));
	end else
	if (WIDTH == 2) begin
		CFG2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]));
	end else
	if (WIDTH == 3) begin
		CFG3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]));
	end else
	if (WIDTH == 4) begin
		CFG4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
	end else begin
		wire _TECHMAP_FAIL_ = 1;
	end
	endgenerate
endmodule
\`endif

`,"cells_sim.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

// Macro Library for PolarFire https://coredocs.s3.amazonaws.com/Libero/2021_2/Tool/pf_mlg.pdf

module AND2 (
	input A, B,
	output Y
);
	assign Y = A & B;
endmodule

module AND3 (
	input A, B, C,
	output Y
);
	assign Y = A & B & C;
endmodule

module AND4 (
	input A, B, C, D,
	output Y
);
	assign Y = A & B & C & D;
endmodule

(* abc9_lut=1 *)
module CFG1 (
	output Y,
	input A
);
	parameter [1:0] INIT = 2'h0;
	assign Y = INIT >> A;
	specify
		(A => Y) = 127;
	endspecify
endmodule

(* abc9_lut=1 *)
module CFG2 (
	output Y,
	input A,
	input B
);
	parameter [3:0] INIT = 4'h0;
	assign Y = INIT >> {B, A};
	specify
		(A => Y) = 238;
		(B => Y) = 127;
	endspecify
endmodule

(* abc9_lut=1 *)
module CFG3 (
	output Y,
	input A,
	input B,
	input C
);
	parameter [7:0] INIT = 8'h0;
	assign Y = INIT >> {C, B, A};
	specify
		(A => Y) = 407;
		(B => Y) = 238;
		(C => Y) = 127;
	endspecify
endmodule

(* abc9_lut=1 *)
module CFG4 (
	output Y,
	input A,
	input B,
	input C,
	input D
);
	parameter [15:0] INIT = 16'h0;
	assign Y = INIT >> {D, C, B, A};
	specify
		(A => Y) = 472;
		(B => Y) = 407;
		(C => Y) = 238;
		(D => Y) = 127;
	endspecify
endmodule

module BUFF (
	input A,
	output Y
);
	assign Y = A;
endmodule

module BUFD (
	input A,
	output Y
);
	assign Y = A;
endmodule

module CLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module CLKINT_PRESERVE (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module GCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

module RCLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module RGCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

// sequential elements

// MICROCHIP_SYNC_SET_DFF and MICROCHIP_SYNC_RESET_DFF are intermediate cell types to implement the simplification idiom for abc9 flow 
//	see: https://yosyshq.readthedocs.io/projects/yosys/en/latest/yosys_internals/extending_yosys/abc_flow.html

(* abc9_flop, lib_whitebox *)
module MICROCHIP_SYNC_SET_DFF(
	input D,
	input CLK,
	input Set,
	input En,
	output reg Q);
	parameter [0:0] INIT = 1'b0; // unused

	always @(posedge CLK) begin
		if (En == 1) begin
			if (Set == 0)
				Q <= 1;
			else
				Q <= D;
		end
	end

	specify
		$setup(D , posedge CLK &&& En && Set, 0); // neg setup not supported?
		$setup(En, posedge CLK, 109);
		$setup(Set, posedge CLK &&& En, 404);
		if (En && !Set) (posedge CLK => (Q : 1'b1)) = 303;
		if (En && Set) (posedge CLK => (Q : D)) = 303;
	endspecify
endmodule

(* abc9_flop, lib_whitebox *)
module MICROCHIP_SYNC_RESET_DFF(
	input D,
	input CLK,
	input Reset,
	input En,
	output reg Q);
	parameter [0:0] INIT = 1'b0; // unused

	always @(posedge CLK) begin
		if (En == 1) begin
			if (Reset == 0) 
				Q <= 0;
			else
				Q <= D;
		end
	end

	specify
		$setup(D , posedge CLK &&& En && Reset, 0); // neg setup not supported?
		$setup(En, posedge CLK, 109);
		$setup(Reset, posedge CLK &&& En, 404);
		if (En && !Reset) (posedge CLK => (Q : 1'b0)) = 303;
		if (En && Reset) (posedge CLK => (Q : D)) = 303;
	endspecify
endmodule

module SLE (
	output Q,
	input ADn,
	input ALn,
	(* clkbuf_sink *)
	input CLK,
	input D,
	input LAT,
	input SD,
	input EN,
	input SLn
);
	reg q_latch, q_ff;

	always @(posedge CLK, negedge ALn) begin
		if (!ALn) begin
			q_ff <= !ADn;
		end else if (EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	always @* begin
		if (!ALn) begin
			q_latch <= !ADn;
		end else if (CLK && EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	assign Q = LAT ? q_latch : q_ff;
endmodule

(* abc9_box, lib_whitebox *)
module ARI1 (
	(* abc9_carry *)
	input FCI,
	(* abc9_carry *)
	output FCO,

	input A, B, C, D, 
	output Y, S
);
	parameter [19:0] INIT = 20'h0;
	wire [2:0] Fsel = {D, C, B};
	wire F0 = INIT[Fsel];
	wire F1 = INIT[8 + Fsel];
	wire Yout = A ? F1 : F0;
	assign Y = Yout;
	assign S = FCI ^ Yout;
	wire G = INIT[16] ? (INIT[17] ? F1 : F0) : INIT[17];
	wire P = INIT[19] ? 1'b1 : (INIT[18] ? Yout : 1'b0);
	assign FCO = P ? FCI : G;
	
	specify
		//pin to pin path delay 
		(A => Y )	= 472;
		(B => Y )	= 407;
		(C => Y )	= 238;
		(D => Y )	= 127;
		(A => S )	= 572;
		(B => S )	= 507;
		(C => S )	= 338;
		(D => S )	= 227;
		(FCI => S ) = 100;
		(A => FCO ) = 522;
		(B => FCO ) = 457;
		(C => FCO ) = 288;
		(D => FCO ) = 177;
		(FCI => FCO ) = 50;
	endspecify
endmodule

(* blackbox *)
module GCLKBUF (
	(* iopad_external_pin *)
	input PAD,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

(* blackbox *)
module GCLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

module INV (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module INVD (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module MX2 (
	input A, B, S,
	output Y
);
	assign Y = S ? B : A;
endmodule

module MX4 (
	input D0, D1, D2, D3, S0, S1,
	output Y
);
	assign Y = S1 ? (S0 ? D3 : D2) : (S0 ? D1 : D0);
endmodule

module NAND2 (
	input A, B,
	output Y
);
	assign Y = !(A & B);
endmodule

module NAND3 (
	input A, B, C,
	output Y
);
	assign Y = !(A & B & C);
endmodule

module NAND4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A & B & C & D);
endmodule

module NOR2 (
	input A, B,
	output Y
);
	assign Y = !(A | B);
endmodule

module NOR3 (
	input A, B, C,
	output Y
);
	assign Y = !(A | B | C);
endmodule

module NOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A | B | C | D);
endmodule

module OR2 (
	input A, B,
	output Y
);
	assign Y = A | B;
endmodule

module OR3 (
	input A, B, C,
	output Y
);
	assign Y = A | B | C;
endmodule

module OR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A | B | C | D;
endmodule

module XOR2 (
	input A, B,
	output Y
);
	assign Y = A ^ B;
endmodule

module XOR3 (
	input A, B, C,
	output Y
);
	assign Y = A ^ B ^ C;
endmodule

module XOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A ^ B ^ C ^ D;
endmodule

module XOR8 (
	input A, B, C, D, E, F, G, H,
	output Y
);
	assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H;
endmodule

// module UJTAG

module BIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

(* blackbox *)
module BIBUF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PADP,
	(* iopad_external_pin *)
	inout PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module CLKBIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

module CLKBUF (
	(* iopad_external_pin *)
	input PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
	specify
	 	(PAD => Y) = 50;
	endspecify
endmodule

(* blackbox *)
module CLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
endmodule

module INBUF (
	(* iopad_external_pin *)
	input PAD,
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
endmodule

(* blackbox *)
module INBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module OUTBUF (
	input D,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = D;
endmodule

(* blackbox *)
module OUTBUF_DIFF (
	input D,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

module TRIBUFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
endmodule

(* blackbox *)
module TRIBUFF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

(* blackbox *)
module MACC_PA (
	input DOTP,
	input SIMD,
	input OVFL_CARRYOUT_SEL,
	input CLK,
	input AL_N,
	input [17:0] A,
	input A_BYPASS,
	input A_SRST_N,
	input A_EN,
	input [17:0] B,
	input B_BYPASS,
	input B_SRST_N,
	input B_EN,
	input [17:0] D,
	input D_BYPASS,
	input D_ARST_N,
	input D_SRST_N,
	input D_EN,
	input CARRYIN,
	input [47:0] C,
	input C_BYPASS,
	input C_ARST_N,
	input C_SRST_N,
	input C_EN,
	input [47:0] CDIN,
	output [47:0] P,
	output OVFL_CARRYOUT,
	input P_BYPASS,
	input P_SRST_N,
	input P_EN,
	output [47:0] CDOUT,
	input PASUB,
	input PASUB_BYPASS,
	input PASUB_AD_N,
	input PASUB_SL_N,
	input PASUB_SD_N,
	input PASUB_EN,
	input [1:0] CDIN_FDBK_SEL,
	input CDIN_FDBK_SEL_BYPASS,
	input [1:0] CDIN_FDBK_SEL_AD_N,
	input CDIN_FDBK_SEL_SL_N,
	input [1:0] CDIN_FDBK_SEL_SD_N,
	input CDIN_FDBK_SEL_EN,
	input ARSHFT17,
	input ARSHFT17_BYPASS,
	input ARSHFT17_AD_N,
	input ARSHFT17_SL_N,
	input ARSHFT17_SD_N,
	input ARSHFT17_EN,
	input SUB,
	input SUB_BYPASS,
	input SUB_AD_N,
	input SUB_SL_N,
	input SUB_SD_N,
	input SUB_EN
);
endmodule

(* blackbox *)
module RAM1K20 (
	input 	[13:0] 	A_ADDR,
	input 	[2:0]	A_BLK_EN,
	input			A_CLK,
	input 	[19:0]	A_DIN,
	output	[19:0]	A_DOUT,
	input 	[1:0]	A_WEN,
	input			A_REN,
	input 	[2:0]	A_WIDTH,
	input 	[1:0]	A_WMODE,
	input 			A_BYPASS,
	input 			A_DOUT_EN,
	input 			A_DOUT_SRST_N,
	input 			A_DOUT_ARST_N,
	input 	[13:0]	B_ADDR,
	input 	[2:0]	B_BLK_EN,
	input			B_CLK,
	input 	[19:0] 	B_DIN,
	output	[19:0]	B_DOUT,
	input 	[1:0]	B_WEN,
	input			B_REN,
	input 	[2:0]	B_WIDTH,
	input 	[1:0]	B_WMODE,
	input			B_BYPASS,
	input			B_DOUT_EN,
	input			B_DOUT_SRST_N,
	input			B_DOUT_ARST_N,
	input			ECC_EN, 
	input			ECC_BYPASS,
	output			SB_CORRECT,
	output			DB_DETECT,
	input			BUSY_FB,
	output			ACCESS_BUSY
);
parameter INIT0 = 1024'h0;
parameter INIT1 = 1024'h0;
parameter INIT2 = 1024'h0;
parameter INIT3 = 1024'h0;
parameter INIT4 = 1024'h0;
parameter INIT5 = 1024'h0;
parameter INIT6 = 1024'h0;
parameter INIT7 = 1024'h0;
parameter INIT8 = 1024'h0;
parameter INIT9 = 1024'h0;
parameter INIT10 = 1024'h0;
parameter INIT11 = 1024'h0;
parameter INIT12 = 1024'h0;
parameter INIT13 = 1024'h0;
parameter INIT14 = 1024'h0;
parameter INIT15 = 1024'h0;
parameter INIT16 = 1024'h0;
parameter INIT17 = 1024'h0;
parameter INIT18 = 1024'h0;
parameter INIT19 = 1024'h0;
endmodule

(* blackbox *)
module RAM64x12 (
	input			R_CLK,
	input [5:0]		R_ADDR,
	input			R_ADDR_BYPASS,
	input			R_ADDR_EN,
	input 			R_ADDR_SL_N,
	input			R_ADDR_SD,
	input			R_ADDR_AL_N, 
	input			R_ADDR_AD_N,
	input			BLK_EN,
	output [11:0]	R_DATA,
	input			R_DATA_BYPASS,
	input	 		R_DATA_EN,
	input	 		R_DATA_SL_N,
	input	 		R_DATA_SD,
	input	 		R_DATA_AL_N,
	input	 		R_DATA_AD_N,

	input		W_CLK,
	input [5:0]	W_ADDR,
	input [11:0]W_DATA,
	input		W_EN,

	input		BUSY_FB,
	output		ACCESS_BUSY
);
parameter INIT0 = 64'h0;
parameter INIT1 = 64'h0;
parameter INIT2 = 64'h0;
parameter INIT3 = 64'h0;
parameter INIT4 = 64'h0;
parameter INIT5 = 64'h0;
parameter INIT6 = 64'h0;
parameter INIT7 = 64'h0;
parameter INIT8 = 64'h0;
parameter INIT9 = 64'h0;
parameter INIT10 = 64'h0;
parameter INIT11 = 64'h0;

endmodule`,"polarfire_dsp_map.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	// For pin descriptions, see Section 9 of PolarFire FPGA Macro Library Guide:
	// https://coredocs.s3.amazonaws.com/Libero/2021_2/Tool/pf_mlg.pdf
	MACC_PA _TECHMAP_REPLACE_ (
		.DOTP(1'b0), 
		.SIMD(1'b0), 
		.OVFL_CARRYOUT_SEL(1'b0), 

		.AL_N(1'b1),
		.A(A),
		.A_BYPASS(1'b1),
		.A_SRST_N(1'b1),
		.A_EN(1'b1),

		.B(B),
		.B_BYPASS(1'b1),
		.B_SRST_N(1'b1),
		.B_EN(1'b1),

		.D(18'b0),
		.D_BYPASS(1'b1),
		.D_ARST_N(1'b1),
		.D_SRST_N(1'b1),
		.D_EN(1'b1),
		
		.CARRYIN(1'b0),
		.C(48'b0),
		.C_BYPASS(1'b1),
		.C_ARST_N(1'b1),
		.C_SRST_N(1'b1),
		.C_EN(1'b1),

		
		.P(P_48),

		.P_BYPASS(1'b1),
		.P_SRST_N(1'b1),
		.P_EN(1'b1),

		.PASUB(1'b0),
		.PASUB_BYPASS(1'b1),
		.PASUB_AD_N(1'b0),
		.PASUB_SL_N(1'b1),
		.PASUB_SD_N(1'b0),
		.PASUB_EN(1'b1),

		.CDIN_FDBK_SEL(2'b00),
		.CDIN_FDBK_SEL_BYPASS(1'b1),
		.CDIN_FDBK_SEL_AD_N(2'b00),
		.CDIN_FDBK_SEL_SL_N(1'b1),
		.CDIN_FDBK_SEL_SD_N(2'b00),
		.CDIN_FDBK_SEL_EN(1'b1),

		.ARSHFT17(1'b0),
		.ARSHFT17_BYPASS(1'b1),
		.ARSHFT17_AD_N(1'b0),
		.ARSHFT17_SL_N(1'b1),
		.ARSHFT17_SD_N(1'b0),
		.ARSHFT17_EN(1'b1),

		.SUB(1'b0),
		.SUB_BYPASS(1'b1),
		.SUB_AD_N(1'b0),
		.SUB_SL_N(1'b1),
		.SUB_SD_N(1'b0),
		.SUB_EN(1'b1)

	);
	assign Y = P_48;
endmodule
`,"uSRAM.txt":`# ISC License
# 
# Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# asynchronous read
ram block $__uSRAM_AR_ {

	#(LSRAM cost)/3
	cost 43;

	# INIT supported
	init any;

	abits 6;
	widths 12 per_port;

	# single write enable wire
	port sw "W" {
		clock posedge;

		# collision not supported, but write takes precedence and read data is invalid while writing to 
		# the same address
		wrtrans all new;
		
		optional;
	}
	port ar "R" {
		optional;
	}
}

# synchronous read
# NOTE: synchronous read can be realized by the address pipeline register or data pipeline register.
#		This assumes address is synchronized
ram block $__uSRAM_SR_ {

	cost 42;

	init any;
	abits 6;
widths 12 per_port;

	port sw "W" {
		clock posedge;

		# collision not supported
		wrtrans all new;
		
		optional;
	}
	port sr "R" {
		clock posedge;
		rden;
		rdinit none;
		optional;
	}
}
`,"uSRAM_map.v":`/*
ISC License

Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

// See document PolarFire Family Fabric User Guide
// section 4.2 for port list.

// Asynchronous read
module $__uSRAM_AR_ (...);

parameter INIT = 0;
parameter ADDR_BITS = 6;

parameter PORT_W_WIDTH = 12;
parameter PORT_R_WIDTH = 12;
parameter PORT_R_USED = 0;
parameter PORT_W_USED = 0;

input PORT_W_CLK;
input [ADDR_BITS-1:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

input [ADDR_BITS-1:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

\`include "brams_defs.vh"

RAM64x12 #(
	\`PARAMS_INIT_uSRAM
) _TECHMAP_REPLACE_ (
	.R_ADDR(PORT_R_ADDR),
	.R_ADDR_BYPASS(1'b1),
	.R_ADDR_EN(1'b0),
	.R_ADDR_SL_N(1'b1),
	.R_ADDR_SD(1'b0),
	.R_ADDR_AL_N(1'b1), 
	.R_ADDR_AD_N(1'b0),
	.BLK_EN(PORT_R_USED ? 1'b1 : 1'b0),
	.R_DATA(PORT_R_RD_DATA),
	.R_DATA_BYPASS(1'b1),
	.R_DATA_EN(1'b0),
	.R_DATA_SL_N(1'b1),
	.R_DATA_SD(1'b0),
	.R_DATA_AL_N(1'b1),
	.R_DATA_AD_N(1'b0),

	.W_CLK(PORT_W_CLK),
	.W_ADDR(PORT_W_ADDR),
	.W_DATA(PORT_W_WR_DATA),
	.W_EN(PORT_W_WR_EN),

	.BUSY_FB(1'b0)
);

endmodule

// Synchronous read
module $__uSRAM_SR_ (...);

parameter INIT = 0;
parameter ADDR_BITS = 6;

parameter PORT_W_WIDTH = 12;
parameter PORT_R_WIDTH = 12;
parameter PORT_R_USED = 0;
parameter PORT_W_USED = 0;

input PORT_W_CLK;
input [ADDR_BITS-1:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

// Read port clock and enable signal
// that async read uSRAM doesn't have
input PORT_R_CLK;
input PORT_R_RD_EN;
input [ADDR_BITS-1:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

\`include "brams_defs.vh"

RAM64x12 #(
	\`PARAMS_INIT_uSRAM
) _TECHMAP_REPLACE_ (
	.R_CLK(PORT_R_CLK),
	.R_ADDR(PORT_R_ADDR),
	.R_ADDR_BYPASS(1'b0),
	.R_ADDR_EN(PORT_R_RD_EN),
	.R_ADDR_SL_N(1'b1),
	.R_ADDR_SD(1'b0),
	.R_ADDR_AL_N(1'b1), 
	.R_ADDR_AD_N(1'b0),
	.BLK_EN(PORT_R_USED ? 1'b1 : 1'b0),
	.R_DATA(PORT_R_RD_DATA),
	.R_DATA_BYPASS(1'b1),
	.R_DATA_EN(1'b0),
	.R_DATA_SL_N(1'b1),
	.R_DATA_SD(1'b0),
	.R_DATA_AL_N(1'b1),
	.R_DATA_AD_N(1'b0),

	.W_CLK(PORT_W_CLK),
	.W_ADDR(PORT_W_ADDR),
	.W_DATA(PORT_W_WR_DATA),
	.W_EN(PORT_W_WR_EN),

	.BUSY_FB(1'b0)
);

endmodule

`},"mul2dsp.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *                2019  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  Tech-mapping rules for decomposing arbitrarily-sized $mul cells
 *  into an equivalent collection of smaller \`DSP_NAME cells (with the 
 *  same interface as $mul) no larger than \`DSP_[AB]_MAXWIDTH, attached 
 *  to $shl and $add cells.
 *
 */

\`ifndef DSP_A_MAXWIDTH
$fatal(1, "Macro DSP_A_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_B_MAXWIDTH
$fatal(1, "Macro DSP_B_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_B_MAXWIDTH
$fatal(1, "Macro DSP_B_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_A_MAXWIDTH_PARTIAL
\`define DSP_A_MAXWIDTH_PARTIAL \`DSP_A_MAXWIDTH
\`endif
\`ifndef DSP_B_MAXWIDTH_PARTIAL
\`define DSP_B_MAXWIDTH_PARTIAL \`DSP_B_MAXWIDTH
\`endif

\`ifndef DSP_NAME
$fatal(1, "Macro DSP_NAME must be defined");
\`endif

\`define MAX(a,b) (a > b ? a : b)
\`define MIN(a,b) (a < b ? a : b)

(* techmap_celltype = "$mul $__mul" *)
module _80_mul (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	parameter _TECHMAP_CELLTYPE_ = "";

	generate
	if (0) begin end
\`ifdef DSP_A_MINWIDTH
	else if (A_WIDTH < \`DSP_A_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_B_MINWIDTH
	else if (B_WIDTH < \`DSP_B_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_Y_MINWIDTH
	else if (Y_WIDTH < \`DSP_Y_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_SIGNEDONLY
	else if (_TECHMAP_CELLTYPE_ == "$mul" && !A_SIGNED && !B_SIGNED)
		\\$mul #(
			.A_SIGNED(1),
			.B_SIGNED(1),
			.A_WIDTH(A_WIDTH + 1),
			.B_WIDTH(B_WIDTH + 1),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A({1'b0, A}),
			.B({1'b0, B}),
			.Y(Y)
		);
\`endif
	else if (_TECHMAP_CELLTYPE_ == "$mul" && A_WIDTH < B_WIDTH)
		\\$mul #(
			.A_SIGNED(B_SIGNED),
			.B_SIGNED(A_SIGNED),
			.A_WIDTH(B_WIDTH),
			.B_WIDTH(A_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(B),
			.B(A),
			.Y(Y)
		);
	else begin
		wire [1023:0] _TECHMAP_DO_ = "proc; clean";

\`ifdef DSP_SIGNEDONLY
		localparam sign_headroom = 1;
\`else
		localparam sign_headroom = 0;
\`endif

		genvar i;
		if (A_WIDTH > \`DSP_A_MAXWIDTH) begin
			localparam n = (A_WIDTH-\`DSP_A_MAXWIDTH+\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom-1) / (\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);
			localparam partial_Y_WIDTH = \`MIN(Y_WIDTH, B_WIDTH+\`DSP_A_MAXWIDTH_PARTIAL);
			localparam last_A_WIDTH = A_WIDTH-n*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);
			localparam last_Y_WIDTH = B_WIDTH+last_A_WIDTH;
			if (A_SIGNED && B_SIGNED) begin : blk
				(* force_downto *)
				wire signed [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire signed [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire signed [Y_WIDTH-1:0] partial_sum [n:0];
			end
			else begin : blk
				(* force_downto *)
				wire [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire [Y_WIDTH-1:0] partial_sum [n:0];
			end

			for (i = 0; i < n; i=i+1) begin:sliceA
				\\$__mul #(
					.A_SIGNED(sign_headroom),
					.B_SIGNED(B_SIGNED),
					.A_WIDTH(\`DSP_A_MAXWIDTH_PARTIAL),
					.B_WIDTH(B_WIDTH),
					.Y_WIDTH(partial_Y_WIDTH)
				) mul (
					.A({{sign_headroom{1'b0}}, A[i*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom) +: \`DSP_A_MAXWIDTH_PARTIAL-sign_headroom]}),
					.B(B),
					.Y(blk.partial[i])
				);
				// TODO: Currently a 'cascade' approach to summing the partial
				//       products is taken here, but a more efficient 'binary
				//       reduction' approach also exists...
				if (i == 0)
					assign blk.partial_sum[i] = blk.partial[i];
				else
					assign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];
			end

			\\$__mul #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(last_A_WIDTH),
				.B_WIDTH(B_WIDTH),
				.Y_WIDTH(last_Y_WIDTH)
			) sliceA.last (
				.A(A[A_WIDTH-1 -: last_A_WIDTH]),
				.B(B),
				.Y(blk.last_partial)
			);
			assign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];
			assign Y = blk.partial_sum[n];
		end
		else if (B_WIDTH > \`DSP_B_MAXWIDTH) begin
			localparam n = (B_WIDTH-\`DSP_B_MAXWIDTH+\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom-1) / (\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);
			localparam partial_Y_WIDTH = \`MIN(Y_WIDTH, A_WIDTH+\`DSP_B_MAXWIDTH_PARTIAL);
			localparam last_B_WIDTH = B_WIDTH-n*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);
			localparam last_Y_WIDTH = A_WIDTH+last_B_WIDTH;
			if (A_SIGNED && B_SIGNED) begin : blk
				(* force_downto *)
				wire signed [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire signed [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire signed [Y_WIDTH-1:0] partial_sum [n:0];
			end
			else begin : blk
				(* force_downto *)
				wire [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire [Y_WIDTH-1:0] partial_sum [n:0];
			end

			for (i = 0; i < n; i=i+1) begin:sliceB
				\\$__mul #(
					.A_SIGNED(A_SIGNED),
					.B_SIGNED(sign_headroom),
					.A_WIDTH(A_WIDTH),
					.B_WIDTH(\`DSP_B_MAXWIDTH_PARTIAL),
					.Y_WIDTH(partial_Y_WIDTH)
				) mul (
					.A(A),
					.B({{sign_headroom{1'b0}}, B[i*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom) +: \`DSP_B_MAXWIDTH_PARTIAL-sign_headroom]}),
					.Y(blk.partial[i])
				);
				// TODO: Currently a 'cascade' approach to summing the partial
				//       products is taken here, but a more efficient 'binary
				//       reduction' approach also exists...
				if (i == 0)
					assign blk.partial_sum[i] = blk.partial[i];
				else
					assign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];
			end

			\\$__mul #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(A_WIDTH),
				.B_WIDTH(last_B_WIDTH),
				.Y_WIDTH(last_Y_WIDTH)
			) mul_sliceB_last (
				.A(A),
				.B(B[B_WIDTH-1 -: last_B_WIDTH]),
				.Y(blk.last_partial)
			);
			assign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];
			assign Y = blk.partial_sum[n];
		end
		else begin
			if (A_SIGNED) begin : blkA
				wire signed [\`DSP_A_MAXWIDTH-1:0] Aext = $signed(A);
			end
			else begin : blkA
				wire [\`DSP_A_MAXWIDTH-1:0] Aext = A;
			end
			if (B_SIGNED) begin : blkB
				wire signed [\`DSP_B_MAXWIDTH-1:0] Bext = $signed(B);
			end
			else begin : blkB
				wire [\`DSP_B_MAXWIDTH-1:0] Bext = B;
			end

			\`DSP_NAME #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(\`DSP_A_MAXWIDTH),
				.B_WIDTH(\`DSP_B_MAXWIDTH),
				.Y_WIDTH(\`MIN(Y_WIDTH,\`DSP_A_MAXWIDTH+\`DSP_B_MAXWIDTH)),
			) _TECHMAP_REPLACE_ (
				.A(blkA.Aext),
				.B(blkB.Bext),
				.Y(Y)
			);
		end
	end
	endgenerate
endmodule

(* techmap_celltype = "$mul $__mul" *)
module _90_soft_mul (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	// Indirection necessary since mapping
	//   back to $mul will cause recursion
	generate
	if (A_SIGNED && !B_SIGNED)
		\\$__soft_mul #(
			.A_SIGNED(A_SIGNED),
			.B_SIGNED(1),
			.A_WIDTH(A_WIDTH),
			.B_WIDTH(B_WIDTH+1),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(A),
			.B({1'b0,B}),
			.Y(Y)
		);
	else if (!A_SIGNED && B_SIGNED)
		\\$__soft_mul #(
			.A_SIGNED(1),
			.B_SIGNED(B_SIGNED),
			.A_WIDTH(A_WIDTH+1),
			.B_WIDTH(B_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A({1'b0,A}),
			.B(B),
			.Y(Y)
		);
	else
		\\$__soft_mul #(
			.A_SIGNED(A_SIGNED),
			.B_SIGNED(B_SIGNED),
			.A_WIDTH(A_WIDTH),
			.B_WIDTH(B_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(A),
			.B(B),
			.Y(Y)
		);
	endgenerate
endmodule
`,nanoxplore:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Miodrag Milanovic <micko@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_nx_cy_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;
    (* force_downto *)
    wire [Y_WIDTH-1:0] COx;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice
		NX_CY_1BIT #(.first(i==0))
			alu_i (
			.CI(i==0 ? CI : COx[i-1]),
			.A(AA[i]),
			.B(BB[i]),
			.S(Y[i]),
			.CO(COx[i])
		);

	end: slice
	endgenerate

	NX_CY_1BIT alu_cout(
		.CI(COx[Y_WIDTH-1]),
		.A(1'b0),
		.B(1'b0),
		.S(CO[Y_WIDTH-1])
	);

   /* End implementation */
   assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__NX_RAM_ {
	option "STD_MODE" "NOECC_48kx1" {
		# only 32k used
		abits 15;
		widths 1 per_port;
	}
	option "STD_MODE" "NOECC_24kx2" {
		# only 16k used
		abits 14;
		widths 2 per_port;
	}
	ifndef IS_NG_MEDIUM {
		option "STD_MODE" "NOECC_16kx3" {
			abits 14;
			widths 3 per_port;
		}
	}
	option "STD_MODE" "NOECC_12kx4" {
		# only 8k used
		abits 13;
		widths 4 per_port;
	}
	ifndef IS_NG_MEDIUM {
		option "STD_MODE" "NOECC_8kx6" {
			abits 13;
			widths 6 per_port;
		}
	}
	option "STD_MODE" "NOECC_6kx8" {
		# only 4k used
		abits 12;
		widths 8 per_port;
	}
	option "STD_MODE" "NOECC_4kx12" {
		abits 12;
		widths 12 per_port;
	}
	option "STD_MODE" "NOECC_2kx24" {
		abits 11;
		widths 24 per_port;
	}
	cost 64;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		rdwr no_change;
		rdinit none;
	}
}`,"brams_init.vh":`function [409600-1:0] bram_init_to_string;
    input [49152-1:0] array;
    input integer blocks;
    input integer width;
    reg [409600-1:0] temp; // (49152+2048)*8 48K bit data + 2k commas
    reg [24-1:0] temp2; 
    integer i;
    integer j;
begin
    temp = "";
    for (i = 0; i < 2048; i = i + 1) begin
        if (i != 0) begin
            temp = {temp, ","};
        end
        temp2 = 24'b0;
        for (j = 0; j < blocks; j = j + 1) begin
            temp2[j*width +: width] = array[{j, i[10:0]}*width +: width];
        end
        temp = {temp, $sformatf("%b",temp2[23:0])};
    end
    bram_init_to_string = temp;
end
endfunction
`,"brams_map.v":`module $__NX_RAM_ (...);

parameter INIT = 0;
parameter OPTION_STD_MODE = "NOECC_24kx2";

parameter PORT_A_WIDTH = 24;
parameter PORT_B_WIDTH = 24;

parameter PORT_A_CLK_POL = 1;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
wire [24-1:0] A_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_CLK_POL = 1;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
wire [24-1:0] B_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

\`include "brams_init.vh"

localparam raw_config1_val = OPTION_STD_MODE == "NOECC_48kx1" ? 16'b0000000000000000:
                             OPTION_STD_MODE == "NOECC_24kx2" ? 16'b0000001001001001:
                             OPTION_STD_MODE == "NOECC_16kx3" ? 16'b0000110110110110:
                             OPTION_STD_MODE == "NOECC_12kx4" ? 16'b0000010010010010:
                             OPTION_STD_MODE == "NOECC_8kx6"  ? 16'b0000111111111111:
                             OPTION_STD_MODE == "NOECC_6kx8"  ? 16'b0000011011011011:
                             OPTION_STD_MODE == "NOECC_4kx12" ? 16'b0000100100100100:
                             OPTION_STD_MODE == "NOECC_2kx24" ? 16'b0000101101101101:
                             16'bx;

localparam A_REPEAT  =  24 / PORT_A_WIDTH;
localparam B_REPEAT  =  24 / PORT_B_WIDTH;

assign A_DATA = {A_REPEAT{PORT_A_WR_DATA[PORT_A_WIDTH-1:0]}};
assign B_DATA = {B_REPEAT{PORT_B_WR_DATA[PORT_B_WIDTH-1:0]}};

NX_RAM_WRAP #(
    .std_mode(OPTION_STD_MODE),
    .mcka_edge(PORT_A_CLK_POL == 1 ? 1'b0 : 1'b1),
    .mckb_edge(PORT_B_CLK_POL == 1 ? 1'b0 : 1'b1),
    .pcka_edge(PORT_A_CLK_POL == 1 ? 1'b0 : 1'b1),
    .pckb_edge(PORT_B_CLK_POL == 1 ? 1'b0 : 1'b1),
    .raw_config0(4'b0000),
    .raw_config1(raw_config1_val[15:0]),
    .mem_ctxt($sformatf("%s",bram_init_to_string(INIT,A_REPEAT,PORT_A_WIDTH))),
) _TECHMAP_REPLACE_ (
    .ACK(PORT_A_CLK),
    //.ACKS(PORT_A_CLK),
    //.ACKD(), // Not used in Non-ECC modes
    //.ACKR(),
    //.AR(),
    //.ACOR(),
    //.AERR(),
    .ACS(PORT_A_CLK_EN),
    .AWE(PORT_A_WR_EN),

    .AA(PORT_A_ADDR),
    .AI(A_DATA),
    .AO(PORT_A_RD_DATA),

    .BCK(PORT_B_CLK),
    //.BCKC(PORT_B_CLK),
    //.BCKD(), // Not used in Non-ECC modes
    //.BCKR()
    //.BR(),
    //.BCOR(),
    //.BERR(),
    .BCS(PORT_B_CLK_EN),
    .BWE(PORT_B_WR_EN),
    .BA(PORT_B_ADDR),
    .BI(B_DATA),
    .BO(PORT_B_RD_DATA)
);
endmodule
`,"cells_bb.v":`// NX_RAM related
(* blackbox *)
module NX_ECC(CKD, CHK, COR, ERR);
    input CHK;
    input CKD;
    output COR;
    output ERR;
endmodule

//TODO
(* blackbox *)
module NX_IOM_BIN2GRP(GS, DS, GVON, GVIN, GVDN, PA, LA);
    input [1:0] DS;
    input GS;
    output [2:0] GVDN;
    output [2:0] GVIN;
    output [2:0] GVON;
    input [5:0] LA;
    output [3:0] PA;
endmodule

//TODO
(* blackbox *)
module NX_SER(FCK, SCK, R, IO, DCK, DRL, I, DS, DRA, DRI, DRO, DID);
    input DCK;
    output [5:0] DID;
    input [5:0] DRA;
    input [5:0] DRI;
    input DRL;
    output [5:0] DRO;
    input [1:0] DS;
    input FCK;
    input [4:0] I;
    output IO;
    input R;
    input SCK;
    parameter data_size = 5;
    parameter differential = "";
    parameter drive = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter outputCapacity = "";
    parameter outputDelayLine = "";
    parameter slewRate = "";
    parameter spath_dynamic = 1'b0;
    parameter standard = "";
endmodule

//TODO
(* blackbox *)
module NX_DES(FCK, SCK, R, IO, DCK, DRL, DIG, FZ, FLD, FLG, O, DS, DRA, DRI, DRO, DID);
    input DCK;
    output [5:0] DID;
    input DIG;
    input [5:0] DRA;
    input [5:0] DRI;
    input DRL;
    output [5:0] DRO;
    input [1:0] DS;
    input FCK;
    output FLD;
    output FLG;
    input FZ;
    input IO;
    output [4:0] O;
    input R;
    input SCK;
    parameter data_size = 5;
    parameter differential = "";
    parameter dpath_dynamic = 1'b0;
    parameter drive = "";
    parameter inputDelayLine = "";
    parameter inputSignalSlope = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter standard = "";
    parameter termination = "";
    parameter terminationReference = "";
    parameter turbo = "";
    parameter weakTermination = "";
endmodule

//TODO
(* blackbox *)
module NX_SERDES(FCK, SCK, RTX, RRX, CI, CCK, CL, CR, IO, DCK, DRL, DIG, FZ, FLD, FLG, I, O, DS, DRA, DRI, DRO
, DID);
    input CCK;
    input CI;
    input CL;
    input CR;
    input DCK;
    output [5:0] DID;
    input DIG;
    input [5:0] DRA;
    input [5:0] DRI;
    input DRL;
    output [5:0] DRO;
    input [1:0] DS;
    input FCK;
    output FLD;
    output FLG;
    input FZ;
    input [4:0] I;
    inout IO;
    output [4:0] O;
    input RRX;
    input RTX;
    input SCK;
    parameter cpath_registered = 1'b0;
    parameter data_size = 5;
    parameter differential = "";
    parameter dpath_dynamic = 1'b0;
    parameter drive = "";
    parameter inputDelayLine = "";
    parameter inputSignalSlope = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter outputCapacity = "";
    parameter outputDelayLine = "";
    parameter slewRate = "";
    parameter spath_dynamic = 1'b0;
    parameter standard = "";
    parameter termination = "";
    parameter terminationReference = "";
    parameter turbo = "";
    parameter weakTermination = "";
endmodule
`,"cells_bb_l.v":`(* blackbox *)
module NX_CKS(CKI, CMD, CKO);
    input CKI;
    output CKO;
    input CMD;
    parameter ck_edge = 1'b0;
endmodule

(* blackbox *)
module NX_CDC_L(CK1, CK2, AI1, AI2, AI3, AI4, AI5, AI6, AO1, AO2, AO3, AO4, AO5, AO6, BI1, BI2, BI3, BI4, BI5, BI6, BO1
, BO2, BO3, BO4, BO5, BO6, CI1, CI2, CI3, CI4, CI5, CI6, CO1, CO2, CO3, CO4, CO5, CO6, DI1, DI2, DI3, DI4
, DI5, DI6, DO1, DO2, DO3, DO4, DO5, DO6);
    input AI1;
    input AI2;
    input AI3;
    input AI4;
    input AI5;
    input AI6;
    output AO1;
    output AO2;
    output AO3;
    output AO4;
    output AO5;
    output AO6;
    input BI1;
    input BI2;
    input BI3;
    input BI4;
    input BI5;
    input BI6;
    output BO1;
    output BO2;
    output BO3;
    output BO4;
    output BO5;
    output BO6;
    input CI1;
    input CI2;
    input CI3;
    input CI4;
    input CI5;
    input CI6;
    input CK1;
    input CK2;
    output CO1;
    output CO2;
    output CO3;
    output CO4;
    output CO5;
    output CO6;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter cck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter dck_sel = 1'b0;
    parameter gt0_bypass_reg1 = 1'b0;
    parameter gt0_bypass_reg2 = 1'b0;
    parameter gt1_bypass_reg1 = 1'b0;
    parameter gt1_bypass_reg2 = 1'b0;
    parameter link_BA = 1'b0;
    parameter link_CB = 1'b0;
    parameter link_DC = 1'b0;
    parameter mode = 0;
    parameter use_adest_arst = 2'b00;
    parameter use_asrc_arst = 2'b00;
    parameter use_bdest_arst = 2'b00;
    parameter use_bsrc_arst = 2'b00;
    parameter use_cdest_arst = 2'b00;
    parameter use_csrc_arst = 2'b00;
    parameter use_ddest_arst = 2'b00;
    parameter use_dsrc_arst = 2'b00;
endmodule

(* blackbox *)
module NX_DSP_L(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21
, A22, A23, A24, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18
, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21
, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, CAI1, CAI2, CAI3, CAI4, CAI5, CAI6
, CAI7, CAI8, CAI9, CAI10, CAI11, CAI12, CAI13, CAI14, CAI15, CAI16, CAI17, CAI18, CAI19, CAI20, CAI21, CAI22, CAI23, CAI24, CAO1, CAO2, CAO3
, CAO4, CAO5, CAO6, CAO7, CAO8, CAO9, CAO10, CAO11, CAO12, CAO13, CAO14, CAO15, CAO16, CAO17, CAO18, CAO19, CAO20, CAO21, CAO22, CAO23, CAO24
, CBI1, CBI2, CBI3, CBI4, CBI5, CBI6, CBI7, CBI8, CBI9, CBI10, CBI11, CBI12, CBI13, CBI14, CBI15, CBI16, CBI17, CBI18, CBO1, CBO2, CBO3
, CBO4, CBO5, CBO6, CBO7, CBO8, CBO9, CBO10, CBO11, CBO12, CBO13, CBO14, CBO15, CBO16, CBO17, CBO18, CCI, CCO, CI, CK, CO, CO37
, CO57, CZI1, CZI2, CZI3, CZI4, CZI5, CZI6, CZI7, CZI8, CZI9, CZI10, CZI11, CZI12, CZI13, CZI14, CZI15, CZI16, CZI17, CZI18, CZI19, CZI20
, CZI21, CZI22, CZI23, CZI24, CZI25, CZI26, CZI27, CZI28, CZI29, CZI30, CZI31, CZI32, CZI33, CZI34, CZI35, CZI36, CZI37, CZI38, CZI39, CZI40, CZI41
, CZI42, CZI43, CZI44, CZI45, CZI46, CZI47, CZI48, CZI49, CZI50, CZI51, CZI52, CZI53, CZI54, CZI55, CZI56, CZO1, CZO2, CZO3, CZO4, CZO5, CZO6
, CZO7, CZO8, CZO9, CZO10, CZO11, CZO12, CZO13, CZO14, CZO15, CZO16, CZO17, CZO18, CZO19, CZO20, CZO21, CZO22, CZO23, CZO24, CZO25, CZO26, CZO27
, CZO28, CZO29, CZO30, CZO31, CZO32, CZO33, CZO34, CZO35, CZO36, CZO37, CZO38, CZO39, CZO40, CZO41, CZO42, CZO43, CZO44, CZO45, CZO46, CZO47, CZO48
, CZO49, CZO50, CZO51, CZO52, CZO53, CZO54, CZO55, CZO56, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13
, D14, D15, D16, D17, D18, OVF, R, RZ, WE, Z1, Z2, Z3, Z4, Z5, Z6, Z7, Z8, Z9, Z10, Z11, Z12
, Z13, Z14, Z15, Z16, Z17, Z18, Z19, Z20, Z21, Z22, Z23, Z24, Z25, Z26, Z27, Z28, Z29, Z30, Z31, Z32, Z33
, Z34, Z35, Z36, Z37, Z38, Z39, Z40, Z41, Z42, Z43, Z44, Z45, Z46, Z47, Z48, Z49, Z50, Z51, Z52, Z53, Z54
, Z55, Z56);
    input A1;
    input A10;
    input A11;
    input A12;
    input A13;
    input A14;
    input A15;
    input A16;
    input A17;
    input A18;
    input A19;
    input A2;
    input A20;
    input A21;
    input A22;
    input A23;
    input A24;
    input A3;
    input A4;
    input A5;
    input A6;
    input A7;
    input A8;
    input A9;
    input B1;
    input B10;
    input B11;
    input B12;
    input B13;
    input B14;
    input B15;
    input B16;
    input B17;
    input B18;
    input B2;
    input B3;
    input B4;
    input B5;
    input B6;
    input B7;
    input B8;
    input B9;
    input C1;
    input C10;
    input C11;
    input C12;
    input C13;
    input C14;
    input C15;
    input C16;
    input C17;
    input C18;
    input C19;
    input C2;
    input C20;
    input C21;
    input C22;
    input C23;
    input C24;
    input C25;
    input C26;
    input C27;
    input C28;
    input C29;
    input C3;
    input C30;
    input C31;
    input C32;
    input C33;
    input C34;
    input C35;
    input C36;
    input C4;
    input C5;
    input C6;
    input C7;
    input C8;
    input C9;
    input CAI1;
    input CAI10;
    input CAI11;
    input CAI12;
    input CAI13;
    input CAI14;
    input CAI15;
    input CAI16;
    input CAI17;
    input CAI18;
    input CAI19;
    input CAI2;
    input CAI20;
    input CAI21;
    input CAI22;
    input CAI23;
    input CAI24;
    input CAI3;
    input CAI4;
    input CAI5;
    input CAI6;
    input CAI7;
    input CAI8;
    input CAI9;
    output CAO1;
    output CAO10;
    output CAO11;
    output CAO12;
    output CAO13;
    output CAO14;
    output CAO15;
    output CAO16;
    output CAO17;
    output CAO18;
    output CAO19;
    output CAO2;
    output CAO20;
    output CAO21;
    output CAO22;
    output CAO23;
    output CAO24;
    output CAO3;
    output CAO4;
    output CAO5;
    output CAO6;
    output CAO7;
    output CAO8;
    output CAO9;
    input CBI1;
    input CBI10;
    input CBI11;
    input CBI12;
    input CBI13;
    input CBI14;
    input CBI15;
    input CBI16;
    input CBI17;
    input CBI18;
    input CBI2;
    input CBI3;
    input CBI4;
    input CBI5;
    input CBI6;
    input CBI7;
    input CBI8;
    input CBI9;
    output CBO1;
    output CBO10;
    output CBO11;
    output CBO12;
    output CBO13;
    output CBO14;
    output CBO15;
    output CBO16;
    output CBO17;
    output CBO18;
    output CBO2;
    output CBO3;
    output CBO4;
    output CBO5;
    output CBO6;
    output CBO7;
    output CBO8;
    output CBO9;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO37;
    output CO57;
    input CZI1;
    input CZI10;
    input CZI11;
    input CZI12;
    input CZI13;
    input CZI14;
    input CZI15;
    input CZI16;
    input CZI17;
    input CZI18;
    input CZI19;
    input CZI2;
    input CZI20;
    input CZI21;
    input CZI22;
    input CZI23;
    input CZI24;
    input CZI25;
    input CZI26;
    input CZI27;
    input CZI28;
    input CZI29;
    input CZI3;
    input CZI30;
    input CZI31;
    input CZI32;
    input CZI33;
    input CZI34;
    input CZI35;
    input CZI36;
    input CZI37;
    input CZI38;
    input CZI39;
    input CZI4;
    input CZI40;
    input CZI41;
    input CZI42;
    input CZI43;
    input CZI44;
    input CZI45;
    input CZI46;
    input CZI47;
    input CZI48;
    input CZI49;
    input CZI5;
    input CZI50;
    input CZI51;
    input CZI52;
    input CZI53;
    input CZI54;
    input CZI55;
    input CZI56;
    input CZI6;
    input CZI7;
    input CZI8;
    input CZI9;
    output CZO1;
    output CZO10;
    output CZO11;
    output CZO12;
    output CZO13;
    output CZO14;
    output CZO15;
    output CZO16;
    output CZO17;
    output CZO18;
    output CZO19;
    output CZO2;
    output CZO20;
    output CZO21;
    output CZO22;
    output CZO23;
    output CZO24;
    output CZO25;
    output CZO26;
    output CZO27;
    output CZO28;
    output CZO29;
    output CZO3;
    output CZO30;
    output CZO31;
    output CZO32;
    output CZO33;
    output CZO34;
    output CZO35;
    output CZO36;
    output CZO37;
    output CZO38;
    output CZO39;
    output CZO4;
    output CZO40;
    output CZO41;
    output CZO42;
    output CZO43;
    output CZO44;
    output CZO45;
    output CZO46;
    output CZO47;
    output CZO48;
    output CZO49;
    output CZO5;
    output CZO50;
    output CZO51;
    output CZO52;
    output CZO53;
    output CZO54;
    output CZO55;
    output CZO56;
    output CZO6;
    output CZO7;
    output CZO8;
    output CZO9;
    input D1;
    input D10;
    input D11;
    input D12;
    input D13;
    input D14;
    input D15;
    input D16;
    input D17;
    input D18;
    input D2;
    input D3;
    input D4;
    input D5;
    input D6;
    input D7;
    input D8;
    input D9;
    output OVF;
    input R;
    input RZ;
    input WE;
    output Z1;
    output Z10;
    output Z11;
    output Z12;
    output Z13;
    output Z14;
    output Z15;
    output Z16;
    output Z17;
    output Z18;
    output Z19;
    output Z2;
    output Z20;
    output Z21;
    output Z22;
    output Z23;
    output Z24;
    output Z25;
    output Z26;
    output Z27;
    output Z28;
    output Z29;
    output Z3;
    output Z30;
    output Z31;
    output Z32;
    output Z33;
    output Z34;
    output Z35;
    output Z36;
    output Z37;
    output Z38;
    output Z39;
    output Z4;
    output Z40;
    output Z41;
    output Z42;
    output Z43;
    output Z44;
    output Z45;
    output Z46;
    output Z47;
    output Z48;
    output Z49;
    output Z5;
    output Z50;
    output Z51;
    output Z52;
    output Z53;
    output Z54;
    output Z55;
    output Z56;
    output Z6;
    output Z7;
    output Z8;
    output Z9;
    parameter raw_config0 = 20'b00000000000000000000;
    parameter raw_config1 = 19'b0000000000000000000;
    parameter raw_config2 = 13'b0000000000000;
    parameter raw_config3 = 7'b0000000;
    parameter std_mode = "";
endmodule

(* blackbox *)
module NX_PLL_L(REF, FBK, R, VCO, LDFO, REFO, DIVO1, DIVO2, DIVP1, DIVP2, DIVP3, OSC, PLL_LOCKED, CAL_LOCKED);
    output CAL_LOCKED;
    output DIVO1;
    output DIVO2;
    output DIVP1;
    output DIVP2;
    output DIVP3;
    input FBK;
    output LDFO;
    output OSC;
    output PLL_LOCKED;
    input R;
    input REF;
    output REFO;
    output VCO;
    parameter cfg_use_pll = 1'b1;
    parameter clk_outdivo1 = 0;
    parameter clk_outdivp1 = 0;
    parameter clk_outdivp2 = 0;
    parameter clk_outdivp3o2 = 0;
    parameter ext_fbk_on = 1'b0;
    parameter fbk_delay = 0;
    parameter fbk_delay_on = 1'b0;
    parameter fbk_intdiv = 2;
    parameter location = "";
    parameter pll_cpump = 3'b010;
    parameter ref_intdiv = 0;
    parameter ref_osc_on = 1'b0;
    parameter wfg_sync_cal_lock = 1'b0;
    parameter wfg_sync_pll_lock = 1'b0;
endmodule

(* blackbox *)
module NX_WFG_L(R, SI, ZI, RDY, SO, ZO);
    input R;
    input RDY;
    input SI;
    output SO;
    input ZI;
    output ZO;
    parameter delay = 0;
    parameter delay_on = 1'b0;
    parameter location = "";
    parameter mode = 1'b0;
    parameter pattern = 16'b0000000000000000;
    parameter pattern_end = 1;
    parameter wfg_edge = 1'b0;
endmodule

(* blackbox *)
module NX_CRX_L(DSCR_E_I, DEC_E_I, ALIGN_E_I, ALIGN_S_I, REP_E_I, BUF_R_I, OVS_BS_I1, OVS_BS_I2, BUF_FE_I, RST_N_I, CDR_R_I, CKG_RN_I, PLL_RN_I, TST_I1, TST_I2, TST_I3, TST_I4, LOS_O, DATA_O1, DATA_O2, DATA_O3
, DATA_O4, DATA_O5, DATA_O6, DATA_O7, DATA_O8, DATA_O9, DATA_O10, DATA_O11, DATA_O12, DATA_O13, DATA_O14, DATA_O15, DATA_O16, DATA_O17, DATA_O18, DATA_O19, DATA_O20, DATA_O21, DATA_O22, DATA_O23, DATA_O24
, DATA_O25, DATA_O26, DATA_O27, DATA_O28, DATA_O29, DATA_O30, DATA_O31, DATA_O32, DATA_O33, DATA_O34, DATA_O35, DATA_O36, DATA_O37, DATA_O38, DATA_O39, DATA_O40, DATA_O41, DATA_O42, DATA_O43, DATA_O44, DATA_O45
, DATA_O46, DATA_O47, DATA_O48, DATA_O49, DATA_O50, DATA_O51, DATA_O52, DATA_O53, DATA_O54, DATA_O55, DATA_O56, DATA_O57, DATA_O58, DATA_O59, DATA_O60, DATA_O61, DATA_O62, DATA_O63, DATA_O64, CH_COM_O1, CH_COM_O2
, CH_COM_O3, CH_COM_O4, CH_COM_O5, CH_COM_O6, CH_COM_O7, CH_COM_O8, CH_K_O1, CH_K_O2, CH_K_O3, CH_K_O4, CH_K_O5, CH_K_O6, CH_K_O7, CH_K_O8, NIT_O1, NIT_O2, NIT_O3, NIT_O4, NIT_O5, NIT_O6, NIT_O7
, NIT_O8, D_ERR_O1, D_ERR_O2, D_ERR_O3, D_ERR_O4, D_ERR_O5, D_ERR_O6, D_ERR_O7, D_ERR_O8, CH_A_O1, CH_A_O2, CH_A_O3, CH_A_O4, CH_A_O5, CH_A_O6, CH_A_O7, CH_A_O8, CH_F_O1, CH_F_O2, CH_F_O3, CH_F_O4
, CH_F_O5, CH_F_O6, CH_F_O7, CH_F_O8, ALIGN_O, BUSY_O, TST_O1, TST_O2, TST_O3, TST_O4, TST_O5, TST_O6, TST_O7, TST_O8, LOCK_O, RX_I, LINK);
    input ALIGN_E_I;
    output ALIGN_O;
    input ALIGN_S_I;
    input BUF_FE_I;
    input BUF_R_I;
    output BUSY_O;
    input CDR_R_I;
    output CH_A_O1;
    output CH_A_O2;
    output CH_A_O3;
    output CH_A_O4;
    output CH_A_O5;
    output CH_A_O6;
    output CH_A_O7;
    output CH_A_O8;
    output CH_COM_O1;
    output CH_COM_O2;
    output CH_COM_O3;
    output CH_COM_O4;
    output CH_COM_O5;
    output CH_COM_O6;
    output CH_COM_O7;
    output CH_COM_O8;
    output CH_F_O1;
    output CH_F_O2;
    output CH_F_O3;
    output CH_F_O4;
    output CH_F_O5;
    output CH_F_O6;
    output CH_F_O7;
    output CH_F_O8;
    output CH_K_O1;
    output CH_K_O2;
    output CH_K_O3;
    output CH_K_O4;
    output CH_K_O5;
    output CH_K_O6;
    output CH_K_O7;
    output CH_K_O8;
    input CKG_RN_I;
    output DATA_O1;
    output DATA_O10;
    output DATA_O11;
    output DATA_O12;
    output DATA_O13;
    output DATA_O14;
    output DATA_O15;
    output DATA_O16;
    output DATA_O17;
    output DATA_O18;
    output DATA_O19;
    output DATA_O2;
    output DATA_O20;
    output DATA_O21;
    output DATA_O22;
    output DATA_O23;
    output DATA_O24;
    output DATA_O25;
    output DATA_O26;
    output DATA_O27;
    output DATA_O28;
    output DATA_O29;
    output DATA_O3;
    output DATA_O30;
    output DATA_O31;
    output DATA_O32;
    output DATA_O33;
    output DATA_O34;
    output DATA_O35;
    output DATA_O36;
    output DATA_O37;
    output DATA_O38;
    output DATA_O39;
    output DATA_O4;
    output DATA_O40;
    output DATA_O41;
    output DATA_O42;
    output DATA_O43;
    output DATA_O44;
    output DATA_O45;
    output DATA_O46;
    output DATA_O47;
    output DATA_O48;
    output DATA_O49;
    output DATA_O5;
    output DATA_O50;
    output DATA_O51;
    output DATA_O52;
    output DATA_O53;
    output DATA_O54;
    output DATA_O55;
    output DATA_O56;
    output DATA_O57;
    output DATA_O58;
    output DATA_O59;
    output DATA_O6;
    output DATA_O60;
    output DATA_O61;
    output DATA_O62;
    output DATA_O63;
    output DATA_O64;
    output DATA_O7;
    output DATA_O8;
    output DATA_O9;
    input DEC_E_I;
    input DSCR_E_I;
    output D_ERR_O1;
    output D_ERR_O2;
    output D_ERR_O3;
    output D_ERR_O4;
    output D_ERR_O5;
    output D_ERR_O6;
    output D_ERR_O7;
    output D_ERR_O8;
    inout [9:0] LINK;
    output LOCK_O;
    output LOS_O;
    output NIT_O1;
    output NIT_O2;
    output NIT_O3;
    output NIT_O4;
    output NIT_O5;
    output NIT_O6;
    output NIT_O7;
    output NIT_O8;
    input OVS_BS_I1;
    input OVS_BS_I2;
    input PLL_RN_I;
    input REP_E_I;
    input RST_N_I;
    input RX_I;
    input TST_I1;
    input TST_I2;
    input TST_I3;
    input TST_I4;
    output TST_O1;
    output TST_O2;
    output TST_O3;
    output TST_O4;
    output TST_O5;
    output TST_O6;
    output TST_O7;
    output TST_O8;
    parameter location = "";
    parameter pcs_8b_dscr_sel = 1'b0;
    parameter pcs_align_bypass = 1'b0;
    parameter pcs_buffers_bypass = 1'b0;
    parameter pcs_buffers_use_cdc = 1'b0;
    parameter pcs_bypass_pma_cdc = 1'b0;
    parameter pcs_bypass_usr_cdc = 1'b0;
    parameter pcs_comma_mask = 10'b0000000000;
    parameter pcs_debug_en = 1'b0;
    parameter pcs_dec_bypass = 1'b0;
    parameter pcs_dscr_bypass = 1'b0;
    parameter pcs_el_buff_diff_bef_comp = 3'b000;
    parameter pcs_el_buff_max_comp = 3'b000;
    parameter pcs_el_buff_only_one_skp = 1'b0;
    parameter pcs_el_buff_skp_char_0 = 9'b000000000;
    parameter pcs_el_buff_skp_char_1 = 9'b000000000;
    parameter pcs_el_buff_skp_char_2 = 9'b000000000;
    parameter pcs_el_buff_skp_char_3 = 9'b000000000;
    parameter pcs_el_buff_skp_header_0 = 9'b000000000;
    parameter pcs_el_buff_skp_header_1 = 9'b000000000;
    parameter pcs_el_buff_skp_header_2 = 9'b000000000;
    parameter pcs_el_buff_skp_header_3 = 9'b000000000;
    parameter pcs_el_buff_skp_header_size = 2'b00;
    parameter pcs_el_buff_skp_seq_size = 2'b00;
    parameter pcs_el_buff_underflow_handle = 1'b0;
    parameter pcs_fsm_sel = 2'b00;
    parameter pcs_fsm_watchdog_en = 1'b0;
    parameter pcs_loopback = 1'b0;
    parameter pcs_m_comma_en = 1'b0;
    parameter pcs_m_comma_val = 10'b0000000000;
    parameter pcs_nb_comma_bef_realign = 2'b00;
    parameter pcs_p_comma_en = 1'b0;
    parameter pcs_p_comma_val = 10'b0000000000;
    parameter pcs_polarity = 1'b0;
    parameter pcs_protocol_size = 1'b0;
    parameter pcs_replace_bypass = 1'b0;
    parameter pcs_sync_supported = 1'b0;
    parameter pma_cdr_cp = 4'b0000;
    parameter pma_clk_pos = 1'b0;
    parameter pma_ctrl_term = 6'b000000;
    parameter pma_loopback = 1'b0;
    parameter pma_pll_cpump_n = 3'b000;
    parameter pma_pll_divf = 2'b00;
    parameter pma_pll_divf_en_n = 1'b0;
    parameter pma_pll_divm = 2'b00;
    parameter pma_pll_divm_en_n = 1'b0;
    parameter pma_pll_divn = 1'b0;
    parameter pma_pll_divn_en_n = 1'b0;
    parameter test = 2'b00;
endmodule

(* blackbox *)
module NX_CTX_L(ENC_E_I1, ENC_E_I2, ENC_E_I3, ENC_E_I4, ENC_E_I5, ENC_E_I6, ENC_E_I7, ENC_E_I8, CH_K_I1, CH_K_I2, CH_K_I3, CH_K_I4, CH_K_I5, CH_K_I6, CH_K_I7, CH_K_I8, SCR_E_I1, SCR_E_I2, SCR_E_I3, SCR_E_I4, SCR_E_I5
, SCR_E_I6, SCR_E_I7, SCR_E_I8, EOMF_I1, EOMF_I2, EOMF_I3, EOMF_I4, EOMF_I5, EOMF_I6, EOMF_I7, EOMF_I8, EOF_I1, EOF_I2, EOF_I3, EOF_I4, EOF_I5, EOF_I6, EOF_I7, EOF_I8, REP_E_I, RST_N_I
, TST_I1, TST_I2, TST_I3, TST_I4, DATA_I1, DATA_I2, DATA_I3, DATA_I4, DATA_I5, DATA_I6, DATA_I7, DATA_I8, DATA_I9, DATA_I10, DATA_I11, DATA_I12, DATA_I13, DATA_I14, DATA_I15, DATA_I16, DATA_I17
, DATA_I18, DATA_I19, DATA_I20, DATA_I21, DATA_I22, DATA_I23, DATA_I24, DATA_I25, DATA_I26, DATA_I27, DATA_I28, DATA_I29, DATA_I30, DATA_I31, DATA_I32, DATA_I33, DATA_I34, DATA_I35, DATA_I36, DATA_I37, DATA_I38
, DATA_I39, DATA_I40, DATA_I41, DATA_I42, DATA_I43, DATA_I44, DATA_I45, DATA_I46, DATA_I47, DATA_I48, DATA_I49, DATA_I50, DATA_I51, DATA_I52, DATA_I53, DATA_I54, DATA_I55, DATA_I56, DATA_I57, DATA_I58, DATA_I59
, DATA_I60, DATA_I61, DATA_I62, DATA_I63, DATA_I64, TST_O1, TST_O2, TST_O3, TST_O4, BUSY_O, CLK_E_I, TX_O, LINK);
    output BUSY_O;
    input CH_K_I1;
    input CH_K_I2;
    input CH_K_I3;
    input CH_K_I4;
    input CH_K_I5;
    input CH_K_I6;
    input CH_K_I7;
    input CH_K_I8;
    input CLK_E_I;
    input DATA_I1;
    input DATA_I10;
    input DATA_I11;
    input DATA_I12;
    input DATA_I13;
    input DATA_I14;
    input DATA_I15;
    input DATA_I16;
    input DATA_I17;
    input DATA_I18;
    input DATA_I19;
    input DATA_I2;
    input DATA_I20;
    input DATA_I21;
    input DATA_I22;
    input DATA_I23;
    input DATA_I24;
    input DATA_I25;
    input DATA_I26;
    input DATA_I27;
    input DATA_I28;
    input DATA_I29;
    input DATA_I3;
    input DATA_I30;
    input DATA_I31;
    input DATA_I32;
    input DATA_I33;
    input DATA_I34;
    input DATA_I35;
    input DATA_I36;
    input DATA_I37;
    input DATA_I38;
    input DATA_I39;
    input DATA_I4;
    input DATA_I40;
    input DATA_I41;
    input DATA_I42;
    input DATA_I43;
    input DATA_I44;
    input DATA_I45;
    input DATA_I46;
    input DATA_I47;
    input DATA_I48;
    input DATA_I49;
    input DATA_I5;
    input DATA_I50;
    input DATA_I51;
    input DATA_I52;
    input DATA_I53;
    input DATA_I54;
    input DATA_I55;
    input DATA_I56;
    input DATA_I57;
    input DATA_I58;
    input DATA_I59;
    input DATA_I6;
    input DATA_I60;
    input DATA_I61;
    input DATA_I62;
    input DATA_I63;
    input DATA_I64;
    input DATA_I7;
    input DATA_I8;
    input DATA_I9;
    input ENC_E_I1;
    input ENC_E_I2;
    input ENC_E_I3;
    input ENC_E_I4;
    input ENC_E_I5;
    input ENC_E_I6;
    input ENC_E_I7;
    input ENC_E_I8;
    input EOF_I1;
    input EOF_I2;
    input EOF_I3;
    input EOF_I4;
    input EOF_I5;
    input EOF_I6;
    input EOF_I7;
    input EOF_I8;
    input EOMF_I1;
    input EOMF_I2;
    input EOMF_I3;
    input EOMF_I4;
    input EOMF_I5;
    input EOMF_I6;
    input EOMF_I7;
    input EOMF_I8;
    inout [19:0] LINK;
    input REP_E_I;
    input RST_N_I;
    input SCR_E_I1;
    input SCR_E_I2;
    input SCR_E_I3;
    input SCR_E_I4;
    input SCR_E_I5;
    input SCR_E_I6;
    input SCR_E_I7;
    input SCR_E_I8;
    input TST_I1;
    input TST_I2;
    input TST_I3;
    input TST_I4;
    output TST_O1;
    output TST_O2;
    output TST_O3;
    output TST_O4;
    output TX_O;
    parameter location = "";
    parameter pcs_8b_scr_sel = 1'b0;
    parameter pcs_bypass_pma_cdc = 1'b0;
    parameter pcs_bypass_usr_cdc = 1'b0;
    parameter pcs_enc_bypass = 1'b0;
    parameter pcs_esistream_fsm_en = 1'b0;
    parameter pcs_loopback = 1'b0;
    parameter pcs_polarity = 1'b0;
    parameter pcs_protocol_size = 1'b0;
    parameter pcs_replace_bypass = 1'b0;
    parameter pcs_scr_bypass = 1'b0;
    parameter pcs_scr_init = 17'b00000000000000000;
    parameter pcs_sync_supported = 1'b0;
    parameter pma_clk_pos = 1'b0;
    parameter pma_loopback = 1'b0;
    parameter test = 2'b00;
endmodule

(* blackbox *)
module NX_IOM_L(RTCK1, RRCK1, WTCK1, WRCK1, RTCK2, RRCK2, WTCK2, WRCK2, CTCK, CCK, DCK, C1TW, C1TS, C1RW1, C1RW2, C1RW3, C1RNE, C1RS, C2TW, C2TS, C2RW1
, C2RW2, C2RW3, C2RNE, C2RS, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DC, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3
, DRA4, DRA5, DRA6, DRL, DOS, DOG, DIS, DIG, DPAS, DPAG, DQSS, DQSG, DS1, DS2, CAD1, CAD2, CAD3, CAD4, CAD5, CAD6, CAP1
, CAP2, CAP3, CAP4, CAN1, CAN2, CAN3, CAN4, CAT1, CAT2, CAT3, CAT4, CKO1, CKO2, FLD, FLG, C1RED, C2RED, DRO1, DRO2, DRO3, DRO4
, DRO5, DRO6, CAL, P1CI1, P1CL, P1CR, P1CO, P1CTI, P1CTO, P1EI1, P1EI2, P1EI3, P1EI4, P1EI5, P1EL, P1ER, P1EO, P1RI, P1RL, P1RR, P1RO1
, P1RO2, P1RO3, P1RO4, P1RO5, P2CI1, P2CL, P2CR, P2CO, P2CTI, P2CTO, P2EI1, P2EI2, P2EI3, P2EI4, P2EI5, P2EL, P2ER, P2EO, P2RI, P2RL, P2RR
, P2RO1, P2RO2, P2RO3, P2RO4, P2RO5, P3CI1, P3CL, P3CR, P3CO, P3CTI, P3CTO, P3EI1, P3EI2, P3EI3, P3EI4, P3EI5, P3EL, P3ER, P3EO, P3RI, P3RL
, P3RR, P3RO1, P3RO2, P3RO3, P3RO4, P3RO5, P4CI1, P4CL, P4CR, P4CO, P4CTI, P4CTO, P4EI1, P4EI2, P4EI3, P4EI4, P4EI5, P4EL, P4ER, P4EO, P4RI
, P4RL, P4RR, P4RO1, P4RO2, P4RO3, P4RO4, P4RO5, P5CI1, P5CI2, P5CI3, P5CI4, P5CI5, P5CL, P5CR, P5CO, P5CTI, P5CTO, P5EI1, P5EI2, P5EI3, P5EI4
, P5EI5, P5EL, P5ER, P5EO, P5RI, P5RL, P5RR, P5RO1, P5RO2, P5RO3, P5RO4, P5RO5, P6CI1, P6CL, P6CR, P6CO, P6CTI, P6CTO, P6EI1, P6EI2, P6EI3
, P6EI4, P6EI5, P6EL, P6ER, P6EO, P6RI, P6RL, P6RR, P6RO1, P6RO2, P6RO3, P6RO4, P6RO5, P7CI1, P7CL, P7CR, P7CO, P7CTI, P7CTO, P7EI1, P7EI2
, P7EI3, P7EI4, P7EI5, P7EL, P7ER, P7EO, P7RI, P7RL, P7RR, P7RO1, P7RO2, P7RO3, P7RO4, P7RO5, P8CI1, P8CL, P8CR, P8CO, P8CTI, P8CTO, P8EI1
, P8EI2, P8EI3, P8EI4, P8EI5, P8EL, P8ER, P8EO, P8RI, P8RL, P8RR, P8RO1, P8RO2, P8RO3, P8RO4, P8RO5, P9CI1, P9CL, P9CR, P9CO, P9CTI, P9CTO
, P9EI1, P9EI2, P9EI3, P9EI4, P9EI5, P9EL, P9ER, P9EO, P9RI, P9RL, P9RR, P9RO1, P9RO2, P9RO3, P9RO4, P9RO5, P10CI1, P10CL, P10CR, P10CO, P10CTI
, P10CTO, P10EI1, P10EI2, P10EI3, P10EI4, P10EI5, P10EL, P10ER, P10EO, P10RI, P10RL, P10RR, P10RO1, P10RO2, P10RO3, P10RO4, P10RO5, P11CI1, P11CL, P11CR, P11CO
, P11CTI, P11CTO, P11EI1, P11EI2, P11EI3, P11EI4, P11EI5, P11EL, P11ER, P11EO, P11RI, P11RL, P11RR, P11RO1, P11RO2, P11RO3, P11RO4, P11RO5, P12CI1, P12CL, P12CR
, P12CO, P12CTI, P12CTO, P12EI1, P12EI2, P12EI3, P12EI4, P12EI5, P12EL, P12ER, P12EO, P12RI, P12RL, P12RR, P12RO1, P12RO2, P12RO3, P12RO4, P12RO5, P13CI1, P13CL
, P13CR, P13CO, P13CTI, P13CTO, P13EI1, P13EI2, P13EI3, P13EI4, P13EI5, P13EL, P13ER, P13EO, P13RI, P13RL, P13RR, P13RO1, P13RO2, P13RO3, P13RO4, P13RO5, P14CI1
, P14CL, P14CR, P14CO, P14CTI, P14CTO, P14EI1, P14EI2, P14EI3, P14EI4, P14EI5, P14EL, P14ER, P14EO, P14RI, P14RL, P14RR, P14RO1, P14RO2, P14RO3, P14RO4, P14RO5
, P15CI1, P15CL, P15CR, P15CO, P15CTI, P15CTO, P15EI1, P15EI2, P15EI3, P15EI4, P15EI5, P15EL, P15ER, P15EO, P15RI, P15RL, P15RR, P15RO1, P15RO2, P15RO3, P15RO4
, P15RO5, P16CI1, P16CL, P16CR, P16CO, P16CTI, P16CTO, P16EI1, P16EI2, P16EI3, P16EI4, P16EI5, P16EL, P16ER, P16EO, P16RI, P16RL, P16RR, P16RO1, P16RO2, P16RO3
, P16RO4, P16RO5, P17CI1, P17CL, P17CR, P17CO, P17CTI, P17CTO, P17EI1, P17EI2, P17EI3, P17EI4, P17EI5, P17EL, P17ER, P17EO, P17RI, P17RL, P17RR, P17RO1, P17RO2
, P17RO3, P17RO4, P17RO5, P18CI1, P18CL, P18CR, P18CO, P18CTI, P18CTO, P18EI1, P18EI2, P18EI3, P18EI4, P18EI5, P18EL, P18ER, P18EO, P18RI, P18RL, P18RR, P18RO1
, P18RO2, P18RO3, P18RO4, P18RO5, P19CI1, P19CL, P19CR, P19CO, P19CTI, P19CTO, P19EI1, P19EI2, P19EI3, P19EI4, P19EI5, P19EL, P19ER, P19EO, P19RI, P19RL, P19RR
, P19RO1, P19RO2, P19RO3, P19RO4, P19RO5, P20CI1, P20CL, P20CR, P20CO, P20CTI, P20CTO, P20EI1, P20EI2, P20EI3, P20EI4, P20EI5, P20EL, P20ER, P20EO, P20RI, P20RL
, P20RR, P20RO1, P20RO2, P20RO3, P20RO4, P20RO5, P21CI1, P21CL, P21CR, P21CO, P21CTI, P21CTO, P21EI1, P21EI2, P21EI3, P21EI4, P21EI5, P21EL, P21ER, P21EO, P21RI
, P21RL, P21RR, P21RO1, P21RO2, P21RO3, P21RO4, P21RO5, P22CI1, P22CL, P22CR, P22CO, P22CTI, P22CTO, P22EI1, P22EI2, P22EI3, P22EI4, P22EI5, P22EL, P22ER, P22EO
, P22RI, P22RL, P22RR, P22RO1, P22RO2, P22RO3, P22RO4, P22RO5, P23CI1, P23CL, P23CR, P23CO, P23CTI, P23CTO, P23EI1, P23EI2, P23EI3, P23EI4, P23EI5, P23EL, P23ER
, P23EO, P23RI, P23RL, P23RR, P23RO1, P23RO2, P23RO3, P23RO4, P23RO5, P24CI1, P24CL, P24CR, P24CO, P24CTI, P24CTO, P24EI1, P24EI2, P24EI3, P24EI4, P24EI5, P24EL
, P24ER, P24EO, P24RI, P24RL, P24RR, P24RO1, P24RO2, P24RO3, P24RO4, P24RO5, P25CI1, P25CL, P25CR, P25CO, P25CTI, P25CTO, P25EI1, P25EI2, P25EI3, P25EI4, P25EI5
, P25EL, P25ER, P25EO, P25RI, P25RL, P25RR, P25RO1, P25RO2, P25RO3, P25RO4, P25RO5, P26CI1, P26CL, P26CR, P26CO, P26CTI, P26CTO, P26EI1, P26EI2, P26EI3, P26EI4
, P26EI5, P26EL, P26ER, P26EO, P26RI, P26RL, P26RR, P26RO1, P26RO2, P26RO3, P26RO4, P26RO5, P27CI1, P27CL, P27CR, P27CO, P27CTI, P27CTO, P27EI1, P27EI2, P27EI3
, P27EI4, P27EI5, P27EL, P27ER, P27EO, P27RI, P27RL, P27RR, P27RO1, P27RO2, P27RO3, P27RO4, P27RO5, P28CI1, P28CL, P28CR, P28CO, P28CTI, P28CTO, P28EI1, P28EI2
, P28EI3, P28EI4, P28EI5, P28EL, P28ER, P28EO, P28RI, P28RL, P28RR, P28RO1, P28RO2, P28RO3, P28RO4, P28RO5, P29CI1, P29CI2, P29CI3, P29CI4, P29CI5, P29CL, P29CR
, P29CO, P29CTI, P29CTO, P29EI1, P29EI2, P29EI3, P29EI4, P29EI5, P29EL, P29ER, P29EO, P29RI, P29RL, P29RR, P29RO1, P29RO2, P29RO3, P29RO4, P29RO5, P30CI1, P30CL
, P30CR, P30CO, P30CTI, P30CTO, P30EI1, P30EI2, P30EI3, P30EI4, P30EI5, P30EL, P30ER, P30EO, P30RI, P30RL, P30RR, P30RO1, P30RO2, P30RO3, P30RO4, P30RO5, P31CI1
, P31CL, P31CR, P31CO, P31CTI, P31CTO, P31EI1, P31EI2, P31EI3, P31EI4, P31EI5, P31EL, P31ER, P31EO, P31RI, P31RL, P31RR, P31RO1, P31RO2, P31RO3, P31RO4, P31RO5
, P32CI1, P32CL, P32CR, P32CO, P32CTI, P32CTO, P32EI1, P32EI2, P32EI3, P32EI4, P32EI5, P32EL, P32ER, P32EO, P32RI, P32RL, P32RR, P32RO1, P32RO2, P32RO3, P32RO4
, P32RO5, P33CI1, P33CL, P33CR, P33CO, P33CTI, P33CTO, P33EI1, P33EI2, P33EI3, P33EI4, P33EI5, P33EL, P33ER, P33EO, P33RI, P33RL, P33RR, P33RO1, P33RO2, P33RO3
, P33RO4, P33RO5, P34CI1, P34CL, P34CR, P34CO, P34CTI, P34CTO, P34EI1, P34EI2, P34EI3, P34EI4, P34EI5, P34EL, P34ER, P34EO, P34RI, P34RL, P34RR, P34RO1, P34RO2
, P34RO3, P34RO4, P34RO5);
    output C1RED;
    input C1RNE;
    input C1RS;
    input C1RW1;
    input C1RW2;
    input C1RW3;
    input C1TS;
    input C1TW;
    output C2RED;
    input C2RNE;
    input C2RS;
    input C2RW1;
    input C2RW2;
    input C2RW3;
    input C2TS;
    input C2TW;
    input CAD1;
    input CAD2;
    input CAD3;
    input CAD4;
    input CAD5;
    input CAD6;
    output CAL;
    input CAN1;
    input CAN2;
    input CAN3;
    input CAN4;
    input CAP1;
    input CAP2;
    input CAP3;
    input CAP4;
    input CAT1;
    input CAT2;
    input CAT3;
    input CAT4;
    input CCK;
    output CKO1;
    output CKO2;
    input CTCK;
    input DC;
    input DCK;
    input DIG;
    input DIS;
    input DOG;
    input DOS;
    input DPAG;
    input DPAS;
    input DQSG;
    input DQSS;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRA5;
    input DRA6;
    input DRI1;
    input DRI2;
    input DRI3;
    input DRI4;
    input DRI5;
    input DRI6;
    input DRL;
    output DRO1;
    output DRO2;
    output DRO3;
    output DRO4;
    output DRO5;
    output DRO6;
    input DS1;
    input DS2;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    output FLD;
    output FLG;
    input FZ;
    input P10CI1;
    input P10CL;
    output P10CO;
    input P10CR;
    input P10CTI;
    output P10CTO;
    input P10EI1;
    input P10EI2;
    input P10EI3;
    input P10EI4;
    input P10EI5;
    input P10EL;
    output P10EO;
    input P10ER;
    input P10RI;
    input P10RL;
    output P10RO1;
    output P10RO2;
    output P10RO3;
    output P10RO4;
    output P10RO5;
    input P10RR;
    input P11CI1;
    input P11CL;
    output P11CO;
    input P11CR;
    input P11CTI;
    output P11CTO;
    input P11EI1;
    input P11EI2;
    input P11EI3;
    input P11EI4;
    input P11EI5;
    input P11EL;
    output P11EO;
    input P11ER;
    input P11RI;
    input P11RL;
    output P11RO1;
    output P11RO2;
    output P11RO3;
    output P11RO4;
    output P11RO5;
    input P11RR;
    input P12CI1;
    input P12CL;
    output P12CO;
    input P12CR;
    input P12CTI;
    output P12CTO;
    input P12EI1;
    input P12EI2;
    input P12EI3;
    input P12EI4;
    input P12EI5;
    input P12EL;
    output P12EO;
    input P12ER;
    input P12RI;
    input P12RL;
    output P12RO1;
    output P12RO2;
    output P12RO3;
    output P12RO4;
    output P12RO5;
    input P12RR;
    input P13CI1;
    input P13CL;
    output P13CO;
    input P13CR;
    input P13CTI;
    output P13CTO;
    input P13EI1;
    input P13EI2;
    input P13EI3;
    input P13EI4;
    input P13EI5;
    input P13EL;
    output P13EO;
    input P13ER;
    input P13RI;
    input P13RL;
    output P13RO1;
    output P13RO2;
    output P13RO3;
    output P13RO4;
    output P13RO5;
    input P13RR;
    input P14CI1;
    input P14CL;
    output P14CO;
    input P14CR;
    input P14CTI;
    output P14CTO;
    input P14EI1;
    input P14EI2;
    input P14EI3;
    input P14EI4;
    input P14EI5;
    input P14EL;
    output P14EO;
    input P14ER;
    input P14RI;
    input P14RL;
    output P14RO1;
    output P14RO2;
    output P14RO3;
    output P14RO4;
    output P14RO5;
    input P14RR;
    input P15CI1;
    input P15CL;
    output P15CO;
    input P15CR;
    input P15CTI;
    output P15CTO;
    input P15EI1;
    input P15EI2;
    input P15EI3;
    input P15EI4;
    input P15EI5;
    input P15EL;
    output P15EO;
    input P15ER;
    input P15RI;
    input P15RL;
    output P15RO1;
    output P15RO2;
    output P15RO3;
    output P15RO4;
    output P15RO5;
    input P15RR;
    input P16CI1;
    input P16CL;
    output P16CO;
    input P16CR;
    input P16CTI;
    output P16CTO;
    input P16EI1;
    input P16EI2;
    input P16EI3;
    input P16EI4;
    input P16EI5;
    input P16EL;
    output P16EO;
    input P16ER;
    input P16RI;
    input P16RL;
    output P16RO1;
    output P16RO2;
    output P16RO3;
    output P16RO4;
    output P16RO5;
    input P16RR;
    input P17CI1;
    input P17CL;
    output P17CO;
    input P17CR;
    input P17CTI;
    output P17CTO;
    input P17EI1;
    input P17EI2;
    input P17EI3;
    input P17EI4;
    input P17EI5;
    input P17EL;
    output P17EO;
    input P17ER;
    input P17RI;
    input P17RL;
    output P17RO1;
    output P17RO2;
    output P17RO3;
    output P17RO4;
    output P17RO5;
    input P17RR;
    input P18CI1;
    input P18CL;
    output P18CO;
    input P18CR;
    input P18CTI;
    output P18CTO;
    input P18EI1;
    input P18EI2;
    input P18EI3;
    input P18EI4;
    input P18EI5;
    input P18EL;
    output P18EO;
    input P18ER;
    input P18RI;
    input P18RL;
    output P18RO1;
    output P18RO2;
    output P18RO3;
    output P18RO4;
    output P18RO5;
    input P18RR;
    input P19CI1;
    input P19CL;
    output P19CO;
    input P19CR;
    input P19CTI;
    output P19CTO;
    input P19EI1;
    input P19EI2;
    input P19EI3;
    input P19EI4;
    input P19EI5;
    input P19EL;
    output P19EO;
    input P19ER;
    input P19RI;
    input P19RL;
    output P19RO1;
    output P19RO2;
    output P19RO3;
    output P19RO4;
    output P19RO5;
    input P19RR;
    input P1CI1;
    input P1CL;
    output P1CO;
    input P1CR;
    input P1CTI;
    output P1CTO;
    input P1EI1;
    input P1EI2;
    input P1EI3;
    input P1EI4;
    input P1EI5;
    input P1EL;
    output P1EO;
    input P1ER;
    input P1RI;
    input P1RL;
    output P1RO1;
    output P1RO2;
    output P1RO3;
    output P1RO4;
    output P1RO5;
    input P1RR;
    input P20CI1;
    input P20CL;
    output P20CO;
    input P20CR;
    input P20CTI;
    output P20CTO;
    input P20EI1;
    input P20EI2;
    input P20EI3;
    input P20EI4;
    input P20EI5;
    input P20EL;
    output P20EO;
    input P20ER;
    input P20RI;
    input P20RL;
    output P20RO1;
    output P20RO2;
    output P20RO3;
    output P20RO4;
    output P20RO5;
    input P20RR;
    input P21CI1;
    input P21CL;
    output P21CO;
    input P21CR;
    input P21CTI;
    output P21CTO;
    input P21EI1;
    input P21EI2;
    input P21EI3;
    input P21EI4;
    input P21EI5;
    input P21EL;
    output P21EO;
    input P21ER;
    input P21RI;
    input P21RL;
    output P21RO1;
    output P21RO2;
    output P21RO3;
    output P21RO4;
    output P21RO5;
    input P21RR;
    input P22CI1;
    input P22CL;
    output P22CO;
    input P22CR;
    input P22CTI;
    output P22CTO;
    input P22EI1;
    input P22EI2;
    input P22EI3;
    input P22EI4;
    input P22EI5;
    input P22EL;
    output P22EO;
    input P22ER;
    input P22RI;
    input P22RL;
    output P22RO1;
    output P22RO2;
    output P22RO3;
    output P22RO4;
    output P22RO5;
    input P22RR;
    input P23CI1;
    input P23CL;
    output P23CO;
    input P23CR;
    input P23CTI;
    output P23CTO;
    input P23EI1;
    input P23EI2;
    input P23EI3;
    input P23EI4;
    input P23EI5;
    input P23EL;
    output P23EO;
    input P23ER;
    input P23RI;
    input P23RL;
    output P23RO1;
    output P23RO2;
    output P23RO3;
    output P23RO4;
    output P23RO5;
    input P23RR;
    input P24CI1;
    input P24CL;
    output P24CO;
    input P24CR;
    input P24CTI;
    output P24CTO;
    input P24EI1;
    input P24EI2;
    input P24EI3;
    input P24EI4;
    input P24EI5;
    input P24EL;
    output P24EO;
    input P24ER;
    input P24RI;
    input P24RL;
    output P24RO1;
    output P24RO2;
    output P24RO3;
    output P24RO4;
    output P24RO5;
    input P24RR;
    input P25CI1;
    input P25CL;
    output P25CO;
    input P25CR;
    input P25CTI;
    output P25CTO;
    input P25EI1;
    input P25EI2;
    input P25EI3;
    input P25EI4;
    input P25EI5;
    input P25EL;
    output P25EO;
    input P25ER;
    input P25RI;
    input P25RL;
    output P25RO1;
    output P25RO2;
    output P25RO3;
    output P25RO4;
    output P25RO5;
    input P25RR;
    input P26CI1;
    input P26CL;
    output P26CO;
    input P26CR;
    input P26CTI;
    output P26CTO;
    input P26EI1;
    input P26EI2;
    input P26EI3;
    input P26EI4;
    input P26EI5;
    input P26EL;
    output P26EO;
    input P26ER;
    input P26RI;
    input P26RL;
    output P26RO1;
    output P26RO2;
    output P26RO3;
    output P26RO4;
    output P26RO5;
    input P26RR;
    input P27CI1;
    input P27CL;
    output P27CO;
    input P27CR;
    input P27CTI;
    output P27CTO;
    input P27EI1;
    input P27EI2;
    input P27EI3;
    input P27EI4;
    input P27EI5;
    input P27EL;
    output P27EO;
    input P27ER;
    input P27RI;
    input P27RL;
    output P27RO1;
    output P27RO2;
    output P27RO3;
    output P27RO4;
    output P27RO5;
    input P27RR;
    input P28CI1;
    input P28CL;
    output P28CO;
    input P28CR;
    input P28CTI;
    output P28CTO;
    input P28EI1;
    input P28EI2;
    input P28EI3;
    input P28EI4;
    input P28EI5;
    input P28EL;
    output P28EO;
    input P28ER;
    input P28RI;
    input P28RL;
    output P28RO1;
    output P28RO2;
    output P28RO3;
    output P28RO4;
    output P28RO5;
    input P28RR;
    input P29CI1;
    input P29CI2;
    input P29CI3;
    input P29CI4;
    input P29CI5;
    input P29CL;
    output P29CO;
    input P29CR;
    input P29CTI;
    output P29CTO;
    input P29EI1;
    input P29EI2;
    input P29EI3;
    input P29EI4;
    input P29EI5;
    input P29EL;
    output P29EO;
    input P29ER;
    input P29RI;
    input P29RL;
    output P29RO1;
    output P29RO2;
    output P29RO3;
    output P29RO4;
    output P29RO5;
    input P29RR;
    input P2CI1;
    input P2CL;
    output P2CO;
    input P2CR;
    input P2CTI;
    output P2CTO;
    input P2EI1;
    input P2EI2;
    input P2EI3;
    input P2EI4;
    input P2EI5;
    input P2EL;
    output P2EO;
    input P2ER;
    input P2RI;
    input P2RL;
    output P2RO1;
    output P2RO2;
    output P2RO3;
    output P2RO4;
    output P2RO5;
    input P2RR;
    input P30CI1;
    input P30CL;
    output P30CO;
    input P30CR;
    input P30CTI;
    output P30CTO;
    input P30EI1;
    input P30EI2;
    input P30EI3;
    input P30EI4;
    input P30EI5;
    input P30EL;
    output P30EO;
    input P30ER;
    input P30RI;
    input P30RL;
    output P30RO1;
    output P30RO2;
    output P30RO3;
    output P30RO4;
    output P30RO5;
    input P30RR;
    input P31CI1;
    input P31CL;
    output P31CO;
    input P31CR;
    input P31CTI;
    output P31CTO;
    input P31EI1;
    input P31EI2;
    input P31EI3;
    input P31EI4;
    input P31EI5;
    input P31EL;
    output P31EO;
    input P31ER;
    input P31RI;
    input P31RL;
    output P31RO1;
    output P31RO2;
    output P31RO3;
    output P31RO4;
    output P31RO5;
    input P31RR;
    input P32CI1;
    input P32CL;
    output P32CO;
    input P32CR;
    input P32CTI;
    output P32CTO;
    input P32EI1;
    input P32EI2;
    input P32EI3;
    input P32EI4;
    input P32EI5;
    input P32EL;
    output P32EO;
    input P32ER;
    input P32RI;
    input P32RL;
    output P32RO1;
    output P32RO2;
    output P32RO3;
    output P32RO4;
    output P32RO5;
    input P32RR;
    input P33CI1;
    input P33CL;
    output P33CO;
    input P33CR;
    input P33CTI;
    output P33CTO;
    input P33EI1;
    input P33EI2;
    input P33EI3;
    input P33EI4;
    input P33EI5;
    input P33EL;
    output P33EO;
    input P33ER;
    input P33RI;
    input P33RL;
    output P33RO1;
    output P33RO2;
    output P33RO3;
    output P33RO4;
    output P33RO5;
    input P33RR;
    input P34CI1;
    input P34CL;
    output P34CO;
    input P34CR;
    input P34CTI;
    output P34CTO;
    input P34EI1;
    input P34EI2;
    input P34EI3;
    input P34EI4;
    input P34EI5;
    input P34EL;
    output P34EO;
    input P34ER;
    input P34RI;
    input P34RL;
    output P34RO1;
    output P34RO2;
    output P34RO3;
    output P34RO4;
    output P34RO5;
    input P34RR;
    input P3CI1;
    input P3CL;
    output P3CO;
    input P3CR;
    input P3CTI;
    output P3CTO;
    input P3EI1;
    input P3EI2;
    input P3EI3;
    input P3EI4;
    input P3EI5;
    input P3EL;
    output P3EO;
    input P3ER;
    input P3RI;
    input P3RL;
    output P3RO1;
    output P3RO2;
    output P3RO3;
    output P3RO4;
    output P3RO5;
    input P3RR;
    input P4CI1;
    input P4CL;
    output P4CO;
    input P4CR;
    input P4CTI;
    output P4CTO;
    input P4EI1;
    input P4EI2;
    input P4EI3;
    input P4EI4;
    input P4EI5;
    input P4EL;
    output P4EO;
    input P4ER;
    input P4RI;
    input P4RL;
    output P4RO1;
    output P4RO2;
    output P4RO3;
    output P4RO4;
    output P4RO5;
    input P4RR;
    input P5CI1;
    input P5CI2;
    input P5CI3;
    input P5CI4;
    input P5CI5;
    input P5CL;
    output P5CO;
    input P5CR;
    input P5CTI;
    output P5CTO;
    input P5EI1;
    input P5EI2;
    input P5EI3;
    input P5EI4;
    input P5EI5;
    input P5EL;
    output P5EO;
    input P5ER;
    input P5RI;
    input P5RL;
    output P5RO1;
    output P5RO2;
    output P5RO3;
    output P5RO4;
    output P5RO5;
    input P5RR;
    input P6CI1;
    input P6CL;
    output P6CO;
    input P6CR;
    input P6CTI;
    output P6CTO;
    input P6EI1;
    input P6EI2;
    input P6EI3;
    input P6EI4;
    input P6EI5;
    input P6EL;
    output P6EO;
    input P6ER;
    input P6RI;
    input P6RL;
    output P6RO1;
    output P6RO2;
    output P6RO3;
    output P6RO4;
    output P6RO5;
    input P6RR;
    input P7CI1;
    input P7CL;
    output P7CO;
    input P7CR;
    input P7CTI;
    output P7CTO;
    input P7EI1;
    input P7EI2;
    input P7EI3;
    input P7EI4;
    input P7EI5;
    input P7EL;
    output P7EO;
    input P7ER;
    input P7RI;
    input P7RL;
    output P7RO1;
    output P7RO2;
    output P7RO3;
    output P7RO4;
    output P7RO5;
    input P7RR;
    input P8CI1;
    input P8CL;
    output P8CO;
    input P8CR;
    input P8CTI;
    output P8CTO;
    input P8EI1;
    input P8EI2;
    input P8EI3;
    input P8EI4;
    input P8EI5;
    input P8EL;
    output P8EO;
    input P8ER;
    input P8RI;
    input P8RL;
    output P8RO1;
    output P8RO2;
    output P8RO3;
    output P8RO4;
    output P8RO5;
    input P8RR;
    input P9CI1;
    input P9CL;
    output P9CO;
    input P9CR;
    input P9CTI;
    output P9CTO;
    input P9EI1;
    input P9EI2;
    input P9EI3;
    input P9EI4;
    input P9EI5;
    input P9EL;
    output P9EO;
    input P9ER;
    input P9RI;
    input P9RL;
    output P9RO1;
    output P9RO2;
    output P9RO3;
    output P9RO4;
    output P9RO5;
    input P9RR;
    input RRCK1;
    input RRCK2;
    input RTCK1;
    input RTCK2;
    input WRCK1;
    input WRCK2;
    input WTCK1;
    input WTCK2;
    parameter div_rx1 = 4'b0000;
    parameter div_rx2 = 4'b0000;
    parameter div_tx1 = 4'b0000;
    parameter div_tx2 = 4'b0000;
    parameter mode_io_cal = 1'b0;
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter pads_dict = "";
    parameter pads_path = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_clkr_rx1 = 1'b0;
    parameter sel_clkr_rx2 = 1'b0;
    parameter sel_clkw_rx1 = 2'b00;
    parameter sel_clkw_rx2 = 2'b00;
endmodule

(* blackbox *)
module NX_PMA_L(CLK_USER_I, CLK_REF_I, PRE_SG_I, PRE_EN_I, PRE_IS_I1, PRE_IS_I2, PRE_IS_I3, PRE_IS_I4, MAIN_SG_I, MAIN_EN_I1, MAIN_EN_I2, MAIN_EN_I3, MAIN_EN_I4, MAIN_EN_I5, MAIN_EN_I6, MARG_S_I1, MARG_S_I2, MARG_S_I3, MARG_S_I4, MARG_IS_I1, MARG_IS_I2
, MARG_IS_I3, MARG_IS_I4, MARG_SV_I1, MARG_SV_I2, MARG_SV_I3, MARG_SV_I4, MARG_SV_I5, MARG_ISV_I1, MARG_ISV_I2, MARG_ISV_I3, MARG_ISV_I4, MARG_ISV_I5, POST_EN_I1, POST_EN_I2, POST_EN_I3, POST_EN_I4, POST_EN_I5, POST_SG_I, POST_IS_I1, POST_IS_I2, POST_IS_I3
, POST_IS_I4, POST_ISV_I1, POST_ISV_I2, POST_ISV_I3, POST_ISV_I4, TX_SEL_I1, TX_SEL_I2, TX_SEL_I3, TX_SEL_I4, TX_SEL_I5, TX_SEL_I6, CT_CAP_I1, CT_CAP_I2, CT_CAP_I3, CT_CAP_I4, CT_RESP_I1, CT_RESP_I2, CT_RESP_I3, CT_RESP_I4, CT_RESN_I1, CT_RESN_I2
, CT_RESN_I3, CT_RESN_I4, M_EYE_I, RX_SEL_I1, RX_SEL_I2, RX_SEL_I3, RX_SEL_I4, RX_SEL_I5, RX_SEL_I6, PLL_RN_I, RST_N_I, CAL_1P_I1, CAL_1P_I2, CAL_1P_I3, CAL_1P_I4, CAL_1P_I5, CAL_1P_I6, CAL_1P_I7, CAL_1P_I8, CAL_2N_I1, CAL_2N_I2
, CAL_2N_I3, CAL_2N_I4, CAL_2N_I5, CAL_2N_I6, CAL_2N_I7, CAL_2N_I8, CAL_3N_I1, CAL_3N_I2, CAL_3N_I3, CAL_3N_I4, CAL_3N_I5, CAL_3N_I6, CAL_3N_I7, CAL_3N_I8, CAL_4P_I1, CAL_4P_I2, CAL_4P_I3, CAL_4P_I4, CAL_4P_I5, CAL_4P_I6, CAL_4P_I7
, CAL_4P_I8, CAL_SEL_I1, CAL_SEL_I2, CAL_SEL_I3, CAL_SEL_I4, CAL_E_I, LOCK_E_I, OVS_E_I, TST_I1, TST_I2, TST_I3, TST_I4, TST_I5, TST_I6, TST_I7, TST_I8, CLK_O, LOCK_O, CAL_O, TST_O1, TST_O2
, TST_O3, TST_O4, TST_O5, TST_O6, TST_O7, TST_O8, CLK_EXT_I, LINK_TX1, LINK_TX2, LINK_TX3, LINK_TX4, LINK_TX5, LINK_RX0, LINK_RX1, LINK_RX2, LINK_RX3, LINK_RX4, LINK_RX5, LINK_TX0);
    input CAL_1P_I1;
    input CAL_1P_I2;
    input CAL_1P_I3;
    input CAL_1P_I4;
    input CAL_1P_I5;
    input CAL_1P_I6;
    input CAL_1P_I7;
    input CAL_1P_I8;
    input CAL_2N_I1;
    input CAL_2N_I2;
    input CAL_2N_I3;
    input CAL_2N_I4;
    input CAL_2N_I5;
    input CAL_2N_I6;
    input CAL_2N_I7;
    input CAL_2N_I8;
    input CAL_3N_I1;
    input CAL_3N_I2;
    input CAL_3N_I3;
    input CAL_3N_I4;
    input CAL_3N_I5;
    input CAL_3N_I6;
    input CAL_3N_I7;
    input CAL_3N_I8;
    input CAL_4P_I1;
    input CAL_4P_I2;
    input CAL_4P_I3;
    input CAL_4P_I4;
    input CAL_4P_I5;
    input CAL_4P_I6;
    input CAL_4P_I7;
    input CAL_4P_I8;
    input CAL_E_I;
    output CAL_O;
    input CAL_SEL_I1;
    input CAL_SEL_I2;
    input CAL_SEL_I3;
    input CAL_SEL_I4;
    input CLK_EXT_I;
    output CLK_O;
    input CLK_REF_I;
    input CLK_USER_I;
    input CT_CAP_I1;
    input CT_CAP_I2;
    input CT_CAP_I3;
    input CT_CAP_I4;
    input CT_RESN_I1;
    input CT_RESN_I2;
    input CT_RESN_I3;
    input CT_RESN_I4;
    input CT_RESP_I1;
    input CT_RESP_I2;
    input CT_RESP_I3;
    input CT_RESP_I4;
    inout [9:0] LINK_RX0;
    inout [9:0] LINK_RX1;
    inout [9:0] LINK_RX2;
    inout [9:0] LINK_RX3;
    inout [9:0] LINK_RX4;
    inout [9:0] LINK_RX5;
    inout [19:0] LINK_TX0;
    inout [19:0] LINK_TX1;
    inout [19:0] LINK_TX2;
    inout [19:0] LINK_TX3;
    inout [19:0] LINK_TX4;
    inout [19:0] LINK_TX5;
    input LOCK_E_I;
    output LOCK_O;
    input MAIN_EN_I1;
    input MAIN_EN_I2;
    input MAIN_EN_I3;
    input MAIN_EN_I4;
    input MAIN_EN_I5;
    input MAIN_EN_I6;
    input MAIN_SG_I;
    input MARG_ISV_I1;
    input MARG_ISV_I2;
    input MARG_ISV_I3;
    input MARG_ISV_I4;
    input MARG_ISV_I5;
    input MARG_IS_I1;
    input MARG_IS_I2;
    input MARG_IS_I3;
    input MARG_IS_I4;
    input MARG_SV_I1;
    input MARG_SV_I2;
    input MARG_SV_I3;
    input MARG_SV_I4;
    input MARG_SV_I5;
    input MARG_S_I1;
    input MARG_S_I2;
    input MARG_S_I3;
    input MARG_S_I4;
    input M_EYE_I;
    input OVS_E_I;
    input PLL_RN_I;
    input POST_EN_I1;
    input POST_EN_I2;
    input POST_EN_I3;
    input POST_EN_I4;
    input POST_EN_I5;
    input POST_ISV_I1;
    input POST_ISV_I2;
    input POST_ISV_I3;
    input POST_ISV_I4;
    input POST_IS_I1;
    input POST_IS_I2;
    input POST_IS_I3;
    input POST_IS_I4;
    input POST_SG_I;
    input PRE_EN_I;
    input PRE_IS_I1;
    input PRE_IS_I2;
    input PRE_IS_I3;
    input PRE_IS_I4;
    input PRE_SG_I;
    input RST_N_I;
    input RX_SEL_I1;
    input RX_SEL_I2;
    input RX_SEL_I3;
    input RX_SEL_I4;
    input RX_SEL_I5;
    input RX_SEL_I6;
    input TST_I1;
    input TST_I2;
    input TST_I3;
    input TST_I4;
    input TST_I5;
    input TST_I6;
    input TST_I7;
    input TST_I8;
    output TST_O1;
    output TST_O2;
    output TST_O3;
    output TST_O4;
    output TST_O5;
    output TST_O6;
    output TST_O7;
    output TST_O8;
    input TX_SEL_I1;
    input TX_SEL_I2;
    input TX_SEL_I3;
    input TX_SEL_I4;
    input TX_SEL_I5;
    input TX_SEL_I6;
    parameter location = "";
    parameter main_clk_to_fabric_div_en = 1'b0;
    parameter main_clk_to_fabric_div_mode = 1'b0;
    parameter main_clk_to_fabric_sel = 1'b0;
    parameter main_test = 8'b00000000;
    parameter main_use_only_usr_clock = 1'b0;
    parameter main_use_pcs_clk_2 = 1'b0;
    parameter pcs_ovs_mode = 1'b0;
    parameter pcs_pll_lock_count = 3'b000;
    parameter pcs_word_len = 2'b00;
    parameter pll_pma_cpump_n = 3'b000;
    parameter pll_pma_divf = 2'b00;
    parameter pll_pma_divf_en_n = 1'b0;
    parameter pll_pma_divm = 2'b00;
    parameter pll_pma_divm_en_n = 1'b0;
    parameter pll_pma_divn = 1'b0;
    parameter pll_pma_divn_en_n = 1'b0;
    parameter pll_pma_int_data_len = 1'b0;
    parameter pll_pma_lvds_mux = 1'b0;
    parameter pll_pma_mux_ckref = 1'b0;
    parameter rx_pma_half_step = 1'b0;
endmodule

(* blackbox *)
module NX_RFB_L(RCK, WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, COR, ERR, O1
, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, RA1, RA2, RA3, RA4, RA5, RA6
, RE, WA1, WA2, WA3, WA4, WA5, WA6, WE);
    output COR;
    output ERR;
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I2;
    input I3;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O2;
    output O3;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RCK;
    input RE;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    parameter mem_ctxt = "";
    parameter mode = 0;
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;
endmodule

(* blackbox *)
module NX_IOM_CONTROL_L(RTCK1, RRCK1, WTCK1, WRCK1, RTCK2, RRCK2, WTCK2, WRCK2, CTCK, C1TW, C1TS, C1RW1, C1RW2, C1RW3, C1RNE, C1RS, C2TW, C2TS, C2RW1, C2RW2, C2RW3
, C2RNE, C2RS, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DC, CCK, DCK, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3
, DRA4, DRA5, DRA6, DRL, DOS, DOG, DIS, DIG, DPAS, DPAG, DQSS, DQSG, DS1, DS2, CAD1, CAD2, CAD3, CAD4, CAD5, CAD6, CAP1
, CAP2, CAP3, CAP4, CAN1, CAN2, CAN3, CAN4, CAT1, CAT2, CAT3, CAT4, CKO1, CKO2, FLD, FLG, C1RED, C2RED, DRO1, DRO2, DRO3, DRO4
, DRO5, DRO6, CAL, LINK2, LINK3, LINK4, LINK5, LINK6, LINK7, LINK8, LINK9, LINK10, LINK11, LINK12, LINK13, LINK14, LINK15, LINK16, LINK17, LINK18, LINK19
, LINK20, LINK21, LINK22, LINK23, LINK24, LINK25, LINK26, LINK27, LINK28, LINK29, LINK30, LINK31, LINK32, LINK33, LINK34, LINK1);
    output C1RED;
    input C1RNE;
    input C1RS;
    input C1RW1;
    input C1RW2;
    input C1RW3;
    input C1TS;
    input C1TW;
    output C2RED;
    input C2RNE;
    input C2RS;
    input C2RW1;
    input C2RW2;
    input C2RW3;
    input C2TS;
    input C2TW;
    input CAD1;
    input CAD2;
    input CAD3;
    input CAD4;
    input CAD5;
    input CAD6;
    output CAL;
    input CAN1;
    input CAN2;
    input CAN3;
    input CAN4;
    input CAP1;
    input CAP2;
    input CAP3;
    input CAP4;
    input CAT1;
    input CAT2;
    input CAT3;
    input CAT4;
    input CCK;
    output CKO1;
    output CKO2;
    input CTCK;
    input DC;
    input DCK;
    input DIG;
    input DIS;
    input DOG;
    input DOS;
    input DPAG;
    input DPAS;
    input DQSG;
    input DQSS;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRA5;
    input DRA6;
    input DRI1;
    input DRI2;
    input DRI3;
    input DRI4;
    input DRI5;
    input DRI6;
    input DRL;
    output DRO1;
    output DRO2;
    output DRO3;
    output DRO4;
    output DRO5;
    output DRO6;
    input DS1;
    input DS2;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    output FLD;
    output FLG;
    input FZ;
    inout [41:0] LINK1;
    inout [41:0] LINK10;
    inout [41:0] LINK11;
    inout [41:0] LINK12;
    inout [41:0] LINK13;
    inout [41:0] LINK14;
    inout [41:0] LINK15;
    inout [41:0] LINK16;
    inout [41:0] LINK17;
    inout [41:0] LINK18;
    inout [41:0] LINK19;
    inout [41:0] LINK2;
    inout [41:0] LINK20;
    inout [41:0] LINK21;
    inout [41:0] LINK22;
    inout [41:0] LINK23;
    inout [41:0] LINK24;
    inout [41:0] LINK25;
    inout [41:0] LINK26;
    inout [41:0] LINK27;
    inout [41:0] LINK28;
    inout [41:0] LINK29;
    inout [41:0] LINK3;
    inout [41:0] LINK30;
    inout [41:0] LINK31;
    inout [41:0] LINK32;
    inout [41:0] LINK33;
    inout [41:0] LINK34;
    inout [41:0] LINK4;
    inout [41:0] LINK5;
    inout [41:0] LINK6;
    inout [41:0] LINK7;
    inout [41:0] LINK8;
    inout [41:0] LINK9;
    input RRCK1;
    input RRCK2;
    input RTCK1;
    input RTCK2;
    input WRCK1;
    input WRCK2;
    input WTCK1;
    input WTCK2;
    parameter div_rx1 = 4'b0000;
    parameter div_rx2 = 4'b0000;
    parameter div_tx1 = 4'b0000;
    parameter div_tx2 = 4'b0000;
    parameter inv_di_fclk1 = 1'b0;
    parameter inv_di_fclk2 = 1'b0;
    parameter latency1 = 1'b0;
    parameter latency2 = 1'b0;
    parameter location = "";
    parameter mode_cpath = "";
    parameter mode_epath = "";
    parameter mode_io_cal = 1'b0;
    parameter mode_rpath = "";
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter mode_tpath = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_clkr_rx1 = 1'b0;
    parameter sel_clkr_rx2 = 1'b0;
    parameter sel_clkw_rx1 = 2'b00;
    parameter sel_clkw_rx2 = 2'b00;
endmodule

`,"cells_bb_m.v":`(* blackbox *)
module NX_CKS(CKI, CMD, CKO);
    input CKI;
    output CKO;
    input CMD;
    parameter ck_edge = 1'b0;
endmodule

(* blackbox *)
module NX_DSP(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21
, A22, A23, A24, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18
, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21
, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, CAI1, CAI2, CAI3, CAI4, CAI5, CAI6
, CAI7, CAI8, CAI9, CAI10, CAI11, CAI12, CAI13, CAI14, CAI15, CAI16, CAI17, CAI18, CAO1, CAO2, CAO3, CAO4, CAO5, CAO6, CAO7, CAO8, CAO9
, CAO10, CAO11, CAO12, CAO13, CAO14, CAO15, CAO16, CAO17, CAO18, CBI1, CBI2, CBI3, CBI4, CBI5, CBI6, CBI7, CBI8, CBI9, CBI10, CBI11, CBI12
, CBI13, CBI14, CBI15, CBI16, CBI17, CBI18, CBO1, CBO2, CBO3, CBO4, CBO5, CBO6, CBO7, CBO8, CBO9, CBO10, CBO11, CBO12, CBO13, CBO14, CBO15
, CBO16, CBO17, CBO18, CCI, CCO, CI, CK, CO, CO37, CO49, CZI1, CZI2, CZI3, CZI4, CZI5, CZI6, CZI7, CZI8, CZI9, CZI10, CZI11
, CZI12, CZI13, CZI14, CZI15, CZI16, CZI17, CZI18, CZI19, CZI20, CZI21, CZI22, CZI23, CZI24, CZI25, CZI26, CZI27, CZI28, CZI29, CZI30, CZI31, CZI32
, CZI33, CZI34, CZI35, CZI36, CZI37, CZI38, CZI39, CZI40, CZI41, CZI42, CZI43, CZI44, CZI45, CZI46, CZI47, CZI48, CZI49, CZI50, CZI51, CZI52, CZI53
, CZI54, CZI55, CZI56, CZO1, CZO2, CZO3, CZO4, CZO5, CZO6, CZO7, CZO8, CZO9, CZO10, CZO11, CZO12, CZO13, CZO14, CZO15, CZO16, CZO17, CZO18
, CZO19, CZO20, CZO21, CZO22, CZO23, CZO24, CZO25, CZO26, CZO27, CZO28, CZO29, CZO30, CZO31, CZO32, CZO33, CZO34, CZO35, CZO36, CZO37, CZO38, CZO39
, CZO40, CZO41, CZO42, CZO43, CZO44, CZO45, CZO46, CZO47, CZO48, CZO49, CZO50, CZO51, CZO52, CZO53, CZO54, CZO55, CZO56, D1, D2, D3, D4
, D5, D6, D7, D8, D9, D10, D11, D12, D13, D14, D15, D16, D17, D18, OVF, R, RZ, WE, Z1, Z2, Z3
, Z4, Z5, Z6, Z7, Z8, Z9, Z10, Z11, Z12, Z13, Z14, Z15, Z16, Z17, Z18, Z19, Z20, Z21, Z22, Z23, Z24
, Z25, Z26, Z27, Z28, Z29, Z30, Z31, Z32, Z33, Z34, Z35, Z36, Z37, Z38, Z39, Z40, Z41, Z42, Z43, Z44, Z45
, Z46, Z47, Z48, Z49, Z50, Z51, Z52, Z53, Z54, Z55, Z56);
    input A1;
    input A10;
    input A11;
    input A12;
    input A13;
    input A14;
    input A15;
    input A16;
    input A17;
    input A18;
    input A19;
    input A2;
    input A20;
    input A21;
    input A22;
    input A23;
    input A24;
    input A3;
    input A4;
    input A5;
    input A6;
    input A7;
    input A8;
    input A9;
    input B1;
    input B10;
    input B11;
    input B12;
    input B13;
    input B14;
    input B15;
    input B16;
    input B17;
    input B18;
    input B2;
    input B3;
    input B4;
    input B5;
    input B6;
    input B7;
    input B8;
    input B9;
    input C1;
    input C10;
    input C11;
    input C12;
    input C13;
    input C14;
    input C15;
    input C16;
    input C17;
    input C18;
    input C19;
    input C2;
    input C20;
    input C21;
    input C22;
    input C23;
    input C24;
    input C25;
    input C26;
    input C27;
    input C28;
    input C29;
    input C3;
    input C30;
    input C31;
    input C32;
    input C33;
    input C34;
    input C35;
    input C36;
    input C4;
    input C5;
    input C6;
    input C7;
    input C8;
    input C9;
    input CAI1;
    input CAI10;
    input CAI11;
    input CAI12;
    input CAI13;
    input CAI14;
    input CAI15;
    input CAI16;
    input CAI17;
    input CAI18;
    input CAI2;
    input CAI3;
    input CAI4;
    input CAI5;
    input CAI6;
    input CAI7;
    input CAI8;
    input CAI9;
    output CAO1;
    output CAO10;
    output CAO11;
    output CAO12;
    output CAO13;
    output CAO14;
    output CAO15;
    output CAO16;
    output CAO17;
    output CAO18;
    output CAO2;
    output CAO3;
    output CAO4;
    output CAO5;
    output CAO6;
    output CAO7;
    output CAO8;
    output CAO9;
    input CBI1;
    input CBI10;
    input CBI11;
    input CBI12;
    input CBI13;
    input CBI14;
    input CBI15;
    input CBI16;
    input CBI17;
    input CBI18;
    input CBI2;
    input CBI3;
    input CBI4;
    input CBI5;
    input CBI6;
    input CBI7;
    input CBI8;
    input CBI9;
    output CBO1;
    output CBO10;
    output CBO11;
    output CBO12;
    output CBO13;
    output CBO14;
    output CBO15;
    output CBO16;
    output CBO17;
    output CBO18;
    output CBO2;
    output CBO3;
    output CBO4;
    output CBO5;
    output CBO6;
    output CBO7;
    output CBO8;
    output CBO9;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO37;
    output CO49;
    input CZI1;
    input CZI10;
    input CZI11;
    input CZI12;
    input CZI13;
    input CZI14;
    input CZI15;
    input CZI16;
    input CZI17;
    input CZI18;
    input CZI19;
    input CZI2;
    input CZI20;
    input CZI21;
    input CZI22;
    input CZI23;
    input CZI24;
    input CZI25;
    input CZI26;
    input CZI27;
    input CZI28;
    input CZI29;
    input CZI3;
    input CZI30;
    input CZI31;
    input CZI32;
    input CZI33;
    input CZI34;
    input CZI35;
    input CZI36;
    input CZI37;
    input CZI38;
    input CZI39;
    input CZI4;
    input CZI40;
    input CZI41;
    input CZI42;
    input CZI43;
    input CZI44;
    input CZI45;
    input CZI46;
    input CZI47;
    input CZI48;
    input CZI49;
    input CZI5;
    input CZI50;
    input CZI51;
    input CZI52;
    input CZI53;
    input CZI54;
    input CZI55;
    input CZI56;
    input CZI6;
    input CZI7;
    input CZI8;
    input CZI9;
    output CZO1;
    output CZO10;
    output CZO11;
    output CZO12;
    output CZO13;
    output CZO14;
    output CZO15;
    output CZO16;
    output CZO17;
    output CZO18;
    output CZO19;
    output CZO2;
    output CZO20;
    output CZO21;
    output CZO22;
    output CZO23;
    output CZO24;
    output CZO25;
    output CZO26;
    output CZO27;
    output CZO28;
    output CZO29;
    output CZO3;
    output CZO30;
    output CZO31;
    output CZO32;
    output CZO33;
    output CZO34;
    output CZO35;
    output CZO36;
    output CZO37;
    output CZO38;
    output CZO39;
    output CZO4;
    output CZO40;
    output CZO41;
    output CZO42;
    output CZO43;
    output CZO44;
    output CZO45;
    output CZO46;
    output CZO47;
    output CZO48;
    output CZO49;
    output CZO5;
    output CZO50;
    output CZO51;
    output CZO52;
    output CZO53;
    output CZO54;
    output CZO55;
    output CZO56;
    output CZO6;
    output CZO7;
    output CZO8;
    output CZO9;
    input D1;
    input D10;
    input D11;
    input D12;
    input D13;
    input D14;
    input D15;
    input D16;
    input D17;
    input D18;
    input D2;
    input D3;
    input D4;
    input D5;
    input D6;
    input D7;
    input D8;
    input D9;
    output OVF;
    input R;
    input RZ;
    input WE;
    output Z1;
    output Z10;
    output Z11;
    output Z12;
    output Z13;
    output Z14;
    output Z15;
    output Z16;
    output Z17;
    output Z18;
    output Z19;
    output Z2;
    output Z20;
    output Z21;
    output Z22;
    output Z23;
    output Z24;
    output Z25;
    output Z26;
    output Z27;
    output Z28;
    output Z29;
    output Z3;
    output Z30;
    output Z31;
    output Z32;
    output Z33;
    output Z34;
    output Z35;
    output Z36;
    output Z37;
    output Z38;
    output Z39;
    output Z4;
    output Z40;
    output Z41;
    output Z42;
    output Z43;
    output Z44;
    output Z45;
    output Z46;
    output Z47;
    output Z48;
    output Z49;
    output Z5;
    output Z50;
    output Z51;
    output Z52;
    output Z53;
    output Z54;
    output Z55;
    output Z56;
    output Z6;
    output Z7;
    output Z8;
    output Z9;
    parameter raw_config0 = 20'b00000000000000000000;
    parameter raw_config1 = 19'b0000000000000000000;
    parameter raw_config2 = 13'b0000000000000;
    parameter raw_config3 = 7'b0000000;
    parameter std_mode = "";
endmodule

(* blackbox *)
module NX_PLL(REF, FBK, VCO, D1, D2, D3, OSC, RDY);
    output D1;
    output D2;
    output D3;
    input FBK;
    output OSC;
    output RDY;
    input REF;
    output VCO;
    parameter clk_outdiv1 = 0;
    parameter clk_outdiv2 = 0;
    parameter clk_outdiv3 = 0;
    parameter ext_fbk_on = 1'b0;
    parameter fbk_delay = 0;
    parameter fbk_delay_on = 1'b0;
    parameter fbk_div_on = 1'b0;
    parameter fbk_intdiv = 2;
    parameter location = "";
    parameter ref_div_on = 1'b0;
    parameter vco_range = 0;
endmodule

(* blackbox *)
module NX_WFG(SI, ZI, RDY, SO, ZO);
    input RDY;
    input SI;
    output SO;
    input ZI;
    output ZO;
    parameter delay = 0;
    parameter delay_on = 1'b0;
    parameter location = "";
    parameter mode = 1'b0;
    parameter pattern = 16'b0000000000000000;
    parameter pattern_end = 1;
    parameter wfg_edge = 1'b0;
endmodule


(* blackbox *)
module NX_IOM(RTCK1, RRCK1, WTCK1, WRCK1, RTCK2, RRCK2, WTCK2, WRCK2, CTCK, CCK, DCK, C1TW, C1TS, C1RW1, C1RW2, C1RW3, C1RNE, C1RS, C2TW, C2TS, C2RW1
, C2RW2, C2RW3, C2RNE, C2RS, FA1, FA2, FA3, FA4, FA5, FZ, DC, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3, DRA4
, DRA5, DRL, DOS, DOG, DIS, DIG, DPAS, DPAG, DQSS, DQSG, DS1, DS2, CAD1, CAD2, CAD3, CAD4, CAD5, CAD6, CAP1, CAP2, CAP3
, CAP4, CAN1, CAN2, CAN3, CAN4, CAT1, CAT2, CAT3, CAT4, SPI1, SPI2, SPI3, CKO1, CKO2, FLD, FLG, C1RED, C2RED, DRO1, DRO2, DRO3
, DRO4, DRO5, DRO6, CAL, P1CI1, P1CL, P1CR, P1CO, P1CTI, P1CTO, P1EI1, P1EI2, P1EI3, P1EI4, P1EI5, P1EL, P1ER, P1EO, P1RI, P1RL, P1RR
, P1RO1, P1RO2, P1RO3, P1RO4, P1RO5, P2CI1, P2CL, P2CR, P2CO, P2CTI, P2CTO, P2EI1, P2EI2, P2EI3, P2EI4, P2EI5, P2EL, P2ER, P2EO, P2RI, P2RL
, P2RR, P2RO1, P2RO2, P2RO3, P2RO4, P2RO5, P3CI1, P3CL, P3CR, P3CO, P3CTI, P3CTO, P3EI1, P3EI2, P3EI3, P3EI4, P3EI5, P3EL, P3ER, P3EO, P3RI
, P3RL, P3RR, P3RO1, P3RO2, P3RO3, P3RO4, P3RO5, P4CI1, P4CL, P4CR, P4CO, P4CTI, P4CTO, P4EI1, P4EI2, P4EI3, P4EI4, P4EI5, P4EL, P4ER, P4EO
, P4RI, P4RL, P4RR, P4RO1, P4RO2, P4RO3, P4RO4, P4RO5, P5CI1, P5CI2, P5CI3, P5CI4, P5CI5, P5CL, P5CR, P5CO, P5CTI, P5CTO, P5EI1, P5EI2, P5EI3
, P5EI4, P5EI5, P5EL, P5ER, P5EO, P5RI, P5RL, P5RR, P5RO1, P5RO2, P5RO3, P5RO4, P5RO5, P6CI1, P6CL, P6CR, P6CO, P6CTI, P6CTO, P6EI1, P6EI2
, P6EI3, P6EI4, P6EI5, P6EL, P6ER, P6EO, P6RI, P6RL, P6RR, P6RO1, P6RO2, P6RO3, P6RO4, P6RO5, P7CI1, P7CL, P7CR, P7CO, P7CTI, P7CTO, P7EI1
, P7EI2, P7EI3, P7EI4, P7EI5, P7EL, P7ER, P7EO, P7RI, P7RL, P7RR, P7RO1, P7RO2, P7RO3, P7RO4, P7RO5, P8CI1, P8CL, P8CR, P8CO, P8CTI, P8CTO
, P8EI1, P8EI2, P8EI3, P8EI4, P8EI5, P8EL, P8ER, P8EO, P8RI, P8RL, P8RR, P8RO1, P8RO2, P8RO3, P8RO4, P8RO5, P9CI1, P9CL, P9CR, P9CO, P9CTI
, P9CTO, P9EI1, P9EI2, P9EI3, P9EI4, P9EI5, P9EL, P9ER, P9EO, P9RI, P9RL, P9RR, P9RO1, P9RO2, P9RO3, P9RO4, P9RO5, P10CI1, P10CL, P10CR, P10CO
, P10CTI, P10CTO, P10EI1, P10EI2, P10EI3, P10EI4, P10EI5, P10EL, P10ER, P10EO, P10RI, P10RL, P10RR, P10RO1, P10RO2, P10RO3, P10RO4, P10RO5, P11CI1, P11CL, P11CR
, P11CO, P11CTI, P11CTO, P11EI1, P11EI2, P11EI3, P11EI4, P11EI5, P11EL, P11ER, P11EO, P11RI, P11RL, P11RR, P11RO1, P11RO2, P11RO3, P11RO4, P11RO5, P12CI1, P12CL
, P12CR, P12CO, P12CTI, P12CTO, P12EI1, P12EI2, P12EI3, P12EI4, P12EI5, P12EL, P12ER, P12EO, P12RI, P12RL, P12RR, P12RO1, P12RO2, P12RO3, P12RO4, P12RO5, P13CI1
, P13CL, P13CR, P13CO, P13CTI, P13CTO, P13EI1, P13EI2, P13EI3, P13EI4, P13EI5, P13EL, P13ER, P13EO, P13RI, P13RL, P13RR, P13RO1, P13RO2, P13RO3, P13RO4, P13RO5
, P14CI1, P14CL, P14CR, P14CO, P14CTI, P14CTO, P14EI1, P14EI2, P14EI3, P14EI4, P14EI5, P14EL, P14ER, P14EO, P14RI, P14RL, P14RR, P14RO1, P14RO2, P14RO3, P14RO4
, P14RO5, P15CI1, P15CL, P15CR, P15CO, P15CTI, P15CTO, P15EI1, P15EI2, P15EI3, P15EI4, P15EI5, P15EL, P15ER, P15EO, P15RI, P15RL, P15RR, P15RO1, P15RO2, P15RO3
, P15RO4, P15RO5, P16CI1, P16CL, P16CR, P16CO, P16CTI, P16CTO, P16EI1, P16EI2, P16EI3, P16EI4, P16EI5, P16EL, P16ER, P16EO, P16RI, P16RL, P16RR, P16RO1, P16RO2
, P16RO3, P16RO4, P16RO5, P17CI1, P17CL, P17CR, P17CO, P17CTI, P17CTO, P17EI1, P17EI2, P17EI3, P17EI4, P17EI5, P17EL, P17ER, P17EO, P17RI, P17RL, P17RR, P17RO1
, P17RO2, P17RO3, P17RO4, P17RO5, P18CI1, P18CL, P18CR, P18CO, P18CTI, P18CTO, P18EI1, P18EI2, P18EI3, P18EI4, P18EI5, P18EL, P18ER, P18EO, P18RI, P18RL, P18RR
, P18RO1, P18RO2, P18RO3, P18RO4, P18RO5, P19CI1, P19CL, P19CR, P19CO, P19CTI, P19CTO, P19EI1, P19EI2, P19EI3, P19EI4, P19EI5, P19EL, P19ER, P19EO, P19RI, P19RL
, P19RR, P19RO1, P19RO2, P19RO3, P19RO4, P19RO5, P20CI1, P20CL, P20CR, P20CO, P20CTI, P20CTO, P20EI1, P20EI2, P20EI3, P20EI4, P20EI5, P20EL, P20ER, P20EO, P20RI
, P20RL, P20RR, P20RO1, P20RO2, P20RO3, P20RO4, P20RO5, P21CI1, P21CL, P21CR, P21CO, P21CTI, P21CTO, P21EI1, P21EI2, P21EI3, P21EI4, P21EI5, P21EL, P21ER, P21EO
, P21RI, P21RL, P21RR, P21RO1, P21RO2, P21RO3, P21RO4, P21RO5, P22CI1, P22CL, P22CR, P22CO, P22CTI, P22CTO, P22EI1, P22EI2, P22EI3, P22EI4, P22EI5, P22EL, P22ER
, P22EO, P22RI, P22RL, P22RR, P22RO1, P22RO2, P22RO3, P22RO4, P22RO5, P23CI1, P23CL, P23CR, P23CO, P23CTI, P23CTO, P23EI1, P23EI2, P23EI3, P23EI4, P23EI5, P23EL
, P23ER, P23EO, P23RI, P23RL, P23RR, P23RO1, P23RO2, P23RO3, P23RO4, P23RO5, P24CI1, P24CL, P24CR, P24CO, P24CTI, P24CTO, P24EI1, P24EI2, P24EI3, P24EI4, P24EI5
, P24EL, P24ER, P24EO, P24RI, P24RL, P24RR, P24RO1, P24RO2, P24RO3, P24RO4, P24RO5, P25CI1, P25CI2, P25CI3, P25CI4, P25CI5, P25CL, P25CR, P25CO, P25CTI, P25CTO
, P25EI1, P25EI2, P25EI3, P25EI4, P25EI5, P25EL, P25ER, P25EO, P25RI, P25RL, P25RR, P25RO1, P25RO2, P25RO3, P25RO4, P25RO5, P26CI1, P26CL, P26CR, P26CO, P26CTI
, P26CTO, P26EI1, P26EI2, P26EI3, P26EI4, P26EI5, P26EL, P26ER, P26EO, P26RI, P26RL, P26RR, P26RO1, P26RO2, P26RO3, P26RO4, P26RO5, P27CI1, P27CL, P27CR, P27CO
, P27CTI, P27CTO, P27EI1, P27EI2, P27EI3, P27EI4, P27EI5, P27EL, P27ER, P27EO, P27RI, P27RL, P27RR, P27RO1, P27RO2, P27RO3, P27RO4, P27RO5, P28CI1, P28CL, P28CR
, P28CO, P28CTI, P28CTO, P28EI1, P28EI2, P28EI3, P28EI4, P28EI5, P28EL, P28ER, P28EO, P28RI, P28RL, P28RR, P28RO1, P28RO2, P28RO3, P28RO4, P28RO5, P29CI1, P29CL
, P29CR, P29CO, P29CTI, P29CTO, P29EI1, P29EI2, P29EI3, P29EI4, P29EI5, P29EL, P29ER, P29EO, P29RI, P29RL, P29RR, P29RO1, P29RO2, P29RO3, P29RO4, P29RO5, P30CI1
, P30CL, P30CR, P30CO, P30CTI, P30CTO, P30EI1, P30EI2, P30EI3, P30EI4, P30EI5, P30EL, P30ER, P30EO, P30RI, P30RL, P30RR, P30RO1, P30RO2, P30RO3, P30RO4, P30RO5
);
    output C1RED;
    input C1RNE;
    input C1RS;
    input C1RW1;
    input C1RW2;
    input C1RW3;
    input C1TS;
    input C1TW;
    output C2RED;
    input C2RNE;
    input C2RS;
    input C2RW1;
    input C2RW2;
    input C2RW3;
    input C2TS;
    input C2TW;
    input CAD1;
    input CAD2;
    input CAD3;
    input CAD4;
    input CAD5;
    input CAD6;
    output CAL;
    input CAN1;
    input CAN2;
    input CAN3;
    input CAN4;
    input CAP1;
    input CAP2;
    input CAP3;
    input CAP4;
    input CAT1;
    input CAT2;
    input CAT3;
    input CAT4;
    input CCK;
    output CKO1;
    output CKO2;
    input CTCK;
    input DC;
    input DCK;
    input DIG;
    input DIS;
    input DOG;
    input DOS;
    input DPAG;
    input DPAS;
    input DQSG;
    input DQSS;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRA5;
    input DRI1;
    input DRI2;
    input DRI3;
    input DRI4;
    input DRI5;
    input DRI6;
    input DRL;
    output DRO1;
    output DRO2;
    output DRO3;
    output DRO4;
    output DRO5;
    output DRO6;
    input DS1;
    input DS2;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    output FLD;
    output FLG;
    input FZ;
    input P10CI1;
    input P10CL;
    output P10CO;
    input P10CR;
    input P10CTI;
    output P10CTO;
    input P10EI1;
    input P10EI2;
    input P10EI3;
    input P10EI4;
    input P10EI5;
    input P10EL;
    output P10EO;
    input P10ER;
    input P10RI;
    input P10RL;
    output P10RO1;
    output P10RO2;
    output P10RO3;
    output P10RO4;
    output P10RO5;
    input P10RR;
    input P11CI1;
    input P11CL;
    output P11CO;
    input P11CR;
    input P11CTI;
    output P11CTO;
    input P11EI1;
    input P11EI2;
    input P11EI3;
    input P11EI4;
    input P11EI5;
    input P11EL;
    output P11EO;
    input P11ER;
    input P11RI;
    input P11RL;
    output P11RO1;
    output P11RO2;
    output P11RO3;
    output P11RO4;
    output P11RO5;
    input P11RR;
    input P12CI1;
    input P12CL;
    output P12CO;
    input P12CR;
    input P12CTI;
    output P12CTO;
    input P12EI1;
    input P12EI2;
    input P12EI3;
    input P12EI4;
    input P12EI5;
    input P12EL;
    output P12EO;
    input P12ER;
    input P12RI;
    input P12RL;
    output P12RO1;
    output P12RO2;
    output P12RO3;
    output P12RO4;
    output P12RO5;
    input P12RR;
    input P13CI1;
    input P13CL;
    output P13CO;
    input P13CR;
    input P13CTI;
    output P13CTO;
    input P13EI1;
    input P13EI2;
    input P13EI3;
    input P13EI4;
    input P13EI5;
    input P13EL;
    output P13EO;
    input P13ER;
    input P13RI;
    input P13RL;
    output P13RO1;
    output P13RO2;
    output P13RO3;
    output P13RO4;
    output P13RO5;
    input P13RR;
    input P14CI1;
    input P14CL;
    output P14CO;
    input P14CR;
    input P14CTI;
    output P14CTO;
    input P14EI1;
    input P14EI2;
    input P14EI3;
    input P14EI4;
    input P14EI5;
    input P14EL;
    output P14EO;
    input P14ER;
    input P14RI;
    input P14RL;
    output P14RO1;
    output P14RO2;
    output P14RO3;
    output P14RO4;
    output P14RO5;
    input P14RR;
    input P15CI1;
    input P15CL;
    output P15CO;
    input P15CR;
    input P15CTI;
    output P15CTO;
    input P15EI1;
    input P15EI2;
    input P15EI3;
    input P15EI4;
    input P15EI5;
    input P15EL;
    output P15EO;
    input P15ER;
    input P15RI;
    input P15RL;
    output P15RO1;
    output P15RO2;
    output P15RO3;
    output P15RO4;
    output P15RO5;
    input P15RR;
    input P16CI1;
    input P16CL;
    output P16CO;
    input P16CR;
    input P16CTI;
    output P16CTO;
    input P16EI1;
    input P16EI2;
    input P16EI3;
    input P16EI4;
    input P16EI5;
    input P16EL;
    output P16EO;
    input P16ER;
    input P16RI;
    input P16RL;
    output P16RO1;
    output P16RO2;
    output P16RO3;
    output P16RO4;
    output P16RO5;
    input P16RR;
    input P17CI1;
    input P17CL;
    output P17CO;
    input P17CR;
    input P17CTI;
    output P17CTO;
    input P17EI1;
    input P17EI2;
    input P17EI3;
    input P17EI4;
    input P17EI5;
    input P17EL;
    output P17EO;
    input P17ER;
    input P17RI;
    input P17RL;
    output P17RO1;
    output P17RO2;
    output P17RO3;
    output P17RO4;
    output P17RO5;
    input P17RR;
    input P18CI1;
    input P18CL;
    output P18CO;
    input P18CR;
    input P18CTI;
    output P18CTO;
    input P18EI1;
    input P18EI2;
    input P18EI3;
    input P18EI4;
    input P18EI5;
    input P18EL;
    output P18EO;
    input P18ER;
    input P18RI;
    input P18RL;
    output P18RO1;
    output P18RO2;
    output P18RO3;
    output P18RO4;
    output P18RO5;
    input P18RR;
    input P19CI1;
    input P19CL;
    output P19CO;
    input P19CR;
    input P19CTI;
    output P19CTO;
    input P19EI1;
    input P19EI2;
    input P19EI3;
    input P19EI4;
    input P19EI5;
    input P19EL;
    output P19EO;
    input P19ER;
    input P19RI;
    input P19RL;
    output P19RO1;
    output P19RO2;
    output P19RO3;
    output P19RO4;
    output P19RO5;
    input P19RR;
    input P1CI1;
    input P1CL;
    output P1CO;
    input P1CR;
    input P1CTI;
    output P1CTO;
    input P1EI1;
    input P1EI2;
    input P1EI3;
    input P1EI4;
    input P1EI5;
    input P1EL;
    output P1EO;
    input P1ER;
    input P1RI;
    input P1RL;
    output P1RO1;
    output P1RO2;
    output P1RO3;
    output P1RO4;
    output P1RO5;
    input P1RR;
    input P20CI1;
    input P20CL;
    output P20CO;
    input P20CR;
    input P20CTI;
    output P20CTO;
    input P20EI1;
    input P20EI2;
    input P20EI3;
    input P20EI4;
    input P20EI5;
    input P20EL;
    output P20EO;
    input P20ER;
    input P20RI;
    input P20RL;
    output P20RO1;
    output P20RO2;
    output P20RO3;
    output P20RO4;
    output P20RO5;
    input P20RR;
    input P21CI1;
    input P21CL;
    output P21CO;
    input P21CR;
    input P21CTI;
    output P21CTO;
    input P21EI1;
    input P21EI2;
    input P21EI3;
    input P21EI4;
    input P21EI5;
    input P21EL;
    output P21EO;
    input P21ER;
    input P21RI;
    input P21RL;
    output P21RO1;
    output P21RO2;
    output P21RO3;
    output P21RO4;
    output P21RO5;
    input P21RR;
    input P22CI1;
    input P22CL;
    output P22CO;
    input P22CR;
    input P22CTI;
    output P22CTO;
    input P22EI1;
    input P22EI2;
    input P22EI3;
    input P22EI4;
    input P22EI5;
    input P22EL;
    output P22EO;
    input P22ER;
    input P22RI;
    input P22RL;
    output P22RO1;
    output P22RO2;
    output P22RO3;
    output P22RO4;
    output P22RO5;
    input P22RR;
    input P23CI1;
    input P23CL;
    output P23CO;
    input P23CR;
    input P23CTI;
    output P23CTO;
    input P23EI1;
    input P23EI2;
    input P23EI3;
    input P23EI4;
    input P23EI5;
    input P23EL;
    output P23EO;
    input P23ER;
    input P23RI;
    input P23RL;
    output P23RO1;
    output P23RO2;
    output P23RO3;
    output P23RO4;
    output P23RO5;
    input P23RR;
    input P24CI1;
    input P24CL;
    output P24CO;
    input P24CR;
    input P24CTI;
    output P24CTO;
    input P24EI1;
    input P24EI2;
    input P24EI3;
    input P24EI4;
    input P24EI5;
    input P24EL;
    output P24EO;
    input P24ER;
    input P24RI;
    input P24RL;
    output P24RO1;
    output P24RO2;
    output P24RO3;
    output P24RO4;
    output P24RO5;
    input P24RR;
    input P25CI1;
    input P25CI2;
    input P25CI3;
    input P25CI4;
    input P25CI5;
    input P25CL;
    output P25CO;
    input P25CR;
    input P25CTI;
    output P25CTO;
    input P25EI1;
    input P25EI2;
    input P25EI3;
    input P25EI4;
    input P25EI5;
    input P25EL;
    output P25EO;
    input P25ER;
    input P25RI;
    input P25RL;
    output P25RO1;
    output P25RO2;
    output P25RO3;
    output P25RO4;
    output P25RO5;
    input P25RR;
    input P26CI1;
    input P26CL;
    output P26CO;
    input P26CR;
    input P26CTI;
    output P26CTO;
    input P26EI1;
    input P26EI2;
    input P26EI3;
    input P26EI4;
    input P26EI5;
    input P26EL;
    output P26EO;
    input P26ER;
    input P26RI;
    input P26RL;
    output P26RO1;
    output P26RO2;
    output P26RO3;
    output P26RO4;
    output P26RO5;
    input P26RR;
    input P27CI1;
    input P27CL;
    output P27CO;
    input P27CR;
    input P27CTI;
    output P27CTO;
    input P27EI1;
    input P27EI2;
    input P27EI3;
    input P27EI4;
    input P27EI5;
    input P27EL;
    output P27EO;
    input P27ER;
    input P27RI;
    input P27RL;
    output P27RO1;
    output P27RO2;
    output P27RO3;
    output P27RO4;
    output P27RO5;
    input P27RR;
    input P28CI1;
    input P28CL;
    output P28CO;
    input P28CR;
    input P28CTI;
    output P28CTO;
    input P28EI1;
    input P28EI2;
    input P28EI3;
    input P28EI4;
    input P28EI5;
    input P28EL;
    output P28EO;
    input P28ER;
    input P28RI;
    input P28RL;
    output P28RO1;
    output P28RO2;
    output P28RO3;
    output P28RO4;
    output P28RO5;
    input P28RR;
    input P29CI1;
    input P29CL;
    output P29CO;
    input P29CR;
    input P29CTI;
    output P29CTO;
    input P29EI1;
    input P29EI2;
    input P29EI3;
    input P29EI4;
    input P29EI5;
    input P29EL;
    output P29EO;
    input P29ER;
    input P29RI;
    input P29RL;
    output P29RO1;
    output P29RO2;
    output P29RO3;
    output P29RO4;
    output P29RO5;
    input P29RR;
    input P2CI1;
    input P2CL;
    output P2CO;
    input P2CR;
    input P2CTI;
    output P2CTO;
    input P2EI1;
    input P2EI2;
    input P2EI3;
    input P2EI4;
    input P2EI5;
    input P2EL;
    output P2EO;
    input P2ER;
    input P2RI;
    input P2RL;
    output P2RO1;
    output P2RO2;
    output P2RO3;
    output P2RO4;
    output P2RO5;
    input P2RR;
    input P30CI1;
    input P30CL;
    output P30CO;
    input P30CR;
    input P30CTI;
    output P30CTO;
    input P30EI1;
    input P30EI2;
    input P30EI3;
    input P30EI4;
    input P30EI5;
    input P30EL;
    output P30EO;
    input P30ER;
    input P30RI;
    input P30RL;
    output P30RO1;
    output P30RO2;
    output P30RO3;
    output P30RO4;
    output P30RO5;
    input P30RR;
    input P3CI1;
    input P3CL;
    output P3CO;
    input P3CR;
    input P3CTI;
    output P3CTO;
    input P3EI1;
    input P3EI2;
    input P3EI3;
    input P3EI4;
    input P3EI5;
    input P3EL;
    output P3EO;
    input P3ER;
    input P3RI;
    input P3RL;
    output P3RO1;
    output P3RO2;
    output P3RO3;
    output P3RO4;
    output P3RO5;
    input P3RR;
    input P4CI1;
    input P4CL;
    output P4CO;
    input P4CR;
    input P4CTI;
    output P4CTO;
    input P4EI1;
    input P4EI2;
    input P4EI3;
    input P4EI4;
    input P4EI5;
    input P4EL;
    output P4EO;
    input P4ER;
    input P4RI;
    input P4RL;
    output P4RO1;
    output P4RO2;
    output P4RO3;
    output P4RO4;
    output P4RO5;
    input P4RR;
    input P5CI1;
    input P5CI2;
    input P5CI3;
    input P5CI4;
    input P5CI5;
    input P5CL;
    output P5CO;
    input P5CR;
    input P5CTI;
    output P5CTO;
    input P5EI1;
    input P5EI2;
    input P5EI3;
    input P5EI4;
    input P5EI5;
    input P5EL;
    output P5EO;
    input P5ER;
    input P5RI;
    input P5RL;
    output P5RO1;
    output P5RO2;
    output P5RO3;
    output P5RO4;
    output P5RO5;
    input P5RR;
    input P6CI1;
    input P6CL;
    output P6CO;
    input P6CR;
    input P6CTI;
    output P6CTO;
    input P6EI1;
    input P6EI2;
    input P6EI3;
    input P6EI4;
    input P6EI5;
    input P6EL;
    output P6EO;
    input P6ER;
    input P6RI;
    input P6RL;
    output P6RO1;
    output P6RO2;
    output P6RO3;
    output P6RO4;
    output P6RO5;
    input P6RR;
    input P7CI1;
    input P7CL;
    output P7CO;
    input P7CR;
    input P7CTI;
    output P7CTO;
    input P7EI1;
    input P7EI2;
    input P7EI3;
    input P7EI4;
    input P7EI5;
    input P7EL;
    output P7EO;
    input P7ER;
    input P7RI;
    input P7RL;
    output P7RO1;
    output P7RO2;
    output P7RO3;
    output P7RO4;
    output P7RO5;
    input P7RR;
    input P8CI1;
    input P8CL;
    output P8CO;
    input P8CR;
    input P8CTI;
    output P8CTO;
    input P8EI1;
    input P8EI2;
    input P8EI3;
    input P8EI4;
    input P8EI5;
    input P8EL;
    output P8EO;
    input P8ER;
    input P8RI;
    input P8RL;
    output P8RO1;
    output P8RO2;
    output P8RO3;
    output P8RO4;
    output P8RO5;
    input P8RR;
    input P9CI1;
    input P9CL;
    output P9CO;
    input P9CR;
    input P9CTI;
    output P9CTO;
    input P9EI1;
    input P9EI2;
    input P9EI3;
    input P9EI4;
    input P9EI5;
    input P9EL;
    output P9EO;
    input P9ER;
    input P9RI;
    input P9RL;
    output P9RO1;
    output P9RO2;
    output P9RO3;
    output P9RO4;
    output P9RO5;
    input P9RR;
    input RRCK1;
    input RRCK2;
    input RTCK1;
    input RTCK2;
    input SPI1;
    input SPI2;
    input SPI3;
    input WRCK1;
    input WRCK2;
    input WTCK1;
    input WTCK2;
    parameter div_rx1 = 4'b0000;
    parameter div_rx2 = 4'b0000;
    parameter div_tx1 = 4'b0000;
    parameter div_tx2 = 4'b0000;
    parameter mode_io_cal = 1'b0;
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter pads_dict = "";
    parameter pads_path = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_clkr_rx1 = 1'b0;
    parameter sel_clkr_rx2 = 1'b0;
    parameter sel_clkw_rx1 = 2'b00;
    parameter sel_clkw_rx2 = 2'b00;
endmodule

(* blackbox *)
module NX_RFB_M(RCK, WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, COR, ERR, O1
, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, RA1, RA2, RA3, RA4, RA5, RA6
, RE, WA1, WA2, WA3, WA4, WA5, WA6, WE);
    output COR;
    output ERR;
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I2;
    input I3;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O2;
    output O3;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RCK;
    input RE;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    parameter mem_ctxt = "";
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;
endmodule


(* blackbox *)
module NX_IOM_CONTROL_M(RTCK1, RRCK1, WTCK1, WRCK1, RTCK2, RRCK2, WTCK2, WRCK2, CTCK, C1TW, C1TS, C1RW1, C1RW2, C1RW3, C1RNE, C1RS, C2TW, C2TS, C2RW1, C2RW2, C2RW3
, C2RNE, C2RS, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DC, CCK, DCK, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3
, DRA4, DRA5, DRA6, DRL, DOS, DOG, DIS, DIG, DPAS, DPAG, DQSS, DQSG, DS1, DS2, CAD1, CAD2, CAD3, CAD4, CAD5, CAD6, CAP1
, CAP2, CAP3, CAP4, CAN1, CAN2, CAN3, CAN4, CAT1, CAT2, CAT3, CAT4, SPI1, SPI2, SPI3, CKO1, CKO2, FLD, FLG, C1RED, C2RED, DRO1
, DRO2, DRO3, DRO4, DRO5, DRO6, CAL, LINK2, LINK3, LINK4, LINK5, LINK6, LINK7, LINK8, LINK9, LINK10, LINK11, LINK12, LINK13, LINK14, LINK15, LINK16
, LINK17, LINK18, LINK19, LINK20, LINK21, LINK22, LINK23, LINK24, LINK25, LINK26, LINK27, LINK28, LINK29, LINK30, LINK31, LINK32, LINK33, LINK34, LINK1);
    output C1RED;
    input C1RNE;
    input C1RS;
    input C1RW1;
    input C1RW2;
    input C1RW3;
    input C1TS;
    input C1TW;
    output C2RED;
    input C2RNE;
    input C2RS;
    input C2RW1;
    input C2RW2;
    input C2RW3;
    input C2TS;
    input C2TW;
    input CAD1;
    input CAD2;
    input CAD3;
    input CAD4;
    input CAD5;
    input CAD6;
    output CAL;
    input CAN1;
    input CAN2;
    input CAN3;
    input CAN4;
    input CAP1;
    input CAP2;
    input CAP3;
    input CAP4;
    input CAT1;
    input CAT2;
    input CAT3;
    input CAT4;
    input CCK;
    output CKO1;
    output CKO2;
    input CTCK;
    input DC;
    input DCK;
    input DIG;
    input DIS;
    input DOG;
    input DOS;
    input DPAG;
    input DPAS;
    input DQSG;
    input DQSS;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRA5;
    input DRA6;
    input DRI1;
    input DRI2;
    input DRI3;
    input DRI4;
    input DRI5;
    input DRI6;
    input DRL;
    output DRO1;
    output DRO2;
    output DRO3;
    output DRO4;
    output DRO5;
    output DRO6;
    input DS1;
    input DS2;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    output FLD;
    output FLG;
    input FZ;
    inout [41:0] LINK1;
    inout [41:0] LINK10;
    inout [41:0] LINK11;
    inout [41:0] LINK12;
    inout [41:0] LINK13;
    inout [41:0] LINK14;
    inout [41:0] LINK15;
    inout [41:0] LINK16;
    inout [41:0] LINK17;
    inout [41:0] LINK18;
    inout [41:0] LINK19;
    inout [41:0] LINK2;
    inout [41:0] LINK20;
    inout [41:0] LINK21;
    inout [41:0] LINK22;
    inout [41:0] LINK23;
    inout [41:0] LINK24;
    inout [41:0] LINK25;
    inout [41:0] LINK26;
    inout [41:0] LINK27;
    inout [41:0] LINK28;
    inout [41:0] LINK29;
    inout [41:0] LINK3;
    inout [41:0] LINK30;
    inout [41:0] LINK31;
    inout [41:0] LINK32;
    inout [41:0] LINK33;
    inout [41:0] LINK34;
    inout [41:0] LINK4;
    inout [41:0] LINK5;
    inout [41:0] LINK6;
    inout [41:0] LINK7;
    inout [41:0] LINK8;
    inout [41:0] LINK9;
    input RRCK1;
    input RRCK2;
    input RTCK1;
    input RTCK2;
    input SPI1;
    input SPI2;
    input SPI3;
    input WRCK1;
    input WRCK2;
    input WTCK1;
    input WTCK2;
    parameter div_rx1 = 4'b0000;
    parameter div_rx2 = 4'b0000;
    parameter div_tx1 = 4'b0000;
    parameter div_tx2 = 4'b0000;
    parameter inv_di_fclk1 = 1'b0;
    parameter inv_di_fclk2 = 1'b0;
    parameter latency1 = 1'b0;
    parameter latency2 = 1'b0;
    parameter location = "";
    parameter mode_cpath = "";
    parameter mode_epath = "";
    parameter mode_io_cal = 1'b0;
    parameter mode_rpath = "";
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter mode_tpath = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_clkr_rx1 = 1'b0;
    parameter sel_clkr_rx2 = 1'b0;
    parameter sel_clkw_rx1 = 2'b00;
    parameter sel_clkw_rx2 = 2'b00;
endmodule

(* blackbox *)
module NX_IOM_DRIVER_M(EI1, EI2, EI3, EI4, EI5, EL, ER, CI1, CI2, CI3, CI4, CI5, CL, CR, CTI, RI, RL, RR, CO, EO, RO1
, RO2, RO3, RO4, RO5, CTO, LINK);
    input CI1;
    input CI2;
    input CI3;
    input CI4;
    input CI5;
    input CL;
    output CO;
    input CR;
    input CTI;
    output CTO;
    input EI1;
    input EI2;
    input EI3;
    input EI4;
    input EI5;
    input EL;
    output EO;
    input ER;
    inout [41:0] LINK;
    input RI;
    input RL;
    output RO1;
    output RO2;
    output RO3;
    output RO4;
    output RO5;
    input RR;
    parameter chained = 1'b0;
    parameter cpath_edge = 1'b0;
    parameter cpath_init = 1'b0;
    parameter cpath_inv = 1'b0;
    parameter cpath_load = 1'b0;
    parameter cpath_mode = 4'b0000;
    parameter cpath_sync = 1'b0;
    parameter epath_dynamic = 1'b0;
    parameter epath_edge = 1'b0;
    parameter epath_init = 1'b0;
    parameter epath_load = 1'b0;
    parameter epath_mode = 4'b0000;
    parameter epath_sync = 1'b0;
    parameter location = "";
    parameter rpath_dynamic = 1'b0;
    parameter rpath_edge = 1'b0;
    parameter rpath_init = 1'b0;
    parameter rpath_load = 1'b0;
    parameter rpath_mode = 4'b0000;
    parameter rpath_sync = 1'b0;
    parameter symbol = "";
    parameter tpath_mode = 2'b00;
    parameter variant = "";
endmodule

(* blackbox *)
module NX_IOM_SERDES_M(RTCK, WRCK, WTCK, RRCK, TRST, RRST, CTCK, DCK, DRL, DIG, FZ, FLD, FLG, DS, DRA, DRI, DRO, DID, LINKN, LINKP);
    input CTCK;
    input DCK;
    output [5:0] DID;
    input DIG;
    input [5:0] DRA;
    input [5:0] DRI;
    input DRL;
    output [5:0] DRO;
    input [1:0] DS;
    output FLD;
    output FLG;
    input FZ;
    inout [41:0] LINKN;
    inout [41:0] LINKP;
    input RRCK;
    input RRST;
    input RTCK;
    input TRST;
    input WRCK;
    input WTCK;
    parameter data_size = 5;
    parameter location = "";
endmodule

`,"cells_bb_u.v":`(* blackbox *)
module NX_CDC_U(CK1, CK2, ASRSTI, ADRSTI, ASRSTO, ADRSTO, AI1, AI2, AI3, AI4, AI5, AI6, AO1, AO2, AO3, AO4, AO5, AO6, BSRSTI, BDRSTI, BSRSTO
, BDRSTO, BI1, BI2, BI3, BI4, BI5, BI6, BO1, BO2, BO3, BO4, BO5, BO6, CSRSTI, CDRSTI, CSRSTO, CDRSTO, CI1, CI2, CI3, CI4
, CI5, CI6, CO1, CO2, CO3, CO4, CO5, CO6, DSRSTI, DDRSTI, DSRSTO, DDRSTO, DI1, DI2, DI3, DI4, DI5, DI6, DO1, DO2, DO3
, DO4, DO5, DO6);
    input ADRSTI;
    output ADRSTO;
    input AI1;
    input AI2;
    input AI3;
    input AI4;
    input AI5;
    input AI6;
    output AO1;
    output AO2;
    output AO3;
    output AO4;
    output AO5;
    output AO6;
    input ASRSTI;
    output ASRSTO;
    input BDRSTI;
    output BDRSTO;
    input BI1;
    input BI2;
    input BI3;
    input BI4;
    input BI5;
    input BI6;
    output BO1;
    output BO2;
    output BO3;
    output BO4;
    output BO5;
    output BO6;
    input BSRSTI;
    output BSRSTO;
    input CDRSTI;
    output CDRSTO;
    input CI1;
    input CI2;
    input CI3;
    input CI4;
    input CI5;
    input CI6;
    input CK1;
    input CK2;
    output CO1;
    output CO2;
    output CO3;
    output CO4;
    output CO5;
    output CO6;
    input CSRSTI;
    output CSRSTO;
    input DDRSTI;
    output DDRSTO;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    input DSRSTI;
    output DSRSTO;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter cck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter dck_sel = 1'b0;
    parameter link_BA = 1'b0;
    parameter link_CB = 1'b0;
    parameter link_DC = 1'b0;
    parameter mode = 0;
    parameter use_adest_arst = 1'b0;
    parameter use_asrc_arst = 1'b0;
    parameter use_bdest_arst = 1'b0;
    parameter use_bsrc_arst = 1'b0;
    parameter use_cdest_arst = 1'b0;
    parameter use_csrc_arst = 1'b0;
    parameter use_ddest_arst = 1'b0;
    parameter use_dsrc_arst = 1'b0;
endmodule

(* blackbox *)
module NX_DSP_U(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21
, A22, A23, A24, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18
, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21
, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, CAI1, CAI2, CAI3, CAI4, CAI5, CAI6
, CAI7, CAI8, CAI9, CAI10, CAI11, CAI12, CAI13, CAI14, CAI15, CAI16, CAI17, CAI18, CAI19, CAI20, CAI21, CAI22, CAI23, CAI24, CAO1, CAO2, CAO3
, CAO4, CAO5, CAO6, CAO7, CAO8, CAO9, CAO10, CAO11, CAO12, CAO13, CAO14, CAO15, CAO16, CAO17, CAO18, CAO19, CAO20, CAO21, CAO22, CAO23, CAO24
, CBI1, CBI2, CBI3, CBI4, CBI5, CBI6, CBI7, CBI8, CBI9, CBI10, CBI11, CBI12, CBI13, CBI14, CBI15, CBI16, CBI17, CBI18, CBO1, CBO2, CBO3
, CBO4, CBO5, CBO6, CBO7, CBO8, CBO9, CBO10, CBO11, CBO12, CBO13, CBO14, CBO15, CBO16, CBO17, CBO18, CCI, CCO, CI, CK, CO43, CO57
, RESERVED, CZI1, CZI2, CZI3, CZI4, CZI5, CZI6, CZI7, CZI8, CZI9, CZI10, CZI11, CZI12, CZI13, CZI14, CZI15, CZI16, CZI17, CZI18, CZI19, CZI20
, CZI21, CZI22, CZI23, CZI24, CZI25, CZI26, CZI27, CZI28, CZI29, CZI30, CZI31, CZI32, CZI33, CZI34, CZI35, CZI36, CZI37, CZI38, CZI39, CZI40, CZI41
, CZI42, CZI43, CZI44, CZI45, CZI46, CZI47, CZI48, CZI49, CZI50, CZI51, CZI52, CZI53, CZI54, CZI55, CZI56, CZO1, CZO2, CZO3, CZO4, CZO5, CZO6
, CZO7, CZO8, CZO9, CZO10, CZO11, CZO12, CZO13, CZO14, CZO15, CZO16, CZO17, CZO18, CZO19, CZO20, CZO21, CZO22, CZO23, CZO24, CZO25, CZO26, CZO27
, CZO28, CZO29, CZO30, CZO31, CZO32, CZO33, CZO34, CZO35, CZO36, CZO37, CZO38, CZO39, CZO40, CZO41, CZO42, CZO43, CZO44, CZO45, CZO46, CZO47, CZO48
, CZO49, CZO50, CZO51, CZO52, CZO53, CZO54, CZO55, CZO56, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13
, D14, D15, D16, D17, D18, OVF, R, RZ, WE, WEZ, Z1, Z2, Z3, Z4, Z5, Z6, Z7, Z8, Z9, Z10, Z11
, Z12, Z13, Z14, Z15, Z16, Z17, Z18, Z19, Z20, Z21, Z22, Z23, Z24, Z25, Z26, Z27, Z28, Z29, Z30, Z31, Z32
, Z33, Z34, Z35, Z36, Z37, Z38, Z39, Z40, Z41, Z42, Z43, Z44, Z45, Z46, Z47, Z48, Z49, Z50, Z51, Z52, Z53
, Z54, Z55, Z56);
    input A1;
    input A10;
    input A11;
    input A12;
    input A13;
    input A14;
    input A15;
    input A16;
    input A17;
    input A18;
    input A19;
    input A2;
    input A20;
    input A21;
    input A22;
    input A23;
    input A24;
    input A3;
    input A4;
    input A5;
    input A6;
    input A7;
    input A8;
    input A9;
    input B1;
    input B10;
    input B11;
    input B12;
    input B13;
    input B14;
    input B15;
    input B16;
    input B17;
    input B18;
    input B2;
    input B3;
    input B4;
    input B5;
    input B6;
    input B7;
    input B8;
    input B9;
    input C1;
    input C10;
    input C11;
    input C12;
    input C13;
    input C14;
    input C15;
    input C16;
    input C17;
    input C18;
    input C19;
    input C2;
    input C20;
    input C21;
    input C22;
    input C23;
    input C24;
    input C25;
    input C26;
    input C27;
    input C28;
    input C29;
    input C3;
    input C30;
    input C31;
    input C32;
    input C33;
    input C34;
    input C35;
    input C36;
    input C4;
    input C5;
    input C6;
    input C7;
    input C8;
    input C9;
    input CAI1;
    input CAI10;
    input CAI11;
    input CAI12;
    input CAI13;
    input CAI14;
    input CAI15;
    input CAI16;
    input CAI17;
    input CAI18;
    input CAI19;
    input CAI2;
    input CAI20;
    input CAI21;
    input CAI22;
    input CAI23;
    input CAI24;
    input CAI3;
    input CAI4;
    input CAI5;
    input CAI6;
    input CAI7;
    input CAI8;
    input CAI9;
    output CAO1;
    output CAO10;
    output CAO11;
    output CAO12;
    output CAO13;
    output CAO14;
    output CAO15;
    output CAO16;
    output CAO17;
    output CAO18;
    output CAO19;
    output CAO2;
    output CAO20;
    output CAO21;
    output CAO22;
    output CAO23;
    output CAO24;
    output CAO3;
    output CAO4;
    output CAO5;
    output CAO6;
    output CAO7;
    output CAO8;
    output CAO9;
    input CBI1;
    input CBI10;
    input CBI11;
    input CBI12;
    input CBI13;
    input CBI14;
    input CBI15;
    input CBI16;
    input CBI17;
    input CBI18;
    input CBI2;
    input CBI3;
    input CBI4;
    input CBI5;
    input CBI6;
    input CBI7;
    input CBI8;
    input CBI9;
    output CBO1;
    output CBO10;
    output CBO11;
    output CBO12;
    output CBO13;
    output CBO14;
    output CBO15;
    output CBO16;
    output CBO17;
    output CBO18;
    output CBO2;
    output CBO3;
    output CBO4;
    output CBO5;
    output CBO6;
    output CBO7;
    output CBO8;
    output CBO9;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO43;
    output CO57;
    input CZI1;
    input CZI10;
    input CZI11;
    input CZI12;
    input CZI13;
    input CZI14;
    input CZI15;
    input CZI16;
    input CZI17;
    input CZI18;
    input CZI19;
    input CZI2;
    input CZI20;
    input CZI21;
    input CZI22;
    input CZI23;
    input CZI24;
    input CZI25;
    input CZI26;
    input CZI27;
    input CZI28;
    input CZI29;
    input CZI3;
    input CZI30;
    input CZI31;
    input CZI32;
    input CZI33;
    input CZI34;
    input CZI35;
    input CZI36;
    input CZI37;
    input CZI38;
    input CZI39;
    input CZI4;
    input CZI40;
    input CZI41;
    input CZI42;
    input CZI43;
    input CZI44;
    input CZI45;
    input CZI46;
    input CZI47;
    input CZI48;
    input CZI49;
    input CZI5;
    input CZI50;
    input CZI51;
    input CZI52;
    input CZI53;
    input CZI54;
    input CZI55;
    input CZI56;
    input CZI6;
    input CZI7;
    input CZI8;
    input CZI9;
    output CZO1;
    output CZO10;
    output CZO11;
    output CZO12;
    output CZO13;
    output CZO14;
    output CZO15;
    output CZO16;
    output CZO17;
    output CZO18;
    output CZO19;
    output CZO2;
    output CZO20;
    output CZO21;
    output CZO22;
    output CZO23;
    output CZO24;
    output CZO25;
    output CZO26;
    output CZO27;
    output CZO28;
    output CZO29;
    output CZO3;
    output CZO30;
    output CZO31;
    output CZO32;
    output CZO33;
    output CZO34;
    output CZO35;
    output CZO36;
    output CZO37;
    output CZO38;
    output CZO39;
    output CZO4;
    output CZO40;
    output CZO41;
    output CZO42;
    output CZO43;
    output CZO44;
    output CZO45;
    output CZO46;
    output CZO47;
    output CZO48;
    output CZO49;
    output CZO5;
    output CZO50;
    output CZO51;
    output CZO52;
    output CZO53;
    output CZO54;
    output CZO55;
    output CZO56;
    output CZO6;
    output CZO7;
    output CZO8;
    output CZO9;
    input D1;
    input D10;
    input D11;
    input D12;
    input D13;
    input D14;
    input D15;
    input D16;
    input D17;
    input D18;
    input D2;
    input D3;
    input D4;
    input D5;
    input D6;
    input D7;
    input D8;
    input D9;
    output OVF;
    input R;
    output RESERVED;
    input RZ;
    input WE;
    input WEZ;
    output Z1;
    output Z10;
    output Z11;
    output Z12;
    output Z13;
    output Z14;
    output Z15;
    output Z16;
    output Z17;
    output Z18;
    output Z19;
    output Z2;
    output Z20;
    output Z21;
    output Z22;
    output Z23;
    output Z24;
    output Z25;
    output Z26;
    output Z27;
    output Z28;
    output Z29;
    output Z3;
    output Z30;
    output Z31;
    output Z32;
    output Z33;
    output Z34;
    output Z35;
    output Z36;
    output Z37;
    output Z38;
    output Z39;
    output Z4;
    output Z40;
    output Z41;
    output Z42;
    output Z43;
    output Z44;
    output Z45;
    output Z46;
    output Z47;
    output Z48;
    output Z49;
    output Z5;
    output Z50;
    output Z51;
    output Z52;
    output Z53;
    output Z54;
    output Z55;
    output Z56;
    output Z6;
    output Z7;
    output Z8;
    output Z9;
    parameter raw_config0 = 27'b000000000000000000000000000;
    parameter raw_config1 = 24'b000000000000000000000000;
    parameter raw_config2 = 14'b00000000000000;
    parameter raw_config3 = 3'b000;
    parameter std_mode = "";
endmodule

(* blackbox *)
module NX_PLL_U(R, REF, FBK, OSC, VCO, LDFO, REFO, CLK_DIV1, CLK_DIV2, CLK_DIV3, CLK_DIV4, CLK_DIVD1, CLK_DIVD2, CLK_DIVD3, CLK_DIVD4, CLK_DIVD5, PLL_LOCKED, PLL_LOCKEDA, ARST_CAL, CLK_CAL, CLK_CAL_DIV
, CAL_LOCKED, EXT_CAL_LOCKED, CAL1, CAL2, CAL3, CAL4, CAL5, EXT_CAL1, EXT_CAL2, EXT_CAL3, EXT_CAL4, EXT_CAL5);
    input ARST_CAL;
    output CAL1;
    output CAL2;
    output CAL3;
    output CAL4;
    output CAL5;
    output CAL_LOCKED;
    input CLK_CAL;
    output CLK_CAL_DIV;
    output CLK_DIV1;
    output CLK_DIV2;
    output CLK_DIV3;
    output CLK_DIV4;
    output CLK_DIVD1;
    output CLK_DIVD2;
    output CLK_DIVD3;
    output CLK_DIVD4;
    output CLK_DIVD5;
    input EXT_CAL1;
    input EXT_CAL2;
    input EXT_CAL3;
    input EXT_CAL4;
    input EXT_CAL5;
    input EXT_CAL_LOCKED;
    input FBK;
    output LDFO;
    output OSC;
    output PLL_LOCKED;
    output PLL_LOCKEDA;
    input R;
    input REF;
    output REFO;
    output VCO;
    parameter cal_delay = 6'b011011;
    parameter cal_div = 4'b0111;
    parameter clk_cal_sel = 2'b01;
    parameter clk_outdiv1 = 3'b000;
    parameter clk_outdiv2 = 3'b000;
    parameter clk_outdiv3 = 3'b000;
    parameter clk_outdiv4 = 3'b000;
    parameter clk_outdivd1 = 4'b0000;
    parameter clk_outdivd2 = 4'b0000;
    parameter clk_outdivd3 = 4'b0000;
    parameter clk_outdivd4 = 4'b0000;
    parameter clk_outdivd5 = 4'b0000;
    parameter ext_fbk_on = 1'b0;
    parameter fbk_delay = 6'b000000;
    parameter fbk_delay_on = 1'b0;
    parameter fbk_intdiv = 7'b0000000;
    parameter location = "";
    parameter pll_cpump = 4'b0000;
    parameter pll_lock = 4'b0000;
    parameter pll_lpf_cap = 4'b0000;
    parameter pll_lpf_res = 4'b0000;
    parameter pll_odf = 2'b00;
    parameter ref_intdiv = 5'b00000;
    parameter ref_osc_on = 1'b0;
    parameter use_cal = 1'b0;
    parameter use_pll = 1'b1;
endmodule

(* blackbox *)
module NX_CRX_U(DSCR_E_I, DEC_E_I, ALIGN_E_I, ALIGN_S_I, REP_E_I, BUF_R_I, OVS_BS_I1, OVS_BS_I2, RST_N_I, PMA_RSTN_I, MEYE_RST_I, PWDN_N_I, DBG_S_I1, DBG_S_I2, DBG_S_I3, DATA_O1, DATA_O2, DATA_O3, DATA_O4, DATA_O5, DATA_O6
, DATA_O7, DATA_O8, DATA_O9, DATA_O10, DATA_O11, DATA_O12, DATA_O13, DATA_O14, DATA_O15, DATA_O16, DATA_O17, DATA_O18, DATA_O19, DATA_O20, DATA_O21, DATA_O22, DATA_O23, DATA_O24, DATA_O25, DATA_O26, DATA_O27
, DATA_O28, DATA_O29, DATA_O30, DATA_O31, DATA_O32, DATA_O33, DATA_O34, DATA_O35, DATA_O36, DATA_O37, DATA_O38, DATA_O39, DATA_O40, DATA_O41, DATA_O42, DATA_O43, DATA_O44, DATA_O45, DATA_O46, DATA_O47, DATA_O48
, DATA_O49, DATA_O50, DATA_O51, DATA_O52, DATA_O53, DATA_O54, DATA_O55, DATA_O56, DATA_O57, DATA_O58, DATA_O59, DATA_O60, DATA_O61, DATA_O62, DATA_O63, DATA_O64, CH_COM_O1, CH_COM_O2, CH_COM_O3, CH_COM_O4, CH_COM_O5
, CH_COM_O6, CH_COM_O7, CH_COM_O8, CH_K_O1, CH_K_O2, CH_K_O3, CH_K_O4, CH_K_O5, CH_K_O6, CH_K_O7, CH_K_O8, NIT_O1, NIT_O2, NIT_O3, NIT_O4, NIT_O5, NIT_O6, NIT_O7, NIT_O8, D_ERR_O1, D_ERR_O2
, D_ERR_O3, D_ERR_O4, D_ERR_O5, D_ERR_O6, D_ERR_O7, D_ERR_O8, CH_A_O1, CH_A_O2, CH_A_O3, CH_A_O4, CH_A_O5, CH_A_O6, CH_A_O7, CH_A_O8, CH_F_O1, CH_F_O2, CH_F_O3, CH_F_O4, CH_F_O5, CH_F_O6, CH_F_O7
, CH_F_O8, ALIGN_O, VREALIGN_O, BUSY_O, TST_O1, TST_O2, TST_O3, TST_O4, TST_O5, TST_O6, TST_O7, TST_O8, LOS_O, LL_FLOCK_O, LL_SLOCK_O, PLL_LOCK_O, PLL_LOCKT_O, LINK);
    input ALIGN_E_I;
    output ALIGN_O;
    input ALIGN_S_I;
    input BUF_R_I;
    output BUSY_O;
    output CH_A_O1;
    output CH_A_O2;
    output CH_A_O3;
    output CH_A_O4;
    output CH_A_O5;
    output CH_A_O6;
    output CH_A_O7;
    output CH_A_O8;
    output CH_COM_O1;
    output CH_COM_O2;
    output CH_COM_O3;
    output CH_COM_O4;
    output CH_COM_O5;
    output CH_COM_O6;
    output CH_COM_O7;
    output CH_COM_O8;
    output CH_F_O1;
    output CH_F_O2;
    output CH_F_O3;
    output CH_F_O4;
    output CH_F_O5;
    output CH_F_O6;
    output CH_F_O7;
    output CH_F_O8;
    output CH_K_O1;
    output CH_K_O2;
    output CH_K_O3;
    output CH_K_O4;
    output CH_K_O5;
    output CH_K_O6;
    output CH_K_O7;
    output CH_K_O8;
    output DATA_O1;
    output DATA_O10;
    output DATA_O11;
    output DATA_O12;
    output DATA_O13;
    output DATA_O14;
    output DATA_O15;
    output DATA_O16;
    output DATA_O17;
    output DATA_O18;
    output DATA_O19;
    output DATA_O2;
    output DATA_O20;
    output DATA_O21;
    output DATA_O22;
    output DATA_O23;
    output DATA_O24;
    output DATA_O25;
    output DATA_O26;
    output DATA_O27;
    output DATA_O28;
    output DATA_O29;
    output DATA_O3;
    output DATA_O30;
    output DATA_O31;
    output DATA_O32;
    output DATA_O33;
    output DATA_O34;
    output DATA_O35;
    output DATA_O36;
    output DATA_O37;
    output DATA_O38;
    output DATA_O39;
    output DATA_O4;
    output DATA_O40;
    output DATA_O41;
    output DATA_O42;
    output DATA_O43;
    output DATA_O44;
    output DATA_O45;
    output DATA_O46;
    output DATA_O47;
    output DATA_O48;
    output DATA_O49;
    output DATA_O5;
    output DATA_O50;
    output DATA_O51;
    output DATA_O52;
    output DATA_O53;
    output DATA_O54;
    output DATA_O55;
    output DATA_O56;
    output DATA_O57;
    output DATA_O58;
    output DATA_O59;
    output DATA_O6;
    output DATA_O60;
    output DATA_O61;
    output DATA_O62;
    output DATA_O63;
    output DATA_O64;
    output DATA_O7;
    output DATA_O8;
    output DATA_O9;
    input DBG_S_I1;
    input DBG_S_I2;
    input DBG_S_I3;
    input DEC_E_I;
    input DSCR_E_I;
    output D_ERR_O1;
    output D_ERR_O2;
    output D_ERR_O3;
    output D_ERR_O4;
    output D_ERR_O5;
    output D_ERR_O6;
    output D_ERR_O7;
    output D_ERR_O8;
    inout [9:0] LINK;
    output LL_FLOCK_O;
    output LL_SLOCK_O;
    output LOS_O;
    input MEYE_RST_I;
    output NIT_O1;
    output NIT_O2;
    output NIT_O3;
    output NIT_O4;
    output NIT_O5;
    output NIT_O6;
    output NIT_O7;
    output NIT_O8;
    input OVS_BS_I1;
    input OVS_BS_I2;
    output PLL_LOCKT_O;
    output PLL_LOCK_O;
    input PMA_RSTN_I;
    input PWDN_N_I;
    input REP_E_I;
    input RST_N_I;
    output TST_O1;
    output TST_O2;
    output TST_O3;
    output TST_O4;
    output TST_O5;
    output TST_O6;
    output TST_O7;
    output TST_O8;
    output VREALIGN_O;
    parameter gearbox_en = 1'b0;
    parameter gearbox_mode = 1'b0;
    parameter location = "";
    parameter pcs_8b_dscr_sel = 1'b0;
    parameter pcs_align_bypass = 1'b0;
    parameter pcs_buffers_bypass = 1'b0;
    parameter pcs_buffers_use_cdc = 1'b0;
    parameter pcs_bypass_pma_cdc = 1'b0;
    parameter pcs_bypass_usr_cdc = 1'b0;
    parameter pcs_comma_mask = 10'b0000000000;
    parameter pcs_debug_en = 1'b0;
    parameter pcs_dec_bypass = 1'b0;
    parameter pcs_dscr_bypass = 1'b0;
    parameter pcs_el_buff_diff_bef_comp = 4'b0000;
    parameter pcs_el_buff_max_comp = 4'b0000;
    parameter pcs_el_buff_only_one_skp = 1'b0;
    parameter pcs_el_buff_skp_char_0 = 9'b000000000;
    parameter pcs_el_buff_skp_char_1 = 9'b000000000;
    parameter pcs_el_buff_skp_char_2 = 9'b000000000;
    parameter pcs_el_buff_skp_char_3 = 9'b000000000;
    parameter pcs_el_buff_skp_header_0 = 9'b000000000;
    parameter pcs_el_buff_skp_header_1 = 9'b000000000;
    parameter pcs_el_buff_skp_header_2 = 9'b000000000;
    parameter pcs_el_buff_skp_header_3 = 9'b000000000;
    parameter pcs_el_buff_skp_header_size = 2'b00;
    parameter pcs_el_buff_skp_seq_size = 2'b00;
    parameter pcs_fsm_sel = 2'b00;
    parameter pcs_fsm_watchdog_en = 1'b0;
    parameter pcs_loopback = 1'b0;
    parameter pcs_m_comma_en = 1'b0;
    parameter pcs_m_comma_val = 10'b0000000000;
    parameter pcs_nb_comma_bef_realign = 2'b00;
    parameter pcs_p_comma_en = 1'b0;
    parameter pcs_p_comma_val = 10'b0000000000;
    parameter pcs_polarity = 1'b0;
    parameter pcs_protocol_size = 1'b0;
    parameter pcs_replace_bypass = 1'b0;
    parameter pcs_sync_supported = 1'b0;
    parameter pma_cdr_cp = 4'b0000;
    parameter pma_clk_pos = 1'b0;
    parameter pma_coarse_ppm = 3'b000;
    parameter pma_ctrl_term = 6'b000000;
    parameter pma_dco_divl = 2'b00;
    parameter pma_dco_divm = 1'b0;
    parameter pma_dco_divn = 2'b00;
    parameter pma_dco_reg_res = 2'b00;
    parameter pma_dco_vref_sel = 1'b0;
    parameter pma_fine_ppm = 3'b000;
    parameter pma_loopback = 1'b0;
    parameter pma_m_eye_ppm = 3'b000;
    parameter pma_peak_detect_cmd = 2'b00;
    parameter pma_peak_detect_on = 1'b0;
    parameter pma_pll_cpump_n = 3'b000;
    parameter pma_pll_divf = 2'b00;
    parameter pma_pll_divf_en_n = 1'b0;
    parameter pma_pll_divm = 2'b00;
    parameter pma_pll_divm_en_n = 1'b0;
    parameter pma_pll_divn = 1'b0;
    parameter pma_pll_divn_en_n = 1'b0;
endmodule


(* blackbox *)
module NX_CTX_U(ENC_E_I1, ENC_E_I2, ENC_E_I3, ENC_E_I4, ENC_E_I5, ENC_E_I6, ENC_E_I7, ENC_E_I8, CH_K_I1, CH_K_I2, CH_K_I3, CH_K_I4, CH_K_I5, CH_K_I6, CH_K_I7, CH_K_I8, SCR_E_I1, SCR_E_I2, SCR_E_I3, SCR_E_I4, SCR_E_I5
, SCR_E_I6, SCR_E_I7, SCR_E_I8, EOMF_I1, EOMF_I2, EOMF_I3, EOMF_I4, EOMF_I5, EOMF_I6, EOMF_I7, EOMF_I8, EOF_I1, EOF_I2, EOF_I3, EOF_I4, EOF_I5, EOF_I6, EOF_I7, EOF_I8, REP_E_I, RST_N_I
, DATA_I1, DATA_I2, DATA_I3, DATA_I4, DATA_I5, DATA_I6, DATA_I7, DATA_I8, DATA_I9, DATA_I10, DATA_I11, DATA_I12, DATA_I13, DATA_I14, DATA_I15, DATA_I16, DATA_I17, DATA_I18, DATA_I19, DATA_I20, DATA_I21
, DATA_I22, DATA_I23, DATA_I24, DATA_I25, DATA_I26, DATA_I27, DATA_I28, DATA_I29, DATA_I30, DATA_I31, DATA_I32, DATA_I33, DATA_I34, DATA_I35, DATA_I36, DATA_I37, DATA_I38, DATA_I39, DATA_I40, DATA_I41, DATA_I42
, DATA_I43, DATA_I44, DATA_I45, DATA_I46, DATA_I47, DATA_I48, DATA_I49, DATA_I50, DATA_I51, DATA_I52, DATA_I53, DATA_I54, DATA_I55, DATA_I56, DATA_I57, DATA_I58, DATA_I59, DATA_I60, DATA_I61, DATA_I62, DATA_I63
, DATA_I64, BUSY_O, INV_K_O, PWDN_N_I, CLK_E_I, CLK_O, LINK);
    output BUSY_O;
    input CH_K_I1;
    input CH_K_I2;
    input CH_K_I3;
    input CH_K_I4;
    input CH_K_I5;
    input CH_K_I6;
    input CH_K_I7;
    input CH_K_I8;
    input CLK_E_I;
    output CLK_O;
    input DATA_I1;
    input DATA_I10;
    input DATA_I11;
    input DATA_I12;
    input DATA_I13;
    input DATA_I14;
    input DATA_I15;
    input DATA_I16;
    input DATA_I17;
    input DATA_I18;
    input DATA_I19;
    input DATA_I2;
    input DATA_I20;
    input DATA_I21;
    input DATA_I22;
    input DATA_I23;
    input DATA_I24;
    input DATA_I25;
    input DATA_I26;
    input DATA_I27;
    input DATA_I28;
    input DATA_I29;
    input DATA_I3;
    input DATA_I30;
    input DATA_I31;
    input DATA_I32;
    input DATA_I33;
    input DATA_I34;
    input DATA_I35;
    input DATA_I36;
    input DATA_I37;
    input DATA_I38;
    input DATA_I39;
    input DATA_I4;
    input DATA_I40;
    input DATA_I41;
    input DATA_I42;
    input DATA_I43;
    input DATA_I44;
    input DATA_I45;
    input DATA_I46;
    input DATA_I47;
    input DATA_I48;
    input DATA_I49;
    input DATA_I5;
    input DATA_I50;
    input DATA_I51;
    input DATA_I52;
    input DATA_I53;
    input DATA_I54;
    input DATA_I55;
    input DATA_I56;
    input DATA_I57;
    input DATA_I58;
    input DATA_I59;
    input DATA_I6;
    input DATA_I60;
    input DATA_I61;
    input DATA_I62;
    input DATA_I63;
    input DATA_I64;
    input DATA_I7;
    input DATA_I8;
    input DATA_I9;
    input ENC_E_I1;
    input ENC_E_I2;
    input ENC_E_I3;
    input ENC_E_I4;
    input ENC_E_I5;
    input ENC_E_I6;
    input ENC_E_I7;
    input ENC_E_I8;
    input EOF_I1;
    input EOF_I2;
    input EOF_I3;
    input EOF_I4;
    input EOF_I5;
    input EOF_I6;
    input EOF_I7;
    input EOF_I8;
    input EOMF_I1;
    input EOMF_I2;
    input EOMF_I3;
    input EOMF_I4;
    input EOMF_I5;
    input EOMF_I6;
    input EOMF_I7;
    input EOMF_I8;
    output INV_K_O;
    inout [19:0] LINK;
    input PWDN_N_I;
    input REP_E_I;
    input RST_N_I;
    input SCR_E_I1;
    input SCR_E_I2;
    input SCR_E_I3;
    input SCR_E_I4;
    input SCR_E_I5;
    input SCR_E_I6;
    input SCR_E_I7;
    input SCR_E_I8;
    parameter gearbox_en = 1'b0;
    parameter gearbox_mode = 1'b0;
    parameter location = "";
    parameter pcs_8b_scr_sel = 1'b0;
    parameter pcs_bypass_pma_cdc = 1'b0;
    parameter pcs_bypass_usr_cdc = 1'b0;
    parameter pcs_enc_bypass = 1'b0;
    parameter pcs_esistream_fsm_en = 1'b0;
    parameter pcs_loopback = 1'b0;
    parameter pcs_polarity = 1'b0;
    parameter pcs_protocol_size = 1'b0;
    parameter pcs_replace_bypass = 1'b0;
    parameter pcs_scr_bypass = 1'b0;
    parameter pcs_scr_init = 17'b00000000000000000;
    parameter pcs_sync_supported = 1'b0;
    parameter pma_clk_pos = 1'b0;
    parameter pma_loopback = 1'b0;
endmodule

(* blackbox *)
module NX_IOM_U(ALCK1, ALCK2, ALCK3, LDSCK1, LDSCK2, LDSCK3, SWRX1CK, SWRX2CK, FCK1, FCK2, FDCK, CCK, DQ1CI1, DQ1CI2, DQ1CI3, DQ1CI4, DQ1CI5, DQ1CI6, DQ1CI7, DQ1CI8, DQ2CI1
, DQ2CI2, DQ2CI3, DQ2CI4, DQ2CI5, DQ2CI6, DQ2CI7, DQ2CI8, DQ3CI1, DQ3CI2, DQ3CI3, DQ3CI4, DQ3CI5, DQ3CI6, DQ3CI7, DQ3CI8, DQS1CI1, DQS1CI2, DQS1CI3, DQS1CI4, DQS1CI5, DQS1CI6
, DQS1CI7, DQS1CI8, DQS2CI1, DQS2CI2, DQS2CI3, DQS2CI4, DQS2CI5, DQS2CI6, DQS2CI7, DQS2CI8, DQS3CI1, DQS3CI2, DQS3CI3, DQS3CI4, DQS3CI5, DQS3CI6, DQS3CI7, DQS3CI8, LD1RN, LD2RN, LD3RN
, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DCRN, LE, SE, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3, DRA4, DRO1CSN
, DRO2CSN, DRO3CSN, DRI1CSN, DRI2CSN, DRI3CSN, DRDPA1CSN, DRDPA2CSN, DRDPA3CSN, DRCCSN, DRWDS, DRWEN, DRE, CA1P1, CA1P2, CA1P3, CA1P4, CA2P1, CA2P2, CA2P3, CA2P4, CA1N1
, CA1N2, CA1N3, CA1N4, CA2N1, CA2N2, CA2N3, CA2N4, CA1T1, CA1T2, CA1T3, CA1T4, CA2T1, CA2T2, CA2T3, CA2T4, CA1D1, CA1D2, CA1D3, CA1D4, CA1D5, CA1D6
, CA2D1, CA2D2, CA2D3, CA2D4, CA2D5, CA2D6, CKO1, CKO2, FLD, FLG, AL1D, AL2D, AL3D, AL1T, AL2T, AL3T, DCL, DRO1, DRO2, DRO3, DRO4
, DRO5, DRO6, P1CI1, P1CL, P1CR, P1CO, P1CTI, P1CTO, P1EI1, P1EI2, P1EI3, P1EI4, P1EI5, P1EI6, P1EI7, P1EI8, P1EL, P1ER, P1EO, P1RI, P1RL
, P1RR, P1RO1, P1RO2, P1RO3, P1RO4, P1RO5, P1RO6, P1RO7, P1RO8, P2CI1, P2CL, P2CR, P2CO, P2CTI, P2CTO, P2EI1, P2EI2, P2EI3, P2EI4, P2EI5, P2EI6
, P2EI7, P2EI8, P2EL, P2ER, P2EO, P2RI, P2RL, P2RR, P2RO1, P2RO2, P2RO3, P2RO4, P2RO5, P2RO6, P2RO7, P2RO8, P3CI1, P3CL, P3CR, P3CO, P3CTI
, P3CTO, P3EI1, P3EI2, P3EI3, P3EI4, P3EI5, P3EI6, P3EI7, P3EI8, P3EL, P3ER, P3EO, P3RI, P3RL, P3RR, P3RO1, P3RO2, P3RO3, P3RO4, P3RO5, P3RO6
, P3RO7, P3RO8, P4CI1, P4CL, P4CR, P4CO, P4CTI, P4CTO, P4EI1, P4EI2, P4EI3, P4EI4, P4EI5, P4EI6, P4EI7, P4EI8, P4EL, P4ER, P4EO, P4RI, P4RL
, P4RR, P4RO1, P4RO2, P4RO3, P4RO4, P4RO5, P4RO6, P4RO7, P4RO8, P5CI1, P5CL, P5CR, P5CO, P5CTI, P5CTO, P5EI1, P5EI2, P5EI3, P5EI4, P5EI5, P5EI6
, P5EI7, P5EI8, P5EL, P5ER, P5EO, P5RI, P5RL, P5RR, P5RO1, P5RO2, P5RO3, P5RO4, P5RO5, P5RO6, P5RO7, P5RO8, P6CI1, P6CL, P6CR, P6CO, P6CTI
, P6CTO, P6EI1, P6EI2, P6EI3, P6EI4, P6EI5, P6EI6, P6EI7, P6EI8, P6EL, P6ER, P6EO, P6RI, P6RL, P6RR, P6RO1, P6RO2, P6RO3, P6RO4, P6RO5, P6RO6
, P6RO7, P6RO8, P7CI1, P7CL, P7CR, P7CO, P7CTI, P7CTO, P7EI1, P7EI2, P7EI3, P7EI4, P7EI5, P7EI6, P7EI7, P7EI8, P7EL, P7ER, P7EO, P7RI, P7RL
, P7RR, P7RO1, P7RO2, P7RO3, P7RO4, P7RO5, P7RO6, P7RO7, P7RO8, P8CI1, P8CL, P8CR, P8CO, P8CTI, P8CTO, P8EI1, P8EI2, P8EI3, P8EI4, P8EI5, P8EI6
, P8EI7, P8EI8, P8EL, P8ER, P8EO, P8RI, P8RL, P8RR, P8RO1, P8RO2, P8RO3, P8RO4, P8RO5, P8RO6, P8RO7, P8RO8, P9CI1, P9CL, P9CR, P9CO, P9CTI
, P9CTO, P9EI1, P9EI2, P9EI3, P9EI4, P9EI5, P9EI6, P9EI7, P9EI8, P9EL, P9ER, P9EO, P9RI, P9RL, P9RR, P9RO1, P9RO2, P9RO3, P9RO4, P9RO5, P9RO6
, P9RO7, P9RO8, P10CI1, P10CL, P10CR, P10CO, P10CTI, P10CTO, P10EI1, P10EI2, P10EI3, P10EI4, P10EI5, P10EI6, P10EI7, P10EI8, P10EL, P10ER, P10EO, P10RI, P10RL
, P10RR, P10RO1, P10RO2, P10RO3, P10RO4, P10RO5, P10RO6, P10RO7, P10RO8, P11CI1, P11CL, P11CR, P11CO, P11CTI, P11CTO, P11EI1, P11EI2, P11EI3, P11EI4, P11EI5, P11EI6
, P11EI7, P11EI8, P11EL, P11ER, P11EO, P11RI, P11RL, P11RR, P11RO1, P11RO2, P11RO3, P11RO4, P11RO5, P11RO6, P11RO7, P11RO8, P12CI1, P12CL, P12CR, P12CO, P12CTI
, P12CTO, P12EI1, P12EI2, P12EI3, P12EI4, P12EI5, P12EI6, P12EI7, P12EI8, P12EL, P12ER, P12EO, P12RI, P12RL, P12RR, P12RO1, P12RO2, P12RO3, P12RO4, P12RO5, P12RO6
, P12RO7, P12RO8, P13CI1, P13CL, P13CR, P13CO, P13CTI, P13CTO, P13EI1, P13EI2, P13EI3, P13EI4, P13EI5, P13EI6, P13EI7, P13EI8, P13EL, P13ER, P13EO, P13RI, P13RL
, P13RR, P13RO1, P13RO2, P13RO3, P13RO4, P13RO5, P13RO6, P13RO7, P13RO8, P14CI1, P14CL, P14CR, P14CO, P14CTI, P14CTO, P14EI1, P14EI2, P14EI3, P14EI4, P14EI5, P14EI6
, P14EI7, P14EI8, P14EL, P14ER, P14EO, P14RI, P14RL, P14RR, P14RO1, P14RO2, P14RO3, P14RO4, P14RO5, P14RO6, P14RO7, P14RO8, P15CI1, P15CL, P15CR, P15CO, P15CTI
, P15CTO, P15EI1, P15EI2, P15EI3, P15EI4, P15EI5, P15EI6, P15EI7, P15EI8, P15EL, P15ER, P15EO, P15RI, P15RL, P15RR, P15RO1, P15RO2, P15RO3, P15RO4, P15RO5, P15RO6
, P15RO7, P15RO8, P16CI1, P16CL, P16CR, P16CO, P16CTI, P16CTO, P16EI1, P16EI2, P16EI3, P16EI4, P16EI5, P16EI6, P16EI7, P16EI8, P16EL, P16ER, P16EO, P16RI, P16RL
, P16RR, P16RO1, P16RO2, P16RO3, P16RO4, P16RO5, P16RO6, P16RO7, P16RO8, P17CI1, P17CL, P17CR, P17CO, P17CTI, P17CTO, P17EI1, P17EI2, P17EI3, P17EI4, P17EI5, P17EI6
, P17EI7, P17EI8, P17EL, P17ER, P17EO, P17RI, P17RL, P17RR, P17RO1, P17RO2, P17RO3, P17RO4, P17RO5, P17RO6, P17RO7, P17RO8, P18CI1, P18CL, P18CR, P18CO, P18CTI
, P18CTO, P18EI1, P18EI2, P18EI3, P18EI4, P18EI5, P18EI6, P18EI7, P18EI8, P18EL, P18ER, P18EO, P18RI, P18RL, P18RR, P18RO1, P18RO2, P18RO3, P18RO4, P18RO5, P18RO6
, P18RO7, P18RO8, P19CI1, P19CL, P19CR, P19CO, P19CTI, P19CTO, P19EI1, P19EI2, P19EI3, P19EI4, P19EI5, P19EI6, P19EI7, P19EI8, P19EL, P19ER, P19EO, P19RI, P19RL
, P19RR, P19RO1, P19RO2, P19RO3, P19RO4, P19RO5, P19RO6, P19RO7, P19RO8, P20CI1, P20CL, P20CR, P20CO, P20CTI, P20CTO, P20EI1, P20EI2, P20EI3, P20EI4, P20EI5, P20EI6
, P20EI7, P20EI8, P20EL, P20ER, P20EO, P20RI, P20RL, P20RR, P20RO1, P20RO2, P20RO3, P20RO4, P20RO5, P20RO6, P20RO7, P20RO8, P21CI1, P21CL, P21CR, P21CO, P21CTI
, P21CTO, P21EI1, P21EI2, P21EI3, P21EI4, P21EI5, P21EI6, P21EI7, P21EI8, P21EL, P21ER, P21EO, P21RI, P21RL, P21RR, P21RO1, P21RO2, P21RO3, P21RO4, P21RO5, P21RO6
, P21RO7, P21RO8, P22CI1, P22CL, P22CR, P22CO, P22CTI, P22CTO, P22EI1, P22EI2, P22EI3, P22EI4, P22EI5, P22EI6, P22EI7, P22EI8, P22EL, P22ER, P22EO, P22RI, P22RL
, P22RR, P22RO1, P22RO2, P22RO3, P22RO4, P22RO5, P22RO6, P22RO7, P22RO8, P23CI1, P23CL, P23CR, P23CO, P23CTI, P23CTO, P23EI1, P23EI2, P23EI3, P23EI4, P23EI5, P23EI6
, P23EI7, P23EI8, P23EL, P23ER, P23EO, P23RI, P23RL, P23RR, P23RO1, P23RO2, P23RO3, P23RO4, P23RO5, P23RO6, P23RO7, P23RO8, P24CI1, P24CL, P24CR, P24CO, P24CTI
, P24CTO, P24EI1, P24EI2, P24EI3, P24EI4, P24EI5, P24EI6, P24EI7, P24EI8, P24EL, P24ER, P24EO, P24RI, P24RL, P24RR, P24RO1, P24RO2, P24RO3, P24RO4, P24RO5, P24RO6
, P24RO7, P24RO8, P25CI1, P25CL, P25CR, P25CO, P25CTI, P25CTO, P25EI1, P25EI2, P25EI3, P25EI4, P25EI5, P25EI6, P25EI7, P25EI8, P25EL, P25ER, P25EO, P25RI, P25RL
, P25RR, P25RO1, P25RO2, P25RO3, P25RO4, P25RO5, P25RO6, P25RO7, P25RO8, P26CI1, P26CL, P26CR, P26CO, P26CTI, P26CTO, P26EI1, P26EI2, P26EI3, P26EI4, P26EI5, P26EI6
, P26EI7, P26EI8, P26EL, P26ER, P26EO, P26RI, P26RL, P26RR, P26RO1, P26RO2, P26RO3, P26RO4, P26RO5, P26RO6, P26RO7, P26RO8, P27CI1, P27CL, P27CR, P27CO, P27CTI
, P27CTO, P27EI1, P27EI2, P27EI3, P27EI4, P27EI5, P27EI6, P27EI7, P27EI8, P27EL, P27ER, P27EO, P27RI, P27RL, P27RR, P27RO1, P27RO2, P27RO3, P27RO4, P27RO5, P27RO6
, P27RO7, P27RO8, P28CI1, P28CL, P28CR, P28CO, P28CTI, P28CTO, P28EI1, P28EI2, P28EI3, P28EI4, P28EI5, P28EI6, P28EI7, P28EI8, P28EL, P28ER, P28EO, P28RI, P28RL
, P28RR, P28RO1, P28RO2, P28RO3, P28RO4, P28RO5, P28RO6, P28RO7, P28RO8, P29CI1, P29CL, P29CR, P29CO, P29CTI, P29CTO, P29EI1, P29EI2, P29EI3, P29EI4, P29EI5, P29EI6
, P29EI7, P29EI8, P29EL, P29ER, P29EO, P29RI, P29RL, P29RR, P29RO1, P29RO2, P29RO3, P29RO4, P29RO5, P29RO6, P29RO7, P29RO8, P30CI1, P30CL, P30CR, P30CO, P30CTI
, P30CTO, P30EI1, P30EI2, P30EI3, P30EI4, P30EI5, P30EI6, P30EI7, P30EI8, P30EL, P30ER, P30EO, P30RI, P30RL, P30RR, P30RO1, P30RO2, P30RO3, P30RO4, P30RO5, P30RO6
, P30RO7, P30RO8, P31CI1, P31CL, P31CR, P31CO, P31CTI, P31CTO, P31EI1, P31EI2, P31EI3, P31EI4, P31EI5, P31EI6, P31EI7, P31EI8, P31EL, P31ER, P31EO, P31RI, P31RL
, P31RR, P31RO1, P31RO2, P31RO3, P31RO4, P31RO5, P31RO6, P31RO7, P31RO8, P32CI1, P32CL, P32CR, P32CO, P32CTI, P32CTO, P32EI1, P32EI2, P32EI3, P32EI4, P32EI5, P32EI6
, P32EI7, P32EI8, P32EL, P32ER, P32EO, P32RI, P32RL, P32RR, P32RO1, P32RO2, P32RO3, P32RO4, P32RO5, P32RO6, P32RO7, P32RO8, P33CI1, P33CL, P33CR, P33CO, P33CTI
, P33CTO, P33EI1, P33EI2, P33EI3, P33EI4, P33EI5, P33EI6, P33EI7, P33EI8, P33EL, P33ER, P33EO, P33RI, P33RL, P33RR, P33RO1, P33RO2, P33RO3, P33RO4, P33RO5, P33RO6
, P33RO7, P33RO8, P34CI1, P34CL, P34CR, P34CO, P34CTI, P34CTO, P34EI1, P34EI2, P34EI3, P34EI4, P34EI5, P34EI6, P34EI7, P34EI8, P34EL, P34ER, P34EO, P34RI, P34RL
, P34RR, P34RO1, P34RO2, P34RO3, P34RO4, P34RO5, P34RO6, P34RO7, P34RO8);
    output AL1D;
    output AL1T;
    output AL2D;
    output AL2T;
    output AL3D;
    output AL3T;
    input ALCK1;
    input ALCK2;
    input ALCK3;
    input CA1D1;
    input CA1D2;
    input CA1D3;
    input CA1D4;
    input CA1D5;
    input CA1D6;
    input CA1N1;
    input CA1N2;
    input CA1N3;
    input CA1N4;
    input CA1P1;
    input CA1P2;
    input CA1P3;
    input CA1P4;
    input CA1T1;
    input CA1T2;
    input CA1T3;
    input CA1T4;
    input CA2D1;
    input CA2D2;
    input CA2D3;
    input CA2D4;
    input CA2D5;
    input CA2D6;
    input CA2N1;
    input CA2N2;
    input CA2N3;
    input CA2N4;
    input CA2P1;
    input CA2P2;
    input CA2P3;
    input CA2P4;
    input CA2T1;
    input CA2T2;
    input CA2T3;
    input CA2T4;
    input CCK;
    output CKO1;
    output CKO2;
    output DCL;
    input DCRN;
    input DQ1CI1;
    input DQ1CI2;
    input DQ1CI3;
    input DQ1CI4;
    input DQ1CI5;
    input DQ1CI6;
    input DQ1CI7;
    input DQ1CI8;
    input DQ2CI1;
    input DQ2CI2;
    input DQ2CI3;
    input DQ2CI4;
    input DQ2CI5;
    input DQ2CI6;
    input DQ2CI7;
    input DQ2CI8;
    input DQ3CI1;
    input DQ3CI2;
    input DQ3CI3;
    input DQ3CI4;
    input DQ3CI5;
    input DQ3CI6;
    input DQ3CI7;
    input DQ3CI8;
    input DQS1CI1;
    input DQS1CI2;
    input DQS1CI3;
    input DQS1CI4;
    input DQS1CI5;
    input DQS1CI6;
    input DQS1CI7;
    input DQS1CI8;
    input DQS2CI1;
    input DQS2CI2;
    input DQS2CI3;
    input DQS2CI4;
    input DQS2CI5;
    input DQS2CI6;
    input DQS2CI7;
    input DQS2CI8;
    input DQS3CI1;
    input DQS3CI2;
    input DQS3CI3;
    input DQS3CI4;
    input DQS3CI5;
    input DQS3CI6;
    input DQS3CI7;
    input DQS3CI8;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRCCSN;
    input DRDPA1CSN;
    input DRDPA2CSN;
    input DRDPA3CSN;
    input DRE;
    input DRI1;
    input DRI1CSN;
    input DRI2;
    input DRI2CSN;
    input DRI3;
    input DRI3CSN;
    input DRI4;
    input DRI5;
    input DRI6;
    output DRO1;
    input DRO1CSN;
    output DRO2;
    input DRO2CSN;
    output DRO3;
    input DRO3CSN;
    output DRO4;
    output DRO5;
    output DRO6;
    input DRWDS;
    input DRWEN;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    input FCK1;
    input FCK2;
    input FDCK;
    output FLD;
    output FLG;
    input FZ;
    input LD1RN;
    input LD2RN;
    input LD3RN;
    input LDSCK1;
    input LDSCK2;
    input LDSCK3;
    input LE;
    input P10CI1;
    input P10CL;
    output P10CO;
    input P10CR;
    input P10CTI;
    output P10CTO;
    input P10EI1;
    input P10EI2;
    input P10EI3;
    input P10EI4;
    input P10EI5;
    input P10EI6;
    input P10EI7;
    input P10EI8;
    input P10EL;
    output P10EO;
    input P10ER;
    input P10RI;
    input P10RL;
    output P10RO1;
    output P10RO2;
    output P10RO3;
    output P10RO4;
    output P10RO5;
    output P10RO6;
    output P10RO7;
    output P10RO8;
    input P10RR;
    input P11CI1;
    input P11CL;
    output P11CO;
    input P11CR;
    input P11CTI;
    output P11CTO;
    input P11EI1;
    input P11EI2;
    input P11EI3;
    input P11EI4;
    input P11EI5;
    input P11EI6;
    input P11EI7;
    input P11EI8;
    input P11EL;
    output P11EO;
    input P11ER;
    input P11RI;
    input P11RL;
    output P11RO1;
    output P11RO2;
    output P11RO3;
    output P11RO4;
    output P11RO5;
    output P11RO6;
    output P11RO7;
    output P11RO8;
    input P11RR;
    input P12CI1;
    input P12CL;
    output P12CO;
    input P12CR;
    input P12CTI;
    output P12CTO;
    input P12EI1;
    input P12EI2;
    input P12EI3;
    input P12EI4;
    input P12EI5;
    input P12EI6;
    input P12EI7;
    input P12EI8;
    input P12EL;
    output P12EO;
    input P12ER;
    input P12RI;
    input P12RL;
    output P12RO1;
    output P12RO2;
    output P12RO3;
    output P12RO4;
    output P12RO5;
    output P12RO6;
    output P12RO7;
    output P12RO8;
    input P12RR;
    input P13CI1;
    input P13CL;
    output P13CO;
    input P13CR;
    input P13CTI;
    output P13CTO;
    input P13EI1;
    input P13EI2;
    input P13EI3;
    input P13EI4;
    input P13EI5;
    input P13EI6;
    input P13EI7;
    input P13EI8;
    input P13EL;
    output P13EO;
    input P13ER;
    input P13RI;
    input P13RL;
    output P13RO1;
    output P13RO2;
    output P13RO3;
    output P13RO4;
    output P13RO5;
    output P13RO6;
    output P13RO7;
    output P13RO8;
    input P13RR;
    input P14CI1;
    input P14CL;
    output P14CO;
    input P14CR;
    input P14CTI;
    output P14CTO;
    input P14EI1;
    input P14EI2;
    input P14EI3;
    input P14EI4;
    input P14EI5;
    input P14EI6;
    input P14EI7;
    input P14EI8;
    input P14EL;
    output P14EO;
    input P14ER;
    input P14RI;
    input P14RL;
    output P14RO1;
    output P14RO2;
    output P14RO3;
    output P14RO4;
    output P14RO5;
    output P14RO6;
    output P14RO7;
    output P14RO8;
    input P14RR;
    input P15CI1;
    input P15CL;
    output P15CO;
    input P15CR;
    input P15CTI;
    output P15CTO;
    input P15EI1;
    input P15EI2;
    input P15EI3;
    input P15EI4;
    input P15EI5;
    input P15EI6;
    input P15EI7;
    input P15EI8;
    input P15EL;
    output P15EO;
    input P15ER;
    input P15RI;
    input P15RL;
    output P15RO1;
    output P15RO2;
    output P15RO3;
    output P15RO4;
    output P15RO5;
    output P15RO6;
    output P15RO7;
    output P15RO8;
    input P15RR;
    input P16CI1;
    input P16CL;
    output P16CO;
    input P16CR;
    input P16CTI;
    output P16CTO;
    input P16EI1;
    input P16EI2;
    input P16EI3;
    input P16EI4;
    input P16EI5;
    input P16EI6;
    input P16EI7;
    input P16EI8;
    input P16EL;
    output P16EO;
    input P16ER;
    input P16RI;
    input P16RL;
    output P16RO1;
    output P16RO2;
    output P16RO3;
    output P16RO4;
    output P16RO5;
    output P16RO6;
    output P16RO7;
    output P16RO8;
    input P16RR;
    input P17CI1;
    input P17CL;
    output P17CO;
    input P17CR;
    input P17CTI;
    output P17CTO;
    input P17EI1;
    input P17EI2;
    input P17EI3;
    input P17EI4;
    input P17EI5;
    input P17EI6;
    input P17EI7;
    input P17EI8;
    input P17EL;
    output P17EO;
    input P17ER;
    input P17RI;
    input P17RL;
    output P17RO1;
    output P17RO2;
    output P17RO3;
    output P17RO4;
    output P17RO5;
    output P17RO6;
    output P17RO7;
    output P17RO8;
    input P17RR;
    input P18CI1;
    input P18CL;
    output P18CO;
    input P18CR;
    input P18CTI;
    output P18CTO;
    input P18EI1;
    input P18EI2;
    input P18EI3;
    input P18EI4;
    input P18EI5;
    input P18EI6;
    input P18EI7;
    input P18EI8;
    input P18EL;
    output P18EO;
    input P18ER;
    input P18RI;
    input P18RL;
    output P18RO1;
    output P18RO2;
    output P18RO3;
    output P18RO4;
    output P18RO5;
    output P18RO6;
    output P18RO7;
    output P18RO8;
    input P18RR;
    input P19CI1;
    input P19CL;
    output P19CO;
    input P19CR;
    input P19CTI;
    output P19CTO;
    input P19EI1;
    input P19EI2;
    input P19EI3;
    input P19EI4;
    input P19EI5;
    input P19EI6;
    input P19EI7;
    input P19EI8;
    input P19EL;
    output P19EO;
    input P19ER;
    input P19RI;
    input P19RL;
    output P19RO1;
    output P19RO2;
    output P19RO3;
    output P19RO4;
    output P19RO5;
    output P19RO6;
    output P19RO7;
    output P19RO8;
    input P19RR;
    input P1CI1;
    input P1CL;
    output P1CO;
    input P1CR;
    input P1CTI;
    output P1CTO;
    input P1EI1;
    input P1EI2;
    input P1EI3;
    input P1EI4;
    input P1EI5;
    input P1EI6;
    input P1EI7;
    input P1EI8;
    input P1EL;
    output P1EO;
    input P1ER;
    input P1RI;
    input P1RL;
    output P1RO1;
    output P1RO2;
    output P1RO3;
    output P1RO4;
    output P1RO5;
    output P1RO6;
    output P1RO7;
    output P1RO8;
    input P1RR;
    input P20CI1;
    input P20CL;
    output P20CO;
    input P20CR;
    input P20CTI;
    output P20CTO;
    input P20EI1;
    input P20EI2;
    input P20EI3;
    input P20EI4;
    input P20EI5;
    input P20EI6;
    input P20EI7;
    input P20EI8;
    input P20EL;
    output P20EO;
    input P20ER;
    input P20RI;
    input P20RL;
    output P20RO1;
    output P20RO2;
    output P20RO3;
    output P20RO4;
    output P20RO5;
    output P20RO6;
    output P20RO7;
    output P20RO8;
    input P20RR;
    input P21CI1;
    input P21CL;
    output P21CO;
    input P21CR;
    input P21CTI;
    output P21CTO;
    input P21EI1;
    input P21EI2;
    input P21EI3;
    input P21EI4;
    input P21EI5;
    input P21EI6;
    input P21EI7;
    input P21EI8;
    input P21EL;
    output P21EO;
    input P21ER;
    input P21RI;
    input P21RL;
    output P21RO1;
    output P21RO2;
    output P21RO3;
    output P21RO4;
    output P21RO5;
    output P21RO6;
    output P21RO7;
    output P21RO8;
    input P21RR;
    input P22CI1;
    input P22CL;
    output P22CO;
    input P22CR;
    input P22CTI;
    output P22CTO;
    input P22EI1;
    input P22EI2;
    input P22EI3;
    input P22EI4;
    input P22EI5;
    input P22EI6;
    input P22EI7;
    input P22EI8;
    input P22EL;
    output P22EO;
    input P22ER;
    input P22RI;
    input P22RL;
    output P22RO1;
    output P22RO2;
    output P22RO3;
    output P22RO4;
    output P22RO5;
    output P22RO6;
    output P22RO7;
    output P22RO8;
    input P22RR;
    input P23CI1;
    input P23CL;
    output P23CO;
    input P23CR;
    input P23CTI;
    output P23CTO;
    input P23EI1;
    input P23EI2;
    input P23EI3;
    input P23EI4;
    input P23EI5;
    input P23EI6;
    input P23EI7;
    input P23EI8;
    input P23EL;
    output P23EO;
    input P23ER;
    input P23RI;
    input P23RL;
    output P23RO1;
    output P23RO2;
    output P23RO3;
    output P23RO4;
    output P23RO5;
    output P23RO6;
    output P23RO7;
    output P23RO8;
    input P23RR;
    input P24CI1;
    input P24CL;
    output P24CO;
    input P24CR;
    input P24CTI;
    output P24CTO;
    input P24EI1;
    input P24EI2;
    input P24EI3;
    input P24EI4;
    input P24EI5;
    input P24EI6;
    input P24EI7;
    input P24EI8;
    input P24EL;
    output P24EO;
    input P24ER;
    input P24RI;
    input P24RL;
    output P24RO1;
    output P24RO2;
    output P24RO3;
    output P24RO4;
    output P24RO5;
    output P24RO6;
    output P24RO7;
    output P24RO8;
    input P24RR;
    input P25CI1;
    input P25CL;
    output P25CO;
    input P25CR;
    input P25CTI;
    output P25CTO;
    input P25EI1;
    input P25EI2;
    input P25EI3;
    input P25EI4;
    input P25EI5;
    input P25EI6;
    input P25EI7;
    input P25EI8;
    input P25EL;
    output P25EO;
    input P25ER;
    input P25RI;
    input P25RL;
    output P25RO1;
    output P25RO2;
    output P25RO3;
    output P25RO4;
    output P25RO5;
    output P25RO6;
    output P25RO7;
    output P25RO8;
    input P25RR;
    input P26CI1;
    input P26CL;
    output P26CO;
    input P26CR;
    input P26CTI;
    output P26CTO;
    input P26EI1;
    input P26EI2;
    input P26EI3;
    input P26EI4;
    input P26EI5;
    input P26EI6;
    input P26EI7;
    input P26EI8;
    input P26EL;
    output P26EO;
    input P26ER;
    input P26RI;
    input P26RL;
    output P26RO1;
    output P26RO2;
    output P26RO3;
    output P26RO4;
    output P26RO5;
    output P26RO6;
    output P26RO7;
    output P26RO8;
    input P26RR;
    input P27CI1;
    input P27CL;
    output P27CO;
    input P27CR;
    input P27CTI;
    output P27CTO;
    input P27EI1;
    input P27EI2;
    input P27EI3;
    input P27EI4;
    input P27EI5;
    input P27EI6;
    input P27EI7;
    input P27EI8;
    input P27EL;
    output P27EO;
    input P27ER;
    input P27RI;
    input P27RL;
    output P27RO1;
    output P27RO2;
    output P27RO3;
    output P27RO4;
    output P27RO5;
    output P27RO6;
    output P27RO7;
    output P27RO8;
    input P27RR;
    input P28CI1;
    input P28CL;
    output P28CO;
    input P28CR;
    input P28CTI;
    output P28CTO;
    input P28EI1;
    input P28EI2;
    input P28EI3;
    input P28EI4;
    input P28EI5;
    input P28EI6;
    input P28EI7;
    input P28EI8;
    input P28EL;
    output P28EO;
    input P28ER;
    input P28RI;
    input P28RL;
    output P28RO1;
    output P28RO2;
    output P28RO3;
    output P28RO4;
    output P28RO5;
    output P28RO6;
    output P28RO7;
    output P28RO8;
    input P28RR;
    input P29CI1;
    input P29CL;
    output P29CO;
    input P29CR;
    input P29CTI;
    output P29CTO;
    input P29EI1;
    input P29EI2;
    input P29EI3;
    input P29EI4;
    input P29EI5;
    input P29EI6;
    input P29EI7;
    input P29EI8;
    input P29EL;
    output P29EO;
    input P29ER;
    input P29RI;
    input P29RL;
    output P29RO1;
    output P29RO2;
    output P29RO3;
    output P29RO4;
    output P29RO5;
    output P29RO6;
    output P29RO7;
    output P29RO8;
    input P29RR;
    input P2CI1;
    input P2CL;
    output P2CO;
    input P2CR;
    input P2CTI;
    output P2CTO;
    input P2EI1;
    input P2EI2;
    input P2EI3;
    input P2EI4;
    input P2EI5;
    input P2EI6;
    input P2EI7;
    input P2EI8;
    input P2EL;
    output P2EO;
    input P2ER;
    input P2RI;
    input P2RL;
    output P2RO1;
    output P2RO2;
    output P2RO3;
    output P2RO4;
    output P2RO5;
    output P2RO6;
    output P2RO7;
    output P2RO8;
    input P2RR;
    input P30CI1;
    input P30CL;
    output P30CO;
    input P30CR;
    input P30CTI;
    output P30CTO;
    input P30EI1;
    input P30EI2;
    input P30EI3;
    input P30EI4;
    input P30EI5;
    input P30EI6;
    input P30EI7;
    input P30EI8;
    input P30EL;
    output P30EO;
    input P30ER;
    input P30RI;
    input P30RL;
    output P30RO1;
    output P30RO2;
    output P30RO3;
    output P30RO4;
    output P30RO5;
    output P30RO6;
    output P30RO7;
    output P30RO8;
    input P30RR;
    input P31CI1;
    input P31CL;
    output P31CO;
    input P31CR;
    input P31CTI;
    output P31CTO;
    input P31EI1;
    input P31EI2;
    input P31EI3;
    input P31EI4;
    input P31EI5;
    input P31EI6;
    input P31EI7;
    input P31EI8;
    input P31EL;
    output P31EO;
    input P31ER;
    input P31RI;
    input P31RL;
    output P31RO1;
    output P31RO2;
    output P31RO3;
    output P31RO4;
    output P31RO5;
    output P31RO6;
    output P31RO7;
    output P31RO8;
    input P31RR;
    input P32CI1;
    input P32CL;
    output P32CO;
    input P32CR;
    input P32CTI;
    output P32CTO;
    input P32EI1;
    input P32EI2;
    input P32EI3;
    input P32EI4;
    input P32EI5;
    input P32EI6;
    input P32EI7;
    input P32EI8;
    input P32EL;
    output P32EO;
    input P32ER;
    input P32RI;
    input P32RL;
    output P32RO1;
    output P32RO2;
    output P32RO3;
    output P32RO4;
    output P32RO5;
    output P32RO6;
    output P32RO7;
    output P32RO8;
    input P32RR;
    input P33CI1;
    input P33CL;
    output P33CO;
    input P33CR;
    input P33CTI;
    output P33CTO;
    input P33EI1;
    input P33EI2;
    input P33EI3;
    input P33EI4;
    input P33EI5;
    input P33EI6;
    input P33EI7;
    input P33EI8;
    input P33EL;
    output P33EO;
    input P33ER;
    input P33RI;
    input P33RL;
    output P33RO1;
    output P33RO2;
    output P33RO3;
    output P33RO4;
    output P33RO5;
    output P33RO6;
    output P33RO7;
    output P33RO8;
    input P33RR;
    input P34CI1;
    input P34CL;
    output P34CO;
    input P34CR;
    input P34CTI;
    output P34CTO;
    input P34EI1;
    input P34EI2;
    input P34EI3;
    input P34EI4;
    input P34EI5;
    input P34EI6;
    input P34EI7;
    input P34EI8;
    input P34EL;
    output P34EO;
    input P34ER;
    input P34RI;
    input P34RL;
    output P34RO1;
    output P34RO2;
    output P34RO3;
    output P34RO4;
    output P34RO5;
    output P34RO6;
    output P34RO7;
    output P34RO8;
    input P34RR;
    input P3CI1;
    input P3CL;
    output P3CO;
    input P3CR;
    input P3CTI;
    output P3CTO;
    input P3EI1;
    input P3EI2;
    input P3EI3;
    input P3EI4;
    input P3EI5;
    input P3EI6;
    input P3EI7;
    input P3EI8;
    input P3EL;
    output P3EO;
    input P3ER;
    input P3RI;
    input P3RL;
    output P3RO1;
    output P3RO2;
    output P3RO3;
    output P3RO4;
    output P3RO5;
    output P3RO6;
    output P3RO7;
    output P3RO8;
    input P3RR;
    input P4CI1;
    input P4CL;
    output P4CO;
    input P4CR;
    input P4CTI;
    output P4CTO;
    input P4EI1;
    input P4EI2;
    input P4EI3;
    input P4EI4;
    input P4EI5;
    input P4EI6;
    input P4EI7;
    input P4EI8;
    input P4EL;
    output P4EO;
    input P4ER;
    input P4RI;
    input P4RL;
    output P4RO1;
    output P4RO2;
    output P4RO3;
    output P4RO4;
    output P4RO5;
    output P4RO6;
    output P4RO7;
    output P4RO8;
    input P4RR;
    input P5CI1;
    input P5CL;
    output P5CO;
    input P5CR;
    input P5CTI;
    output P5CTO;
    input P5EI1;
    input P5EI2;
    input P5EI3;
    input P5EI4;
    input P5EI5;
    input P5EI6;
    input P5EI7;
    input P5EI8;
    input P5EL;
    output P5EO;
    input P5ER;
    input P5RI;
    input P5RL;
    output P5RO1;
    output P5RO2;
    output P5RO3;
    output P5RO4;
    output P5RO5;
    output P5RO6;
    output P5RO7;
    output P5RO8;
    input P5RR;
    input P6CI1;
    input P6CL;
    output P6CO;
    input P6CR;
    input P6CTI;
    output P6CTO;
    input P6EI1;
    input P6EI2;
    input P6EI3;
    input P6EI4;
    input P6EI5;
    input P6EI6;
    input P6EI7;
    input P6EI8;
    input P6EL;
    output P6EO;
    input P6ER;
    input P6RI;
    input P6RL;
    output P6RO1;
    output P6RO2;
    output P6RO3;
    output P6RO4;
    output P6RO5;
    output P6RO6;
    output P6RO7;
    output P6RO8;
    input P6RR;
    input P7CI1;
    input P7CL;
    output P7CO;
    input P7CR;
    input P7CTI;
    output P7CTO;
    input P7EI1;
    input P7EI2;
    input P7EI3;
    input P7EI4;
    input P7EI5;
    input P7EI6;
    input P7EI7;
    input P7EI8;
    input P7EL;
    output P7EO;
    input P7ER;
    input P7RI;
    input P7RL;
    output P7RO1;
    output P7RO2;
    output P7RO3;
    output P7RO4;
    output P7RO5;
    output P7RO6;
    output P7RO7;
    output P7RO8;
    input P7RR;
    input P8CI1;
    input P8CL;
    output P8CO;
    input P8CR;
    input P8CTI;
    output P8CTO;
    input P8EI1;
    input P8EI2;
    input P8EI3;
    input P8EI4;
    input P8EI5;
    input P8EI6;
    input P8EI7;
    input P8EI8;
    input P8EL;
    output P8EO;
    input P8ER;
    input P8RI;
    input P8RL;
    output P8RO1;
    output P8RO2;
    output P8RO3;
    output P8RO4;
    output P8RO5;
    output P8RO6;
    output P8RO7;
    output P8RO8;
    input P8RR;
    input P9CI1;
    input P9CL;
    output P9CO;
    input P9CR;
    input P9CTI;
    output P9CTO;
    input P9EI1;
    input P9EI2;
    input P9EI3;
    input P9EI4;
    input P9EI5;
    input P9EI6;
    input P9EI7;
    input P9EI8;
    input P9EL;
    output P9EO;
    input P9ER;
    input P9RI;
    input P9RL;
    output P9RO1;
    output P9RO2;
    output P9RO3;
    output P9RO4;
    output P9RO5;
    output P9RO6;
    output P9RO7;
    output P9RO8;
    input P9RR;
    input SE;
    input SWRX1CK;
    input SWRX2CK;
    parameter cal_delay1 = "";
    parameter cal_delay2 = "";
    parameter div1 = 3'b000;
    parameter div2 = 3'b000;
    parameter div3 = 3'b000;
    parameter div_swrx1 = 3'b000;
    parameter div_swrx2 = 3'b000;
    parameter inv_ld_sck1 = 1'b0;
    parameter inv_ld_sck2 = 1'b0;
    parameter inv_ld_sck3 = 1'b0;
    parameter link_ld_12 = 1'b0;
    parameter link_ld_23 = 1'b0;
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter mode_side3 = 0;
    parameter pads_dict = "";
    parameter pads_path = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_dc_clk = 2'b00;
    parameter sel_ld_fck1 = 2'b00;
    parameter sel_ld_fck2 = 2'b00;
    parameter sel_ld_fck3 = 2'b00;
    parameter sel_sw_fck1 = 2'b00;
    parameter sel_sw_fck2 = 2'b00;
    parameter use_dc = 1'b0;
endmodule

(* blackbox *)
module NX_PMA_U(CLK_TX_I, CLK_RX_I, CLK_REF_I, DC_E_I, DC_LCSN_I1, DC_LCSN_I2, DC_LCSN_I3, DC_LCSN_I4, DC_CCSN_I, DC_WE_N_I, DC_ADD_I1, DC_ADD_I2, DC_ADD_I3, DC_ADD_I4, DC_WDATAS_I, DC_WDATA_I1, DC_WDATA_I2, DC_WDATA_I3, DC_WDATA_I4, DC_WDATA_I5, DC_WDATA_I6
, DC_WDATA_I7, DC_WDATA_I8, DC_WDATA_I9, DC_WDATA_I10, DC_WDATA_I11, DC_WDATA_I12, PLL_RN_I, PWDN_N_I, RST_N_I, DBG_S_I1, DBG_S_I2, DBG_A_I, SE_I, SCAN_I1, SCAN_I2, SCAN_I3, SCAN_I4, SCAN_I5, SCAN_I6, SCAN_I7, SCAN_I8
, CLK_O, CLK_RX_O, LOCK_O, LOCKA_O, FB_LOCK_O, CAL_OUT_O, DBG_R_O, LL_O1, LL_O2, LL_O3, LL_O4, LL_O5, LL_O6, LL_O7, LL_O8, LL_O9, LL_O10, LL_O11, LL_O12, LL_O13, LL_O14
, LL_O15, LL_O16, LL_O17, LL_O18, LL_O19, LL_O20, SCAN_O1, SCAN_O2, SCAN_O3, SCAN_O4, SCAN_O5, SCAN_O6, SCAN_O7, SCAN_O8, LINK_TX1, LINK_TX2, LINK_TX3, LINK_RX0, LINK_RX1, LINK_RX2, LINK_RX3
, LINK_TX0);
    output CAL_OUT_O;
    output CLK_O;
    input CLK_REF_I;
    input CLK_RX_I;
    output CLK_RX_O;
    input CLK_TX_I;
    input DBG_A_I;
    output DBG_R_O;
    input DBG_S_I1;
    input DBG_S_I2;
    input DC_ADD_I1;
    input DC_ADD_I2;
    input DC_ADD_I3;
    input DC_ADD_I4;
    input DC_CCSN_I;
    input DC_E_I;
    input DC_LCSN_I1;
    input DC_LCSN_I2;
    input DC_LCSN_I3;
    input DC_LCSN_I4;
    input DC_WDATAS_I;
    input DC_WDATA_I1;
    input DC_WDATA_I10;
    input DC_WDATA_I11;
    input DC_WDATA_I12;
    input DC_WDATA_I2;
    input DC_WDATA_I3;
    input DC_WDATA_I4;
    input DC_WDATA_I5;
    input DC_WDATA_I6;
    input DC_WDATA_I7;
    input DC_WDATA_I8;
    input DC_WDATA_I9;
    input DC_WE_N_I;
    output FB_LOCK_O;
    inout [9:0] LINK_RX0;
    inout [9:0] LINK_RX1;
    inout [9:0] LINK_RX2;
    inout [9:0] LINK_RX3;
    inout [19:0] LINK_TX0;
    inout [19:0] LINK_TX1;
    inout [19:0] LINK_TX2;
    inout [19:0] LINK_TX3;
    output LL_O1;
    output LL_O10;
    output LL_O11;
    output LL_O12;
    output LL_O13;
    output LL_O14;
    output LL_O15;
    output LL_O16;
    output LL_O17;
    output LL_O18;
    output LL_O19;
    output LL_O2;
    output LL_O20;
    output LL_O3;
    output LL_O4;
    output LL_O5;
    output LL_O6;
    output LL_O7;
    output LL_O8;
    output LL_O9;
    output LOCKA_O;
    output LOCK_O;
    input PLL_RN_I;
    input PWDN_N_I;
    input RST_N_I;
    input SCAN_I1;
    input SCAN_I2;
    input SCAN_I3;
    input SCAN_I4;
    input SCAN_I5;
    input SCAN_I6;
    input SCAN_I7;
    input SCAN_I8;
    output SCAN_O1;
    output SCAN_O2;
    output SCAN_O3;
    output SCAN_O4;
    output SCAN_O5;
    output SCAN_O6;
    output SCAN_O7;
    output SCAN_O8;
    input SE_I;
    parameter dyn_all_rx_pma_m_eye = 1'b0;
    parameter dyn_all_rx_pma_m_eye_coarse_ena = 1'b0;
    parameter dyn_all_rx_pma_m_eye_dn = 1'b0;
    parameter dyn_all_rx_pma_m_eye_fine_ena = 1'b0;
    parameter dyn_all_rx_pma_m_eye_step = 4'b0000;
    parameter dyn_all_rx_pma_m_eye_up = 1'b0;
    parameter dyn_all_rx_pma_threshold_1 = 5'b00000;
    parameter dyn_all_rx_pma_threshold_2 = 5'b00000;
    parameter dyn_all_rx_pma_trim_locked = 3'b000;
    parameter dyn_all_rx_pma_trim_mode = 2'b00;
    parameter dyn_all_rx_pma_trim_unlocked = 3'b000;
    parameter dyn_rx0_pma_ctle_cap_p = 4'b0000;
    parameter dyn_rx0_pma_ctle_res_p = 4'b0000;
    parameter dyn_rx0_pma_dfe_idac_tap1_n = 6'b000000;
    parameter dyn_rx0_pma_dfe_idac_tap2_n = 6'b000000;
    parameter dyn_rx0_pma_dfe_idac_tap3_n = 6'b000000;
    parameter dyn_rx0_pma_dfe_idac_tap4_n = 6'b000000;
    parameter dyn_rx0_pma_termination_cmd = 6'b000000;
    parameter dyn_rx1_pma_ctle_cap_p = 4'b0000;
    parameter dyn_rx1_pma_ctle_res_p = 4'b0000;
    parameter dyn_rx1_pma_dfe_idac_tap1_n = 6'b000000;
    parameter dyn_rx1_pma_dfe_idac_tap2_n = 6'b000000;
    parameter dyn_rx1_pma_dfe_idac_tap3_n = 6'b000000;
    parameter dyn_rx1_pma_dfe_idac_tap4_n = 6'b000000;
    parameter dyn_rx1_pma_termination_cmd = 6'b000000;
    parameter dyn_rx2_pma_ctle_cap_p = 4'b0000;
    parameter dyn_rx2_pma_ctle_res_p = 4'b0000;
    parameter dyn_rx2_pma_dfe_idac_tap1_n = 6'b000000;
    parameter dyn_rx2_pma_dfe_idac_tap2_n = 6'b000000;
    parameter dyn_rx2_pma_dfe_idac_tap3_n = 6'b000000;
    parameter dyn_rx2_pma_dfe_idac_tap4_n = 6'b000000;
    parameter dyn_rx2_pma_termination_cmd = 6'b000000;
    parameter dyn_rx3_pma_ctle_cap_p = 4'b0000;
    parameter dyn_rx3_pma_ctle_res_p = 4'b0000;
    parameter dyn_rx3_pma_dfe_idac_tap1_n = 6'b000000;
    parameter dyn_rx3_pma_dfe_idac_tap2_n = 6'b000000;
    parameter dyn_rx3_pma_dfe_idac_tap3_n = 6'b000000;
    parameter dyn_rx3_pma_dfe_idac_tap4_n = 6'b000000;
    parameter dyn_rx3_pma_termination_cmd = 6'b000000;
    parameter dyn_tx0_pma_main_en = 6'b000000;
    parameter dyn_tx0_pma_main_sign = 1'b0;
    parameter dyn_tx0_pma_margin_input = 9'b000000000;
    parameter dyn_tx0_pma_margin_sel = 9'b000000000;
    parameter dyn_tx0_pma_post_en = 5'b00000;
    parameter dyn_tx0_pma_post_sel = 8'b00000000;
    parameter dyn_tx0_pma_post_sign = 1'b0;
    parameter dyn_tx0_pma_pre_en = 1'b0;
    parameter dyn_tx0_pma_pre_sel = 4'b0000;
    parameter dyn_tx0_pma_pre_sign = 1'b0;
    parameter dyn_tx1_pma_main_en = 6'b000000;
    parameter dyn_tx1_pma_main_sign = 1'b0;
    parameter dyn_tx1_pma_margin_input = 9'b000000000;
    parameter dyn_tx1_pma_margin_sel = 9'b000000000;
    parameter dyn_tx1_pma_post_en = 5'b00000;
    parameter dyn_tx1_pma_post_sel = 8'b00000000;
    parameter dyn_tx1_pma_post_sign = 1'b0;
    parameter dyn_tx1_pma_pre_en = 1'b0;
    parameter dyn_tx1_pma_pre_sel = 4'b0000;
    parameter dyn_tx1_pma_pre_sign = 1'b0;
    parameter dyn_tx2_pma_main_en = 6'b000000;
    parameter dyn_tx2_pma_main_sign = 1'b0;
    parameter dyn_tx2_pma_margin_input = 9'b000000000;
    parameter dyn_tx2_pma_margin_sel = 9'b000000000;
    parameter dyn_tx2_pma_post_en = 5'b00000;
    parameter dyn_tx2_pma_post_sel = 8'b00000000;
    parameter dyn_tx2_pma_post_sign = 1'b0;
    parameter dyn_tx2_pma_pre_en = 1'b0;
    parameter dyn_tx2_pma_pre_sel = 4'b0000;
    parameter dyn_tx2_pma_pre_sign = 1'b0;
    parameter dyn_tx3_pma_main_en = 6'b000000;
    parameter dyn_tx3_pma_main_sign = 1'b0;
    parameter dyn_tx3_pma_margin_input = 9'b000000000;
    parameter dyn_tx3_pma_margin_sel = 9'b000000000;
    parameter dyn_tx3_pma_post_en = 5'b00000;
    parameter dyn_tx3_pma_post_sel = 8'b00000000;
    parameter dyn_tx3_pma_post_sign = 1'b0;
    parameter dyn_tx3_pma_pre_en = 1'b0;
    parameter dyn_tx3_pma_pre_sel = 4'b0000;
    parameter dyn_tx3_pma_pre_sign = 1'b0;
    parameter location = "";
    parameter main_clk_to_fabric_div_en = 1'b0;
    parameter main_clk_to_fabric_div_mode = 1'b0;
    parameter main_clk_to_fabric_sel = 1'b0;
    parameter main_rclk_to_fabric_sel = 2'b00;
    parameter main_use_only_usr_clock = 1'b0;
    parameter pcs_ovs_en = 1'b0;
    parameter pcs_ovs_mode = 1'b0;
    parameter pcs_pll_lock_ppm = 3'b000;
    parameter pcs_word_len = 2'b00;
    parameter pll_pma_ckref_ext = 1'b0;
    parameter pll_pma_cpump = 4'b0000;
    parameter pll_pma_divl = 2'b00;
    parameter pll_pma_divm = 1'b0;
    parameter pll_pma_divn = 2'b00;
    parameter pll_pma_gbx_en = 1'b0;
    parameter pll_pma_int_data_len = 1'b0;
    parameter pll_pma_lvds_en = 1'b0;
    parameter pll_pma_lvds_mux = 1'b0;
    parameter pll_pma_mux_ckref = 1'b0;
    parameter rx_usrclk_use_pcs_clk_2 = 1'b0;
    parameter test_mode = 2'b00;
    parameter tx_usrclk_use_pcs_clk_2 = 1'b0;
endmodule

(* blackbox *)
module NX_FIFO_U(RCK, WCK, WE, WEA, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, I17
, I18, I19, I20, I21, I22, I23, I24, I25, I26, I27, I28, I29, I30, I31, I32, I33, I34, I35, I36, O1, O2
, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20, O21, O22, O23
, O24, O25, O26, O27, O28, O29, O30, O31, O32, O33, O34, O35, O36, WRSTI, WAI1, WAI2, WAI3, WAI4, WAI5, WAI6, WAI7
, WRSTO, WAO1, WAO2, WAO3, WAO4, WAO5, WAO6, WAO7, WEQ1, WEQ2, RRSTI, RAI1, RAI2, RAI3, RAI4, RAI5, RAI6, RAI7, RRSTO, RAO1, RAO2
, RAO3, RAO4, RAO5, RAO6, RAO7, REQ1, REQ2);
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I17;
    input I18;
    input I19;
    input I2;
    input I20;
    input I21;
    input I22;
    input I23;
    input I24;
    input I25;
    input I26;
    input I27;
    input I28;
    input I29;
    input I3;
    input I30;
    input I31;
    input I32;
    input I33;
    input I34;
    input I35;
    input I36;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O17;
    output O18;
    output O19;
    output O2;
    output O20;
    output O21;
    output O22;
    output O23;
    output O24;
    output O25;
    output O26;
    output O27;
    output O28;
    output O29;
    output O3;
    output O30;
    output O31;
    output O32;
    output O33;
    output O34;
    output O35;
    output O36;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RAI1;
    input RAI2;
    input RAI3;
    input RAI4;
    input RAI5;
    input RAI6;
    input RAI7;
    output RAO1;
    output RAO2;
    output RAO3;
    output RAO4;
    output RAO5;
    output RAO6;
    output RAO7;
    input RCK;
    output REQ1;
    output REQ2;
    input RRSTI;
    output RRSTO;
    input WAI1;
    input WAI2;
    input WAI3;
    input WAI4;
    input WAI5;
    input WAI6;
    input WAI7;
    output WAO1;
    output WAO2;
    output WAO3;
    output WAO4;
    output WAO5;
    output WAO6;
    output WAO7;
    input WCK;
    input WE;
    input WEA;
    output WEQ1;
    output WEQ2;
    input WRSTI;
    output WRSTO;
    parameter mode = 0;
    parameter rck_edge = 1'b0;
    parameter read_addr_inv = 7'b0000000;
    parameter use_read_arst = 1'b0;
    parameter use_write_arst = 1'b0;
    parameter wck_edge = 1'b0;
endmodule


(* blackbox *)
module NX_IOM_CONTROL_U(ALCK1, ALCK2, ALCK3, LDSCK1, LDSCK2, LDSCK3, SWRX1CK, SWRX2CK, FCK1, FCK2, FDCK, CCK, DQ1CI1, DQ1CI2, DQ1CI3, DQ1CI4, DQ1CI5, DQ1CI6, DQ1CI7, DQ1CI8, DQ2CI1
, DQ2CI2, DQ2CI3, DQ2CI4, DQ2CI5, DQ2CI6, DQ2CI7, DQ2CI8, DQ3CI1, DQ3CI2, DQ3CI3, DQ3CI4, DQ3CI5, DQ3CI6, DQ3CI7, DQ3CI8, DQS1CI1, DQS1CI2, DQS1CI3, DQS1CI4, DQS1CI5, DQS1CI6
, DQS1CI7, DQS1CI8, DQS2CI1, DQS2CI2, DQS2CI3, DQS2CI4, DQS2CI5, DQS2CI6, DQS2CI7, DQS2CI8, DQS3CI1, DQS3CI2, DQS3CI3, DQS3CI4, DQS3CI5, DQS3CI6, DQS3CI7, DQS3CI8, LD1RN, LD2RN, LD3RN
, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DCRN, LE, SE, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3, DRA4, DRO1CSN
, DRO2CSN, DRO3CSN, DRI1CSN, DRI2CSN, DRI3CSN, DRDPA1CSN, DRDPA2CSN, DRDPA3CSN, DRCCSN, DRWDS, DRWEN, DRE, CA1P1, CA1P2, CA1P3, CA1P4, CA2P1, CA2P2, CA2P3, CA2P4, CA1N1
, CA1N2, CA1N3, CA1N4, CA2N1, CA2N2, CA2N3, CA2N4, CA1T1, CA1T2, CA1T3, CA1T4, CA2T1, CA2T2, CA2T3, CA2T4, CA1D1, CA1D2, CA1D3, CA1D4, CA1D5, CA1D6
, CA2D1, CA2D2, CA2D3, CA2D4, CA2D5, CA2D6, CKO1, CKO2, FLD, FLG, AL1D, AL2D, AL3D, AL1T, AL2T, AL3T, DCL, DRO1, DRO2, DRO3, DRO4
, DRO5, DRO6, LINK2, LINK3, LINK4, LINK5, LINK6, LINK7, LINK8, LINK9, LINK10, LINK11, LINK12, LINK13, LINK14, LINK15, LINK16, LINK17, LINK18, LINK19, LINK20
, LINK21, LINK22, LINK23, LINK24, LINK25, LINK26, LINK27, LINK28, LINK29, LINK30, LINK31, LINK32, LINK33, LINK34, LINK1);
    output AL1D;
    output AL1T;
    output AL2D;
    output AL2T;
    output AL3D;
    output AL3T;
    input ALCK1;
    input ALCK2;
    input ALCK3;
    input CA1D1;
    input CA1D2;
    input CA1D3;
    input CA1D4;
    input CA1D5;
    input CA1D6;
    input CA1N1;
    input CA1N2;
    input CA1N3;
    input CA1N4;
    input CA1P1;
    input CA1P2;
    input CA1P3;
    input CA1P4;
    input CA1T1;
    input CA1T2;
    input CA1T3;
    input CA1T4;
    input CA2D1;
    input CA2D2;
    input CA2D3;
    input CA2D4;
    input CA2D5;
    input CA2D6;
    input CA2N1;
    input CA2N2;
    input CA2N3;
    input CA2N4;
    input CA2P1;
    input CA2P2;
    input CA2P3;
    input CA2P4;
    input CA2T1;
    input CA2T2;
    input CA2T3;
    input CA2T4;
    input CCK;
    output CKO1;
    output CKO2;
    output DCL;
    input DCRN;
    input DQ1CI1;
    input DQ1CI2;
    input DQ1CI3;
    input DQ1CI4;
    input DQ1CI5;
    input DQ1CI6;
    input DQ1CI7;
    input DQ1CI8;
    input DQ2CI1;
    input DQ2CI2;
    input DQ2CI3;
    input DQ2CI4;
    input DQ2CI5;
    input DQ2CI6;
    input DQ2CI7;
    input DQ2CI8;
    input DQ3CI1;
    input DQ3CI2;
    input DQ3CI3;
    input DQ3CI4;
    input DQ3CI5;
    input DQ3CI6;
    input DQ3CI7;
    input DQ3CI8;
    input DQS1CI1;
    input DQS1CI2;
    input DQS1CI3;
    input DQS1CI4;
    input DQS1CI5;
    input DQS1CI6;
    input DQS1CI7;
    input DQS1CI8;
    input DQS2CI1;
    input DQS2CI2;
    input DQS2CI3;
    input DQS2CI4;
    input DQS2CI5;
    input DQS2CI6;
    input DQS2CI7;
    input DQS2CI8;
    input DQS3CI1;
    input DQS3CI2;
    input DQS3CI3;
    input DQS3CI4;
    input DQS3CI5;
    input DQS3CI6;
    input DQS3CI7;
    input DQS3CI8;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRCCSN;
    input DRDPA1CSN;
    input DRDPA2CSN;
    input DRDPA3CSN;
    input DRE;
    input DRI1;
    input DRI1CSN;
    input DRI2;
    input DRI2CSN;
    input DRI3;
    input DRI3CSN;
    input DRI4;
    input DRI5;
    input DRI6;
    output DRO1;
    input DRO1CSN;
    output DRO2;
    input DRO2CSN;
    output DRO3;
    input DRO3CSN;
    output DRO4;
    output DRO5;
    output DRO6;
    input DRWDS;
    input DRWEN;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    input FCK1;
    input FCK2;
    input FDCK;
    output FLD;
    output FLG;
    input FZ;
    input LD1RN;
    input LD2RN;
    input LD3RN;
    input LDSCK1;
    input LDSCK2;
    input LDSCK3;
    input LE;
    inout [41:0] LINK1;
    inout [41:0] LINK10;
    inout [41:0] LINK11;
    inout [41:0] LINK12;
    inout [41:0] LINK13;
    inout [41:0] LINK14;
    inout [41:0] LINK15;
    inout [41:0] LINK16;
    inout [41:0] LINK17;
    inout [41:0] LINK18;
    inout [41:0] LINK19;
    inout [41:0] LINK2;
    inout [41:0] LINK20;
    inout [41:0] LINK21;
    inout [41:0] LINK22;
    inout [41:0] LINK23;
    inout [41:0] LINK24;
    inout [41:0] LINK25;
    inout [41:0] LINK26;
    inout [41:0] LINK27;
    inout [41:0] LINK28;
    inout [41:0] LINK29;
    inout [41:0] LINK3;
    inout [41:0] LINK30;
    inout [41:0] LINK31;
    inout [41:0] LINK32;
    inout [41:0] LINK33;
    inout [41:0] LINK34;
    inout [41:0] LINK4;
    inout [41:0] LINK5;
    inout [41:0] LINK6;
    inout [41:0] LINK7;
    inout [41:0] LINK8;
    inout [41:0] LINK9;
    input SE;
    input SWRX1CK;
    input SWRX2CK;
    parameter cal_delay1 = "";
    parameter cal_delay2 = "";
    parameter div1 = 3'b000;
    parameter div2 = 3'b000;
    parameter div3 = 3'b000;
    parameter div_swrx1 = 3'b000;
    parameter div_swrx2 = 3'b000;
    parameter inv_ld_sck1 = 1'b0;
    parameter inv_ld_sck2 = 1'b0;
    parameter inv_ld_sck3 = 1'b0;
    parameter link_ld_12 = 1'b0;
    parameter link_ld_23 = 1'b0;
    parameter location = "";
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter mode_side3 = 0;
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_dc_clk = 2'b00;
    parameter sel_ld_fck1 = 2'b00;
    parameter sel_ld_fck2 = 2'b00;
    parameter sel_ld_fck3 = 2'b00;
    parameter sel_sw_fck1 = 2'b00;
    parameter sel_sw_fck2 = 2'b00;
    parameter use_dc = 1'b0;
endmodule

(* blackbox *)
module NX_IOM_DRIVER_M(EI1, EI2, EI3, EI4, EI5, EL, ER, CI1, CI2, CI3, CI4, CI5, CL, CR, CTI, RI, RL, RR, CO, EO, RO1
, RO2, RO3, RO4, RO5, CTO, LINK);
    input CI1;
    input CI2;
    input CI3;
    input CI4;
    input CI5;
    input CL;
    output CO;
    input CR;
    input CTI;
    output CTO;
    input EI1;
    input EI2;
    input EI3;
    input EI4;
    input EI5;
    input EL;
    output EO;
    input ER;
    inout [41:0] LINK;
    input RI;
    input RL;
    output RO1;
    output RO2;
    output RO3;
    output RO4;
    output RO5;
    input RR;
    parameter chained = 1'b0;
    parameter cpath_edge = 1'b0;
    parameter cpath_init = 1'b0;
    parameter cpath_inv = 1'b0;
    parameter cpath_load = 1'b0;
    parameter cpath_mode = 4'b0000;
    parameter cpath_sync = 1'b0;
    parameter epath_dynamic = 1'b0;
    parameter epath_edge = 1'b0;
    parameter epath_init = 1'b0;
    parameter epath_load = 1'b0;
    parameter epath_mode = 4'b0000;
    parameter epath_sync = 1'b0;
    parameter location = "";
    parameter rpath_dynamic = 1'b0;
    parameter rpath_edge = 1'b0;
    parameter rpath_init = 1'b0;
    parameter rpath_load = 1'b0;
    parameter rpath_mode = 4'b0000;
    parameter rpath_sync = 1'b0;
    parameter symbol = "";
    parameter tpath_mode = 2'b00;
    parameter variant = "";
endmodule

(* blackbox *)
module NX_IOM_DRIVER_U(EI1, EI2, EI3, EI4, EI5, EI6, EI7, EI8, EL, ER, CI1, CL, CR, RI, RL, RR, CO, CTI, CTO, EO, RO1
, RO2, RO3, RO4, RO5, RO6, RO7, RO8, LINK);
    input CI1;
    input CL;
    output CO;
    input CR;
    input CTI;
    output CTO;
    input EI1;
    input EI2;
    input EI3;
    input EI4;
    input EI5;
    input EI6;
    input EI7;
    input EI8;
    input EL;
    output EO;
    input ER;
    inout [41:0] LINK;
    input RI;
    input RL;
    output RO1;
    output RO2;
    output RO3;
    output RO4;
    output RO5;
    output RO6;
    output RO7;
    output RO8;
    input RR;
    parameter chained = 1'b0;
    parameter cpath_edge = 1'b0;
    parameter cpath_init = 1'b0;
    parameter cpath_inv = 1'b0;
    parameter cpath_load = 1'b0;
    parameter cpath_mode = 4'b0000;
    parameter cpath_sync = 1'b0;
    parameter cpath_type = 1'b0;
    parameter epath_dynamic = 1'b0;
    parameter epath_edge = 1'b0;
    parameter epath_init = 1'b0;
    parameter epath_load = 1'b0;
    parameter epath_mode = 4'b0000;
    parameter epath_sync = 1'b0;
    parameter epath_type = 1'b0;
    parameter location = "";
    parameter rpath_dynamic = 1'b0;
    parameter rpath_edge = 1'b0;
    parameter rpath_init = 1'b0;
    parameter rpath_load = 1'b0;
    parameter rpath_mode = 4'b0000;
    parameter rpath_sync = 1'b0;
    parameter rpath_type = 1'b0;
    parameter symbol = "";
    parameter tpath_mode = 1'b0;
endmodule

(* blackbox *)
module NX_IOM_SERDES_U(FCK, SCK, LDRN, DRWDS, DRWEN, DRE, FZ, ALD, ALT, FLD, FLG, LINK, DRA, DRI, DRO, DID, DRIN, DRDN, FA, DRON);
    output ALD;
    output ALT;
    output [5:0] DID;
    input [3:0] DRA;
    input [2:0] DRDN;
    input DRE;
    input [5:0] DRI;
    input [2:0] DRIN;
    output [5:0] DRO;
    input [2:0] DRON;
    input DRWDS;
    input DRWEN;
    input [5:0] FA;
    input FCK;
    output FLD;
    output FLG;
    input FZ;
    input LDRN;
    inout [41:0] LINK;
    input SCK;
    parameter data_size = 5;
    parameter location = "";
endmodule
`,"cells_map.v":`\`default_nettype none

module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      localparam [15:0] INIT = {{2{LUT[1:0]}}, {2{LUT[1:0]}}, {2{LUT[1:0]}}, {2{LUT[1:0]}},
                                {2{LUT[1:0]}}, {2{LUT[1:0]}}, {2{LUT[1:0]}}, {2{LUT[1:0]}}};
      NX_LUT #(.lut_table(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I1(A[0]), .I2(1'b0), .I3(1'b0), .I4(1'b0));
    end else
    if (WIDTH == 2) begin
      localparam [15:0] INIT = {{4{LUT[3:0]}}, {4{LUT[3:0]}}, {4{LUT[3:0]}}, {4{LUT[3:0]}}};
      NX_LUT #(.lut_table(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I1(A[0]), .I2(A[1]), .I3(1'b0), .I4(1'b0), );
    end else
    if (WIDTH == 3) begin
      localparam [15:0] INIT = {{8{LUT[7:0]}}, {8{LUT[7:0]}}};
      NX_LUT #(.lut_table(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I1(A[0]), .I2(A[1]), .I3(A[2]), .I4(1'b0));
    end else
    if (WIDTH == 4) begin
      NX_LUT #(.lut_table(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I1(A[0]), .I2(A[1]), .I3(A[2]), .I4(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule

(* techmap_celltype = "$_DFF_[NP]P[01]_" *)
module \\$_DFF_xxxx_ (input D, C, R, output Q);
	parameter _TECHMAP_CELLTYPE_ = "";
  localparam dff_edge = _TECHMAP_CELLTYPE_[3*8 +: 8] == "N";
  localparam dff_type = _TECHMAP_CELLTYPE_[1*8 +: 8] == "1";
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(dff_type), .dff_edge(dff_edge), .dff_init(1'b1), .dff_load(1'b0), .dff_sync(1'b0), .dff_type(dff_type)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(1'b1), .R(R), .O(Q));
endmodule

(* techmap_celltype = "$_SDFF_[NP]P[01]_" *)
module \\$_SDFF_xxxx_ (input D, C, R, output Q);
	parameter _TECHMAP_CELLTYPE_ = "";
  localparam dff_edge = _TECHMAP_CELLTYPE_[3*8 +: 8] == "N";
  localparam dff_type = _TECHMAP_CELLTYPE_[1*8 +: 8] == "1";
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(dff_type), .dff_edge(dff_edge), .dff_init(1'b1), .dff_load(1'b0), .dff_sync(1'b1), .dff_type(dff_type)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(1'b1), .R(R), .O(Q));
endmodule

(* techmap_celltype = "$_DFFE_[NP]P[01]P_" *)
module \\$_DFFE_xxxx_ (input D, C, R, E, output Q);
	parameter _TECHMAP_CELLTYPE_ = "";
  localparam dff_edge = _TECHMAP_CELLTYPE_[4*8 +: 8] == "N";
  localparam dff_type = _TECHMAP_CELLTYPE_[2*8 +: 8] == "1";
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(dff_type), .dff_edge(dff_edge), .dff_init(1'b1), .dff_load(1'b1), .dff_sync(1'b0), .dff_type(dff_type)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(E), .R(R), .O(Q));
endmodule

(* techmap_celltype = "$_SDFFE_[NP]P[01]P_" *)
module \\$_SDFFE_xxxx_ (input D, C, R, E, output Q);
	parameter _TECHMAP_CELLTYPE_ = "";
  localparam dff_edge = _TECHMAP_CELLTYPE_[4*8 +: 8] == "N";
  localparam dff_type = _TECHMAP_CELLTYPE_[2*8 +: 8] == "1";
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(dff_type), .dff_edge(dff_edge), .dff_init(1'b1), .dff_load(1'b1), .dff_sync(1'b1), .dff_type(dff_type)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(E), .R(R), .O(Q));
endmodule

module \\$_DFF_P_ (input D, C, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'b0;
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(_TECHMAP_WIREINIT_Q_), .dff_edge(1'b0), .dff_init(1'b0), .dff_load(1'b0), .dff_sync(1'b0), .dff_type(1'b0)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(1'b1), .R(1'b0), .O(Q));
endmodule

module \\$_DFF_N_ (input D, C, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'b0;
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(_TECHMAP_WIREINIT_Q_), .dff_edge(1'b1), .dff_init(1'b0), .dff_load(1'b0), .dff_sync(1'b0), .dff_type(1'b0)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(1'b1), .R(1'b0), .O(Q));
endmodule

module \\$_DFFE_PP_ (input D, C, E, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'b0;
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(_TECHMAP_WIREINIT_Q_), .dff_edge(1'b0), .dff_init(1'b0), .dff_load(1'b1), .dff_sync(1'b0), .dff_type(1'b0)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(E), .R(1'b0), .O(Q));
endmodule

module \\$_DFFE_NP_ (input D, C, E, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'b0;
  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
  NX_DFF #(.dff_ctxt(_TECHMAP_WIREINIT_Q_), .dff_edge(1'b1), .dff_init(1'b0), .dff_load(1'b1), .dff_sync(1'b0), .dff_type(1'b0)) _TECHMAP_REPLACE_ (.I(D), .CK(C), .L(E), .R(1'b0), .O(Q));
endmodule
`,"cells_sim.v":`(* abc9_lut=1 *)
module NX_LUT(input I1, I2, I3, I4, output O);

parameter lut_table = 16'h0000;

wire [7:0] s1 = I4 ? lut_table[15:8] : lut_table[7:0];
wire [3:0] s2 = I3 ? s1[7:4] : s1[3:0];
wire [1:0] s3 = I2 ? s2[3:2] : s2[1:0];
assign O = I1 ? s3[1] : s3[0];

endmodule

(* abc9_box, lib_whitebox *)
module NX_DFF(input I, CK, L, R, output reg O);

parameter dff_ctxt = 1'bx;
parameter dff_edge = 1'b0;
parameter dff_init = 1'b0;
parameter dff_load = 1'b0;
parameter dff_sync = 1'b0;
parameter dff_type = 1'b0;

initial begin
	O = dff_ctxt;
end

wire clock = CK ^ dff_edge;
wire load = dff_load ? L : 1'b1;
wire async_reset = !dff_sync && dff_init && R;
wire sync_reset = dff_sync && dff_init && R;

always @(posedge clock, posedge async_reset)
	if (async_reset) O <= dff_type;
	else if (sync_reset) O <= dff_type;
	else if (load) O <= I;

endmodule

(* abc9_box, lib_whitebox *)
module NX_DFR(input I, CK, L, R, output O);

parameter data_inv = 1'b0;
parameter dff_edge = 1'b0;
parameter dff_init = 1'b0;
parameter dff_load = 1'b0;
parameter dff_sync = 1'b0;
parameter dff_type = 1'b0;
parameter iobname = "";
parameter location = "";
parameter mode = 0;
parameter path = 0;
parameter ring = 0;

wire clock = CK ^ dff_edge;
wire load = dff_load ? L : 1'b1;
wire async_reset = !dff_sync && dff_init && R;
wire sync_reset = dff_sync && dff_init && R;
reg O_reg;

always @(posedge clock, posedge async_reset)
	if (async_reset) O_reg <= dff_type;
	else if (sync_reset) O_reg <= dff_type;
	else if (load) O_reg <= I;

assign O = data_inv ? O_reg : ~O_reg;

endmodule


(* abc9_box, lib_whitebox *)
module NX_CY(input A1, A2, A3, A4, B1, B2, B3, B4, (* abc9_carry *) input CI, output S1, S2, S3, S4, (* abc9_carry *) output CO);
parameter add_carry = 0;

wire CI_1;
wire CO1, CO2, CO3;

assign  CI_1 = (add_carry==2) ? CI : ((add_carry==1) ? 1'b1 : 1'b0);

assign { CO1, S1 } = A1 + B1 + CI_1;
assign { CO2, S2 } = A2 + B2 + CO1;
assign { CO3, S3 } = A3 + B3 + CO2;
assign { CO,  S4 } = A4 + B4 + CO3;

endmodule

module NX_IOB(I, C, T, O, IO);
    input C;
    input I;
	(* iopad_external_pin *)
    inout IO;
    output O;
    input T;
    parameter differential = "";
    parameter drive = "";
    parameter dynDrive = "";
    parameter dynInput = "";
    parameter dynTerm = "";
    parameter extra = 3;
    parameter inputDelayLine = "";
    parameter inputDelayOn = "";
    parameter inputSignalSlope = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter outputCapacity = "";
    parameter outputDelayLine = "";
    parameter outputDelayOn = "";
    parameter slewRate = "";
    parameter standard = "";
    parameter termination = "";
    parameter terminationReference = "";
    parameter turbo = "";
    parameter weakTermination = "";

	assign O = IO;
	assign IO = C ? I : 1'bz;
endmodule

module NX_IOB_I(C, T, IO, O);
    input C;
	(* iopad_external_pin *)
    input IO;
    output O;
    input T;
    parameter differential = "";
    parameter drive = "";
    parameter dynDrive = "";
    parameter dynInput = "";
    parameter dynTerm = "";
    parameter extra = 1;
    parameter inputDelayLine = "";
    parameter inputDelayOn = "";
    parameter inputSignalSlope = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter outputCapacity = "";
    parameter outputDelayLine = "";
    parameter outputDelayOn = "";
    parameter slewRate = "";
    parameter standard = "";
    parameter termination = "";
    parameter terminationReference = "";
    parameter turbo = "";
    parameter weakTermination = "";

	assign O = IO;
endmodule

module NX_IOB_O(I, C, T, IO);
    input C;
    input I;
	(* iopad_external_pin *)
    output IO;
    input T;
    parameter differential = "";
    parameter drive = "";
    parameter dynDrive = "";
    parameter dynInput = "";
    parameter dynTerm = "";
    parameter extra = 2;
    parameter inputDelayLine = "";
    parameter inputDelayOn = "";
    parameter inputSignalSlope = "";
    parameter location = "";
    parameter locked = 1'b0;
    parameter outputCapacity = "";
    parameter outputDelayLine = "";
    parameter outputDelayOn = "";
    parameter slewRate = "";
    parameter standard = "";
    parameter termination = "";
    parameter terminationReference = "";
    parameter turbo = "";
    parameter weakTermination = "";

	assign IO = C ? I : 1'bz;
endmodule

(* abc9_box, lib_whitebox *)
module NX_CY_1BIT(CI, A, B, S, CO);
    (* abc9_carry *)
    input CI;
    input A;
    input B;
    output S;
    (* abc9_carry *)
    output CO;
    parameter first = 1'b0;

    assign {CO, S} = A + B + CI;
endmodule

module NX_BD(I, O);
    input I;
    output O;
    parameter mode = "global_lowskew";

    assign O = I;
endmodule

module NX_BFF(I, O);
    input I;
    output O;

    assign O = I;
endmodule

module NX_BFR(I, O);
    input I;
    output O;
    parameter data_inv = 1'b0;
    parameter iobname = "";
    parameter location = "";
    parameter mode = 0;
    parameter path = 0;
    parameter ring = 0;

    assign O = data_inv ? ~I : I;
endmodule

(* abc9_box, lib_whitebox *)
module NX_RAM(ACK, ACKC, ACKD, ACKR, BCK, BCKC, BCKD, BCKR, AI1, AI2, AI3, AI4, AI5, AI6, AI7, AI8, AI9, AI10, AI11, AI12, AI13
, AI14, AI15, AI16, AI17, AI18, AI19, AI20, AI21, AI22, AI23, AI24, BI1, BI2, BI3, BI4, BI5, BI6, BI7, BI8, BI9, BI10
, BI11, BI12, BI13, BI14, BI15, BI16, BI17, BI18, BI19, BI20, BI21, BI22, BI23, BI24, ACOR, AERR, BCOR, BERR, AO1, AO2, AO3
, AO4, AO5, AO6, AO7, AO8, AO9, AO10, AO11, AO12, AO13, AO14, AO15, AO16, AO17, AO18, AO19, AO20, AO21, AO22, AO23, AO24
, BO1, BO2, BO3, BO4, BO5, BO6, BO7, BO8, BO9, BO10, BO11, BO12, BO13, BO14, BO15, BO16, BO17, BO18, BO19, BO20, BO21
, BO22, BO23, BO24, AA1, AA2, AA3, AA4, AA5, AA6, AA7, AA8, AA9, AA10, AA11, AA12, AA13, AA14, AA15, AA16, ACS, AWE
, AR, BA1, BA2, BA3, BA4, BA5, BA6, BA7, BA8, BA9, BA10, BA11, BA12, BA13, BA14, BA15, BA16, BCS, BWE, BR);
    input AA1;
    input AA10;
    input AA11;
    input AA12;
    input AA13;
    input AA14;
    input AA15;
    input AA16;
    input AA2;
    input AA3;
    input AA4;
    input AA5;
    input AA6;
    input AA7;
    input AA8;
    input AA9;
    input ACK;
    input ACKC;
    input ACKD;
    input ACKR;
    output ACOR;
    input ACS;
    output AERR;
    input AI1;
    input AI10;
    input AI11;
    input AI12;
    input AI13;
    input AI14;
    input AI15;
    input AI16;
    input AI17;
    input AI18;
    input AI19;
    input AI2;
    input AI20;
    input AI21;
    input AI22;
    input AI23;
    input AI24;
    input AI3;
    input AI4;
    input AI5;
    input AI6;
    input AI7;
    input AI8;
    input AI9;
    output reg AO1;
    output reg AO10;
    output reg AO11;
    output reg AO12;
    output reg AO13;
    output reg AO14;
    output reg AO15;
    output reg AO16;
    output reg AO17;
    output reg AO18;
    output reg AO19;
    output reg AO2;
    output reg AO20;
    output reg AO21;
    output reg AO22;
    output reg AO23;
    output reg AO24;
    output reg AO3;
    output reg AO4;
    output reg AO5;
    output reg AO6;
    output reg AO7;
    output reg AO8;
    output reg AO9;
    input AR;
    input AWE;
    input BA1;
    input BA10;
    input BA11;
    input BA12;
    input BA13;
    input BA14;
    input BA15;
    input BA16;
    input BA2;
    input BA3;
    input BA4;
    input BA5;
    input BA6;
    input BA7;
    input BA8;
    input BA9;
    input BCK;
    input BCKC;
    input BCKD;
    input BCKR;
    output BCOR;
    input BCS;
    output BERR;
    input BI1;
    input BI10;
    input BI11;
    input BI12;
    input BI13;
    input BI14;
    input BI15;
    input BI16;
    input BI17;
    input BI18;
    input BI19;
    input BI2;
    input BI20;
    input BI21;
    input BI22;
    input BI23;
    input BI24;
    input BI3;
    input BI4;
    input BI5;
    input BI6;
    input BI7;
    input BI8;
    input BI9;
    output reg BO1;
    output reg BO10;
    output reg BO11;
    output reg BO12;
    output reg BO13;
    output reg BO14;
    output reg BO15;
    output reg BO16;
    output reg BO17;
    output reg BO18;
    output reg BO19;
    output reg BO2;
    output reg BO20;
    output reg BO21;
    output reg BO22;
    output reg BO23;
    output reg BO24;
    output reg BO3;
    output reg BO4;
    output reg BO5;
    output reg BO6;
    output reg BO7;
    output reg BO8;
    output reg BO9;
    input BR;
    input BWE;
    parameter mcka_edge = 1'b0;
    parameter mckb_edge = 1'b0;
    parameter mem_ctxt = "";
    parameter pcka_edge = 1'b0;
    parameter pckb_edge = 1'b0;
    parameter pipe_ia = 1'b0;
    parameter pipe_ib = 1'b0;
    parameter pipe_oa = 1'b0;
    parameter pipe_ob = 1'b0;
    parameter raw_config0 = 4'b0000;
    parameter raw_config1 = 16'b0000000000000000;
    //parameter raw_l_enable = 1'b0;
    //parameter raw_l_extend = 4'b0000;
    //parameter raw_u_enable = 1'b0;
    //parameter raw_u_extend = 8'b00000000;
    parameter std_mode = "";

    reg [24-1:0] mem [2048-1:0]; // 48 Kbit of memory

    /*integer i;
    initial begin
        for (i = 0; i < 2048; i = i + 1)
            mem[i] = 24'b0;
    end*/

    wire [15:0] AA = { AA16, AA15, AA14, AA13, AA12, AA11, AA10, AA9, AA8, AA7, AA6, AA5, AA4, AA3, AA2, AA1 };
    wire [23:0] AI = { AI24, AI23, AI22, AI21, AI20, AI19, AI18, AI17, AI16, AI15, AI14, AI13, AI12, AI11, AI10, AI9, AI8, AI7, AI6, AI5, AI4, AI3, AI2, AI1 };
    wire [23:0] AO = { AO24, AO23, AO22, AO21, AO20, AO19, AO18, AO17, AO16, AO15, AO14, AO13, AO12, AO11, AO10, AO9, AO8, AO7, AO6, AO5, AO4, AO3, AO2, AO1 };
    wire [15:0] BA = { BA16, BA15, BA14, BA13, BA12, BA11, BA10, BA9, BA8, BA7, BA6, BA5, BA4, BA3, BA2, BA1 };
    wire [23:0] BI = { BI24, BI23, BI22, BI21, BI20, BI19, BI18, BI17, BI16, BI15, BI14, BI13, BI12, BI11, BI10, BI9, BI8, BI7, BI6, BI5, BI4, BI3, BI2, BI1 };
    wire [23:0] BO = { BO24, BO23, BO22, BO21, BO20, BO19, BO18, BO17, BO16, BO15, BO14, BO13, BO12, BO11, BO10, BO9, BO8, BO7, BO6, BO5, BO4, BO3, BO2, BO1 };

    always @(posedge ACK)
        if (AWE)
            mem[AA[10:0]] <= AI;
        else
            { AO24, AO23, AO22, AO21, AO20, AO19, AO18, AO17, AO16, AO15, AO14, AO13, AO12, AO11, AO10, AO9, AO8, AO7, AO6, AO5, AO4, AO3, AO2, AO1 } <= mem[AA[10:0]];
    assign ACOR = 1'b0;
    assign AERR = 1'b0;

    always @(posedge BCK)
        if (BWE)
            mem[BA[10:0]] <= BI;
        else
            { BO24, BO23, BO22, BO21, BO20, BO19, BO18, BO17, BO16, BO15, BO14, BO13, BO12, BO11, BO10, BO9, BO8, BO7, BO6, BO5, BO4, BO3, BO2, BO1 } <= mem[BA[10:0]];
    assign BCOR = 1'b0;
    assign BERR = 1'b0;
endmodule
`,"cells_sim_l.v":"","cells_sim_m.v":"","cells_sim_u.v":`(* abc9_box, lib_whitebox *)
module NX_GCK_U(SI1, SI2, CMD, SO);
    input CMD;
    input SI1;
    input SI2;
    output SO;
    parameter inv_in = 1'b0;
    parameter inv_out = 1'b0;
    parameter std_mode = "BYPASS";

    wire SI1_int = inv_in ? ~SI1 : SI1;
    wire SI2_int = inv_in ? ~SI2 : SI2;

    wire SO_int;
    generate
        if (std_mode == "BYPASS") begin
            assign SO_int = SI1_int;
        end
        else if (std_mode == "MUX") begin
            assign SO_int = CMD ? SI1_int : SI2_int;
        end
        else if (std_mode == "CKS") begin
            assign SO_int = CMD ? SI1_int : 1'b0;
        end
        else if (std_mode == "CSC") begin
            assign SO_int = CMD;
        end
        else
            $error("Unrecognised std_mode");
    endgenerate
    assign SO = inv_out ? ~SO_int : SO_int;
endmodule

(* abc9_box, lib_whitebox *)
module NX_RFB_U(WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20
, I21, I22, I23, I24, I25, I26, I27, I28, I29, I30, I31, I32, I33, I34, I35, I36, O1, O2, O3, O4, O5
, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20, O21, O22, O23, O24, O25, O26
, O27, O28, O29, O30, O31, O32, O33, O34, O35, O36, RA1, RA2, RA3, RA4, RA5, RA6, RA7, RA8, RA9, RA10, WA1
, WA2, WA3, WA4, WA5, WA6, WE, WEA);
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I17;
    input I18;
    input I19;
    input I2;
    input I20;
    input I21;
    input I22;
    input I23;
    input I24;
    input I25;
    input I26;
    input I27;
    input I28;
    input I29;
    input I3;
    input I30;
    input I31;
    input I32;
    input I33;
    input I34;
    input I35;
    input I36;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O17;
    output O18;
    output O19;
    output O2;
    output O20;
    output O21;
    output O22;
    output O23;
    output O24;
    output O25;
    output O26;
    output O27;
    output O28;
    output O29;
    output O3;
    output O30;
    output O31;
    output O32;
    output O33;
    output O34;
    output O35;
    output O36;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA10;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RA7;
    input RA8;
    input RA9;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter mode = 0;
    parameter wck_edge = 1'b0;

    wire clock = WCK ^ wck_edge;

    localparam MEM_SIZE  = mode == 2 ? 64 : 32;
    localparam MEM_WIDTH = mode == 3 ? 36 : 18;
    localparam ADDR_WIDTH = mode == 2 ? 6 : 5;
    localparam DATA_SIZE = MEM_SIZE * MEM_WIDTH;
    localparam MAX_SIZE = DATA_SIZE + MEM_SIZE + 1;

    reg [MEM_WIDTH-1:0] mem [MEM_SIZE-1:0];

	function [DATA_SIZE-1:0] convert_initval;
		input [8*MAX_SIZE-1:0] hex_initval;
		reg done;
		reg [DATA_SIZE-1:0] temp;
		reg [7:0] char;
		integer i,j;
		begin
			done = 1'b0;
			temp = 0;
            j = 0;
			for (i = 0; i < MAX_SIZE; i = i + 1) begin
                char = hex_initval[8*i +: 8];
                if (char >= "0" && char <= "1") begin
                    temp[j] = char - "0";
                    j = j + 1;
                end
			end
			convert_initval = temp;
		end
	endfunction

    integer i;
    reg [DATA_SIZE-1:0] mem_data;
    initial begin
        mem_data = convert_initval(mem_ctxt);
        for (i = 0; i < MEM_SIZE; i = i + 1)
            mem[i] = mem_data[MEM_WIDTH*(MEM_SIZE-i-1) +: MEM_WIDTH];
    end

    wire [ADDR_WIDTH-1:0] WA = (mode==2) ? { WA6, WA5, WA4, WA3, WA2, WA1 } : { WA5, WA4, WA3, WA2, WA1 };
    wire [36-1:0] O = { O36, O35, O34, O33, O32, O31, O30, O29, O28, 
                        O27, O26, O25, O24, O23, O22, O21, O20, O19, 
                        O18, O17, O16, O15, O14, O13, O12, O11, O10,
                         O9,  O8,  O7,  O6,  O5,  O4,  O3,  O2,  O1 };
    wire [36-1:0] I = { I36, I35, I34, I33, I32, I31, I30, I29, I28,
                        I27, I26, I25, I24, I23, I22, I21, I20, I19,
                        I18, I17, I16, I15, I14, I13, I12, I11, I10,
                         I9,  I8,  I7,  I6,  I5,  I4,  I3,  I2,  I1 };
    generate 
        if (mode==0) begin
            assign O = mem[{ RA5, RA4, RA3, RA2, RA1 }];
        end
        else if (mode==1) begin
            assign O = mem[{ WA5, WA4, WA3, WA2, WA1 }];
        end
        else if (mode==2) begin
            assign O = mem[{ RA6, RA5, RA4, RA3, RA2, RA1 }];
        end
        else if (mode==3) begin
            assign O = mem[{ RA5, RA4, RA3, RA2, RA1 }];
        end
        else if (mode==4) begin
            assign O = { mem[{ RA10, RA9, RA8, RA7, RA6 }], mem[{ RA5, RA4, RA3, RA2, RA1 }] };
        end
        else 
            $error("Unknown NX_RFB_U mode");
    endgenerate

    always @(posedge clock)
        if (WE)
            mem[WA] <= I[MEM_WIDTH-1:0];
endmodule

(* abc9_box, lib_whitebox *)
module NX_WFG_U(R, SI, ZI, SO, ZO);
    input R;
    input SI;
    output SO;
    input ZI;
    output ZO;
    parameter delay = 0;
    parameter delay_on = 1'b0;
    parameter div_phase = 1'b0;
    parameter div_ratio = 0;
    parameter location = "";
    parameter mode = 0;
    parameter pattern = 16'b0000000000000000;
    parameter pattern_end = 0;
    parameter reset_on_cal_lock_n = 1'b0;
    parameter reset_on_pll_lock_n = 1'b0;
    parameter reset_on_pll_locka_n = 1'b0;
    parameter wfg_edge = 1'b0;

    generate
        if (mode==0) begin
            assign SO = SI;
        end
        else if (mode==1) begin
            wire clock = ZI ^ wfg_edge;
            wire reset = R || SI;
            reg [3:0] counter = 0;
            reg [15:0] rom = pattern;

            always @(posedge clock)
            begin
                if (reset)
                    counter <= 4'b0;
                else
                    counter <= counter + 1;
            end
            assign SO = counter == pattern_end;
            assign ZO = rom[counter];
        end
        else if (mode==2) begin
        end
        else
            $error("Unknown NX_WFG_U mode");
    endgenerate
endmodule

module NX_DDFR_U(CK,CKF,R,I,I2,L,O,O2);
    input CK;
    input CKF;
    input R;
    input I;
    input I2;
    input L;
    output O;
    output O2;

    parameter location = "";
    parameter path = 0;
    parameter dff_type = 1'b0;
    parameter dff_sync = 1'b0;
    parameter dff_load = 1'b0;

    wire load = dff_load ? 1'b1 : L; // reversed when compared to DFF
    wire async_reset = !dff_sync && R;
    wire sync_reset = dff_sync && R;

    generate
        if (path==1) begin
            // IDDFR
            always @(posedge CK, posedge async_reset)
                if (async_reset) O <= dff_type;
                else if (sync_reset) O <= dff_type;
                else if (load) O <= I;

            always @(posedge CKF, posedge async_reset)
                if (async_reset) O2 <= dff_type;
                else if (sync_reset) O2 <= dff_type;
                else if (load) O2 <= I;
        end
        else if (path==0 || path==2) begin
            reg q1, q2;
            // ODDFR
            always @(posedge CK, posedge async_reset)
                if (async_reset) q1 <= dff_type;
                else if (sync_reset) q1 <= dff_type;
                else if (load) q1 <= I;

            always @(posedge CKF, posedge async_reset)
                if (async_reset) q2 <= dff_type;
                else if (sync_reset) q2 <= dff_type;
                else if (load) q2 <= I2;

            assign O = CK ? q1 : q2;
        end
        else
            $error("Unknown NX_DDFR_U path");
    endgenerate
endmodule
`,"cells_wrap.v":`module NX_RAM_WRAP(ACK, ACKD, ACKR, BCK, BCKD, BCKR, ACOR, AERR, BCOR, BERR, ACS, AWE, AR, BCS, BWE, BR, BI, AO, BO, AI, AA
, BA);
    input [15:0] AA;
    input ACK;
    input ACKD;
    input ACKR;
    output ACOR;
    input ACS;
    output AERR;
    input [23:0] AI;
    output [23:0] AO;
    input AR;
    input AWE;
    input [15:0] BA;
    input BCK;
    input BCKD;
    input BCKR;
    output BCOR;
    input BCS;
    output BERR;
    input [23:0] BI;
    output [23:0] BO;
    input BR;
    input BWE;
    parameter mcka_edge = 1'b0;
    parameter mckb_edge = 1'b0;
    parameter mem_ctxt = "";
    parameter pcka_edge = 1'b0;
    parameter pckb_edge = 1'b0;
    parameter pipe_ia = 1'b0;
    parameter pipe_ib = 1'b0;
    parameter pipe_oa = 1'b0;
    parameter pipe_ob = 1'b0;
    parameter raw_config0 = 4'b0000;
    parameter raw_config1 = 16'b0000000000000000;
    parameter std_mode = "";

  NX_RAM #(
    .mcka_edge(mcka_edge),
    .mckb_edge(mckb_edge),
    .mem_ctxt(mem_ctxt),
    .pcka_edge(pcka_edge),
    .pckb_edge(pckb_edge),
    .pipe_ia(pipe_ia),
    .pipe_ib(pipe_ib),
    .pipe_oa(pipe_oa),
    .pipe_ob(pipe_ob),
    .raw_config0(raw_config0),
    .raw_config1(raw_config1),
    .std_mode(std_mode)
  ) ram (
    .AA1(AA[0]),
    .AA10(AA[9]),
    .AA11(AA[10]),
    .AA12(AA[11]),
    .AA13(AA[12]),
    .AA14(AA[13]),
    .AA15(AA[14]),
    .AA16(AA[15]),
    .AA2(AA[1]),
    .AA3(AA[2]),
    .AA4(AA[3]),
    .AA5(AA[4]),
    .AA6(AA[5]),
    .AA7(AA[6]),
    .AA8(AA[7]),
    .AA9(AA[8]),
    .ACK(ACK),
    .ACKC(ACK),
    .ACKD(ACKD),
    .ACKR(ACKR),
    .ACOR(ACOR),
    .ACS(ACS),
    .AERR(AERR),
    .AI1(AI[0]),
    .AI10(AI[9]),
    .AI11(AI[10]),
    .AI12(AI[11]),
    .AI13(AI[12]),
    .AI14(AI[13]),
    .AI15(AI[14]),
    .AI16(AI[15]),
    .AI17(AI[16]),
    .AI18(AI[17]),
    .AI19(AI[18]),
    .AI2(AI[1]),
    .AI20(AI[19]),
    .AI21(AI[20]),
    .AI22(AI[21]),
    .AI23(AI[22]),
    .AI24(AI[23]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AI7(AI[6]),
    .AI8(AI[7]),
    .AI9(AI[8]),
    .AO1(AO[0]),
    .AO10(AO[9]),
    .AO11(AO[10]),
    .AO12(AO[11]),
    .AO13(AO[12]),
    .AO14(AO[13]),
    .AO15(AO[14]),
    .AO16(AO[15]),
    .AO17(AO[16]),
    .AO18(AO[17]),
    .AO19(AO[18]),
    .AO2(AO[1]),
    .AO20(AO[19]),
    .AO21(AO[20]),
    .AO22(AO[21]),
    .AO23(AO[22]),
    .AO24(AO[23]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .AO7(AO[6]),
    .AO8(AO[7]),
    .AO9(AO[8]),
    .AR(AR),
    .AWE(AWE),
    .BA1(BA[0]),
    .BA10(BA[9]),
    .BA11(BA[10]),
    .BA12(BA[11]),
    .BA13(BA[12]),
    .BA14(BA[13]),
    .BA15(BA[14]),
    .BA16(BA[15]),
    .BA2(BA[1]),
    .BA3(BA[2]),
    .BA4(BA[3]),
    .BA5(BA[4]),
    .BA6(BA[5]),
    .BA7(BA[6]),
    .BA8(BA[7]),
    .BA9(BA[8]),
    .BCK(BCK),
    .BCKC(BCK),
    .BCKD(BCKD),
    .BCKR(BCKR),
    .BCOR(BCOR),
    .BCS(BCS),
    .BERR(BERR),
    .BI1(BI[0]),
    .BI10(BI[9]),
    .BI11(BI[10]),
    .BI12(BI[11]),
    .BI13(BI[12]),
    .BI14(BI[13]),
    .BI15(BI[14]),
    .BI16(BI[15]),
    .BI17(BI[16]),
    .BI18(BI[17]),
    .BI19(BI[18]),
    .BI2(BI[1]),
    .BI20(BI[19]),
    .BI21(BI[20]),
    .BI22(BI[21]),
    .BI23(BI[22]),
    .BI24(BI[23]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BI7(BI[6]),
    .BI8(BI[7]),
    .BI9(BI[8]),
    .BO1(BO[0]),
    .BO10(BO[9]),
    .BO11(BO[10]),
    .BO12(BO[11]),
    .BO13(BO[12]),
    .BO14(BO[13]),
    .BO15(BO[14]),
    .BO16(BO[15]),
    .BO17(BO[16]),
    .BO18(BO[17]),
    .BO19(BO[18]),
    .BO2(BO[1]),
    .BO20(BO[19]),
    .BO21(BO[20]),
    .BO22(BO[21]),
    .BO23(BO[22]),
    .BO24(BO[23]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .BO7(BO[6]),
    .BO8(BO[7]),
    .BO9(BO[8]),
    .BR(BR),
    .BWE(BWE)
  );

endmodule

`,"cells_wrap_l.v":`module NX_CDC_L_2DFF(CK1, CK2, ADRSTI, BDRSTI, BI, AO, BO, AI);
    input ADRSTI;
    input [5:0] AI;
    output [5:0] AO;
    input BDRSTI;
    input [5:0] BI;
    output [5:0] BO;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter gt0_bypass_reg1 = 1'b0;
    parameter gt0_bypass_reg2 = 1'b0;
    parameter gt1_bypass_reg1 = 1'b0;
    parameter gt1_bypass_reg2 = 1'b0;
    parameter use_adest_arst = 2'b00;
    parameter use_bdest_arst = 2'b00;

  NX_CDC_L #(
    .mode(0), // -- 0: 2DFF
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(2'b00),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(2'b00),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(2'b00),
    .use_cdest_arst(2'b00),
    .use_dsrc_arst(2'b00),
    .use_ddest_arst(2'b00),
    .gt0_bypass_reg1(gt0_bypass_reg1),
    .gt0_bypass_reg2(gt0_bypass_reg2),
    .gt1_bypass_reg1(gt1_bypass_reg2),
    .gt1_bypass_reg2(gt1_bypass_reg2),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0)
  );
endmodule

module NX_CDC_L_3DFF(CK1, CK2, ASRSTI, ADRSTI, BDRSTI, BSRSTI, BI, AO, BO, AI);
    input ADRSTI;
    input [5:0] AI;
    output [5:0] AO;
    input ASRSTI;
    input BDRSTI;
    input [5:0] BI;
    output [5:0] BO;
    input BSRSTI;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter gt0_bypass_reg1 = 1'b0;
    parameter gt0_bypass_reg2 = 1'b0;
    parameter gt1_bypass_reg1 = 1'b0;
    parameter gt1_bypass_reg2 = 1'b0;
    parameter use_adest_arst = 2'b00;
    parameter use_asrc_arst = 2'b00;
    parameter use_bdest_arst = 2'b00;
    parameter use_bsrc_arst = 2'b00;

  NX_CDC_L #(
    .mode(1), // -- 1: 3DFF
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(use_asrc_arst),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(use_bsrc_arst),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(2'b00),
    .use_cdest_arst(2'b00),
    .use_dsrc_arst(2'b00),
    .use_ddest_arst(2'b00),
    .gt0_bypass_reg1(gt0_bypass_reg1),
    .gt0_bypass_reg2(gt0_bypass_reg2),
    .gt1_bypass_reg1(gt1_bypass_reg2),
    .gt1_bypass_reg2(gt1_bypass_reg2),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0)
  );
endmodule

module NX_CDC_L_FULL(CK1, CK2, ASRSTI, ADRSTI, BDRSTI, BSRSTI, BI, AO, BO, AI);
    input ADRSTI;
    input [5:0] AI;
    output [5:0] AO;
    input ASRSTI;
    input BDRSTI;
    input [5:0] BI;
    output [5:0] BO;
    input BSRSTI;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter gt0_bypass_reg1 = 1'b0;
    parameter gt0_bypass_reg2 = 1'b0;
    parameter gt1_bypass_reg1 = 1'b0;
    parameter gt1_bypass_reg2 = 1'b0;
    parameter use_adest_arst = 2'b00;
    parameter use_asrc_arst = 2'b00;
    parameter use_bdest_arst = 2'b00;
    parameter use_bsrc_arst = 2'b00;

  NX_CDC_L #(
    .mode(2), // -- 2: B2G_3DFF_G2B
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(use_asrc_arst),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(use_bsrc_arst),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(2'b00),
    .use_cdest_arst(2'b00),
    .use_dsrc_arst(2'b00),
    .use_ddest_arst(2'b00),
    .gt0_bypass_reg1(gt0_bypass_reg1),
    .gt0_bypass_reg2(gt0_bypass_reg2),
    .gt1_bypass_reg1(gt1_bypass_reg2),
    .gt1_bypass_reg2(gt1_bypass_reg2),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0)
  );
endmodule

module NX_CDC_L_BIN2GRAY(CK1, CK2, BI, AO, BO, AI);
    input [5:0] AI;
    output [5:0] AO;
    input [5:0] BI;
    output [5:0] BO;
    input CK1;
    input CK2;

  NX_CDC_L #(
    .mode(3), // -- 3: bin2gray
    .ck0_edge(1'b0),
    .ck1_edge(1'b0),
    .ack_sel(1'b0),
    .bck_sel(1'b0),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(2'b00),
    .use_adest_arst(2'b00),
    .use_bsrc_arst(2'b00),
    .use_bdest_arst(2'b00),
    .use_csrc_arst(2'b00),
    .use_cdest_arst(2'b00),
    .use_dsrc_arst(2'b00),
    .use_ddest_arst(2'b00),
    .gt0_bypass_reg1(1'b0),
    .gt0_bypass_reg2(1'b0),
    .gt1_bypass_reg1(1'b0),
    .gt1_bypass_reg2(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0)
  );
endmodule

module NX_DSP_L_SPLIT(CK, R, RZ, WE, CI, CCI, CO, CO36, CO56, OVF, CCO, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO
, CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [23:0] CAI;
    output [23:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO36;
    output CO56;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    output [55:0] Z;
    parameter ALU_DYNAMIC_OP = 1'b0;
    parameter ALU_MUX = 1'b0;
    parameter ALU_OP = 6'b000000;
    parameter CO_SEL = 1'b0;
    parameter ENABLE_PR_ALU_RST = 1'b0;
    parameter ENABLE_PR_A_RST = 1'b0;
    parameter ENABLE_PR_B_RST = 1'b0;
    parameter ENABLE_PR_CI_RST = 1'b0;
    parameter ENABLE_PR_CO_RST = 1'b0;
    parameter ENABLE_PR_C_RST = 1'b0;
    parameter ENABLE_PR_D_RST = 1'b0;
    parameter ENABLE_PR_MULT_RST = 1'b0;
    parameter ENABLE_PR_OV_RST = 1'b0;
    parameter ENABLE_PR_P_RST = 1'b0;
    parameter ENABLE_PR_X_RST = 1'b0;
    parameter ENABLE_PR_Y_RST = 1'b0;
    parameter ENABLE_PR_Z_RST = 1'b0;
    parameter ENABLE_SATURATION = 1'b0;
    parameter MUX_A = 1'b0;
    parameter MUX_B = 1'b0;
    parameter MUX_CI = 1'b0;
    parameter MUX_P = 1'b0;
    parameter MUX_X = 2'b00;
    parameter MUX_Y = 1'b0;
    parameter MUX_Z = 1'b0;
    parameter PRE_ADDER_OP = 1'b0;
    parameter PR_ALU_MUX = 1'b0;
    parameter PR_A_CASCADE_MUX = 2'b00;
    parameter PR_A_MUX = 2'b00;
    parameter PR_B_CASCADE_MUX = 2'b00;
    parameter PR_B_MUX = 2'b00;
    parameter PR_CI_MUX = 1'b0;
    parameter PR_CO_MUX = 1'b0;
    parameter PR_C_MUX = 1'b0;
    parameter PR_D_MUX = 1'b0;
    parameter PR_MULT_MUX = 1'b0;
    parameter PR_OV_MUX = 1'b0;
    parameter PR_P_MUX = 1'b0;
    parameter PR_X_MUX = 1'b0;
    parameter PR_Y_MUX = 1'b0;
    parameter PR_Z_MUX = 1'b0;
    parameter SATURATION_RANK = 6'b000000;
    parameter SIGNED_MODE = 1'b0;
    parameter Z_FEEDBACK_SHL12 = 1'b0;

localparam RAW_CONFIG0_GEN = { CO_SEL, ALU_DYNAMIC_OP, SATURATION_RANK, ENABLE_SATURATION, Z_FEEDBACK_SHL12, MUX_Z,
       MUX_CI, MUX_Y, MUX_X, MUX_P, MUX_B, MUX_A, PRE_ADDER_OP, SIGNED_MODE };

localparam RAW_CONFIG1_GEN = { PR_OV_MUX, PR_CO_MUX, PR_Z_MUX, PR_ALU_MUX, PR_MULT_MUX, PR_Y_MUX, PR_X_MUX,
       PR_P_MUX, PR_CI_MUX, PR_D_MUX, PR_C_MUX, PR_B_CASCADE_MUX, PR_B_MUX, PR_A_CASCADE_MUX, PR_A_MUX };

localparam RAW_CONFIG2_GEN = { ENABLE_PR_OV_RST, ENABLE_PR_CO_RST, ENABLE_PR_Z_RST, ENABLE_PR_ALU_RST,
       ENABLE_PR_MULT_RST, ENABLE_PR_Y_RST, ENABLE_PR_X_RST, ENABLE_PR_P_RST, ENABLE_PR_CI_RST,
       ENABLE_PR_D_RST, ENABLE_PR_C_RST, ENABLE_PR_B_RST, ENABLE_PR_A_RST };

localparam RAW_CONFIG3_GEN = { ALU_MUX, ALU_OP };

  NX_DSP_L #(
    .std_mode(""),
    .raw_config0(RAW_CONFIG0_GEN),
    .raw_config1(RAW_CONFIG1_GEN),
    .raw_config2(RAW_CONFIG2_GEN),
    .raw_config3(RAW_CONFIG3_GEN),
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),
    .CAI19(CAI[18]),
    .CAI20(CAI[19]),
    .CAI21(CAI[20]),
    .CAI22(CAI[21]),
    .CAI23(CAI[22]),
    .CAI24(CAI[23]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),
    .CAO19(CAO[18]),
    .CAO20(CAO[19]),
    .CAO21(CAO[20]),
    .CAO22(CAO[21]),
    .CAO23(CAO[22]),
    .CAO24(CAO[23]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO(CO),
    .CO37(CO36),
    .CO57(CO56),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_DSP_L_WRAP(CCI, CCO, CI, CK, CO, CO37, CO57, OVF, R, RZ, WE, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO
, CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [23:0] CAI;
    output [23:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO37;
    output CO57;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    output [55:0] Z;
    parameter raw_config0 = 20'b00000000000000000000;
    parameter raw_config1 = 19'b0000000000000000000;
    parameter raw_config2 = 13'b0000000000000;
    parameter raw_config3 = 7'b0000000;
    parameter std_mode = "";

  NX_DSP_L #(
    .std_mode(std_mode),
    .raw_config0(raw_config0),
    .raw_config1(raw_config1),
    .raw_config2(raw_config2),
    .raw_config3(raw_config3),
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),
    .CAI19(CAI[18]),
    .CAI20(CAI[19]),
    .CAI21(CAI[20]),
    .CAI22(CAI[21]),
    .CAI23(CAI[22]),
    .CAI24(CAI[23]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),
    .CAO19(CAO[18]),
    .CAO20(CAO[19]),
    .CAO21(CAO[20]),
    .CAO22(CAO[21]),
    .CAO23(CAO[22]),
    .CAO24(CAO[23]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO(CO),
    .CO37(CO37),
    .CO57(CO57),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_RFB_L_WRAP(RCK, WCK, COR, ERR, RE, WE, I, O, RA, WA);
    output COR;
    output ERR;
    input [15:0] I;
    output [15:0] O;
    input [5:0] RA;
    input RCK;
    input RE;
    input [5:0] WA;
    input WCK;
    input WE;
    parameter mem_ctxt = "";
    parameter mode = 0;
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;

  NX_RFB_L #(
    .mode(mode),
    .rck_edge(rck_edge),
    .wck_edge(wck_edge),
    .mem_ctxt(mem_ctxt)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .COR(COR),
    .ERR(ERR),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .RA1(RA[0]),
    .RA2(RA[1]),
    .RA3(RA[2]),
    .RA4(RA[3]),
    .RA5(RA[4]),
    .RA6(RA[5]),
    .RE(RE),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(WA[5]),
    .WE(WE)
  );
endmodule

module NX_RFB(RCK, WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, COR, ERR, O1
, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, RA1, RA2, RA3, RA4, RA5, RA6
, RE, WA1, WA2, WA3, WA4, WA5, WA6, WE);
    output COR;
    output ERR;
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I2;
    input I3;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O2;
    output O3;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RCK;
    input RE;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    parameter addr_mask = 5'b00000;
    parameter mem_ctxt = "";
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;
    parameter we_mask = 1'b0;
    parameter wea_mask = 1'b0;

  NX_RFB_L #(
    .mode(0),
    .mem_ctxt(mem_ctxt),
    .rck_edge(rck_edge),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .I1(I1),
    .I2(I2),
    .I3(I3),
    .I4(I4),
    .I5(I5),
    .I6(I6),
    .I7(I7),
    .I8(I8),
    .I9(I9),
    .I10(I10),
    .I11(I11),
    .I12(I12),
    .I13(I13),
    .I14(I14),
    .I15(I15),
    .I16(I16),
    .COR(COR),
    .ERR(ERR),
    .O1(O1),
    .O2(O2),
    .O3(O3),
    .O4(O4),
    .O5(O5),
    .O6(O6),
    .O7(O7),
    .O8(O8),
    .O9(O9),
    .O10(O10),
    .O11(O11),
    .O12(O12),
    .O13(O13),
    .O14(O14),
    .O15(O15),
    .O16(O16),
    .RA1(RA1),
    .RA2(RA2),
    .RA3(RA3),
    .RA4(RA4),
    .RA5(RA5),
    .RA6(RA6),
    .RE(RE),
    .WA1(WA1),
    .WA2(WA2),
    .WA3(WA3),
    .WA4(WA4),
    .WA5(WA5),
    .WA6(WA6),
    .WE(WE)
  );
endmodule

//TODO
module SMUL24x32_2DSP_ACC_2DSP_L(clk, rst, we, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [91:0] Z;
    input clk;
    input rst;
    input we;
endmodule

//TODO
module NX_HSSL_L_FULL(hssl_clk_user_i, hssl_clk_ref_i, hssl_clock_o, usr_com_tx_pma_pre_sign_i, usr_com_tx_pma_pre_en_i, usr_com_tx_pma_main_sign_i, usr_com_rx_pma_m_eye_i, usr_com_tx_pma_post_sign_i, usr_pll_pma_rst_n_i, usr_main_rst_n_i, usr_calibrate_pma_en_i, usr_pcs_ctrl_pll_lock_en_i, usr_pcs_ctrl_ovs_en_i, usr_pll_lock_o, usr_calibrate_pma_out_o, pma_clk_ext_i, usr_tx0_ctrl_replace_en_i, usr_tx0_rst_n_i, usr_tx0_pma_clk_en_i, usr_tx0_busy_o, pma_tx0_o
, usr_rx0_ctrl_dscr_en_i, usr_rx0_ctrl_dec_en_i, usr_rx0_ctrl_align_en_i, usr_rx0_ctrl_align_sync_i, usr_rx0_ctrl_replace_en_i, usr_rx0_ctrl_el_buff_rst_i, usr_rx0_ctrl_el_buff_fifo_en_i, usr_rx0_rst_n_i, usr_rx0_pma_cdr_rst_i, usr_rx0_pma_ckgen_rst_n_i, usr_rx0_pma_pll_rst_n_i, usr_rx0_pma_loss_of_signal_o, usr_rx0_ctrl_char_is_aligned_o, usr_rx0_busy_o, usr_rx0_pll_lock_o, pma_rx0_i, usr_tx1_ctrl_replace_en_i, usr_tx1_rst_n_i, usr_tx1_pma_clk_en_i, usr_tx1_busy_o, pma_tx1_o
, usr_rx1_ctrl_dscr_en_i, usr_rx1_ctrl_dec_en_i, usr_rx1_ctrl_align_en_i, usr_rx1_ctrl_align_sync_i, usr_rx1_ctrl_replace_en_i, usr_rx1_ctrl_el_buff_rst_i, usr_rx1_ctrl_el_buff_fifo_en_i, usr_rx1_rst_n_i, usr_rx1_pma_cdr_rst_i, usr_rx1_pma_ckgen_rst_n_i, usr_rx1_pma_pll_rst_n_i, usr_rx1_pma_loss_of_signal_o, usr_rx1_ctrl_char_is_aligned_o, usr_rx1_busy_o, usr_rx1_pll_lock_o, pma_rx1_i, usr_tx2_ctrl_replace_en_i, usr_tx2_rst_n_i, usr_tx2_pma_clk_en_i, usr_tx2_busy_o, pma_tx2_o
, usr_rx2_ctrl_dscr_en_i, usr_rx2_ctrl_dec_en_i, usr_rx2_ctrl_align_en_i, usr_rx2_ctrl_align_sync_i, usr_rx2_ctrl_replace_en_i, usr_rx2_ctrl_el_buff_rst_i, usr_rx2_ctrl_el_buff_fifo_en_i, usr_rx2_rst_n_i, usr_rx2_pma_cdr_rst_i, usr_rx2_pma_ckgen_rst_n_i, usr_rx2_pma_pll_rst_n_i, usr_rx2_pma_loss_of_signal_o, usr_rx2_ctrl_char_is_aligned_o, usr_rx2_busy_o, usr_rx2_pll_lock_o, pma_rx2_i, usr_tx3_ctrl_replace_en_i, usr_tx3_rst_n_i, usr_tx3_pma_clk_en_i, usr_tx3_busy_o, pma_tx3_o
, usr_rx3_ctrl_dscr_en_i, usr_rx3_ctrl_dec_en_i, usr_rx3_ctrl_align_en_i, usr_rx3_ctrl_align_sync_i, usr_rx3_ctrl_replace_en_i, usr_rx3_ctrl_el_buff_rst_i, usr_rx3_ctrl_el_buff_fifo_en_i, usr_rx3_rst_n_i, usr_rx3_pma_cdr_rst_i, usr_rx3_pma_ckgen_rst_n_i, usr_rx3_pma_pll_rst_n_i, usr_rx3_pma_loss_of_signal_o, usr_rx3_ctrl_char_is_aligned_o, usr_rx3_busy_o, usr_rx3_pll_lock_o, pma_rx3_i, usr_tx4_ctrl_replace_en_i, usr_tx4_rst_n_i, usr_tx4_pma_clk_en_i, usr_tx4_busy_o, pma_tx4_o
, usr_rx4_ctrl_dscr_en_i, usr_rx4_ctrl_dec_en_i, usr_rx4_ctrl_align_en_i, usr_rx4_ctrl_align_sync_i, usr_rx4_ctrl_replace_en_i, usr_rx4_ctrl_el_buff_rst_i, usr_rx4_ctrl_el_buff_fifo_en_i, usr_rx4_rst_n_i, usr_rx4_pma_cdr_rst_i, usr_rx4_pma_ckgen_rst_n_i, usr_rx4_pma_pll_rst_n_i, usr_rx4_pma_loss_of_signal_o, usr_rx4_ctrl_char_is_aligned_o, usr_rx4_busy_o, usr_rx4_pll_lock_o, pma_rx4_i, usr_tx5_ctrl_replace_en_i, usr_tx5_rst_n_i, usr_tx5_pma_clk_en_i, usr_tx5_busy_o, pma_tx5_o
, usr_rx5_ctrl_dscr_en_i, usr_rx5_ctrl_dec_en_i, usr_rx5_ctrl_align_en_i, usr_rx5_ctrl_align_sync_i, usr_rx5_ctrl_replace_en_i, usr_rx5_ctrl_el_buff_rst_i, usr_rx5_ctrl_el_buff_fifo_en_i, usr_rx5_rst_n_i, usr_rx5_pma_cdr_rst_i, usr_rx5_pma_ckgen_rst_n_i, usr_rx5_pma_pll_rst_n_i, usr_rx5_pma_loss_of_signal_o, usr_rx5_ctrl_char_is_aligned_o, usr_rx5_busy_o, usr_rx5_pll_lock_o, pma_rx5_i, usr_com_tx_pma_main_en_i, usr_com_tx_pma_margin_sel_i, usr_com_tx_pma_margin_input_sel_i, usr_com_tx_pma_margin_sel_var_i, usr_com_tx_pma_margin_input_sel_var_i
, usr_com_tx_pma_post_en_i, usr_com_tx_pma_post_input_sel_i, usr_com_tx_pma_post_input_sel_var_i, usr_com_rx_pma_ctle_cap_i, usr_com_rx_pma_ctle_resp_i, usr_com_rx_pma_ctle_resn_i, usr_com_ctrl_tx_sel_i, usr_com_ctrl_rx_sel_i, usr_calibrate_pma_res_p1_i, usr_calibrate_pma_res_n2_i, usr_calibrate_pma_res_n3_i, usr_calibrate_pma_res_p4_i, usr_calibrate_pma_sel_i, usr_main_test_i, usr_main_test_o, usr_tx0_ctrl_enc_en_i, usr_tx0_ctrl_char_is_k_i, usr_tx0_ctrl_scr_en_i, usr_tx0_ctrl_end_of_multiframe_i, usr_tx0_ctrl_end_of_frame_i, usr_tx0_test_i
, usr_tx0_data_i, usr_tx0_test_o, usr_rx0_data_o, usr_rx0_ctrl_ovs_bit_sel_i, usr_rx0_test_i, usr_rx0_ctrl_char_is_comma_o, usr_rx0_ctrl_char_is_k_o, usr_rx0_ctrl_not_in_table_o, usr_rx0_ctrl_disp_err_o, usr_rx0_ctrl_char_is_a_o, usr_rx0_ctrl_char_is_f_o, usr_rx0_test_o, usr_tx1_ctrl_enc_en_i, usr_tx1_ctrl_char_is_k_i, usr_tx1_ctrl_scr_en_i, usr_tx1_ctrl_end_of_multiframe_i, usr_tx1_ctrl_end_of_frame_i, usr_tx1_test_i, usr_tx1_data_i, usr_tx1_test_o, usr_rx1_data_o
, usr_rx1_ctrl_ovs_bit_sel_i, usr_rx1_test_i, usr_rx1_ctrl_char_is_comma_o, usr_rx1_ctrl_char_is_k_o, usr_rx1_ctrl_not_in_table_o, usr_rx1_ctrl_disp_err_o, usr_rx1_ctrl_char_is_a_o, usr_rx1_ctrl_char_is_f_o, usr_rx1_test_o, usr_tx2_ctrl_enc_en_i, usr_tx2_ctrl_char_is_k_i, usr_tx2_ctrl_scr_en_i, usr_tx2_ctrl_end_of_multiframe_i, usr_tx2_ctrl_end_of_frame_i, usr_tx2_test_i, usr_tx2_data_i, usr_tx2_test_o, usr_rx2_data_o, usr_rx2_ctrl_ovs_bit_sel_i, usr_rx2_test_i, usr_rx2_ctrl_char_is_comma_o
, usr_rx2_ctrl_char_is_k_o, usr_rx2_ctrl_not_in_table_o, usr_rx2_ctrl_disp_err_o, usr_rx2_ctrl_char_is_a_o, usr_rx2_ctrl_char_is_f_o, usr_rx2_test_o, usr_tx3_ctrl_enc_en_i, usr_tx3_ctrl_char_is_k_i, usr_tx3_ctrl_scr_en_i, usr_tx3_ctrl_end_of_multiframe_i, usr_tx3_ctrl_end_of_frame_i, usr_tx3_test_i, usr_tx3_data_i, usr_tx3_test_o, usr_rx3_data_o, usr_rx3_ctrl_ovs_bit_sel_i, usr_rx3_test_i, usr_rx3_ctrl_char_is_comma_o, usr_rx3_ctrl_char_is_k_o, usr_rx3_ctrl_not_in_table_o, usr_rx3_ctrl_disp_err_o
, usr_rx3_ctrl_char_is_a_o, usr_rx3_ctrl_char_is_f_o, usr_rx3_test_o, usr_tx4_ctrl_enc_en_i, usr_tx4_ctrl_char_is_k_i, usr_tx4_ctrl_scr_en_i, usr_tx4_ctrl_end_of_multiframe_i, usr_tx4_ctrl_end_of_frame_i, usr_tx4_test_i, usr_tx4_data_i, usr_tx4_test_o, usr_rx4_data_o, usr_rx4_ctrl_ovs_bit_sel_i, usr_rx4_test_i, usr_rx4_ctrl_char_is_comma_o, usr_rx4_ctrl_char_is_k_o, usr_rx4_ctrl_not_in_table_o, usr_rx4_ctrl_disp_err_o, usr_rx4_ctrl_char_is_a_o, usr_rx4_ctrl_char_is_f_o, usr_rx4_test_o
, usr_tx5_ctrl_enc_en_i, usr_tx5_ctrl_char_is_k_i, usr_tx5_ctrl_scr_en_i, usr_tx5_ctrl_end_of_multiframe_i, usr_tx5_ctrl_end_of_frame_i, usr_tx5_test_i, usr_tx5_data_i, usr_tx5_test_o, usr_rx5_data_o, usr_rx5_ctrl_ovs_bit_sel_i, usr_rx5_test_i, usr_rx5_ctrl_char_is_comma_o, usr_rx5_ctrl_char_is_k_o, usr_rx5_ctrl_not_in_table_o, usr_rx5_ctrl_disp_err_o, usr_rx5_ctrl_char_is_a_o, usr_rx5_ctrl_char_is_f_o, usr_rx5_test_o, usr_com_tx_pma_pre_input_sel_i);
    input hssl_clk_ref_i;
    input hssl_clk_user_i;
    output hssl_clock_o;
    input pma_clk_ext_i;
    input pma_rx0_i;
    input pma_rx1_i;
    input pma_rx2_i;
    input pma_rx3_i;
    input pma_rx4_i;
    input pma_rx5_i;
    output pma_tx0_o;
    output pma_tx1_o;
    output pma_tx2_o;
    output pma_tx3_o;
    output pma_tx4_o;
    output pma_tx5_o;
    input usr_calibrate_pma_en_i;
    output usr_calibrate_pma_out_o;
    input [7:0] usr_calibrate_pma_res_n2_i;
    input [7:0] usr_calibrate_pma_res_n3_i;
    input [7:0] usr_calibrate_pma_res_p1_i;
    input [7:0] usr_calibrate_pma_res_p4_i;
    input [3:0] usr_calibrate_pma_sel_i;
    input [5:0] usr_com_ctrl_rx_sel_i;
    input [5:0] usr_com_ctrl_tx_sel_i;
    input [3:0] usr_com_rx_pma_ctle_cap_i;
    input [3:0] usr_com_rx_pma_ctle_resn_i;
    input [3:0] usr_com_rx_pma_ctle_resp_i;
    input usr_com_rx_pma_m_eye_i;
    input [5:0] usr_com_tx_pma_main_en_i;
    input usr_com_tx_pma_main_sign_i;
    input [3:0] usr_com_tx_pma_margin_input_sel_i;
    input [4:0] usr_com_tx_pma_margin_input_sel_var_i;
    input [3:0] usr_com_tx_pma_margin_sel_i;
    input [4:0] usr_com_tx_pma_margin_sel_var_i;
    input [4:0] usr_com_tx_pma_post_en_i;
    input [3:0] usr_com_tx_pma_post_input_sel_i;
    input [3:0] usr_com_tx_pma_post_input_sel_var_i;
    input usr_com_tx_pma_post_sign_i;
    input usr_com_tx_pma_pre_en_i;
    input [3:0] usr_com_tx_pma_pre_input_sel_i;
    input usr_com_tx_pma_pre_sign_i;
    input usr_main_rst_n_i;
    input [7:0] usr_main_test_i;
    output [7:0] usr_main_test_o;
    input usr_pcs_ctrl_ovs_en_i;
    input usr_pcs_ctrl_pll_lock_en_i;
    output usr_pll_lock_o;
    input usr_pll_pma_rst_n_i;
    output usr_rx0_busy_o;
    input usr_rx0_ctrl_align_en_i;
    input usr_rx0_ctrl_align_sync_i;
    output [7:0] usr_rx0_ctrl_char_is_a_o;
    output usr_rx0_ctrl_char_is_aligned_o;
    output [7:0] usr_rx0_ctrl_char_is_comma_o;
    output [7:0] usr_rx0_ctrl_char_is_f_o;
    output [7:0] usr_rx0_ctrl_char_is_k_o;
    input usr_rx0_ctrl_dec_en_i;
    output [7:0] usr_rx0_ctrl_disp_err_o;
    input usr_rx0_ctrl_dscr_en_i;
    input usr_rx0_ctrl_el_buff_fifo_en_i;
    input usr_rx0_ctrl_el_buff_rst_i;
    output [7:0] usr_rx0_ctrl_not_in_table_o;
    input [1:0] usr_rx0_ctrl_ovs_bit_sel_i;
    input usr_rx0_ctrl_replace_en_i;
    output [63:0] usr_rx0_data_o;
    output usr_rx0_pll_lock_o;
    input usr_rx0_pma_cdr_rst_i;
    input usr_rx0_pma_ckgen_rst_n_i;
    output usr_rx0_pma_loss_of_signal_o;
    input usr_rx0_pma_pll_rst_n_i;
    input usr_rx0_rst_n_i;
    input [3:0] usr_rx0_test_i;
    output [7:0] usr_rx0_test_o;
    output usr_rx1_busy_o;
    input usr_rx1_ctrl_align_en_i;
    input usr_rx1_ctrl_align_sync_i;
    output [7:0] usr_rx1_ctrl_char_is_a_o;
    output usr_rx1_ctrl_char_is_aligned_o;
    output [7:0] usr_rx1_ctrl_char_is_comma_o;
    output [7:0] usr_rx1_ctrl_char_is_f_o;
    output [7:0] usr_rx1_ctrl_char_is_k_o;
    input usr_rx1_ctrl_dec_en_i;
    output [7:0] usr_rx1_ctrl_disp_err_o;
    input usr_rx1_ctrl_dscr_en_i;
    input usr_rx1_ctrl_el_buff_fifo_en_i;
    input usr_rx1_ctrl_el_buff_rst_i;
    output [7:0] usr_rx1_ctrl_not_in_table_o;
    input [1:0] usr_rx1_ctrl_ovs_bit_sel_i;
    input usr_rx1_ctrl_replace_en_i;
    output [63:0] usr_rx1_data_o;
    output usr_rx1_pll_lock_o;
    input usr_rx1_pma_cdr_rst_i;
    input usr_rx1_pma_ckgen_rst_n_i;
    output usr_rx1_pma_loss_of_signal_o;
    input usr_rx1_pma_pll_rst_n_i;
    input usr_rx1_rst_n_i;
    input [3:0] usr_rx1_test_i;
    output [7:0] usr_rx1_test_o;
    output usr_rx2_busy_o;
    input usr_rx2_ctrl_align_en_i;
    input usr_rx2_ctrl_align_sync_i;
    output [7:0] usr_rx2_ctrl_char_is_a_o;
    output usr_rx2_ctrl_char_is_aligned_o;
    output [7:0] usr_rx2_ctrl_char_is_comma_o;
    output [7:0] usr_rx2_ctrl_char_is_f_o;
    output [7:0] usr_rx2_ctrl_char_is_k_o;
    input usr_rx2_ctrl_dec_en_i;
    output [7:0] usr_rx2_ctrl_disp_err_o;
    input usr_rx2_ctrl_dscr_en_i;
    input usr_rx2_ctrl_el_buff_fifo_en_i;
    input usr_rx2_ctrl_el_buff_rst_i;
    output [7:0] usr_rx2_ctrl_not_in_table_o;
    input [1:0] usr_rx2_ctrl_ovs_bit_sel_i;
    input usr_rx2_ctrl_replace_en_i;
    output [63:0] usr_rx2_data_o;
    output usr_rx2_pll_lock_o;
    input usr_rx2_pma_cdr_rst_i;
    input usr_rx2_pma_ckgen_rst_n_i;
    output usr_rx2_pma_loss_of_signal_o;
    input usr_rx2_pma_pll_rst_n_i;
    input usr_rx2_rst_n_i;
    input [3:0] usr_rx2_test_i;
    output [7:0] usr_rx2_test_o;
    output usr_rx3_busy_o;
    input usr_rx3_ctrl_align_en_i;
    input usr_rx3_ctrl_align_sync_i;
    output [7:0] usr_rx3_ctrl_char_is_a_o;
    output usr_rx3_ctrl_char_is_aligned_o;
    output [7:0] usr_rx3_ctrl_char_is_comma_o;
    output [7:0] usr_rx3_ctrl_char_is_f_o;
    output [7:0] usr_rx3_ctrl_char_is_k_o;
    input usr_rx3_ctrl_dec_en_i;
    output [7:0] usr_rx3_ctrl_disp_err_o;
    input usr_rx3_ctrl_dscr_en_i;
    input usr_rx3_ctrl_el_buff_fifo_en_i;
    input usr_rx3_ctrl_el_buff_rst_i;
    output [7:0] usr_rx3_ctrl_not_in_table_o;
    input [1:0] usr_rx3_ctrl_ovs_bit_sel_i;
    input usr_rx3_ctrl_replace_en_i;
    output [63:0] usr_rx3_data_o;
    output usr_rx3_pll_lock_o;
    input usr_rx3_pma_cdr_rst_i;
    input usr_rx3_pma_ckgen_rst_n_i;
    output usr_rx3_pma_loss_of_signal_o;
    input usr_rx3_pma_pll_rst_n_i;
    input usr_rx3_rst_n_i;
    input [3:0] usr_rx3_test_i;
    output [7:0] usr_rx3_test_o;
    output usr_rx4_busy_o;
    input usr_rx4_ctrl_align_en_i;
    input usr_rx4_ctrl_align_sync_i;
    output [7:0] usr_rx4_ctrl_char_is_a_o;
    output usr_rx4_ctrl_char_is_aligned_o;
    output [7:0] usr_rx4_ctrl_char_is_comma_o;
    output [7:0] usr_rx4_ctrl_char_is_f_o;
    output [7:0] usr_rx4_ctrl_char_is_k_o;
    input usr_rx4_ctrl_dec_en_i;
    output [7:0] usr_rx4_ctrl_disp_err_o;
    input usr_rx4_ctrl_dscr_en_i;
    input usr_rx4_ctrl_el_buff_fifo_en_i;
    input usr_rx4_ctrl_el_buff_rst_i;
    output [7:0] usr_rx4_ctrl_not_in_table_o;
    input [1:0] usr_rx4_ctrl_ovs_bit_sel_i;
    input usr_rx4_ctrl_replace_en_i;
    output [63:0] usr_rx4_data_o;
    output usr_rx4_pll_lock_o;
    input usr_rx4_pma_cdr_rst_i;
    input usr_rx4_pma_ckgen_rst_n_i;
    output usr_rx4_pma_loss_of_signal_o;
    input usr_rx4_pma_pll_rst_n_i;
    input usr_rx4_rst_n_i;
    input [3:0] usr_rx4_test_i;
    output [7:0] usr_rx4_test_o;
    output usr_rx5_busy_o;
    input usr_rx5_ctrl_align_en_i;
    input usr_rx5_ctrl_align_sync_i;
    output [7:0] usr_rx5_ctrl_char_is_a_o;
    output usr_rx5_ctrl_char_is_aligned_o;
    output [7:0] usr_rx5_ctrl_char_is_comma_o;
    output [7:0] usr_rx5_ctrl_char_is_f_o;
    output [7:0] usr_rx5_ctrl_char_is_k_o;
    input usr_rx5_ctrl_dec_en_i;
    output [7:0] usr_rx5_ctrl_disp_err_o;
    input usr_rx5_ctrl_dscr_en_i;
    input usr_rx5_ctrl_el_buff_fifo_en_i;
    input usr_rx5_ctrl_el_buff_rst_i;
    output [7:0] usr_rx5_ctrl_not_in_table_o;
    input [1:0] usr_rx5_ctrl_ovs_bit_sel_i;
    input usr_rx5_ctrl_replace_en_i;
    output [63:0] usr_rx5_data_o;
    output usr_rx5_pll_lock_o;
    input usr_rx5_pma_cdr_rst_i;
    input usr_rx5_pma_ckgen_rst_n_i;
    output usr_rx5_pma_loss_of_signal_o;
    input usr_rx5_pma_pll_rst_n_i;
    input usr_rx5_rst_n_i;
    input [3:0] usr_rx5_test_i;
    output [7:0] usr_rx5_test_o;
    output usr_tx0_busy_o;
    input [7:0] usr_tx0_ctrl_char_is_k_i;
    input [7:0] usr_tx0_ctrl_enc_en_i;
    input [7:0] usr_tx0_ctrl_end_of_frame_i;
    input [7:0] usr_tx0_ctrl_end_of_multiframe_i;
    input usr_tx0_ctrl_replace_en_i;
    input [7:0] usr_tx0_ctrl_scr_en_i;
    input [63:0] usr_tx0_data_i;
    input usr_tx0_pma_clk_en_i;
    input usr_tx0_rst_n_i;
    input [3:0] usr_tx0_test_i;
    output [3:0] usr_tx0_test_o;
    output usr_tx1_busy_o;
    input [7:0] usr_tx1_ctrl_char_is_k_i;
    input [7:0] usr_tx1_ctrl_enc_en_i;
    input [7:0] usr_tx1_ctrl_end_of_frame_i;
    input [7:0] usr_tx1_ctrl_end_of_multiframe_i;
    input usr_tx1_ctrl_replace_en_i;
    input [7:0] usr_tx1_ctrl_scr_en_i;
    input [63:0] usr_tx1_data_i;
    input usr_tx1_pma_clk_en_i;
    input usr_tx1_rst_n_i;
    input [3:0] usr_tx1_test_i;
    output [3:0] usr_tx1_test_o;
    output usr_tx2_busy_o;
    input [7:0] usr_tx2_ctrl_char_is_k_i;
    input [7:0] usr_tx2_ctrl_enc_en_i;
    input [7:0] usr_tx2_ctrl_end_of_frame_i;
    input [7:0] usr_tx2_ctrl_end_of_multiframe_i;
    input usr_tx2_ctrl_replace_en_i;
    input [7:0] usr_tx2_ctrl_scr_en_i;
    input [63:0] usr_tx2_data_i;
    input usr_tx2_pma_clk_en_i;
    input usr_tx2_rst_n_i;
    input [3:0] usr_tx2_test_i;
    output [3:0] usr_tx2_test_o;
    output usr_tx3_busy_o;
    input [7:0] usr_tx3_ctrl_char_is_k_i;
    input [7:0] usr_tx3_ctrl_enc_en_i;
    input [7:0] usr_tx3_ctrl_end_of_frame_i;
    input [7:0] usr_tx3_ctrl_end_of_multiframe_i;
    input usr_tx3_ctrl_replace_en_i;
    input [7:0] usr_tx3_ctrl_scr_en_i;
    input [63:0] usr_tx3_data_i;
    input usr_tx3_pma_clk_en_i;
    input usr_tx3_rst_n_i;
    input [3:0] usr_tx3_test_i;
    output [3:0] usr_tx3_test_o;
    output usr_tx4_busy_o;
    input [7:0] usr_tx4_ctrl_char_is_k_i;
    input [7:0] usr_tx4_ctrl_enc_en_i;
    input [7:0] usr_tx4_ctrl_end_of_frame_i;
    input [7:0] usr_tx4_ctrl_end_of_multiframe_i;
    input usr_tx4_ctrl_replace_en_i;
    input [7:0] usr_tx4_ctrl_scr_en_i;
    input [63:0] usr_tx4_data_i;
    input usr_tx4_pma_clk_en_i;
    input usr_tx4_rst_n_i;
    input [3:0] usr_tx4_test_i;
    output [3:0] usr_tx4_test_o;
    output usr_tx5_busy_o;
    input [7:0] usr_tx5_ctrl_char_is_k_i;
    input [7:0] usr_tx5_ctrl_enc_en_i;
    input [7:0] usr_tx5_ctrl_end_of_frame_i;
    input [7:0] usr_tx5_ctrl_end_of_multiframe_i;
    input usr_tx5_ctrl_replace_en_i;
    input [7:0] usr_tx5_ctrl_scr_en_i;
    input [63:0] usr_tx5_data_i;
    input usr_tx5_pma_clk_en_i;
    input usr_tx5_rst_n_i;
    input [3:0] usr_tx5_test_i;
    output [3:0] usr_tx5_test_o;
    parameter cfg_main_i = 34'b0000000000000000000000000000000000;
    parameter cfg_rx0_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_rx1_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_rx2_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_rx3_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_rx4_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_rx5_i = 160'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter cfg_tx0_i = 0;
    parameter cfg_tx1_i = 0;
    parameter cfg_tx2_i = 0;
    parameter cfg_tx3_i = 0;
    parameter cfg_tx4_i = 0;
    parameter cfg_tx5_i = 0;
    parameter location = "";
endmodule
`,"cells_wrap_m.v":`module NX_DSP_SPLIT(CK, R, RZ, WE, CI, CCI, CO, CO36, CO48, OVF, CCO, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO , CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [17:0] CAI;
    output [17:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO36;
    output CO48;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    output [55:0] Z;
    parameter ALU_DYNAMIC_OP = 1'b0;
    parameter ALU_MUX = 1'b0;
    parameter ALU_OP = 6'b000000;
    parameter CO_SEL = 1'b0;
    parameter ENABLE_PR_ALU_RST = 1'b0;
    parameter ENABLE_PR_A_RST = 1'b0;
    parameter ENABLE_PR_B_RST = 1'b0;
    parameter ENABLE_PR_CI_RST = 1'b0;
    parameter ENABLE_PR_CO_RST = 1'b0;
    parameter ENABLE_PR_C_RST = 1'b0;
    parameter ENABLE_PR_D_RST = 1'b0;
    parameter ENABLE_PR_MULT_RST = 1'b0;
    parameter ENABLE_PR_OV_RST = 1'b0;
    parameter ENABLE_PR_P_RST = 1'b0;
    parameter ENABLE_PR_X_RST = 1'b0;
    parameter ENABLE_PR_Y_RST = 1'b0;
    parameter ENABLE_PR_Z_RST = 1'b0;
    parameter ENABLE_SATURATION = 1'b0;
    parameter MUX_A = 1'b0;
    parameter MUX_B = 1'b0;
    parameter MUX_CI = 1'b0;
    parameter MUX_P = 1'b0;
    parameter MUX_X = 2'b00;
    parameter MUX_Y = 1'b0;
    parameter MUX_Z = 1'b0;
    parameter PRE_ADDER_OP = 1'b0;
    parameter PR_ALU_MUX = 1'b0;
    parameter PR_A_CASCADE_MUX = 2'b00;
    parameter PR_A_MUX = 2'b00;
    parameter PR_B_CASCADE_MUX = 2'b00;
    parameter PR_B_MUX = 2'b00;
    parameter PR_CI_MUX = 1'b0;
    parameter PR_CO_MUX = 1'b0;
    parameter PR_C_MUX = 1'b0;
    parameter PR_D_MUX = 1'b0;
    parameter PR_MULT_MUX = 1'b0;
    parameter PR_OV_MUX = 1'b0;
    parameter PR_P_MUX = 1'b0;
    parameter PR_X_MUX = 1'b0;
    parameter PR_Y_MUX = 1'b0;
    parameter PR_Z_MUX = 1'b0;
    parameter SATURATION_RANK = 6'b000000;
    parameter SIGNED_MODE = 1'b0;
    parameter Z_FEEDBACK_SHL12 = 1'b0;

localparam RAW_CONFIG0_GEN = { CO_SEL, ALU_DYNAMIC_OP, SATURATION_RANK, ENABLE_SATURATION, Z_FEEDBACK_SHL12, MUX_Z,
       MUX_CI, MUX_Y, MUX_X, MUX_P, MUX_B, MUX_A, PRE_ADDER_OP, SIGNED_MODE };

localparam RAW_CONFIG1_GEN = { PR_OV_MUX, PR_CO_MUX, PR_Z_MUX, PR_ALU_MUX, PR_MULT_MUX, PR_Y_MUX, PR_X_MUX,
       PR_P_MUX, PR_CI_MUX, PR_D_MUX, PR_C_MUX, PR_B_CASCADE_MUX, PR_B_MUX, PR_A_CASCADE_MUX, PR_A_MUX };

localparam RAW_CONFIG2_GEN = { ENABLE_PR_OV_RST, ENABLE_PR_CO_RST, ENABLE_PR_Z_RST, ENABLE_PR_ALU_RST,
       ENABLE_PR_MULT_RST, ENABLE_PR_Y_RST, ENABLE_PR_X_RST, ENABLE_PR_P_RST, ENABLE_PR_CI_RST,
       ENABLE_PR_D_RST, ENABLE_PR_C_RST, ENABLE_PR_B_RST, ENABLE_PR_A_RST };

localparam RAW_CONFIG3_GEN = { ALU_MUX,  ALU_OP };

  NX_DSP #(
    .std_mode(""),
    .raw_config0(RAW_CONFIG0_GEN),
    .raw_config1(RAW_CONFIG1_GEN),
    .raw_config2(RAW_CONFIG2_GEN),
    .raw_config3(RAW_CONFIG3_GEN),
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO(CO),
    .CO37(CO36),
    .CO49(CO48),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_DSP_WRAP(CCI, CCO, CI, CK, CO, CO37, CO49, OVF, R, RZ, WE, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO
, CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [17:0] CAI;
    output [17:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO;
    output CO37;
    output CO49;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    output [55:0] Z;
    parameter raw_config0 = 20'b00000000000000000000;
    parameter raw_config1 = 19'b0000000000000000000;
    parameter raw_config2 = 13'b0000000000000;
    parameter raw_config3 = 7'b0000000;
    parameter std_mode = "";

  NX_DSP #(
    .std_mode(std_mode),
    .raw_config0(raw_config0),
    .raw_config1(raw_config1),
    .raw_config2(raw_config2),
    .raw_config3(raw_config3),
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO(CO),
    .CO37(CO37),
    .CO49(CO49),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_RFB_WRAP(RCK, WCK, COR, ERR, RE, WE, I, O, RA, WA);
    output COR;
    output ERR;
    input [15:0] I;
    output [15:0] O;
    input [5:0] RA;
    input RCK;
    input RE;
    input [5:0] WA;
    input WCK;
    input WE;
    parameter mem_ctxt = "";
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;

  NX_RFB_M #(
    .mem_ctxt(mem_ctxt),
    .rck_edge(rck_edge),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .COR(COR),
    .ERR(ERR),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .RA1(RA[0]),
    .RA2(RA[1]),
    .RA3(RA[2]),
    .RA4(RA[3]),
    .RA5(RA[4]),
    .RA6(RA[5]),
    .RE(RE),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(WA[5]),
    .WE(WE)
  );
endmodule

module NX_RFB(RCK, WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, COR, ERR, O1
, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, RA1, RA2, RA3, RA4, RA5, RA6
, RE, WA1, WA2, WA3, WA4, WA5, WA6, WE);
    output COR;
    output ERR;
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I2;
    input I3;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O2;
    output O3;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RCK;
    input RE;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    parameter addr_mask = 5'b00000;
    parameter mem_ctxt = "";
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;
    parameter we_mask = 1'b0;
    parameter wea_mask = 1'b0;

  NX_RFB_M #(
    .mem_ctxt(mem_ctxt),
    .rck_edge(rck_edge),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .I1(I1),
    .I2(I2),
    .I3(I3),
    .I4(I4),
    .I5(I5),
    .I6(I6),
    .I7(I7),
    .I8(I8),
    .I9(I9),
    .I10(I10),
    .I11(I11),
    .I12(I12),
    .I13(I13),
    .I14(I14),
    .I15(I15),
    .I16(I16),
    .COR(COR),
    .ERR(ERR),
    .O1(O1),
    .O2(O2),
    .O3(O3),
    .O4(O4),
    .O5(O5),
    .O6(O6),
    .O7(O7),
    .O8(O8),
    .O9(O9),
    .O10(O10),
    .O11(O11),
    .O12(O12),
    .O13(O13),
    .O14(O14),
    .O15(O15),
    .O16(O16),
    .RA1(RA1),
    .RA2(RA2),
    .RA3(RA3),
    .RA4(RA4),
    .RA5(RA5),
    .RA6(RA6),
    .RE(RE),
    .WA1(WA1),
    .WA2(WA2),
    .WA3(WA3),
    .WA4(WA4),
    .WA5(WA5),
    .WA6(WA6),
    .WE(WE)
  );
endmodule

module NX_IOM_CONTROL(RTCK1, RRCK1, WTCK1, WRCK1, RTCK2, RRCK2, WTCK2, WRCK2, CTCK, C1TW, C1TS, C1RW1, C1RW2, C1RW3, C1RNE, C1RS, C2TW, C2TS, C2RW1, C2RW2, C2RW3
, C2RNE, C2RS, FA1, FA2, FA3, FA4, FA5, FA6, FZ, DC, CCK, DCK, DRI1, DRI2, DRI3, DRI4, DRI5, DRI6, DRA1, DRA2, DRA3
, DRA4, DRA5, DRA6, DRL, DOS, DOG, DIS, DIG, DPAS, DPAG, DQSS, DQSG, DS1, DS2, CAD1, CAD2, CAD3, CAD4, CAD5, CAD6, CAP1
, CAP2, CAP3, CAP4, CAN1, CAN2, CAN3, CAN4, CAT1, CAT2, CAT3, CAT4, SPI1, SPI2, SPI3, CKO1, CKO2, FLD, FLG, C1RED, C2RED, DRO1
, DRO2, DRO3, DRO4, DRO5, DRO6, CAL, LINK2, LINK3, LINK4, LINK5, LINK6, LINK7, LINK8, LINK9, LINK10, LINK11, LINK12, LINK13, LINK14, LINK15, LINK16
, LINK17, LINK18, LINK19, LINK20, LINK21, LINK22, LINK23, LINK24, LINK25, LINK26, LINK27, LINK28, LINK29, LINK30, LINK31, LINK32, LINK33, LINK34, LINK1);
    output C1RED;
    input C1RNE;
    input C1RS;
    input C1RW1;
    input C1RW2;
    input C1RW3;
    input C1TS;
    input C1TW;
    output C2RED;
    input C2RNE;
    input C2RS;
    input C2RW1;
    input C2RW2;
    input C2RW3;
    input C2TS;
    input C2TW;
    input CAD1;
    input CAD2;
    input CAD3;
    input CAD4;
    input CAD5;
    input CAD6;
    output CAL;
    input CAN1;
    input CAN2;
    input CAN3;
    input CAN4;
    input CAP1;
    input CAP2;
    input CAP3;
    input CAP4;
    input CAT1;
    input CAT2;
    input CAT3;
    input CAT4;
    input CCK;
    output CKO1;
    output CKO2;
    input CTCK;
    input DC;
    input DCK;
    input DIG;
    input DIS;
    input DOG;
    input DOS;
    input DPAG;
    input DPAS;
    input DQSG;
    input DQSS;
    input DRA1;
    input DRA2;
    input DRA3;
    input DRA4;
    input DRA5;
    input DRA6;
    input DRI1;
    input DRI2;
    input DRI3;
    input DRI4;
    input DRI5;
    input DRI6;
    input DRL;
    output DRO1;
    output DRO2;
    output DRO3;
    output DRO4;
    output DRO5;
    output DRO6;
    input DS1;
    input DS2;
    input FA1;
    input FA2;
    input FA3;
    input FA4;
    input FA5;
    input FA6;
    output FLD;
    output FLG;
    input FZ;
    inout [41:0] LINK1;
    inout [41:0] LINK10;
    inout [41:0] LINK11;
    inout [41:0] LINK12;
    inout [41:0] LINK13;
    inout [41:0] LINK14;
    inout [41:0] LINK15;
    inout [41:0] LINK16;
    inout [41:0] LINK17;
    inout [41:0] LINK18;
    inout [41:0] LINK19;
    inout [41:0] LINK2;
    inout [41:0] LINK20;
    inout [41:0] LINK21;
    inout [41:0] LINK22;
    inout [41:0] LINK23;
    inout [41:0] LINK24;
    inout [41:0] LINK25;
    inout [41:0] LINK26;
    inout [41:0] LINK27;
    inout [41:0] LINK28;
    inout [41:0] LINK29;
    inout [41:0] LINK3;
    inout [41:0] LINK30;
    inout [41:0] LINK31;
    inout [41:0] LINK32;
    inout [41:0] LINK33;
    inout [41:0] LINK34;
    inout [41:0] LINK4;
    inout [41:0] LINK5;
    inout [41:0] LINK6;
    inout [41:0] LINK7;
    inout [41:0] LINK8;
    inout [41:0] LINK9;
    input RRCK1;
    input RRCK2;
    input RTCK1;
    input RTCK2;
    input SPI1;
    input SPI2;
    input SPI3;
    input WRCK1;
    input WRCK2;
    input WTCK1;
    input WTCK2;
    parameter div_rx1 = 4'b0000;
    parameter div_rx2 = 4'b0000;
    parameter div_tx1 = 4'b0000;
    parameter div_tx2 = 4'b0000;
    parameter inv_di_fclk1 = 1'b0;
    parameter inv_di_fclk2 = 1'b0;
    parameter latency1 = 1'b0;
    parameter latency2 = 1'b0;
    parameter location = "";
    parameter mode_cpath = "";
    parameter mode_epath = "";
    parameter mode_io_cal = 1'b0;
    parameter mode_rpath = "";
    parameter mode_side1 = 0;
    parameter mode_side2 = 0;
    parameter mode_tpath = "";
    parameter sel_clk_out1 = 1'b0;
    parameter sel_clk_out2 = 1'b0;
    parameter sel_clkr_rx1 = 1'b0;
    parameter sel_clkr_rx2 = 1'b0;
    parameter sel_clkw_rx1 = 2'b00;
    parameter sel_clkw_rx2 = 2'b00;

  NX_IOM_CONTROL_M #(
    .div_rx1(div_rx1),
    .div_rx2(div_rx2),
    .div_tx1(div_tx1),
    .div_tx2(div_tx2),
    .inv_di_fclk1(inv_di_fclk1),
    .inv_di_fclk2(inv_di_fclk2),
    .latency1(latency1),
    .latency2(latency2),
    .location(location),
    .mode_cpath(mode_cpath),
    .mode_epath(mode_epath),
    .mode_io_cal(mode_io_cal),
    .mode_rpath(mode_rpath),
    .mode_side1(mode_side1),
    .mode_side2(mode_side2),
    .mode_tpath(mode_tpath),
    .sel_clk_out1(sel_clk_out1),
    .sel_clk_out2(sel_clk_out2),
    .sel_clkr_rx1(sel_clkr_rx1),
    .sel_clkr_rx2(sel_clkr_rx2),
    .sel_clkw_rx1(sel_clkw_rx1),
    .sel_clkw_rx2(sel_clkw_rx2)
  ) _TECHMAP_REPLACE_ (
    .C1RED(C1RED),
    .C1RNE(C1RNE),
    .C1RS(C1RS),
    .C1RW1(C1RW1),
    .C1RW2(C1RW2),
    .C1RW3(C1RW3),
    .C1TS(C1TS),
    .C1TW(C1TW),
    .C2RED(C2RED),
    .C2RNE(C2RNE),
    .C2RS(C2RS),
    .C2RW1(C2RW1),
    .C2RW2(C2RW2),
    .C2RW3(C2RW3),
    .C2TS(C2TS),
    .C2TW(C2TW),
    .CAD1(CAD1),
    .CAD2(CAD2),
    .CAD3(CAD3),
    .CAD4(CAD4),
    .CAD5(CAD5),
    .CAD6(CAD6),
    .CAL(CAL),
    .CAN1(CAN1),
    .CAN2(CAN2),
    .CAN3(CAN3),
    .CAN4(CAN4),
    .CAP1(CAP1),
    .CAP2(CAP2),
    .CAP3(CAP3),
    .CAP4(CAP4),
    .CAT1(CAT1),
    .CAT2(CAT2),
    .CAT3(CAT3),
    .CAT4(CAT4),
    .CCK(CCK),
    .CKO1(CKO1),
    .CKO2(CKO2),
    .CTCK(CTCK),
    .DC(DC),
    .DCK(DCK),
    .DIG(DIG),
    .DIS(DIS),
    .DOG(DOG),
    .DOS(DOS),
    .DPAG(DPAG),
    .DPAS(DPAS),
    .DQSG(DQSG),
    .DQSS(DQSS),
    .DRA1(DRA1),
    .DRA2(DRA2),
    .DRA3(DRA3),
    .DRA4(DRA4),
    .DRA5(DRA5),
    .DRA6(DRA6),
    .DRI1(DRI1),
    .DRI2(DRI2),
    .DRI3(DRI3),
    .DRI4(DRI4),
    .DRI5(DRI5),
    .DRI6(DRI6),
    .DRL(DRL),
    .DRO1(DRO1),
    .DRO2(DRO2),
    .DRO3(DRO3),
    .DRO4(DRO4),
    .DRO5(DRO5),
    .DRO6(DRO6),
    .DS1(DS1),
    .DS2(DS2),
    .FA1(FA1),
    .FA2(FA2),
    .FA3(FA3),
    .FA4(FA4),
    .FA5(FA5),
    .FA6(FA6),
    .FLD(FLD),
    .FLG(FLG),
    .FZ(FZ),
    .LINK1(LINK1),
    .LINK10(LINK10),
    .LINK11(LINK11),
    .LINK12(LINK12),
    .LINK13(LINK13),
    .LINK14(LINK14),
    .LINK15(LINK15),
    .LINK16(LINK16),
    .LINK17(LINK17),
    .LINK18(LINK18),
    .LINK19(LINK19),
    .LINK2(LINK2),
    .LINK20(LINK20),
    .LINK21(LINK21),
    .LINK22(LINK22),
    .LINK23(LINK23),
    .LINK24(LINK24),
    .LINK25(LINK25),
    .LINK26(LINK26),
    .LINK27(LINK27),
    .LINK28(LINK28),
    .LINK29(LINK29),
    .LINK3(LINK3),
    .LINK30(LINK30),
    .LINK31(LINK31),
    .LINK32(LINK32),
    .LINK33(LINK33),
    .LINK34(LINK34),
    .LINK4(LINK4),
    .LINK5(LINK5),
    .LINK6(LINK6),
    .LINK7(LINK7),
    .LINK8(LINK8),
    .LINK9(LINK9),
    .RRCK1(RRCK1),
    .RRCK2(RRCK2),
    .RTCK1(RTCK1),
    .RTCK2(RTCK2),
    .SPI1(SPI1),
    .SPI2(SPI2),
    .SPI3(SPI3),
    .WRCK1(WRCK1),
    .WRCK2(WRCK2),
    .WTCK1(WTCK1),
    .WTCK2(WTCK2)
  );
endmodule

module NX_IOM_DRIVER(EI1, EI2, EI3, EI4, EI5, EL, ER, CI1, CI2, CI3, CI4, CI5, CL, CR, CTI, RI, RL, RR, CO, EO, RO1
, RO2, RO3, RO4, RO5, CTO, LINK);
    input CI1;
    input CI2;
    input CI3;
    input CI4;
    input CI5;
    input CL;
    output CO;
    input CR;
    input CTI;
    output CTO;
    input EI1;
    input EI2;
    input EI3;
    input EI4;
    input EI5;
    input EL;
    output EO;
    input ER;
    inout [41:0] LINK;
    input RI;
    input RL;
    output RO1;
    output RO2;
    output RO3;
    output RO4;
    output RO5;
    input RR;
    parameter chained = 1'b0;
    parameter cpath_edge = 1'b0;
    parameter cpath_init = 1'b0;
    parameter cpath_inv = 1'b0;
    parameter cpath_load = 1'b0;
    parameter cpath_mode = 4'b0000;
    parameter cpath_sync = 1'b0;
    parameter epath_dynamic = 1'b0;
    parameter epath_edge = 1'b0;
    parameter epath_init = 1'b0;
    parameter epath_load = 1'b0;
    parameter epath_mode = 4'b0000;
    parameter epath_sync = 1'b0;
    parameter location = "";
    parameter rpath_dynamic = 1'b0;
    parameter rpath_edge = 1'b0;
    parameter rpath_init = 1'b0;
    parameter rpath_load = 1'b0;
    parameter rpath_mode = 4'b0000;
    parameter rpath_sync = 1'b0;
    parameter symbol = "";
    parameter tpath_mode = 2'b00;
    parameter variant = "";

  NX_IOM_DRIVER_M #(
    .chained(chained),
    .cpath_edge(cpath_edge),
    .cpath_init(cpath_init),
    .cpath_inv(cpath_inv),
    .cpath_load(cpath_load),
    .cpath_mode(cpath_mode),
    .cpath_sync(cpath_sync),
    .epath_dynamic(epath_dynamic),
    .epath_edge(epath_edge),
    .epath_init(epath_init),
    .epath_load(epath_load),
    .epath_mode(epath_mode),
    .epath_sync(epath_sync),
    .location(location),
    .rpath_dynamic(rpath_dynamic),
    .rpath_edge(rpath_edge),
    .rpath_init(rpath_init),
    .rpath_load(rpath_load),
    .rpath_mode(rpath_mode),
    .rpath_sync(rpath_sync),
    .symbol(symbol),
    .tpath_mode(tpath_mode),
    .variant(variant)
  ) _TECHMAP_REPLACE_ (
    .CI1(CI1),
    .CI2(CI2),
    .CI3(CI3),
    .CI4(CI4),
    .CI5(CI5),
    .CL(CL),
    .CO(CO),
    .CR(CR),
    .CTI(CTI),
    .CTO(CTO),
    .EI1(EI1),
    .EI2(EI2),
    .EI3(EI3),
    .EI4(EI4),
    .EI5(EI5),
    .EL(EL),
    .EO(EO),
    .ER(ER),
    .LINK(LINK),
    .RI(RI),
    .RL(RL),
    .RO1(RO1),
    .RO2(RO2),
    .RO3(RO3),
    .RO4(RO4),
    .RO5(RO5),
    .RR(RR)
  );
endmodule

module NX_IOM_SERDES(RTCK, WRCK, WTCK, RRCK, TRST, RRST, CTCK, DCK, DRL, DIG, FZ, FLD, FLG, DS, DRA, DRI, DRO, DID, LINKN, LINKP);
    input CTCK;
    input DCK;
    output [5:0] DID;
    input DIG;
    input [5:0] DRA;
    input [5:0] DRI;
    input DRL;
    output [5:0] DRO;
    input [1:0] DS;
    output FLD;
    output FLG;
    input FZ;
    inout [41:0] LINKN;
    inout [41:0] LINKP;
    input RRCK;
    input RRST;
    input RTCK;
    input TRST;
    input WRCK;
    input WTCK;
    parameter data_size = 5;
    parameter location = "";

  NX_IOM_SERDES_M #(
    .data_size(data_size),
    .location(location)
  ) _TECHMAP_REPLACE_ (
    .CTCK(CTCK),
    .DCK(DCK),
    .DID(DID),
    .DIG(DIG),
    .DRA(DRA),
    .DRI(DRI),
    .DRL(DRL),
    .DRO(DRO),
    .DS(DS),
    .FLD(FLD),
    .FLG(FLG),
    .FZ(FZ),
    .LINKN(LINKN),
    .LINKP(LINKP),
    .RRCK(RRCK),
    .RRST(RRST),
    .RTCK(RTCK),
    .TRST(TRST),
    .WRCK(WRCK),
    .WTCK(WTCK)
  );
endmodule
`,"cells_wrap_u.v":`
module NX_ODDFR_U(CK,R,I1,I2,L,O);
    input CK;
    input R;
    input I1;
    input I2;
    input L;
    output O;

    parameter location = "";
    parameter path = 0;
    parameter dff_type = 1'b0;
    parameter dff_sync = 1'b0;
    parameter dff_load = 1'b0;

  NX_DDFR_U #(
      .location(location),
      .path(path),
      .dff_type(dff_type),
      .dff_sync(dff_sync),
      .dff_load(dff_load)
  ) _TECHMAP_REPLACE_ (
      .CK(CK),
      .CKF(CK),
      .R(R),
      .I(I1),
      .I2(I2),
      .L(L),
      .O(O),
      .O2()
  );
endmodule

module NX_IDDFR_U(CK,R,I,L,O1,O2);
    input CK;
    input R;
    input I;
    input L;
    output O1;
    output O2;

    parameter location = "";
    parameter dff_type = 1'b0;
    parameter dff_sync = 1'b0;
    parameter dff_load = 1'b0;

  NX_DDFR_U #(
      .location(location),
      .path(1),
      .dff_type(dff_type),
      .dff_sync(dff_sync),
      .dff_load(dff_load)
  ) _TECHMAP_REPLACE_ (
      .CK(CK),
      .CKF(CK),
      .R(R),
      .I(I),
      .I2(1'b0),
      .L(L),
      .O(O1),
      .O2(O2)
  );
endmodule

module NX_CKS_U(CKI, CMD, CKO);
    input CKI;
    output CKO;
    input CMD;

  NX_GCK_U #(
      .inv_in(1'b0),
      .inv_out(1'b0),
      .std_mode("CKS")
  ) _TECHMAP_REPLACE_ (
      .CMD(CMD),
      .SI1(CKI),
      .SI2(),
      .SO(CKO)
  );
endmodule

module NX_CMUX_U(CKI0, CKI1, SEL, CKO);
    input CKI0;
    input CKI1;
    output CKO;
    input SEL;

  NX_GCK_U #(
      .inv_in(1'b0),
      .inv_out(1'b0),
      .std_mode("MUX")
  ) _TECHMAP_REPLACE_ (
      .CMD(SEL),
      .SI1(CKI0),
      .SI2(CKI1),
      .SO(CKO)
  );
endmodule

module NX_CDC_U_2DFF(CK1, CK2, ADRSTI, ADRSTO, BDRSTI, BDRSTO, BI, AO, BO, AI);
    input ADRSTI;
    output ADRSTO;
    input [5:0] AI;
    output [5:0] AO;
    input BDRSTI;
    output BDRSTO;
    input [5:0] BI;
    output [5:0] BO;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter use_adest_arst = 1'b0;
    parameter use_bdest_arst = 1'b0;

  NX_CDC_U #(
    .mode(0), // -- 0: 2DFF
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(1'b0),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(1'b0),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(1'b0),
    .use_cdest_arst(1'b0),
    .use_dsrc_arst(1'b0),
    .use_ddest_arst(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .ASRSTI(1'b0),
    .ADRSTI(ADRSTI),
    .ADRSTO(ADRSTO),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(1'b0),
    .BDRSTI(BDRSTI),
    .BDRSTO(BDRSTO),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(1'b0),
    .CDRSTI(1'b0),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DSRSTI(1'b0),
    .DDRSTI(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0),
  );
endmodule

module NX_CDC_U_3DFF(CK1, CK2, ASRSTI, ADRSTI, ASRSTO, ADRSTO, BSRSTI, BDRSTI, BSRSTO, BDRSTO, BI, AO, BO, AI);
    input ADRSTI;
    output ADRSTO;
    input [5:0] AI;
    output [5:0] AO;
    input ASRSTI;
    output ASRSTO;
    input BDRSTI;
    output BDRSTO;
    input [5:0] BI;
    output [5:0] BO;
    input BSRSTI;
    output BSRSTO;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter use_adest_arst = 1'b0;
    parameter use_asrc_arst = 1'b0;
    parameter use_bdest_arst = 1'b0;
    parameter use_bsrc_arst = 1'b0;

  NX_CDC_U #(
    .mode(1), // -- 1: 3DFF
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(use_asrc_arst),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(use_bsrc_arst),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(1'b0),
    .use_cdest_arst(1'b0),
    .use_dsrc_arst(1'b0),
    .use_ddest_arst(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .ASRSTI(ASRSTI),
    .ADRSTI(ADRSTI),
    .ASRSTO(ASRSTO),
    .ADRSTO(ADRSTO),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(BSRSTI),
    .BDRSTI(BDRSTI),
    .BSRSTO(BSRSTO),
    .BDRSTO(BDRSTO),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(1'b0),
    .CDRSTI(1'b0),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DSRSTI(1'b0),
    .DDRSTI(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0),
  );
endmodule

module NX_CDC_U_FULL(CK1, CK2, ASRSTI, ADRSTI, ASRSTO, ADRSTO, BSRSTI, BDRSTI, BSRSTO, BDRSTO, BI, AO, BO, AI);
    input ADRSTI;
    output ADRSTO;
    input [5:0] AI;
    output [5:0] AO;
    input ASRSTI;
    output ASRSTO;
    input BDRSTI;
    output BDRSTO;
    input [5:0] BI;
    output [5:0] BO;
    input BSRSTI;
    output BSRSTO;
    input CK1;
    input CK2;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter use_adest_arst = 1'b0;
    parameter use_asrc_arst = 1'b0;
    parameter use_bdest_arst = 1'b0;
    parameter use_bsrc_arst = 1'b0;

  NX_CDC_U #(
    .mode(2), // -- 2: bin2gray + 3DFF + gray2bin
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(use_asrc_arst),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(use_bsrc_arst),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(1'b0),
    .use_cdest_arst(1'b0),
    .use_dsrc_arst(1'b0),
    .use_ddest_arst(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .ASRSTI(ASRSTI),
    .ADRSTI(ADRSTI),
    .ASRSTO(ASRSTO),
    .ADRSTO(ADRSTO),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(BSRSTI),
    .BDRSTI(BDRSTI),
    .BSRSTO(BSRSTO),
    .BDRSTO(BDRSTO),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(1'b0),
    .CDRSTI(1'b0),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DSRSTI(1'b0),
    .DDRSTI(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0),
  );
endmodule

module NX_CDC_U_BIN2GRAY(BI, AO, BO, AI);
    input [5:0] AI;
    output [5:0] AO;
    input [5:0] BI;
    output [5:0] BO;

  NX_CDC_U #(
    .mode(3), // -- 3: bin2gray
    .ck0_edge(1'b0),
    .ck1_edge(1'b0),
    .ack_sel(1'b0),
    .bck_sel(1'b0),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(1'b0),
    .use_adest_arst(1'b0),
    .use_bsrc_arst(1'b0),
    .use_bdest_arst(1'b0),
    .use_csrc_arst(1'b0),
    .use_cdest_arst(1'b0),
    .use_dsrc_arst(1'b0),
    .use_ddest_arst(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(1'b0),
    .CK2(1'b0),
    .ASRSTI(1'b0),
    .ADRSTI(1'b0),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(1'b0),
    .BDRSTI(1'b0),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(1'b0),
    .CDRSTI(1'b0),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DSRSTI(1'b0),
    .DDRSTI(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0),
  );
endmodule

module NX_CDC_U_GRAY2BIN(BI, AO, BO, AI);
    input [5:0] AI;
    output [5:0] AO;
    input [5:0] BI;
    output [5:0] BO;

  NX_CDC_U #(
    .mode(4), // -- 4: gray2bin
    .ck0_edge(1'b0),
    .ck1_edge(1'b0),
    .ack_sel(1'b0),
    .bck_sel(1'b0),
    .cck_sel(1'b0),
    .dck_sel(1'b0),
    .use_asrc_arst(1'b0),
    .use_adest_arst(1'b0),
    .use_bsrc_arst(1'b0),
    .use_bdest_arst(1'b0),
    .use_csrc_arst(1'b0),
    .use_cdest_arst(1'b0),
    .use_dsrc_arst(1'b0),
    .use_ddest_arst(1'b0),
    .link_BA(1'b0),
    .link_CB(1'b0),
    .link_DC(1'b0),
  ) _TECHMAP_REPLACE_ (
    .CK1(1'b0),
    .CK2(1'b0),
    .ASRSTI(1'b0),
    .ADRSTI(1'b0),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(1'b0),
    .BDRSTI(1'b0),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(1'b0),
    .CDRSTI(1'b0),
    .CI1(1'b0),
    .CI2(1'b0),
    .CI3(1'b0),
    .CI4(1'b0),
    .CI5(1'b0),
    .CI6(1'b0),
    .DSRSTI(1'b0),
    .DDRSTI(1'b0),
    .DI1(1'b0),
    .DI2(1'b0),
    .DI3(1'b0),
    .DI4(1'b0),
    .DI5(1'b0),
    .DI6(1'b0),
  );
endmodule

module NX_XCDC_U(CK1, CK2, ASRSTI, ADRSTI, ASRSTO, ADRSTO, BSRSTI, BDRSTI, BSRSTO, BDRSTO, CSRSTI, CDRSTI, CSRSTO, CDRSTO, DSRSTI, DDRSTI, DSRSTO, DDRSTO, BI, CI, CO
, AO, BO, AI, DI, DO);
    input ADRSTI;
    output ADRSTO;
    input [5:0] AI;
    output [5:0] AO;
    input ASRSTI;
    output ASRSTO;
    input BDRSTI;
    output BDRSTO;
    input [5:0] BI;
    output [5:0] BO;
    input BSRSTI;
    output BSRSTO;
    input CDRSTI;
    output CDRSTO;
    input [5:0] CI;
    input CK1;
    input CK2;
    output [5:0] CO;
    input CSRSTI;
    output CSRSTO;
    input DDRSTI;
    output DDRSTO;
    input [5:0] DI;
    output [5:0] DO;
    input DSRSTI;
    output DSRSTO;
    parameter ack_sel = 1'b0;
    parameter bck_sel = 1'b0;
    parameter cck_sel = 1'b0;
    parameter ck0_edge = 1'b0;
    parameter ck1_edge = 1'b0;
    parameter dck_sel = 1'b0;
    parameter link_BA = 1'b0;
    parameter link_CB = 1'b0;
    parameter link_DC = 1'b0;
    parameter use_adest_arst = 1'b0;
    parameter use_asrc_arst = 1'b0;
    parameter use_bdest_arst = 1'b0;
    parameter use_bsrc_arst = 1'b0;
    parameter use_cdest_arst = 1'b0;
    parameter use_csrc_arst = 1'b0;
    parameter use_ddest_arst = 1'b0;
    parameter use_dsrc_arst = 1'b0;

  NX_CDC_U #(
    .mode(5), // -- 5: XCDC
    .ck0_edge(ck0_edge),
    .ck1_edge(ck1_edge),
    .ack_sel(ack_sel),
    .bck_sel(bck_sel),
    .cck_sel(cck_sel),
    .dck_sel(dck_sel),
    .use_asrc_arst(use_asrc_arst),
    .use_adest_arst(use_adest_arst),
    .use_bsrc_arst(use_bsrc_arst),
    .use_bdest_arst(use_bdest_arst),
    .use_csrc_arst(use_csrc_arst),
    .use_cdest_arst(use_cdest_arst),
    .use_dsrc_arst(use_dsrc_arst),
    .use_ddest_arst(use_ddest_arst),
    .link_BA(link_BA),
    .link_CB(link_CB),
    .link_DC(link_DC),
  ) _TECHMAP_REPLACE_ (
    .CK1(CK1),
    .CK2(CK2),
    .ASRSTI(ASRSTI),
    .ADRSTI(ADRSTI),
    .ASRSTO(ASRSTO),
    .ADRSTO(ADRSTO),
    .AI1(AI[0]),
    .AI2(AI[1]),
    .AI3(AI[2]),
    .AI4(AI[3]),
    .AI5(AI[4]),
    .AI6(AI[5]),
    .AO1(AO[0]),
    .AO2(AO[1]),
    .AO3(AO[2]),
    .AO4(AO[3]),
    .AO5(AO[4]),
    .AO6(AO[5]),
    .BSRSTI(BSRSTI),
    .BDRSTI(BDRSTI),
    .BSRSTO(BSRSTO),
    .BDRSTO(BDRSTO),
    .BI1(BI[0]),
    .BI2(BI[1]),
    .BI3(BI[2]),
    .BI4(BI[3]),
    .BI5(BI[4]),
    .BI6(BI[5]),
    .BO1(BO[0]),
    .BO2(BO[1]),
    .BO3(BO[2]),
    .BO4(BO[3]),
    .BO5(BO[4]),
    .BO6(BO[5]),
    .CSRSTI(CSRSTI),
    .CDRSTI(CDRSTI),
    .CSRSTO(CSRSTO),
    .CDRSTO(CDRSTO),
    .CI1(CI[0]),
    .CI2(CI[1]),
    .CI3(CI[2]),
    .CI4(CI[3]),
    .CI5(CI[4]),
    .CI6(CI[5]),
    .CO1(CO[0]),
    .CO2(CO[1]),
    .CO3(CO[2]),
    .CO4(CO[3]),
    .CO5(CO[4]),
    .CO6(CO[5]),
    .DSRSTI(DSRSTI),
    .DDRSTI(DDRSTI),
    .DSRSTO(DSRSTO),
    .DDRSTO(DDRSTO),
    .DI1(DI[0]),
    .DI2(DI[1]),
    .DI3(DI[2]),
    .DI4(DI[3]),
    .DI5(DI[4]),
    .DI6(DI[5]),
    .DO1(DO[0]),
    .DO2(DO[1]),
    .DO3(DO[2]),
    .DO4(DO[3]),
    .DO5(DO[4]),
    .DO6(DO[5]),
  );
endmodule

module NX_DSP_U_SPLIT(CK, R, RZ, WE, WEZ, CI, CCI, CO42, CO56, OVF, CCO, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO, CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [23:0] CAI;
    output [23:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO42;
    output CO56;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    input WEZ;
    output [55:0] Z;
    parameter ALU_DYNAMIC_OP = 2'b00;
    parameter ALU_OP = 3'b000;
    parameter ENABLE_PR_A_RST = 1'b0;
    parameter ENABLE_PR_B_RST = 1'b0;
    parameter ENABLE_PR_CCO_RST = 1'b0;
    parameter ENABLE_PR_CI_RST = 1'b0;
    parameter ENABLE_PR_CO_RST = 1'b0;
    parameter ENABLE_PR_CZ_RST = 1'b0;
    parameter ENABLE_PR_C_RST = 1'b0;
    parameter ENABLE_PR_D_RST = 1'b0;
    parameter ENABLE_PR_MULT_RST = 1'b0;
    parameter ENABLE_PR_OV_RST = 1'b0;
    parameter ENABLE_PR_P_RST = 1'b0;
    parameter ENABLE_PR_X_RST = 1'b0;
    parameter ENABLE_PR_Y_RST = 1'b0;
    parameter ENABLE_PR_Z_RST = 1'b0;
    parameter ENABLE_SATURATION = 1'b0;
    parameter INV_RST = 1'b0;
    parameter INV_RSTZ = 1'b0;
    parameter INV_WE = 1'b0;
    parameter INV_WEZ = 1'b0;
    parameter MUX_A = 1'b0;
    parameter MUX_B = 1'b0;
    parameter MUX_CCI = 1'b0;
    parameter MUX_CCO = 1'b0;
    parameter MUX_CI = 1'b0;
    parameter MUX_CZ = 1'b0;
    parameter MUX_P = 1'b0;
    parameter MUX_X = 3'b000;
    parameter MUX_Y = 1'b0;
    parameter MUX_Z = 1'b0;
    parameter PRE_ADDER_OP = 1'b0;
    parameter PR_A_CASCADE_MUX = 2'b00;
    parameter PR_A_MUX = 2'b00;
    parameter PR_B_CASCADE_MUX = 2'b00;
    parameter PR_B_MUX = 2'b00;
    parameter PR_CCO_MUX = 1'b0;
    parameter PR_CI_MUX = 1'b0;
    parameter PR_CO_MUX = 1'b0;
    parameter PR_CZ_MUX = 1'b0;
    parameter PR_C_MUX = 1'b0;
    parameter PR_D_MUX = 1'b0;
    parameter PR_MULT_MUX = 1'b0;
    parameter PR_OV_MUX = 1'b0;
    parameter PR_P_MUX = 1'b0;
    parameter PR_RSTZ_MUX = 1'b0;
    parameter PR_RST_MUX = 1'b0;
    parameter PR_WEZ_MUX = 1'b0;
    parameter PR_WE_MUX = 1'b0;
    parameter PR_X_MUX = 1'b0;
    parameter PR_Y_MUX = 1'b0;
    parameter PR_Z_MUX = 1'b0;
    parameter SATURATION_RANK = 6'b000000;
    parameter SIGNED_MODE = 1'b0;

    localparam RAW_CONFIG0_GEN = { INV_WE, INV_WEZ, INV_RST, INV_RSTZ, MUX_CCO, ALU_DYNAMIC_OP, SATURATION_RANK,
     ENABLE_SATURATION, MUX_Z, MUX_CCI, MUX_CI, MUX_Y, MUX_CZ, MUX_X, MUX_P,
     MUX_B, MUX_A, PRE_ADDER_OP, SIGNED_MODE };

    localparam RAW_CONFIG1_GEN = { PR_WE_MUX, PR_WEZ_MUX, PR_RST_MUX, PR_RSTZ_MUX, PR_OV_MUX, PR_CO_MUX, PR_CCO_MUX,
    PR_Z_MUX, PR_CZ_MUX, PR_Y_MUX, PR_X_MUX, PR_CI_MUX, PR_MULT_MUX, PR_P_MUX, PR_D_MUX,
    PR_C_MUX, PR_B_CASCADE_MUX, PR_B_MUX, PR_A_CASCADE_MUX, PR_A_MUX };

    localparam RAW_CONFIG2_GEN = { ENABLE_PR_OV_RST, ENABLE_PR_CO_RST, ENABLE_PR_CCO_RST, ENABLE_PR_Z_RST, ENABLE_PR_CZ_RST,
    ENABLE_PR_MULT_RST, ENABLE_PR_Y_RST, ENABLE_PR_X_RST, ENABLE_PR_P_RST, ENABLE_PR_CI_RST,
    ENABLE_PR_D_RST, ENABLE_PR_C_RST, ENABLE_PR_B_RST, ENABLE_PR_A_RST };

    localparam RAW_CONFIG3_GEN = { ALU_OP };

  NX_DSP_U #(
    .std_mode(""),
    .raw_config0(RAW_CONFIG0_GEN),
    .raw_config1(RAW_CONFIG1_GEN),
    .raw_config2(RAW_CONFIG2_GEN),
    .raw_config3(RAW_CONFIG3_GEN)
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),
    .CAI19(CAI[18]),
    .CAI20(CAI[19]),
    .CAI21(CAI[20]),
    .CAI22(CAI[21]),
    .CAI23(CAI[22]),
    .CAI24(CAI[23]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),
    .CAO19(CAO[18]),
    .CAO20(CAO[19]),
    .CAO21(CAO[20]),
    .CAO22(CAO[21]),
    .CAO23(CAO[22]),
    .CAO24(CAO[23]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO43(CO42),
    .CO57(CO56),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),
    .WEZ(WEZ),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_DSP_U_WRAP(CCI, CCO, CI, CK, CO43, CO57, OVF, R, RZ, WE, WEZ, A, B, C, D, Z, CAI, CBI, CZI, CAO, CBO
, CZO);
    input [23:0] A;
    input [17:0] B;
    input [35:0] C;
    input [23:0] CAI;
    output [23:0] CAO;
    input [17:0] CBI;
    output [17:0] CBO;
    input CCI;
    output CCO;
    input CI;
    input CK;
    output CO43;
    output CO57;
    input [55:0] CZI;
    output [55:0] CZO;
    input [17:0] D;
    output OVF;
    input R;
    input RZ;
    input WE;
    input WEZ;
    output [55:0] Z;
    parameter raw_config0 = 27'b000000000000000000000000000;
    parameter raw_config1 = 24'b000000000000000000000000;
    parameter raw_config2 = 14'b00000000000000;
    parameter raw_config3 = 3'b000;
    parameter std_mode = "";

  NX_DSP_U #(
    .std_mode(std_mode),
    .raw_config0(raw_config0),
    .raw_config1(raw_config1),
    .raw_config2(raw_config2),
    .raw_config3(raw_config3)
  ) _TECHMAP_REPLACE_ (
    .A1(A[0]),
    .A2(A[1]),
    .A3(A[2]),
    .A4(A[3]),
    .A5(A[4]),
    .A6(A[5]),
    .A7(A[6]),
    .A8(A[7]),
    .A9(A[8]),
    .A10(A[9]),
    .A11(A[10]),
    .A12(A[11]),
    .A13(A[12]),
    .A14(A[13]),
    .A15(A[14]),
    .A16(A[15]),
    .A17(A[16]),
    .A18(A[17]),
    .A19(A[18]),
    .A20(A[19]),
    .A21(A[20]),
    .A22(A[21]),
    .A23(A[22]),
    .A24(A[23]),

    .B1(B[0]),
    .B2(B[1]),
    .B3(B[2]),
    .B4(B[3]),
    .B5(B[4]),
    .B6(B[5]),
    .B7(B[6]),
    .B8(B[7]),
    .B9(B[8]),
    .B10(B[9]),
    .B11(B[10]),
    .B12(B[11]),
    .B13(B[12]),
    .B14(B[13]),
    .B15(B[14]),
    .B16(B[15]),
    .B17(B[16]),
    .B18(B[17]),

    .C1(C[0]),
    .C2(C[1]),
    .C3(C[2]),
    .C4(C[3]),
    .C5(C[4]),
    .C6(C[5]),
    .C7(C[6]),
    .C8(C[7]),
    .C9(C[8]),
    .C10(C[9]),
    .C11(C[10]),
    .C12(C[11]),
    .C13(C[12]),
    .C14(C[13]),
    .C15(C[14]),
    .C16(C[15]),
    .C17(C[16]),
    .C18(C[17]),
    .C19(C[18]),
    .C20(C[19]),
    .C21(C[20]),
    .C22(C[21]),
    .C23(C[22]),
    .C24(C[23]),
    .C25(C[24]),
    .C26(C[25]),
    .C27(C[26]),
    .C28(C[27]),
    .C29(C[28]),
    .C30(C[29]),
    .C31(C[30]),
    .C32(C[31]),
    .C33(C[32]),
    .C34(C[33]),
    .C35(C[34]),
    .C36(C[35]),

    .CAI1(CAI[0]),
    .CAI2(CAI[1]),
    .CAI3(CAI[2]),
    .CAI4(CAI[3]),
    .CAI5(CAI[4]),
    .CAI6(CAI[5]),
    .CAI7(CAI[6]),
    .CAI8(CAI[7]),
    .CAI9(CAI[8]),
    .CAI10(CAI[9]),
    .CAI11(CAI[10]),
    .CAI12(CAI[11]),
    .CAI13(CAI[12]),
    .CAI14(CAI[13]),
    .CAI15(CAI[14]),
    .CAI16(CAI[15]),
    .CAI17(CAI[16]),
    .CAI18(CAI[17]),
    .CAI19(CAI[18]),
    .CAI20(CAI[19]),
    .CAI21(CAI[20]),
    .CAI22(CAI[21]),
    .CAI23(CAI[22]),
    .CAI24(CAI[23]),

    .CAO1(CAO[0]),
    .CAO2(CAO[1]),
    .CAO3(CAO[2]),
    .CAO4(CAO[3]),
    .CAO5(CAO[4]),
    .CAO6(CAO[5]),
    .CAO7(CAO[6]),
    .CAO8(CAO[7]),
    .CAO9(CAO[8]),
    .CAO10(CAO[9]),
    .CAO11(CAO[10]),
    .CAO12(CAO[11]),
    .CAO13(CAO[12]),
    .CAO14(CAO[13]),
    .CAO15(CAO[14]),
    .CAO16(CAO[15]),
    .CAO17(CAO[16]),
    .CAO18(CAO[17]),
    .CAO19(CAO[18]),
    .CAO20(CAO[19]),
    .CAO21(CAO[20]),
    .CAO22(CAO[21]),
    .CAO23(CAO[22]),
    .CAO24(CAO[23]),

    .CBI1(CBI[0]),
    .CBI2(CBI[1]),
    .CBI3(CBI[2]),
    .CBI4(CBI[3]),
    .CBI5(CBI[4]),
    .CBI6(CBI[5]),
    .CBI7(CBI[6]),
    .CBI8(CBI[7]),
    .CBI9(CBI[8]),
    .CBI10(CBI[9]),
    .CBI11(CBI[10]),
    .CBI12(CBI[11]),
    .CBI13(CBI[12]),
    .CBI14(CBI[13]),
    .CBI15(CBI[14]),
    .CBI16(CBI[15]),
    .CBI17(CBI[16]),
    .CBI18(CBI[17]),

    .CBO1(CBO[0]),
    .CBO2(CBO[1]),
    .CBO3(CBO[2]),
    .CBO4(CBO[3]),
    .CBO5(CBO[4]),
    .CBO6(CBO[5]),
    .CBO7(CBO[6]),
    .CBO8(CBO[7]),
    .CBO9(CBO[8]),
    .CBO10(CBO[9]),
    .CBO11(CBO[10]),
    .CBO12(CBO[11]),
    .CBO13(CBO[12]),
    .CBO14(CBO[13]),
    .CBO15(CBO[14]),
    .CBO16(CBO[15]),
    .CBO17(CBO[16]),
    .CBO18(CBO[17]),

    .CCI(CCI),
    .CCO(CCO),
    .CI(CI),
    .CK(CK),
    .CO43(CO43),
    .CO57(CO57),

    .CZI1(CZI[0]),
    .CZI2(CZI[1]),
    .CZI3(CZI[2]),
    .CZI4(CZI[3]),
    .CZI5(CZI[4]),
    .CZI6(CZI[5]),
    .CZI7(CZI[6]),
    .CZI8(CZI[7]),
    .CZI9(CZI[8]),
    .CZI10(CZI[9]),
    .CZI11(CZI[10]),
    .CZI12(CZI[11]),
    .CZI13(CZI[12]),
    .CZI14(CZI[13]),
    .CZI15(CZI[14]),
    .CZI16(CZI[15]),
    .CZI17(CZI[16]),
    .CZI18(CZI[17]),
    .CZI19(CZI[18]),
    .CZI20(CZI[19]),
    .CZI21(CZI[20]),
    .CZI22(CZI[21]),
    .CZI23(CZI[22]),
    .CZI24(CZI[23]),
    .CZI25(CZI[24]),
    .CZI26(CZI[25]),
    .CZI27(CZI[26]),
    .CZI28(CZI[27]),
    .CZI29(CZI[28]),
    .CZI30(CZI[29]),
    .CZI31(CZI[30]),
    .CZI32(CZI[31]),
    .CZI33(CZI[32]),
    .CZI34(CZI[33]),
    .CZI35(CZI[34]),
    .CZI36(CZI[35]),
    .CZI37(CZI[36]),
    .CZI38(CZI[37]),
    .CZI39(CZI[38]),
    .CZI40(CZI[39]),
    .CZI41(CZI[40]),
    .CZI42(CZI[41]),
    .CZI43(CZI[42]),
    .CZI44(CZI[43]),
    .CZI45(CZI[44]),
    .CZI46(CZI[45]),
    .CZI47(CZI[46]),
    .CZI48(CZI[47]),
    .CZI49(CZI[48]),
    .CZI50(CZI[49]),
    .CZI51(CZI[50]),
    .CZI52(CZI[51]),
    .CZI53(CZI[52]),
    .CZI54(CZI[53]),
    .CZI55(CZI[54]),
    .CZI56(CZI[55]),

    .CZO1(CZO[0]),
    .CZO2(CZO[1]),
    .CZO3(CZO[2]),
    .CZO4(CZO[3]),
    .CZO5(CZO[4]),
    .CZO6(CZO[5]),
    .CZO7(CZO[6]),
    .CZO8(CZO[7]),
    .CZO9(CZO[8]),
    .CZO10(CZO[9]),
    .CZO11(CZO[10]),
    .CZO12(CZO[11]),
    .CZO13(CZO[12]),
    .CZO14(CZO[13]),
    .CZO15(CZO[14]),
    .CZO16(CZO[15]),
    .CZO17(CZO[16]),
    .CZO18(CZO[17]),
    .CZO19(CZO[18]),
    .CZO20(CZO[19]),
    .CZO21(CZO[20]),
    .CZO22(CZO[21]),
    .CZO23(CZO[22]),
    .CZO24(CZO[23]),
    .CZO25(CZO[24]),
    .CZO26(CZO[25]),
    .CZO27(CZO[26]),
    .CZO28(CZO[27]),
    .CZO29(CZO[28]),
    .CZO30(CZO[29]),
    .CZO31(CZO[30]),
    .CZO32(CZO[31]),
    .CZO33(CZO[32]),
    .CZO34(CZO[33]),
    .CZO35(CZO[34]),
    .CZO36(CZO[35]),
    .CZO37(CZO[36]),
    .CZO38(CZO[37]),
    .CZO39(CZO[38]),
    .CZO40(CZO[39]),
    .CZO41(CZO[40]),
    .CZO42(CZO[41]),
    .CZO43(CZO[42]),
    .CZO44(CZO[43]),
    .CZO45(CZO[44]),
    .CZO46(CZO[45]),
    .CZO47(CZO[46]),
    .CZO48(CZO[47]),
    .CZO49(CZO[48]),
    .CZO50(CZO[49]),
    .CZO51(CZO[50]),
    .CZO52(CZO[51]),
    .CZO53(CZO[52]),
    .CZO54(CZO[53]),
    .CZO55(CZO[54]),
    .CZO56(CZO[55]),

    .D1(D[0]),
    .D2(D[1]),
    .D3(D[2]),
    .D4(D[3]),
    .D5(D[4]),
    .D6(D[5]),
    .D7(D[6]),
    .D8(D[7]),
    .D9(D[8]),
    .D10(D[9]),
    .D11(D[10]),
    .D12(D[11]),
    .D13(D[12]),
    .D14(D[13]),
    .D15(D[14]),
    .D16(D[15]),
    .D17(D[16]),
    .D18(D[17]),

    .OVF(OVF),
    .R(R),
    .RZ(RZ),
    .WE(WE),
    .WEZ(WEZ),

    .Z1(Z[0]),
    .Z2(Z[1]),
    .Z3(Z[2]),
    .Z4(Z[3]),
    .Z5(Z[4]),
    .Z6(Z[5]),
    .Z7(Z[6]),
    .Z8(Z[7]),
    .Z9(Z[8]),
    .Z10(Z[9]),
    .Z11(Z[10]),
    .Z12(Z[11]),
    .Z13(Z[12]),
    .Z14(Z[13]),
    .Z15(Z[14]),
    .Z16(Z[15]),
    .Z17(Z[16]),
    .Z18(Z[17]),
    .Z19(Z[18]),
    .Z20(Z[19]),
    .Z21(Z[20]),
    .Z22(Z[21]),
    .Z23(Z[22]),
    .Z24(Z[23]),
    .Z25(Z[24]),
    .Z26(Z[25]),
    .Z27(Z[26]),
    .Z28(Z[27]),
    .Z29(Z[28]),
    .Z30(Z[29]),
    .Z31(Z[30]),
    .Z32(Z[31]),
    .Z33(Z[32]),
    .Z34(Z[33]),
    .Z35(Z[34]),
    .Z36(Z[35]),
    .Z37(Z[36]),
    .Z38(Z[37]),
    .Z39(Z[38]),
    .Z40(Z[39]),
    .Z41(Z[40]),
    .Z42(Z[41]),
    .Z43(Z[42]),
    .Z44(Z[43]),
    .Z45(Z[44]),
    .Z46(Z[45]),
    .Z47(Z[46]),
    .Z48(Z[47]),
    .Z49(Z[48]),
    .Z50(Z[49]),
    .Z51(Z[50]),
    .Z52(Z[51]),
    .Z53(Z[52]),
    .Z54(Z[53]),
    .Z55(Z[54]),
    .Z56(Z[55])
  );
endmodule

module NX_PLL_U_WRAP(R, REF, FBK, OSC, VCO, LDFO, REFO, PLL_LOCKED, PLL_LOCKEDA, ARST_CAL, CLK_CAL, CLK_CAL_DIV, CAL_LOCKED, EXT_CAL_LOCKED, CAL, CLK_DIVD, EXT_CAL, CLK_DIV);
    input ARST_CAL;
    output [4:0] CAL;
    output CAL_LOCKED;
    input CLK_CAL;
    output CLK_CAL_DIV;
    output [3:0] CLK_DIV;
    output [4:0] CLK_DIVD;
    input [4:0] EXT_CAL;
    input EXT_CAL_LOCKED;
    input FBK;
    output LDFO;
    output OSC;
    output PLL_LOCKED;
    output PLL_LOCKEDA;
    input R;
    input REF;
    output REFO;
    output VCO;
    parameter cal_delay = 6'b011011;
    parameter cal_div = 4'b0111;
    parameter clk_cal_sel = 2'b01;
    parameter clk_outdiv1 = 3'b000;
    parameter clk_outdiv2 = 3'b000;
    parameter clk_outdiv3 = 3'b000;
    parameter clk_outdiv4 = 3'b000;
    parameter clk_outdivd1 = 4'b0000;
    parameter clk_outdivd2 = 4'b0000;
    parameter clk_outdivd3 = 4'b0000;
    parameter clk_outdivd4 = 4'b0000;
    parameter clk_outdivd5 = 4'b0000;
    parameter ext_fbk_on = 1'b0;
    parameter fbk_delay = 6'b000000;
    parameter fbk_delay_on = 1'b0;
    parameter fbk_intdiv = 7'b0000000;
    parameter location = "";
    parameter pll_cpump = 4'b0000;
    parameter pll_lock = 4'b0000;
    parameter pll_lpf_cap = 4'b0000;
    parameter pll_lpf_res = 4'b0000;
    parameter pll_odf = 2'b00;
    parameter ref_intdiv = 5'b00000;
    parameter ref_osc_on = 1'b0;
    parameter use_cal = 1'b0;
    parameter use_pll = 1'b1;

  NX_PLL_U #(
    .cal_delay(cal_delay),
    .cal_div(cal_div),
    .clk_cal_sel(clk_cal_sel),
    .clk_outdiv1(clk_outdiv1),
    .clk_outdiv2(clk_outdiv2),
    .clk_outdiv3(clk_outdiv3),
    .clk_outdiv4(clk_outdiv4),
    .clk_outdivd1(clk_outdivd1),
    .clk_outdivd2(clk_outdivd2),
    .clk_outdivd3(clk_outdivd3),
    .clk_outdivd4(clk_outdivd4),
    .clk_outdivd5(clk_outdivd5),
    .ext_fbk_on(ext_fbk_on),
    .fbk_delay(fbk_delay),
    .fbk_delay_on(fbk_delay_on),
    .fbk_intdiv(fbk_intdiv),
    .location(location),
    .pll_cpump(pll_cpump),
    .pll_lock(pll_lock),
    .pll_lpf_cap(pll_lpf_cap),
    .pll_lpf_res(pll_lpf_res),
    .pll_odf(pll_odf),
    .ref_intdiv(ref_intdiv),
    .ref_osc_on(ref_osc_on),
    .use_cal(use_cal),
    .use_pll(use_pll)
  ) _TECHMAP_REPLACE_ (
    .ARST_CAL(ARST_CAL),
    .CAL1(CAL[0]),
    .CAL2(CAL[1]),
    .CAL3(CAL[2]),
    .CAL4(CAL[3]),
    .CAL5(CAL[4]),
    .CAL_LOCKED(CAL_LOCKED),
    .CLK_CAL(CLK_CAL),
    .CLK_CAL_DIV(CLK_CAL_DIV),
    .CLK_DIV1(CLK_DIV[0]),
    .CLK_DIV2(CLK_DIV[1]),
    .CLK_DIV3(CLK_DIV[2]),
    .CLK_DIV4(CLK_DIV[3]),
    .CLK_DIVD1(CLK_DIVD[0]),
    .CLK_DIVD2(CLK_DIVD[1]),
    .CLK_DIVD3(CLK_DIVD[2]),
    .CLK_DIVD4(CLK_DIVD[3]),
    .CLK_DIVD5(CLK_DIVD[4]),
    .EXT_CAL1(EXT_CAL[0]),
    .EXT_CAL2(EXT_CAL[1]),
    .EXT_CAL3(EXT_CAL[2]),
    .EXT_CAL4(EXT_CAL[3]),
    .EXT_CAL5(EXT_CAL[4]),
    .EXT_CAL_LOCKED(EXT_CAL_LOCKED),
    .FBK(FBK),
    .LDFO(LDFO),
    .OSC(OSC),
    .PLL_LOCKED(PLL_LOCKED),
    .PLL_LOCKEDA(PLL_LOCKEDA),
    .R(R),
    .REF(REF),
    .REFO(REFO),
    .VCO(VCO)
  );
endmodule

module NX_RFBDP_U_WRAP(WCK, WE, WEA, I, O, RA, WA);
    input [17:0] I;
    output [17:0] O;
    input [4:0] RA;
    input [4:0] WA;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter wck_edge = 1'b0;

  NX_RFB_U #(
    .mode(0),
    .mem_ctxt(mem_ctxt),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .RA1(RA[0]),
    .RA2(RA[1]),
    .RA3(RA[2]),
    .RA4(RA[3]),
    .RA5(RA[4]),
    .RA6(),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(),
    .WE(WE),
    .WEA(WEA)
  );

endmodule

module NX_RFBSP_U_WRAP(WCK, WE, WEA, I, O, WA);
    input [17:0] I;
    output [17:0] O;
    input [4:0] WA;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter wck_edge = 1'b0;

  NX_RFB_U #(
    .mode(1),
    .mem_ctxt(mem_ctxt),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .RA1(),
    .RA2(),
    .RA3(),
    .RA4(),
    .RA5(),
    .RA6(),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(),
    .WE(WE),
    .WEA(WEA)
  );
endmodule

module NX_XRFB_64x18(WCK, WE, WEA, I, O, RA, WA);
    input [17:0] I;
    output [17:0] O;
    input [5:0] RA;
    input [5:0] WA;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter wck_edge = 1'b0;

  NX_RFB_U #(
    .mode(2),
    .mem_ctxt(mem_ctxt),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .RA1(RA[0]),
    .RA2(RA[1]),
    .RA3(RA[2]),
    .RA4(RA[3]),
    .RA5(RA[4]),
    .RA6(RA[5]),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(WA[5]),
    .WE(WE),
    .WEA(WEA)
  );
endmodule

module NX_XRFB_32x36(WCK, WE, WEA, I, O, RA, WA);
    input [35:0] I;
    output [35:0] O;
    input [4:0] RA;
    input [4:0] WA;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter wck_edge = 1'b0;

  NX_RFB_U #(
    .mode(3),
    .mem_ctxt(mem_ctxt),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(I[18]),
    .I20(I[19]),
    .I21(I[20]),
    .I22(I[21]),
    .I23(I[22]),
    .I24(I[23]),
    .I25(I[24]),
    .I26(I[25]),
    .I27(I[26]),
    .I28(I[27]),
    .I29(I[28]),
    .I30(I[29]),
    .I31(I[30]),
    .I32(I[31]),
    .I33(I[32]),
    .I34(I[33]),
    .I35(I[34]),
    .I36(I[35]),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .O19(O[18]),
    .O20(O[19]),
    .O21(O[20]),
    .O22(O[21]),
    .O23(O[22]),
    .O24(O[23]),
    .O25(O[24]),
    .O26(O[25]),
    .O27(O[26]),
    .O28(O[27]),
    .O29(O[28]),
    .O30(O[29]),
    .O31(O[30]),
    .O32(O[31]),
    .O33(O[32]),
    .O34(O[33]),
    .O35(O[34]),
    .O36(O[35]),
    .RA1(RA[0]),
    .RA2(RA[1]),
    .RA3(RA[2]),
    .RA4(RA[3]),
    .RA5(RA[4]),
    .RA6(),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(),
    .WE(WE),
    .WEA(WEA)
  );
endmodule

module NX_XRFB_2R_1W(WCK, WE, WEA, I, AO, BO, WA, ARA, BRA);
    output [17:0] AO;
    input [4:0] ARA;
    output [17:0] BO;
    input [4:0] BRA;
    input [17:0] I;
    input [4:0] WA;
    input WCK;
    input WE;
    input WEA;
    parameter mem_ctxt = "";
    parameter wck_edge = 1'b0;

  NX_RFB_U #(
    .mode(32'd4),
    .mem_ctxt(mem_ctxt),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(AO[0]),
    .O2(AO[1]),
    .O3(AO[2]),
    .O4(AO[3]),
    .O5(AO[4]),
    .O6(AO[5]),
    .O7(AO[6]),
    .O8(AO[7]),
    .O9(AO[8]),
    .O10(AO[9]),
    .O11(AO[10]),
    .O12(AO[11]),
    .O13(AO[12]),
    .O14(AO[13]),
    .O15(AO[14]),
    .O16(AO[15]),
    .O17(AO[16]),
    .O18(AO[17]),
    .O19(BO[0]),
    .O20(BO[1]),
    .O21(BO[2]),
    .O22(BO[3]),
    .O23(BO[4]),
    .O24(BO[5]),
    .O25(BO[6]),
    .O26(BO[7]),
    .O27(BO[8]),
    .O28(BO[9]),
    .O29(BO[10]),
    .O30(BO[11]),
    .O31(BO[12]),
    .O32(BO[13]),
    .O33(BO[14]),
    .O34(BO[15]),
    .O35(BO[16]),
    .O36(BO[17]),
    .RA1(ARA[0]),
    .RA2(ARA[1]),
    .RA3(ARA[2]),
    .RA4(ARA[3]),
    .RA5(ARA[4]),
    .RA6(BRA[0]),
    .RA7(BRA[1]),
    .RA8(BRA[2]),
    .RA9(BRA[3]),
    .RA10(BRA[4]),
    .WA1(WA[0]),
    .WA2(WA[1]),
    .WA3(WA[2]),
    .WA4(WA[3]),
    .WA5(WA[4]),
    .WA6(),
    .WE(WE),
    .WEA(WEA)
  );
endmodule

module NX_RFB(RCK, WCK, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, COR, ERR, O1
, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, RA1, RA2, RA3, RA4, RA5, RA6
, RE, WA1, WA2, WA3, WA4, WA5, WA6, WE);
    output COR;
    output ERR;
    input I1;
    input I10;
    input I11;
    input I12;
    input I13;
    input I14;
    input I15;
    input I16;
    input I2;
    input I3;
    input I4;
    input I5;
    input I6;
    input I7;
    input I8;
    input I9;
    output O1;
    output O10;
    output O11;
    output O12;
    output O13;
    output O14;
    output O15;
    output O16;
    output O2;
    output O3;
    output O4;
    output O5;
    output O6;
    output O7;
    output O8;
    output O9;
    input RA1;
    input RA2;
    input RA3;
    input RA4;
    input RA5;
    input RA6;
    input RCK;
    input RE;
    input WA1;
    input WA2;
    input WA3;
    input WA4;
    input WA5;
    input WA6;
    input WCK;
    input WE;
    parameter addr_mask = 5'b00000;
    parameter mem_ctxt = "";
    parameter rck_edge = 1'b0;
    parameter wck_edge = 1'b0;
    parameter we_mask = 1'b0;
    parameter wea_mask = 1'b0;

  wire [15:0] D;
  wire [15:0] Q;

  NX_RFB_U #(
    .mem_ctxt(mem_ctxt),
    .mode(2),
    .wck_edge(wck_edge)
  ) _TECHMAP_REPLACE_ (
    .WCK(WCK),
    .I1(I1),
    .I2(I2),
    .I3(I3),
    .I4(I4),
    .I5(I5),
    .I6(I6),
    .I7(I7),
    .I8(I8),
    .I9(I9),
    .I10(I10),
    .I11(I11),
    .I12(I12),
    .I13(I13),
    .I14(I14),
    .I15(I15),
    .I16(I16),
    .I17(),
    .I18(),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(D[0]),
    .O2(D[1]),
    .O3(D[2]),
    .O4(D[3]),
    .O5(D[4]),
    .O6(D[5]),
    .O7(D[6]),
    .O8(D[7]),
    .O9(D[8]),
    .O10(D[9]),
    .O11(D[10]),
    .O12(D[11]),
    .O13(D[12]),
    .O14(D[13]),
    .O15(D[14]),
    .O16(D[15]),
    .RA1(RA1),
    .RA2(RA2),
    .RA3(RA3),
    .RA4(RA4),
    .RA5(RA5),
    .RA6(RA6),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(WA1),
    .WA2(WA2),
    .WA3(WA3),
    .WA4(WA4),
    .WA5(WA5),
    .WA6(WA6),
    .WE(WE),
    .WEA()
  );

  genvar i;
  generate for (i = 0; i < 16; i = i + 1) begin:q_reg
    NX_DFF #(
      .dff_edge(rck_edge),
      .dff_init(1'b0),
      .dff_load(1'b1)
    ) out_reg_i (
        .CK(RCK),
        .I(D[i]),
        .L(RE),
        .R(),
        .O(Q[i])
    );
  end endgenerate;
  assign O1=Q[0];
  assign O2=Q[1];
  assign O3=Q[2];
  assign O4=Q[3];
  assign O5=Q[4];
  assign O6=Q[5];
  assign O7=Q[6];
  assign O8=Q[7];
  assign O9=Q[8];
  assign O10=Q[9];
  assign O11=Q[10];
  assign O12=Q[11];
  assign O13=Q[12];
  assign O14=Q[13];
  assign O15=Q[14];
  assign O16=Q[15];

  assign COR=1'b0;
  assign ERR=1'b0;
endmodule

module NX_FIFO_DPREG(RCK, WCK, WE, WEA, WRSTI, WRSTO, WEQ, RRSTI, RRSTO, REQ, I, O, WAI, WAO, RAI, RAO);
    input [17:0] I;
    output [17:0] O;
    input [5:0] RAI;
    output [5:0] RAO;
    input RCK;
    output REQ;
    input RRSTI;
    output RRSTO;
    input [5:0] WAI;
    output [5:0] WAO;
    input WCK;
    input WE;
    input WEA;
    output WEQ;
    input WRSTI;
    output WRSTO;
    parameter rck_edge = 1'b0;
    parameter read_addr_inv = 6'b000000;
    parameter use_read_arst = 1'b0;
    parameter use_write_arst = 1'b0;
    parameter wck_edge = 1'b0;

  NX_FIFO_U #(
    .mode(0),
    .wck_edge(wck_edge),
    .rck_edge(rck_edge),
    .read_addr_inv(read_addr_inv),
    .use_write_arst(use_write_arst),
    .use_read_arst(use_read_arst)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .WE(WE),
    .WEA(WEA),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .WRSTI(WRSTI),
    .WAI1(WAI[0]),
    .WAI2(WAI[1]),
    .WAI3(WAI[2]),
    .WAI4(WAI[3]),
    .WAI5(WAI[4]),
    .WAI6(WAI[5]),
    .WAI7(),
    .WRSTO(WRSTO),
    .WAO1(WAO[0]),
    .WAO2(WAO[1]),
    .WAO3(WAO[2]),
    .WAO4(WAO[3]),
    .WAO5(WAO[4]),
    .WAO6(WAO[5]),
    .WEQ1(WEQ),
    .RRSTI(RRSTI),
    .RAI1(RAI[0]),
    .RAI2(RAI[1]),
    .RAI3(RAI[2]),
    .RAI4(RAI[3]),
    .RAI5(RAI[4]),
    .RAI6(RAI[5]),
    .RAI7(),
    .RRSTO(RRSTO),
    .RAO1(RAO[0]),
    .RAO2(RAO[1]),
    .RAO3(RAO[2]),
    .RAO4(RAO[3]),
    .RAO5(RAO[4]),
    .RAO6(RAO[5]),
    .REQ1(REQ)
  );
endmodule

module NX_XFIFO_64x18(RCK, WCK, WE, WEA, WRSTI, RRSTI, I, O, WEQ, REQ, WAI, WAO, RAI, RAO);
    input [17:0] I;
    output [17:0] O;
    input [6:0] RAI;
    output [6:0] RAO;
    input RCK;
    output [1:0] REQ;
    input RRSTI;
    input [6:0] WAI;
    output [6:0] WAO;
    input WCK;
    input WE;
    input WEA;
    output [1:0] WEQ;
    input WRSTI;
    parameter rck_edge = 1'b0;
    parameter read_addr_inv = 7'b0000000;
    parameter use_read_arst = 1'b0;
    parameter use_write_arst = 1'b0;
    parameter wck_edge = 1'b0;

  NX_FIFO_U #(
    .mode(1),
    .wck_edge(wck_edge),
    .rck_edge(rck_edge),
    .read_addr_inv(read_addr_inv),
    .use_write_arst(use_write_arst),
    .use_read_arst(use_read_arst)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .WE(WE),
    .WEA(WEA),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .WRSTI(WRSTI),
    .WAI1(WAI[0]),
    .WAI2(WAI[1]),
    .WAI3(WAI[2]),
    .WAI4(WAI[3]),
    .WAI5(WAI[4]),
    .WAI6(WAI[5]),
    .WAI7(WAI[6]),
    .WAO1(WAO[0]),
    .WAO2(WAO[1]),
    .WAO3(WAO[2]),
    .WAO4(WAO[3]),
    .WAO5(WAO[4]),
    .WAO6(WAO[5]),
    .WAO7(WAO[6]),
    .WEQ1(WEQ[0]),
    .WEQ2(WEQ[1]),
    .RRSTI(RRSTI),
    .RAI1(RAI[0]),
    .RAI2(RAI[1]),
    .RAI3(RAI[2]),
    .RAI4(RAI[3]),
    .RAI5(RAI[4]),
    .RAI6(RAI[5]),
    .RAI7(RAI[6]),
    .RAO1(RAO[0]),
    .RAO2(RAO[1]),
    .RAO3(RAO[2]),
    .RAO4(RAO[3]),
    .RAO5(RAO[4]),
    .RAO6(RAO[5]),
    .RAO7(RAO[6]),
    .REQ1(REQ[0]),
    .REQ2(REQ[1])
  );
endmodule

module NX_XFIFO_32x36(RCK, WCK, WE, WEA, WRSTI, WEQ, RRSTI, REQ, I, O, WAI, WAO, RAI, RAO);
    input [35:0] I;
    output [35:0] O;
    input [5:0] RAI;
    output [5:0] RAO;
    input RCK;
    output REQ;
    input RRSTI;
    input [5:0] WAI;
    output [5:0] WAO;
    input WCK;
    input WE;
    input WEA;
    output WEQ;
    input WRSTI;
    parameter rck_edge = 1'b0;
    parameter read_addr_inv = 7'b0000000;
    parameter use_read_arst = 1'b0;
    parameter use_write_arst = 1'b0;
    parameter wck_edge = 1'b0;

  NX_FIFO_U #(
    .mode(2),
    .wck_edge(wck_edge),
    .rck_edge(rck_edge),
    .read_addr_inv(read_addr_inv),
    .use_write_arst(use_write_arst),
    .use_read_arst(use_read_arst)
  ) _TECHMAP_REPLACE_ (
    .RCK(RCK),
    .WCK(WCK),
    .WE(WE),
    .WEA(WEA),
    .I1(I[0]),
    .I2(I[1]),
    .I3(I[2]),
    .I4(I[3]),
    .I5(I[4]),
    .I6(I[5]),
    .I7(I[6]),
    .I8(I[7]),
    .I9(I[8]),
    .I10(I[9]),
    .I11(I[10]),
    .I12(I[11]),
    .I13(I[12]),
    .I14(I[13]),
    .I15(I[14]),
    .I16(I[15]),
    .I17(I[16]),
    .I18(I[17]),
    .I19(I[18]),
    .I20(I[19]),
    .I21(I[20]),
    .I22(I[21]),
    .I23(I[22]),
    .I24(I[23]),
    .I25(I[24]),
    .I26(I[25]),
    .I27(I[26]),
    .I28(I[27]),
    .I29(I[28]),
    .I30(I[29]),
    .I31(I[30]),
    .I32(I[31]),
    .I33(I[32]),
    .I34(I[33]),
    .I35(I[34]),
    .I36(I[35]),
    .O1(O[0]),
    .O2(O[1]),
    .O3(O[2]),
    .O4(O[3]),
    .O5(O[4]),
    .O6(O[5]),
    .O7(O[6]),
    .O8(O[7]),
    .O9(O[8]),
    .O10(O[9]),
    .O11(O[10]),
    .O12(O[11]),
    .O13(O[12]),
    .O14(O[13]),
    .O15(O[14]),
    .O16(O[15]),
    .O17(O[16]),
    .O18(O[17]),
    .O19(O[18]),
    .O20(O[19]),
    .O21(O[20]),
    .O22(O[21]),
    .O23(O[22]),
    .O24(O[23]),
    .O25(O[24]),
    .O26(O[25]),
    .O27(O[26]),
    .O28(O[27]),
    .O29(O[28]),
    .O30(O[29]),
    .O31(O[30]),
    .O32(O[31]),
    .O33(O[32]),
    .O34(O[33]),
    .O35(O[34]),
    .O36(O[35]),
    .WRSTI(WRSTI),
    .WAI1(WAI[0]),
    .WAI2(WAI[1]),
    .WAI3(WAI[2]),
    .WAI4(WAI[3]),
    .WAI5(WAI[4]),
    .WAI6(WAI[5]),
    .WAI7(),
    .WAO1(WAO[0]),
    .WAO2(WAO[1]),
    .WAO3(WAO[2]),
    .WAO4(WAO[3]),
    .WAO5(WAO[4]),
    .WAO6(WAO[5]),
    .WEQ1(WEQ),
    .RRSTI(RRSTI),
    .RAI1(RAI[0]),
    .RAI2(RAI[1]),
    .RAI3(RAI[2]),
    .RAI4(RAI[3]),
    .RAI5(RAI[4]),
    .RAI6(RAI[5]),
    .RAI7(),
    .RAO1(RAO[0]),
    .RAO2(RAO[1]),
    .RAO3(RAO[2]),
    .RAO4(RAO[3]),
    .RAO5(RAO[4]),
    .RAO6(RAO[5]),
    .REQ1(REQ)
  );
endmodule

//TODO
module ACC84_2DSP(clk, rst, X, Z);
    input [83:0] X;
    output [84:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 2;
endmodule

//TODO
module ACC92_2DSP(clk, rst, X, Z);
    input [55:0] X;
    output [91:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 2;
endmodule

//TODO
module ACC98_2DSP(clk, rst, X, Z);
    input [55:0] X;
    output [97:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 2;
endmodule

//TODO
module ADD84_1DSP_2CYCLES(clk, rst, X, Y, Z);
    input [41:0] X;
    input [41:0] Y;
    output [84:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module ADD84_2DSP(clk, rst, X, Y, Z);
    input [83:0] X;
    input [83:0] Y;
    output [84:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module SMACC24x18_1DSP(clk, rst, A, B, Z);
    input [23:0] A;
    input [17:0] B;
    output [55:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 1;
endmodule

//TODO
module SMACC24x32_2DSP(clk, rst, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [55:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 1;
endmodule

//TODO
module SMACC24x32_enable_2DSP(clk, rst, we, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [55:0] Z;
    input clk;
    input rst;
    input we;
    parameter STAGE_1 = "false";
    parameter STAGE_2 = "false";
    parameter STAGE_3 = "false";
    parameter STAGE_4 = "false";
endmodule

//TODO
module SMUL24x32_2DSP(clk, rst, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [54:0] Z;
    input clk;
    input rst;
    parameter g_pipe = 1;
endmodule

//TODO
module SMUL24x32_2DSP_ACC_2DSP(clk, rst, we, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [97:0] Z;
    input clk;
    input rst;
    input we;
    parameter STAGE_1 = "false";
    parameter STAGE_2 = "false";
    parameter STAGE_3 = "false";
endmodule

//TODO
module SMUL47x35_4DSP(clk, rst, A, B, Z);
    input [46:0] A;
    input [34:0] B;
    output [80:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMADD24_2DSP(clk, rst, A, B, C, Z);
    input [23:0] A;
    input [31:0] B;
    input [55:0] C;
    output [55:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL24x32_1DSP_2CYCLES(clk, rst, A, B, Z);
    input [23:0] A;
    input [15:0] B;
    output [55:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL24x32_2DSP(clk, rst, A, B, Z);
    input [23:0] A;
    input [31:0] B;
    output [55:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL24x36_1DSP_2CYCLES(clk, rst, A, B, Z);
    input [23:0] A;
    input [17:0] B;
    output [59:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL24x36_2DSP(clk, rst, A, B, Z);
    input [23:0] A;
    input [35:0] B;
    output [59:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL48x36_1DSP_4CYCLES(clk, rst, A, B, Z);
    input [23:0] A;
    input [17:0] B;
    output [83:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module UMUL48x36_4DSP(clk, rst, A, B, Z);
    input [47:0] A;
    input [35:0] B;
    output [83:0] Z;
    input clk;
    input rst;
    parameter piped = "true";
endmodule

//TODO
module NX_HSSL_U_FULL(hssl_clk_user_tx_i, hssl_clk_user_rx_i, hssl_clk_ref_i, hssl_clock_o, hssl_rclock_o, usr_dyn_cfg_en_i, usr_dyn_cfg_calibration_cs_n_i, usr_dyn_cfg_we_n_i, usr_dyn_cfg_wdata_sel_i, usr_pll_pma_rst_n_i, usr_pll_pma_pwr_down_n_i, usr_main_rst_n_i, usr_pll_lock_o, usr_pll_pma_lock_analog_o, usr_pll_ckfb_lock_o, usr_calibrate_pma_out_o, usr_main_async_debug_ack_i, usr_main_async_debug_req_o, scan_en_i, usr_tx0_ctrl_replace_en_i, usr_tx0_rst_n_i
, usr_tx0_busy_o, usr_tx0_ctrl_invalid_k_o, usr_tx0_ctrl_driver_pwrdwn_n_i, usr_tx0_pma_clk_en_i, usr_tx0_pma_tx_clk_o, usr_rx0_ctrl_dscr_en_i, usr_rx0_ctrl_dec_en_i, usr_rx0_ctrl_align_en_i, usr_rx0_ctrl_align_sync_i, usr_rx0_ctrl_replace_en_i, usr_rx0_ctrl_el_buff_rst_i, usr_rx0_rst_n_i, usr_rx0_pma_rst_n_i, usr_rx0_pma_m_eye_rst_i, usr_rx0_pma_pwr_down_n_i, usr_rx0_ctrl_char_is_aligned_o, usr_rx0_ctrl_valid_realign_o, usr_rx0_busy_o, usr_rx0_pma_loss_of_signal_o, usr_rx0_pma_ll_fast_locked_o, usr_rx0_pma_ll_slow_locked_o
, usr_rx0_pma_pll_lock_o, usr_rx0_pma_pll_lock_track_o, usr_tx1_ctrl_replace_en_i, usr_tx1_rst_n_i, usr_tx1_busy_o, usr_tx1_ctrl_invalid_k_o, usr_tx1_ctrl_driver_pwrdwn_n_i, usr_tx1_pma_clk_en_i, usr_tx1_pma_tx_clk_o, usr_rx1_ctrl_dscr_en_i, usr_rx1_ctrl_dec_en_i, usr_rx1_ctrl_align_en_i, usr_rx1_ctrl_align_sync_i, usr_rx1_ctrl_replace_en_i, usr_rx1_ctrl_el_buff_rst_i, usr_rx1_rst_n_i, usr_rx1_pma_rst_n_i, usr_rx1_pma_m_eye_rst_i, usr_rx1_pma_pwr_down_n_i, usr_rx1_ctrl_char_is_aligned_o, usr_rx1_ctrl_valid_realign_o
, usr_rx1_busy_o, usr_rx1_pma_loss_of_signal_o, usr_rx1_pma_ll_fast_locked_o, usr_rx1_pma_ll_slow_locked_o, usr_rx1_pma_pll_lock_o, usr_rx1_pma_pll_lock_track_o, usr_tx2_ctrl_replace_en_i, usr_tx2_rst_n_i, usr_tx2_busy_o, usr_tx2_ctrl_invalid_k_o, usr_tx2_ctrl_driver_pwrdwn_n_i, usr_tx2_pma_clk_en_i, usr_tx2_pma_tx_clk_o, usr_rx2_ctrl_dscr_en_i, usr_rx2_ctrl_dec_en_i, usr_rx2_ctrl_align_en_i, usr_rx2_ctrl_align_sync_i, usr_rx2_ctrl_replace_en_i, usr_rx2_ctrl_el_buff_rst_i, usr_rx2_rst_n_i, usr_rx2_pma_rst_n_i
, usr_rx2_pma_m_eye_rst_i, usr_rx2_pma_pwr_down_n_i, usr_rx2_ctrl_char_is_aligned_o, usr_rx2_ctrl_valid_realign_o, usr_rx2_busy_o, usr_rx2_pma_loss_of_signal_o, usr_rx2_pma_ll_fast_locked_o, usr_rx2_pma_ll_slow_locked_o, usr_rx2_pma_pll_lock_o, usr_rx2_pma_pll_lock_track_o, usr_tx3_ctrl_replace_en_i, usr_tx3_rst_n_i, usr_tx3_busy_o, usr_tx3_ctrl_invalid_k_o, usr_tx3_ctrl_driver_pwrdwn_n_i, usr_tx3_pma_clk_en_i, usr_tx3_pma_tx_clk_o, usr_rx3_ctrl_dscr_en_i, usr_rx3_ctrl_dec_en_i, usr_rx3_ctrl_align_en_i, usr_rx3_ctrl_align_sync_i
, usr_rx3_ctrl_replace_en_i, usr_rx3_ctrl_el_buff_rst_i, usr_rx3_rst_n_i, usr_rx3_pma_rst_n_i, usr_rx3_pma_m_eye_rst_i, usr_rx3_pma_pwr_down_n_i, usr_rx3_ctrl_char_is_aligned_o, usr_rx3_ctrl_valid_realign_o, usr_rx3_busy_o, usr_rx3_pma_loss_of_signal_o, usr_rx3_pma_ll_fast_locked_o, usr_rx3_pma_ll_slow_locked_o, usr_rx3_pma_pll_lock_o, usr_rx3_pma_pll_lock_track_o, usr_tx0_ctrl_enc_en_i, usr_tx0_ctrl_char_is_k_i, usr_tx0_ctrl_scr_en_i, usr_tx0_ctrl_end_of_multiframe_i, usr_tx0_ctrl_end_of_frame_i, usr_tx0_data_i, usr_rx0_data_o
, usr_rx0_ctrl_ovs_bit_sel_i, usr_rx0_ctrl_char_is_comma_o, usr_rx0_ctrl_char_is_k_o, usr_rx0_ctrl_not_in_table_o, usr_rx0_ctrl_disp_err_o, usr_rx0_ctrl_char_is_a_o, usr_rx0_ctrl_char_is_f_o, usr_rx0_test_o, usr_tx1_ctrl_enc_en_i, usr_tx1_ctrl_char_is_k_i, usr_tx1_ctrl_scr_en_i, usr_tx1_ctrl_end_of_multiframe_i, usr_tx1_ctrl_end_of_frame_i, usr_tx1_data_i, usr_rx1_data_o, usr_rx1_ctrl_ovs_bit_sel_i, usr_rx1_ctrl_char_is_comma_o, usr_rx1_ctrl_char_is_k_o, usr_rx1_ctrl_not_in_table_o, usr_rx1_ctrl_disp_err_o, usr_rx1_ctrl_char_is_a_o
, usr_rx1_ctrl_char_is_f_o, usr_rx1_test_o, usr_tx2_ctrl_enc_en_i, usr_tx2_ctrl_char_is_k_i, usr_tx2_ctrl_scr_en_i, usr_tx2_ctrl_end_of_multiframe_i, usr_tx2_ctrl_end_of_frame_i, usr_tx2_data_i, usr_rx2_data_o, usr_rx2_ctrl_ovs_bit_sel_i, usr_rx2_ctrl_char_is_comma_o, usr_rx2_ctrl_char_is_k_o, usr_rx2_ctrl_not_in_table_o, usr_rx2_ctrl_disp_err_o, usr_rx2_ctrl_char_is_a_o, usr_rx2_ctrl_char_is_f_o, usr_rx2_test_o, usr_tx3_ctrl_enc_en_i, usr_tx3_ctrl_char_is_k_i, usr_tx3_ctrl_scr_en_i, usr_tx3_ctrl_end_of_multiframe_i
, usr_tx3_ctrl_end_of_frame_i, usr_tx3_data_i, usr_rx3_data_o, usr_rx3_ctrl_ovs_bit_sel_i, usr_rx3_ctrl_char_is_comma_o, usr_rx3_ctrl_char_is_k_o, usr_rx3_ctrl_not_in_table_o, usr_rx3_ctrl_disp_err_o, usr_rx3_ctrl_char_is_a_o, usr_rx3_ctrl_char_is_f_o, usr_rx3_test_o, usr_dyn_cfg_addr_i, usr_dyn_cfg_wdata_i, usr_main_async_debug_lane_sel_i, usr_main_rx_pma_ll_out_o, scan_in_i, scan_out_o, usr_rx0_ctrl_debug_sel_i, usr_rx1_ctrl_debug_sel_i, usr_rx2_ctrl_debug_sel_i, usr_rx3_ctrl_debug_sel_i
, usr_dyn_cfg_lane_cs_n_i);
    input hssl_clk_ref_i;
    input hssl_clk_user_rx_i;
    input hssl_clk_user_tx_i;
    output hssl_clock_o;
    output hssl_rclock_o;
    input scan_en_i;
    input [7:0] scan_in_i;
    output [7:0] scan_out_o;
    output usr_calibrate_pma_out_o;
    input [3:0] usr_dyn_cfg_addr_i;
    input usr_dyn_cfg_calibration_cs_n_i;
    input usr_dyn_cfg_en_i;
    input [3:0] usr_dyn_cfg_lane_cs_n_i;
    input [11:0] usr_dyn_cfg_wdata_i;
    input usr_dyn_cfg_wdata_sel_i;
    input usr_dyn_cfg_we_n_i;
    input usr_main_async_debug_ack_i;
    input [1:0] usr_main_async_debug_lane_sel_i;
    output usr_main_async_debug_req_o;
    input usr_main_rst_n_i;
    output [19:0] usr_main_rx_pma_ll_out_o;
    output usr_pll_ckfb_lock_o;
    output usr_pll_lock_o;
    output usr_pll_pma_lock_analog_o;
    input usr_pll_pma_pwr_down_n_i;
    input usr_pll_pma_rst_n_i;
    output usr_rx0_busy_o;
    input usr_rx0_ctrl_align_en_i;
    input usr_rx0_ctrl_align_sync_i;
    output [7:0] usr_rx0_ctrl_char_is_a_o;
    output usr_rx0_ctrl_char_is_aligned_o;
    output [7:0] usr_rx0_ctrl_char_is_comma_o;
    output [7:0] usr_rx0_ctrl_char_is_f_o;
    output [7:0] usr_rx0_ctrl_char_is_k_o;
    input [2:0] usr_rx0_ctrl_debug_sel_i;
    input usr_rx0_ctrl_dec_en_i;
    output [7:0] usr_rx0_ctrl_disp_err_o;
    input usr_rx0_ctrl_dscr_en_i;
    input usr_rx0_ctrl_el_buff_rst_i;
    output [7:0] usr_rx0_ctrl_not_in_table_o;
    input [1:0] usr_rx0_ctrl_ovs_bit_sel_i;
    input usr_rx0_ctrl_replace_en_i;
    output usr_rx0_ctrl_valid_realign_o;
    output [63:0] usr_rx0_data_o;
    output usr_rx0_pma_ll_fast_locked_o;
    output usr_rx0_pma_ll_slow_locked_o;
    output usr_rx0_pma_loss_of_signal_o;
    input usr_rx0_pma_m_eye_rst_i;
    output usr_rx0_pma_pll_lock_o;
    output usr_rx0_pma_pll_lock_track_o;
    input usr_rx0_pma_pwr_down_n_i;
    input usr_rx0_pma_rst_n_i;
    input usr_rx0_rst_n_i;
    output [7:0] usr_rx0_test_o;
    output usr_rx1_busy_o;
    input usr_rx1_ctrl_align_en_i;
    input usr_rx1_ctrl_align_sync_i;
    output [7:0] usr_rx1_ctrl_char_is_a_o;
    output usr_rx1_ctrl_char_is_aligned_o;
    output [7:0] usr_rx1_ctrl_char_is_comma_o;
    output [7:0] usr_rx1_ctrl_char_is_f_o;
    output [7:0] usr_rx1_ctrl_char_is_k_o;
    input [2:0] usr_rx1_ctrl_debug_sel_i;
    input usr_rx1_ctrl_dec_en_i;
    output [7:0] usr_rx1_ctrl_disp_err_o;
    input usr_rx1_ctrl_dscr_en_i;
    input usr_rx1_ctrl_el_buff_rst_i;
    output [7:0] usr_rx1_ctrl_not_in_table_o;
    input [1:0] usr_rx1_ctrl_ovs_bit_sel_i;
    input usr_rx1_ctrl_replace_en_i;
    output usr_rx1_ctrl_valid_realign_o;
    output [63:0] usr_rx1_data_o;
    output usr_rx1_pma_ll_fast_locked_o;
    output usr_rx1_pma_ll_slow_locked_o;
    output usr_rx1_pma_loss_of_signal_o;
    input usr_rx1_pma_m_eye_rst_i;
    output usr_rx1_pma_pll_lock_o;
    output usr_rx1_pma_pll_lock_track_o;
    input usr_rx1_pma_pwr_down_n_i;
    input usr_rx1_pma_rst_n_i;
    input usr_rx1_rst_n_i;
    output [7:0] usr_rx1_test_o;
    output usr_rx2_busy_o;
    input usr_rx2_ctrl_align_en_i;
    input usr_rx2_ctrl_align_sync_i;
    output [7:0] usr_rx2_ctrl_char_is_a_o;
    output usr_rx2_ctrl_char_is_aligned_o;
    output [7:0] usr_rx2_ctrl_char_is_comma_o;
    output [7:0] usr_rx2_ctrl_char_is_f_o;
    output [7:0] usr_rx2_ctrl_char_is_k_o;
    input [2:0] usr_rx2_ctrl_debug_sel_i;
    input usr_rx2_ctrl_dec_en_i;
    output [7:0] usr_rx2_ctrl_disp_err_o;
    input usr_rx2_ctrl_dscr_en_i;
    input usr_rx2_ctrl_el_buff_rst_i;
    output [7:0] usr_rx2_ctrl_not_in_table_o;
    input [1:0] usr_rx2_ctrl_ovs_bit_sel_i;
    input usr_rx2_ctrl_replace_en_i;
    output usr_rx2_ctrl_valid_realign_o;
    output [63:0] usr_rx2_data_o;
    output usr_rx2_pma_ll_fast_locked_o;
    output usr_rx2_pma_ll_slow_locked_o;
    output usr_rx2_pma_loss_of_signal_o;
    input usr_rx2_pma_m_eye_rst_i;
    output usr_rx2_pma_pll_lock_o;
    output usr_rx2_pma_pll_lock_track_o;
    input usr_rx2_pma_pwr_down_n_i;
    input usr_rx2_pma_rst_n_i;
    input usr_rx2_rst_n_i;
    output [7:0] usr_rx2_test_o;
    output usr_rx3_busy_o;
    input usr_rx3_ctrl_align_en_i;
    input usr_rx3_ctrl_align_sync_i;
    output [7:0] usr_rx3_ctrl_char_is_a_o;
    output usr_rx3_ctrl_char_is_aligned_o;
    output [7:0] usr_rx3_ctrl_char_is_comma_o;
    output [7:0] usr_rx3_ctrl_char_is_f_o;
    output [7:0] usr_rx3_ctrl_char_is_k_o;
    input [2:0] usr_rx3_ctrl_debug_sel_i;
    input usr_rx3_ctrl_dec_en_i;
    output [7:0] usr_rx3_ctrl_disp_err_o;
    input usr_rx3_ctrl_dscr_en_i;
    input usr_rx3_ctrl_el_buff_rst_i;
    output [7:0] usr_rx3_ctrl_not_in_table_o;
    input [1:0] usr_rx3_ctrl_ovs_bit_sel_i;
    input usr_rx3_ctrl_replace_en_i;
    output usr_rx3_ctrl_valid_realign_o;
    output [63:0] usr_rx3_data_o;
    output usr_rx3_pma_ll_fast_locked_o;
    output usr_rx3_pma_ll_slow_locked_o;
    output usr_rx3_pma_loss_of_signal_o;
    input usr_rx3_pma_m_eye_rst_i;
    output usr_rx3_pma_pll_lock_o;
    output usr_rx3_pma_pll_lock_track_o;
    input usr_rx3_pma_pwr_down_n_i;
    input usr_rx3_pma_rst_n_i;
    input usr_rx3_rst_n_i;
    output [7:0] usr_rx3_test_o;
    output usr_tx0_busy_o;
    input [7:0] usr_tx0_ctrl_char_is_k_i;
    input usr_tx0_ctrl_driver_pwrdwn_n_i;
    input [7:0] usr_tx0_ctrl_enc_en_i;
    input [7:0] usr_tx0_ctrl_end_of_frame_i;
    input [7:0] usr_tx0_ctrl_end_of_multiframe_i;
    output usr_tx0_ctrl_invalid_k_o;
    input usr_tx0_ctrl_replace_en_i;
    input [7:0] usr_tx0_ctrl_scr_en_i;
    input [63:0] usr_tx0_data_i;
    input usr_tx0_pma_clk_en_i;
    output usr_tx0_pma_tx_clk_o;
    input usr_tx0_rst_n_i;
    output usr_tx1_busy_o;
    input [7:0] usr_tx1_ctrl_char_is_k_i;
    input usr_tx1_ctrl_driver_pwrdwn_n_i;
    input [7:0] usr_tx1_ctrl_enc_en_i;
    input [7:0] usr_tx1_ctrl_end_of_frame_i;
    input [7:0] usr_tx1_ctrl_end_of_multiframe_i;
    output usr_tx1_ctrl_invalid_k_o;
    input usr_tx1_ctrl_replace_en_i;
    input [7:0] usr_tx1_ctrl_scr_en_i;
    input [63:0] usr_tx1_data_i;
    input usr_tx1_pma_clk_en_i;
    output usr_tx1_pma_tx_clk_o;
    input usr_tx1_rst_n_i;
    output usr_tx2_busy_o;
    input [7:0] usr_tx2_ctrl_char_is_k_i;
    input usr_tx2_ctrl_driver_pwrdwn_n_i;
    input [7:0] usr_tx2_ctrl_enc_en_i;
    input [7:0] usr_tx2_ctrl_end_of_frame_i;
    input [7:0] usr_tx2_ctrl_end_of_multiframe_i;
    output usr_tx2_ctrl_invalid_k_o;
    input usr_tx2_ctrl_replace_en_i;
    input [7:0] usr_tx2_ctrl_scr_en_i;
    input [63:0] usr_tx2_data_i;
    input usr_tx2_pma_clk_en_i;
    output usr_tx2_pma_tx_clk_o;
    input usr_tx2_rst_n_i;
    output usr_tx3_busy_o;
    input [7:0] usr_tx3_ctrl_char_is_k_i;
    input usr_tx3_ctrl_driver_pwrdwn_n_i;
    input [7:0] usr_tx3_ctrl_enc_en_i;
    input [7:0] usr_tx3_ctrl_end_of_frame_i;
    input [7:0] usr_tx3_ctrl_end_of_multiframe_i;
    output usr_tx3_ctrl_invalid_k_o;
    input usr_tx3_ctrl_replace_en_i;
    input [7:0] usr_tx3_ctrl_scr_en_i;
    input [63:0] usr_tx3_data_i;
    input usr_tx3_pma_clk_en_i;
    output usr_tx3_pma_tx_clk_o;
    input usr_tx3_rst_n_i;
    parameter cfg_dyn_all_rx_pma_m_eye_coarse_ena_i = 1'b0;
    parameter cfg_dyn_all_rx_pma_m_eye_dn_i = 1'b0;
    parameter cfg_dyn_all_rx_pma_m_eye_fine_ena_i = 1'b0;
    parameter cfg_dyn_all_rx_pma_m_eye_i = 1'b0;
    parameter cfg_dyn_all_rx_pma_m_eye_step_i = 4'b0000;
    parameter cfg_dyn_all_rx_pma_m_eye_up_i = 1'b0;
    parameter cfg_dyn_all_rx_pma_threshold_1 = 5'b00000;
    parameter cfg_dyn_all_rx_pma_threshold_2 = 5'b00000;
    parameter cfg_dyn_all_rx_pma_trim_locked_i = 3'b000;
    parameter cfg_dyn_all_rx_pma_trim_mode_i = 2'b00;
    parameter cfg_dyn_all_rx_pma_trim_unlocked_i = 3'b000;
    parameter cfg_dyn_rx0_pma_ctle_cap_p_i = 4'b0000;
    parameter cfg_dyn_rx0_pma_ctle_res_p_i = 4'b0000;
    parameter cfg_dyn_rx0_pma_dfe_idac_tap1_n_i = 6'b000000;
    parameter cfg_dyn_rx0_pma_dfe_idac_tap2_n_i = 6'b000000;
    parameter cfg_dyn_rx0_pma_dfe_idac_tap3_n_i = 6'b000000;
    parameter cfg_dyn_rx0_pma_dfe_idac_tap4_n_i = 6'b000000;
    parameter cfg_dyn_rx0_pma_termination_cmd_i = 6'b000000;
    parameter cfg_dyn_rx1_pma_ctle_cap_p_i = 4'b0000;
    parameter cfg_dyn_rx1_pma_ctle_res_p_i = 4'b0000;
    parameter cfg_dyn_rx1_pma_dfe_idac_tap1_n_i = 6'b000000;
    parameter cfg_dyn_rx1_pma_dfe_idac_tap2_n_i = 6'b000000;
    parameter cfg_dyn_rx1_pma_dfe_idac_tap3_n_i = 6'b000000;
    parameter cfg_dyn_rx1_pma_dfe_idac_tap4_n_i = 6'b000000;
    parameter cfg_dyn_rx1_pma_termination_cmd_i = 6'b000000;
    parameter cfg_dyn_rx2_pma_ctle_cap_p_i = 4'b0000;
    parameter cfg_dyn_rx2_pma_ctle_res_p_i = 4'b0000;
    parameter cfg_dyn_rx2_pma_dfe_idac_tap1_n_i = 6'b000000;
    parameter cfg_dyn_rx2_pma_dfe_idac_tap2_n_i = 6'b000000;
    parameter cfg_dyn_rx2_pma_dfe_idac_tap3_n_i = 6'b000000;
    parameter cfg_dyn_rx2_pma_dfe_idac_tap4_n_i = 6'b000000;
    parameter cfg_dyn_rx2_pma_termination_cmd_i = 6'b000000;
    parameter cfg_dyn_rx3_pma_ctle_cap_p_i = 4'b0000;
    parameter cfg_dyn_rx3_pma_ctle_res_p_i = 4'b0000;
    parameter cfg_dyn_rx3_pma_dfe_idac_tap1_n_i = 6'b000000;
    parameter cfg_dyn_rx3_pma_dfe_idac_tap2_n_i = 6'b000000;
    parameter cfg_dyn_rx3_pma_dfe_idac_tap3_n_i = 6'b000000;
    parameter cfg_dyn_rx3_pma_dfe_idac_tap4_n_i = 6'b000000;
    parameter cfg_dyn_rx3_pma_termination_cmd_i = 6'b000000;
    parameter cfg_dyn_tx0_pma_main_en_i = 6'b000000;
    parameter cfg_dyn_tx0_pma_main_sign_i = 1'b0;
    parameter cfg_dyn_tx0_pma_margin_input_i = 9'b000000000;
    parameter cfg_dyn_tx0_pma_margin_sel_i = 9'b000000000;
    parameter cfg_dyn_tx0_pma_post_en_i = 5'b00000;
    parameter cfg_dyn_tx0_pma_post_sel_i = 8'b00000000;
    parameter cfg_dyn_tx0_pma_post_sign_i = 1'b0;
    parameter cfg_dyn_tx0_pma_pre_en_i = 1'b0;
    parameter cfg_dyn_tx0_pma_pre_sel_i = 4'b0000;
    parameter cfg_dyn_tx0_pma_pre_sign_i = 1'b0;
    parameter cfg_dyn_tx1_pma_main_en_i = 6'b000000;
    parameter cfg_dyn_tx1_pma_main_sign_i = 1'b0;
    parameter cfg_dyn_tx1_pma_margin_input_i = 9'b000000000;
    parameter cfg_dyn_tx1_pma_margin_sel_i = 9'b000000000;
    parameter cfg_dyn_tx1_pma_post_en_i = 5'b00000;
    parameter cfg_dyn_tx1_pma_post_sel_i = 8'b00000000;
    parameter cfg_dyn_tx1_pma_post_sign_i = 1'b0;
    parameter cfg_dyn_tx1_pma_pre_en_i = 1'b0;
    parameter cfg_dyn_tx1_pma_pre_sel_i = 4'b0000;
    parameter cfg_dyn_tx1_pma_pre_sign_i = 1'b0;
    parameter cfg_dyn_tx2_pma_main_en_i = 6'b000000;
    parameter cfg_dyn_tx2_pma_main_sign_i = 1'b0;
    parameter cfg_dyn_tx2_pma_margin_input_i = 9'b000000000;
    parameter cfg_dyn_tx2_pma_margin_sel_i = 9'b000000000;
    parameter cfg_dyn_tx2_pma_post_en_i = 5'b00000;
    parameter cfg_dyn_tx2_pma_post_sel_i = 8'b00000000;
    parameter cfg_dyn_tx2_pma_post_sign_i = 1'b0;
    parameter cfg_dyn_tx2_pma_pre_en_i = 1'b0;
    parameter cfg_dyn_tx2_pma_pre_sel_i = 4'b0000;
    parameter cfg_dyn_tx2_pma_pre_sign_i = 1'b0;
    parameter cfg_dyn_tx3_pma_main_en_i = 6'b000000;
    parameter cfg_dyn_tx3_pma_main_sign_i = 1'b0;
    parameter cfg_dyn_tx3_pma_margin_input_i = 9'b000000000;
    parameter cfg_dyn_tx3_pma_margin_sel_i = 9'b000000000;
    parameter cfg_dyn_tx3_pma_post_en_i = 5'b00000;
    parameter cfg_dyn_tx3_pma_post_sel_i = 8'b00000000;
    parameter cfg_dyn_tx3_pma_post_sign_i = 1'b0;
    parameter cfg_dyn_tx3_pma_pre_en_i = 1'b0;
    parameter cfg_dyn_tx3_pma_pre_sel_i = 4'b0000;
    parameter cfg_dyn_tx3_pma_pre_sign_i = 1'b0;
    parameter cfg_main_clk_to_fabric_div_en_i = 1'b0;
    parameter cfg_main_clk_to_fabric_div_mode_i = 1'b0;
    parameter cfg_main_clk_to_fabric_sel_i = 1'b0;
    parameter cfg_main_rclk_to_fabric_sel_i = 2'b00;
    parameter cfg_main_use_only_usr_clock_i = 1'b0;
    parameter cfg_pcs_ovs_en_i = 1'b0;
    parameter cfg_pcs_ovs_mode_i = 1'b0;
    parameter cfg_pcs_pll_lock_ppm_i = 3'b000;
    parameter cfg_pcs_word_len_i = 2'b00;
    parameter cfg_pll_pma_ckref_ext_i = 1'b0;
    parameter cfg_pll_pma_cpump_i = 4'b0000;
    parameter cfg_pll_pma_divl_i = 2'b00;
    parameter cfg_pll_pma_divm_i = 1'b0;
    parameter cfg_pll_pma_divn_i = 2'b00;
    parameter cfg_pll_pma_gbx_en_i = 1'b0;
    parameter cfg_pll_pma_int_data_len_i = 1'b0;
    parameter cfg_pll_pma_lvds_en_i = 1'b0;
    parameter cfg_pll_pma_lvds_mux_i = 1'b0;
    parameter cfg_pll_pma_mux_ckref_i = 1'b0;
    parameter cfg_rx0_gearbox_en_i = 1'b0;
    parameter cfg_rx0_gearbox_mode_i = 1'b0;
    parameter cfg_rx0_pcs_8b_dscr_sel_i = 1'b0;
    parameter cfg_rx0_pcs_align_bypass_i = 1'b0;
    parameter cfg_rx0_pcs_buffers_bypass_i = 1'b0;
    parameter cfg_rx0_pcs_buffers_use_cdc_i = 1'b0;
    parameter cfg_rx0_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_rx0_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_rx0_pcs_comma_mask_i = 10'b0000000000;
    parameter cfg_rx0_pcs_debug_en_i = 1'b0;
    parameter cfg_rx0_pcs_dec_bypass_i = 1'b0;
    parameter cfg_rx0_pcs_dscr_bypass_i = 1'b0;
    parameter cfg_rx0_pcs_el_buff_diff_bef_comp_i = 4'b0000;
    parameter cfg_rx0_pcs_el_buff_max_comp_i = 4'b0000;
    parameter cfg_rx0_pcs_el_buff_only_one_skp_i = 1'b0;
    parameter cfg_rx0_pcs_el_buff_skp_char_0_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_char_1_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_char_2_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_char_3_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_header_0_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_header_1_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_header_2_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_header_3_i = 9'b000000000;
    parameter cfg_rx0_pcs_el_buff_skp_header_size_i = 2'b00;
    parameter cfg_rx0_pcs_el_buff_skp_seq_size_i = 2'b00;
    parameter cfg_rx0_pcs_fsm_sel_i = 2'b00;
    parameter cfg_rx0_pcs_fsm_watchdog_en_i = 1'b0;
    parameter cfg_rx0_pcs_loopback_i = 1'b0;
    parameter cfg_rx0_pcs_m_comma_en_i = 1'b0;
    parameter cfg_rx0_pcs_m_comma_val_i = 10'b0000000000;
    parameter cfg_rx0_pcs_nb_comma_bef_realign_i = 2'b00;
    parameter cfg_rx0_pcs_p_comma_en_i = 1'b0;
    parameter cfg_rx0_pcs_p_comma_val_i = 10'b0000000000;
    parameter cfg_rx0_pcs_polarity_i = 1'b0;
    parameter cfg_rx0_pcs_protocol_size_i = 1'b0;
    parameter cfg_rx0_pcs_replace_bypass_i = 1'b0;
    parameter cfg_rx0_pcs_sync_supported_i = 1'b0;
    parameter cfg_rx0_pma_cdr_cp_i = 4'b0000;
    parameter cfg_rx0_pma_clk_pos_i = 1'b0;
    parameter cfg_rx0_pma_coarse_ppm_i = 3'b000;
    parameter cfg_rx0_pma_ctrl_term_i = 6'b000000;
    parameter cfg_rx0_pma_dco_divl_i = 2'b00;
    parameter cfg_rx0_pma_dco_divm_i = 1'b0;
    parameter cfg_rx0_pma_dco_divn_i = 2'b00;
    parameter cfg_rx0_pma_dco_reg_res_i = 2'b00;
    parameter cfg_rx0_pma_dco_vref_sel_i = 1'b0;
    parameter cfg_rx0_pma_fine_ppm_i = 3'b000;
    parameter cfg_rx0_pma_loopback_i = 1'b0;
    parameter cfg_rx0_pma_m_eye_ppm_i = 3'b000;
    parameter cfg_rx0_pma_peak_detect_cmd_i = 2'b00;
    parameter cfg_rx0_pma_peak_detect_on_i = 1'b0;
    parameter cfg_rx0_pma_pll_cpump_n_i = 3'b000;
    parameter cfg_rx0_pma_pll_divf_en_n_i = 1'b0;
    parameter cfg_rx0_pma_pll_divf_i = 2'b00;
    parameter cfg_rx0_pma_pll_divm_en_n_i = 1'b0;
    parameter cfg_rx0_pma_pll_divm_i = 2'b00;
    parameter cfg_rx0_pma_pll_divn_en_n_i = 1'b0;
    parameter cfg_rx0_pma_pll_divn_i = 1'b0;
    parameter cfg_rx1_gearbox_en_i = 1'b0;
    parameter cfg_rx1_gearbox_mode_i = 1'b0;
    parameter cfg_rx1_pcs_8b_dscr_sel_i = 1'b0;
    parameter cfg_rx1_pcs_align_bypass_i = 1'b0;
    parameter cfg_rx1_pcs_buffers_bypass_i = 1'b0;
    parameter cfg_rx1_pcs_buffers_use_cdc_i = 1'b0;
    parameter cfg_rx1_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_rx1_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_rx1_pcs_comma_mask_i = 10'b0000000000;
    parameter cfg_rx1_pcs_debug_en_i = 1'b0;
    parameter cfg_rx1_pcs_dec_bypass_i = 1'b0;
    parameter cfg_rx1_pcs_dscr_bypass_i = 1'b0;
    parameter cfg_rx1_pcs_el_buff_diff_bef_comp_i = 4'b0000;
    parameter cfg_rx1_pcs_el_buff_max_comp_i = 4'b0000;
    parameter cfg_rx1_pcs_el_buff_only_one_skp_i = 1'b0;
    parameter cfg_rx1_pcs_el_buff_skp_char_0_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_char_1_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_char_2_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_char_3_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_header_0_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_header_1_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_header_2_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_header_3_i = 9'b000000000;
    parameter cfg_rx1_pcs_el_buff_skp_header_size_i = 2'b00;
    parameter cfg_rx1_pcs_el_buff_skp_seq_size_i = 2'b00;
    parameter cfg_rx1_pcs_fsm_sel_i = 2'b00;
    parameter cfg_rx1_pcs_fsm_watchdog_en_i = 1'b0;
    parameter cfg_rx1_pcs_loopback_i = 1'b0;
    parameter cfg_rx1_pcs_m_comma_en_i = 1'b0;
    parameter cfg_rx1_pcs_m_comma_val_i = 10'b0000000000;
    parameter cfg_rx1_pcs_nb_comma_bef_realign_i = 2'b00;
    parameter cfg_rx1_pcs_p_comma_en_i = 1'b0;
    parameter cfg_rx1_pcs_p_comma_val_i = 10'b0000000000;
    parameter cfg_rx1_pcs_polarity_i = 1'b0;
    parameter cfg_rx1_pcs_protocol_size_i = 1'b0;
    parameter cfg_rx1_pcs_replace_bypass_i = 1'b0;
    parameter cfg_rx1_pcs_sync_supported_i = 1'b0;
    parameter cfg_rx1_pma_cdr_cp_i = 4'b0000;
    parameter cfg_rx1_pma_clk_pos_i = 1'b0;
    parameter cfg_rx1_pma_coarse_ppm_i = 3'b000;
    parameter cfg_rx1_pma_ctrl_term_i = 6'b000000;
    parameter cfg_rx1_pma_dco_divl_i = 2'b00;
    parameter cfg_rx1_pma_dco_divm_i = 1'b0;
    parameter cfg_rx1_pma_dco_divn_i = 2'b00;
    parameter cfg_rx1_pma_dco_reg_res_i = 2'b00;
    parameter cfg_rx1_pma_dco_vref_sel_i = 1'b0;
    parameter cfg_rx1_pma_fine_ppm_i = 3'b000;
    parameter cfg_rx1_pma_loopback_i = 1'b0;
    parameter cfg_rx1_pma_m_eye_ppm_i = 3'b000;
    parameter cfg_rx1_pma_peak_detect_cmd_i = 2'b00;
    parameter cfg_rx1_pma_peak_detect_on_i = 1'b0;
    parameter cfg_rx1_pma_pll_cpump_n_i = 3'b000;
    parameter cfg_rx1_pma_pll_divf_en_n_i = 1'b0;
    parameter cfg_rx1_pma_pll_divf_i = 2'b00;
    parameter cfg_rx1_pma_pll_divm_en_n_i = 1'b0;
    parameter cfg_rx1_pma_pll_divm_i = 2'b00;
    parameter cfg_rx1_pma_pll_divn_en_n_i = 1'b0;
    parameter cfg_rx1_pma_pll_divn_i = 1'b0;
    parameter cfg_rx2_gearbox_en_i = 1'b0;
    parameter cfg_rx2_gearbox_mode_i = 1'b0;
    parameter cfg_rx2_pcs_8b_dscr_sel_i = 1'b0;
    parameter cfg_rx2_pcs_align_bypass_i = 1'b0;
    parameter cfg_rx2_pcs_buffers_bypass_i = 1'b0;
    parameter cfg_rx2_pcs_buffers_use_cdc_i = 1'b0;
    parameter cfg_rx2_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_rx2_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_rx2_pcs_comma_mask_i = 10'b0000000000;
    parameter cfg_rx2_pcs_debug_en_i = 1'b0;
    parameter cfg_rx2_pcs_dec_bypass_i = 1'b0;
    parameter cfg_rx2_pcs_dscr_bypass_i = 1'b0;
    parameter cfg_rx2_pcs_el_buff_diff_bef_comp_i = 4'b0000;
    parameter cfg_rx2_pcs_el_buff_max_comp_i = 4'b0000;
    parameter cfg_rx2_pcs_el_buff_only_one_skp_i = 1'b0;
    parameter cfg_rx2_pcs_el_buff_skp_char_0_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_char_1_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_char_2_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_char_3_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_header_0_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_header_1_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_header_2_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_header_3_i = 9'b000000000;
    parameter cfg_rx2_pcs_el_buff_skp_header_size_i = 2'b00;
    parameter cfg_rx2_pcs_el_buff_skp_seq_size_i = 2'b00;
    parameter cfg_rx2_pcs_fsm_sel_i = 2'b00;
    parameter cfg_rx2_pcs_fsm_watchdog_en_i = 1'b0;
    parameter cfg_rx2_pcs_loopback_i = 1'b0;
    parameter cfg_rx2_pcs_m_comma_en_i = 1'b0;
    parameter cfg_rx2_pcs_m_comma_val_i = 10'b0000000000;
    parameter cfg_rx2_pcs_nb_comma_bef_realign_i = 2'b00;
    parameter cfg_rx2_pcs_p_comma_en_i = 1'b0;
    parameter cfg_rx2_pcs_p_comma_val_i = 10'b0000000000;
    parameter cfg_rx2_pcs_polarity_i = 1'b0;
    parameter cfg_rx2_pcs_protocol_size_i = 1'b0;
    parameter cfg_rx2_pcs_replace_bypass_i = 1'b0;
    parameter cfg_rx2_pcs_sync_supported_i = 1'b0;
    parameter cfg_rx2_pma_cdr_cp_i = 4'b0000;
    parameter cfg_rx2_pma_clk_pos_i = 1'b0;
    parameter cfg_rx2_pma_coarse_ppm_i = 3'b000;
    parameter cfg_rx2_pma_ctrl_term_i = 6'b000000;
    parameter cfg_rx2_pma_dco_divl_i = 2'b00;
    parameter cfg_rx2_pma_dco_divm_i = 1'b0;
    parameter cfg_rx2_pma_dco_divn_i = 2'b00;
    parameter cfg_rx2_pma_dco_reg_res_i = 2'b00;
    parameter cfg_rx2_pma_dco_vref_sel_i = 1'b0;
    parameter cfg_rx2_pma_fine_ppm_i = 3'b000;
    parameter cfg_rx2_pma_loopback_i = 1'b0;
    parameter cfg_rx2_pma_m_eye_ppm_i = 3'b000;
    parameter cfg_rx2_pma_peak_detect_cmd_i = 2'b00;
    parameter cfg_rx2_pma_peak_detect_on_i = 1'b0;
    parameter cfg_rx2_pma_pll_cpump_n_i = 3'b000;
    parameter cfg_rx2_pma_pll_divf_en_n_i = 1'b0;
    parameter cfg_rx2_pma_pll_divf_i = 2'b00;
    parameter cfg_rx2_pma_pll_divm_en_n_i = 1'b0;
    parameter cfg_rx2_pma_pll_divm_i = 2'b00;
    parameter cfg_rx2_pma_pll_divn_en_n_i = 1'b0;
    parameter cfg_rx2_pma_pll_divn_i = 1'b0;
    parameter cfg_rx3_gearbox_en_i = 1'b0;
    parameter cfg_rx3_gearbox_mode_i = 1'b0;
    parameter cfg_rx3_pcs_8b_dscr_sel_i = 1'b0;
    parameter cfg_rx3_pcs_align_bypass_i = 1'b0;
    parameter cfg_rx3_pcs_buffers_bypass_i = 1'b0;
    parameter cfg_rx3_pcs_buffers_use_cdc_i = 1'b0;
    parameter cfg_rx3_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_rx3_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_rx3_pcs_comma_mask_i = 10'b0000000000;
    parameter cfg_rx3_pcs_debug_en_i = 1'b0;
    parameter cfg_rx3_pcs_dec_bypass_i = 1'b0;
    parameter cfg_rx3_pcs_dscr_bypass_i = 1'b0;
    parameter cfg_rx3_pcs_el_buff_diff_bef_comp_i = 4'b0000;
    parameter cfg_rx3_pcs_el_buff_max_comp_i = 4'b0000;
    parameter cfg_rx3_pcs_el_buff_only_one_skp_i = 1'b0;
    parameter cfg_rx3_pcs_el_buff_skp_char_0_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_char_1_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_char_2_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_char_3_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_header_0_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_header_1_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_header_2_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_header_3_i = 9'b000000000;
    parameter cfg_rx3_pcs_el_buff_skp_header_size_i = 2'b00;
    parameter cfg_rx3_pcs_el_buff_skp_seq_size_i = 2'b00;
    parameter cfg_rx3_pcs_fsm_sel_i = 2'b00;
    parameter cfg_rx3_pcs_fsm_watchdog_en_i = 1'b0;
    parameter cfg_rx3_pcs_loopback_i = 1'b0;
    parameter cfg_rx3_pcs_m_comma_en_i = 1'b0;
    parameter cfg_rx3_pcs_m_comma_val_i = 10'b0000000000;
    parameter cfg_rx3_pcs_nb_comma_bef_realign_i = 2'b00;
    parameter cfg_rx3_pcs_p_comma_en_i = 1'b0;
    parameter cfg_rx3_pcs_p_comma_val_i = 10'b0000000000;
    parameter cfg_rx3_pcs_polarity_i = 1'b0;
    parameter cfg_rx3_pcs_protocol_size_i = 1'b0;
    parameter cfg_rx3_pcs_replace_bypass_i = 1'b0;
    parameter cfg_rx3_pcs_sync_supported_i = 1'b0;
    parameter cfg_rx3_pma_cdr_cp_i = 4'b0000;
    parameter cfg_rx3_pma_clk_pos_i = 1'b0;
    parameter cfg_rx3_pma_coarse_ppm_i = 3'b000;
    parameter cfg_rx3_pma_ctrl_term_i = 6'b000000;
    parameter cfg_rx3_pma_dco_divl_i = 2'b00;
    parameter cfg_rx3_pma_dco_divm_i = 1'b0;
    parameter cfg_rx3_pma_dco_divn_i = 2'b00;
    parameter cfg_rx3_pma_dco_reg_res_i = 2'b00;
    parameter cfg_rx3_pma_dco_vref_sel_i = 1'b0;
    parameter cfg_rx3_pma_fine_ppm_i = 3'b000;
    parameter cfg_rx3_pma_loopback_i = 1'b0;
    parameter cfg_rx3_pma_m_eye_ppm_i = 3'b000;
    parameter cfg_rx3_pma_peak_detect_cmd_i = 2'b00;
    parameter cfg_rx3_pma_peak_detect_on_i = 1'b0;
    parameter cfg_rx3_pma_pll_cpump_n_i = 3'b000;
    parameter cfg_rx3_pma_pll_divf_en_n_i = 1'b0;
    parameter cfg_rx3_pma_pll_divf_i = 2'b00;
    parameter cfg_rx3_pma_pll_divm_en_n_i = 1'b0;
    parameter cfg_rx3_pma_pll_divm_i = 2'b00;
    parameter cfg_rx3_pma_pll_divn_en_n_i = 1'b0;
    parameter cfg_rx3_pma_pll_divn_i = 1'b0;
    parameter cfg_test_mode_i = 2'b00;
    parameter cfg_tx0_gearbox_en_i = 1'b0;
    parameter cfg_tx0_gearbox_mode_i = 1'b0;
    parameter cfg_tx0_pcs_8b_scr_sel_i = 1'b0;
    parameter cfg_tx0_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_tx0_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_tx0_pcs_enc_bypass_i = 1'b0;
    parameter cfg_tx0_pcs_esistream_fsm_en_i = 1'b0;
    parameter cfg_tx0_pcs_loopback_i = 1'b0;
    parameter cfg_tx0_pcs_polarity_i = 1'b0;
    parameter cfg_tx0_pcs_protocol_size_i = 1'b0;
    parameter cfg_tx0_pcs_replace_bypass_i = 1'b0;
    parameter cfg_tx0_pcs_scr_bypass_i = 1'b0;
    parameter cfg_tx0_pcs_scr_init_i = 17'b00000000000000000;
    parameter cfg_tx0_pcs_sync_supported_i = 1'b0;
    parameter cfg_tx0_pma_clk_pos_i = 1'b0;
    parameter cfg_tx0_pma_loopback_i = 1'b0;
    parameter cfg_tx1_gearbox_en_i = 1'b0;
    parameter cfg_tx1_gearbox_mode_i = 1'b0;
    parameter cfg_tx1_pcs_8b_scr_sel_i = 1'b0;
    parameter cfg_tx1_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_tx1_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_tx1_pcs_enc_bypass_i = 1'b0;
    parameter cfg_tx1_pcs_esistream_fsm_en_i = 1'b0;
    parameter cfg_tx1_pcs_loopback_i = 1'b0;
    parameter cfg_tx1_pcs_polarity_i = 1'b0;
    parameter cfg_tx1_pcs_protocol_size_i = 1'b0;
    parameter cfg_tx1_pcs_replace_bypass_i = 1'b0;
    parameter cfg_tx1_pcs_scr_bypass_i = 1'b0;
    parameter cfg_tx1_pcs_scr_init_i = 17'b00000000000000000;
    parameter cfg_tx1_pcs_sync_supported_i = 1'b0;
    parameter cfg_tx1_pma_clk_pos_i = 1'b0;
    parameter cfg_tx1_pma_loopback_i = 1'b0;
    parameter cfg_tx2_gearbox_en_i = 1'b0;
    parameter cfg_tx2_gearbox_mode_i = 1'b0;
    parameter cfg_tx2_pcs_8b_scr_sel_i = 1'b0;
    parameter cfg_tx2_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_tx2_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_tx2_pcs_enc_bypass_i = 1'b0;
    parameter cfg_tx2_pcs_esistream_fsm_en_i = 1'b0;
    parameter cfg_tx2_pcs_loopback_i = 1'b0;
    parameter cfg_tx2_pcs_polarity_i = 1'b0;
    parameter cfg_tx2_pcs_protocol_size_i = 1'b0;
    parameter cfg_tx2_pcs_replace_bypass_i = 1'b0;
    parameter cfg_tx2_pcs_scr_bypass_i = 1'b0;
    parameter cfg_tx2_pcs_scr_init_i = 17'b00000000000000000;
    parameter cfg_tx2_pcs_sync_supported_i = 1'b0;
    parameter cfg_tx2_pma_clk_pos_i = 1'b0;
    parameter cfg_tx2_pma_loopback_i = 1'b0;
    parameter cfg_tx3_gearbox_en_i = 1'b0;
    parameter cfg_tx3_gearbox_mode_i = 1'b0;
    parameter cfg_tx3_pcs_8b_scr_sel_i = 1'b0;
    parameter cfg_tx3_pcs_bypass_pma_cdc_i = 1'b0;
    parameter cfg_tx3_pcs_bypass_usr_cdc_i = 1'b0;
    parameter cfg_tx3_pcs_enc_bypass_i = 1'b0;
    parameter cfg_tx3_pcs_esistream_fsm_en_i = 1'b0;
    parameter cfg_tx3_pcs_loopback_i = 1'b0;
    parameter cfg_tx3_pcs_polarity_i = 1'b0;
    parameter cfg_tx3_pcs_protocol_size_i = 1'b0;
    parameter cfg_tx3_pcs_replace_bypass_i = 1'b0;
    parameter cfg_tx3_pcs_scr_bypass_i = 1'b0;
    parameter cfg_tx3_pcs_scr_init_i = 17'b00000000000000000;
    parameter cfg_tx3_pcs_sync_supported_i = 1'b0;
    parameter cfg_tx3_pma_clk_pos_i = 1'b0;
    parameter cfg_tx3_pma_loopback_i = 1'b0;
    parameter location = "";
    parameter rx_usrclk_use_pcs_clk_2 = 1'b0;
    parameter tx_usrclk_use_pcs_clk_2 = 1'b0;
endmodule
`,"io_map.v":`module \\$__BEYOND_IBUF (input PAD, output O);
	NX_IOB_I _TECHMAP_REPLACE_ (.IO(PAD), .O(O), .C(1'b0));
endmodule

module \\$__BEYOND_OBUF (output PAD, input I);
	NX_IOB_O _TECHMAP_REPLACE_ (.IO(PAD), .I(I), .C(1'b1));
endmodule

module \\$__BEYOND_TOBUF (output PAD, input I, input C);
	NX_IOB _TECHMAP_REPLACE_ (.IO(PAD), .I(I), .C(C));
endmodule

module \\$__BEYOND_IOBUF (output PAD, input I, output O, output C);
	NX_IOB _TECHMAP_REPLACE_ (.IO(PAD), .I(I), .O(O), .C(C));
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"rf_init.vh":`function [9728-1:0] rf_init_to_string;
    input [1152-1:0] array;
    input integer blocks;
    input integer width;
    reg [9728-1:0] temp; // (1152+1152/18)*8
    integer i;
begin
    temp = "";
    for (i = 0; i < blocks; i = i + 1) begin
    if (i != 0) begin
        temp = {temp, ","};
    end
    temp = {temp, $sformatf("%b",array[(i+1)*width-1: i*width])};
    end
    rf_init_to_string = temp;
end
endfunction
`,"rf_rams_l.txt":`ram distributed $__NX_RFB_L_ {
    abits 6;
    width 16;
    cost 10;
    init no_undef;
    prune_rom;

    port sw "W" {
        clock anyedge;
    }
    port sr "R" {
        clock anyedge;
        rden;
    }
}
`,"rf_rams_m.txt":`ram distributed $__NX_RFB_M_ {
    abits 6;
    width 16;
    cost 10;
    init no_undef;
    prune_rom;

    port sw "W" {
        clock anyedge;
    }
    port sr "R" {
        clock anyedge;
        rden;
    }
}
`,"rf_rams_map_l.v":`module $__NX_RFB_L_ (
  input PORT_W_CLK,
  input PORT_W_WR_EN,
  input [5:0] PORT_W_ADDR,
  input [15:0] PORT_W_WR_DATA, 
  input PORT_R_CLK,
  input PORT_R_RD_EN,
  input [5:0] PORT_R_ADDR,
  output [15:0] PORT_R_RD_DATA,
);
  parameter INIT = 1152'bx;
  parameter PORT_W_CLK_POL = 1'b1;
  parameter PORT_R_CLK_POL = 1'b1;

  NX_RFB_L_WRAP #(
    .mode(0),
    .mem_ctxt(INIT),
    .rck_edge(~PORT_R_CLK_POL),
    .wck_edge(~PORT_W_CLK_POL)
  ) _TECHMAP_REPLACE_ (
    .RCK(PORT_R_CLK),
    .WCK(PORT_W_CLK),
    .I(PORT_W_WR_DATA),
    .RA(PORT_R_ADDR),
    .WA(PORT_W_ADDR),
    .RE(PORT_R_RD_EN),
    .WE(PORT_W_WR_EN),
    .O(PORT_R_RD_DATA)
  );
endmodule
`,"rf_rams_map_m.v":`module $__NX_RFB_M_ (
  input PORT_W_CLK,
  input PORT_W_WR_EN,
  input [5:0] PORT_W_ADDR,
  input [15:0] PORT_W_WR_DATA, 
  input PORT_R_CLK,
  input PORT_R_RD_EN,
  input [5:0] PORT_R_ADDR,
  output [15:0] PORT_R_RD_DATA,
);
  parameter INIT = 1152'bx;
  parameter PORT_W_CLK_POL = 1'b1;
  parameter PORT_R_CLK_POL = 1'b1;

  NX_RFB_M_WRAP #(
    .mode(0),
    .mem_ctxt(INIT),
    .rck_edge(~PORT_R_CLK_POL),
    .wck_edge(~PORT_W_CLK_POL)
  ) _TECHMAP_REPLACE_ (
    .RCK(PORT_R_CLK),
    .WCK(PORT_W_CLK),
    .I(PORT_W_WR_DATA),
    .RA(PORT_R_ADDR),
    .WA(PORT_W_ADDR),
    .RE(PORT_R_RD_EN),
    .WE(PORT_W_WR_EN),
    .O(PORT_R_RD_DATA)
  );
endmodule
`,"rf_rams_map_u.v":`
module $__NX_RFB_U_DPREG_ (
  input PORT_W_CLK,
  input [6-1:0] PORT_W_ADDR,
  input [6-1:0] PORT_R_ADDR,
  input [36-1:0] PORT_W_WR_DATA,
  input PORT_W_WR_EN,
  output [36-1:0] PORT_R_RD_DATA
);
  parameter INIT = 1152'bx;
  parameter PORT_W_CLK_POL = 1'b1;
  parameter OPTION_MODE = 0;
  parameter WIDTH = 18;
  parameter BITS_USED = 0;
  localparam BLOCK_NUM  = OPTION_MODE == 2 ? 64 : 32;
  localparam BLOCK_SIZE = OPTION_MODE == 3 ? 36 : 18;

\`include "rf_init.vh"

  // mode 0 - DPREG
  // mode 2 - NX_XRFB_64x18
  // mode 3 - NX_XRFB_32x36
  NX_RFB_U #(
    .mode(OPTION_MODE),
    .mem_ctxt($sformatf("%s",rf_init_to_string(INIT, BLOCK_NUM, BLOCK_SIZE))),
    .wck_edge(PORT_W_CLK_POL == 1 ? 1'b0 : 1'b1)
  ) _TECHMAP_REPLACE_ (
    .WCK(PORT_W_CLK),
    .I1(PORT_W_WR_DATA[0]),
    .I2(PORT_W_WR_DATA[1]),
    .I3(PORT_W_WR_DATA[2]),
    .I4(PORT_W_WR_DATA[3]),
    .I5(PORT_W_WR_DATA[4]),
    .I6(PORT_W_WR_DATA[5]),
    .I7(PORT_W_WR_DATA[6]),
    .I8(PORT_W_WR_DATA[7]),
    .I9(PORT_W_WR_DATA[8]),
    .I10(PORT_W_WR_DATA[9]),
    .I11(PORT_W_WR_DATA[10]),
    .I12(PORT_W_WR_DATA[11]),
    .I13(PORT_W_WR_DATA[12]),
    .I14(PORT_W_WR_DATA[13]),
    .I15(PORT_W_WR_DATA[14]),
    .I16(PORT_W_WR_DATA[15]),
    .I17(PORT_W_WR_DATA[16]),
    .I18(PORT_W_WR_DATA[17]),
    .I19(PORT_W_WR_DATA[18]),
    .I20(PORT_W_WR_DATA[19]),
    .I21(PORT_W_WR_DATA[20]),
    .I22(PORT_W_WR_DATA[21]),
    .I23(PORT_W_WR_DATA[22]),
    .I24(PORT_W_WR_DATA[23]),
    .I25(PORT_W_WR_DATA[24]),
    .I26(PORT_W_WR_DATA[25]),
    .I27(PORT_W_WR_DATA[26]),
    .I28(PORT_W_WR_DATA[27]),
    .I29(PORT_W_WR_DATA[28]),
    .I30(PORT_W_WR_DATA[29]),
    .I31(PORT_W_WR_DATA[30]),
    .I32(PORT_W_WR_DATA[31]),
    .I33(PORT_W_WR_DATA[32]),
    .I34(PORT_W_WR_DATA[33]),
    .I35(PORT_W_WR_DATA[34]),
    .I36(PORT_W_WR_DATA[35]),
    .O1(PORT_R_RD_DATA[0]),
    .O2(PORT_R_RD_DATA[1]),
    .O3(PORT_R_RD_DATA[2]),
    .O4(PORT_R_RD_DATA[3]),
    .O5(PORT_R_RD_DATA[4]),
    .O6(PORT_R_RD_DATA[5]),
    .O7(PORT_R_RD_DATA[6]),
    .O8(PORT_R_RD_DATA[7]),
    .O9(PORT_R_RD_DATA[8]),
    .O10(PORT_R_RD_DATA[9]),
    .O11(PORT_R_RD_DATA[10]),
    .O12(PORT_R_RD_DATA[11]),
    .O13(PORT_R_RD_DATA[12]),
    .O14(PORT_R_RD_DATA[13]),
    .O15(PORT_R_RD_DATA[14]),
    .O16(PORT_R_RD_DATA[15]),
    .O17(PORT_R_RD_DATA[16]),
    .O18(PORT_R_RD_DATA[17]),
    .O19(PORT_R_RD_DATA[18]),
    .O20(PORT_R_RD_DATA[19]),
    .O21(PORT_R_RD_DATA[20]),
    .O22(PORT_R_RD_DATA[21]),
    .O23(PORT_R_RD_DATA[22]),
    .O24(PORT_R_RD_DATA[23]),
    .O25(PORT_R_RD_DATA[24]),
    .O26(PORT_R_RD_DATA[25]),
    .O27(PORT_R_RD_DATA[26]),
    .O28(PORT_R_RD_DATA[27]),
    .O29(PORT_R_RD_DATA[28]),
    .O30(PORT_R_RD_DATA[29]),
    .O31(PORT_R_RD_DATA[30]),
    .O32(PORT_R_RD_DATA[31]),
    .O33(PORT_R_RD_DATA[32]),
    .O34(PORT_R_RD_DATA[33]),
    .O35(PORT_R_RD_DATA[34]),
    .O36(PORT_R_RD_DATA[35]),
    .RA1(PORT_R_ADDR[0]),
    .RA2(PORT_R_ADDR[1]),
    .RA3(PORT_R_ADDR[2]),
    .RA4(PORT_R_ADDR[3]),
    .RA5(PORT_R_ADDR[4]),
    .RA6(PORT_R_ADDR[5]),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(PORT_W_ADDR[0]),
    .WA2(PORT_W_ADDR[1]),
    .WA3(PORT_W_ADDR[2]),
    .WA4(PORT_W_ADDR[3]),
    .WA5(PORT_W_ADDR[4]),
    .WA6(PORT_W_ADDR[5]),
    .WE(PORT_W_WR_EN),
    .WEA(1'b0)
  );
endmodule

module $__NX_RFB_U_SPREG_ (
  input PORT_RW_CLK,
  input [4:0] PORT_RW_ADDR,
  input [17:0] PORT_RW_WR_DATA,
  input PORT_RW_WR_EN,
  output [17:0] PORT_RW_RD_DATA
);
  parameter INIT = 576'bx;
  parameter PORT_RW_CLK_POL = 1'b1;
  parameter BITS_USED = 0;
\`include "rf_init.vh"

  NX_RFB_U #(
    .mode(1),
    .mem_ctxt($sformatf("%s",rf_init_to_string(INIT, 32, 18))),
    .wck_edge(PORT_RW_CLK_POL == 1 ? 1'b0 : 1'b1)
  ) _TECHMAP_REPLACE_ (
    .WCK(PORT_RW_CLK),
    .I1(PORT_RW_WR_DATA[0]),
    .I2(PORT_RW_WR_DATA[1]),
    .I3(PORT_RW_WR_DATA[2]),
    .I4(PORT_RW_WR_DATA[3]),
    .I5(PORT_RW_WR_DATA[4]),
    .I6(PORT_RW_WR_DATA[5]),
    .I7(PORT_RW_WR_DATA[6]),
    .I8(PORT_RW_WR_DATA[7]),
    .I9(PORT_RW_WR_DATA[8]),
    .I10(PORT_RW_WR_DATA[9]),
    .I11(PORT_RW_WR_DATA[10]),
    .I12(PORT_RW_WR_DATA[11]),
    .I13(PORT_RW_WR_DATA[12]),
    .I14(PORT_RW_WR_DATA[13]),
    .I15(PORT_RW_WR_DATA[14]),
    .I16(PORT_RW_WR_DATA[15]),
    .I17(PORT_RW_WR_DATA[16]),
    .I18(PORT_RW_WR_DATA[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(PORT_RW_RD_DATA[0]),
    .O2(PORT_RW_RD_DATA[1]),
    .O3(PORT_RW_RD_DATA[2]),
    .O4(PORT_RW_RD_DATA[3]),
    .O5(PORT_RW_RD_DATA[4]),
    .O6(PORT_RW_RD_DATA[5]),
    .O7(PORT_RW_RD_DATA[6]),
    .O8(PORT_RW_RD_DATA[7]),
    .O9(PORT_RW_RD_DATA[8]),
    .O10(PORT_RW_RD_DATA[9]),
    .O11(PORT_RW_RD_DATA[10]),
    .O12(PORT_RW_RD_DATA[11]),
    .O13(PORT_RW_RD_DATA[12]),
    .O14(PORT_RW_RD_DATA[13]),
    .O15(PORT_RW_RD_DATA[14]),
    .O16(PORT_RW_RD_DATA[15]),
    .O17(PORT_RW_RD_DATA[16]),
    .O18(PORT_RW_RD_DATA[17]),
    .O19(),
    .O20(),
    .O21(),
    .O22(),
    .O23(),
    .O24(),
    .O25(),
    .O26(),
    .O27(),
    .O28(),
    .O29(),
    .O30(),
    .O31(),
    .O32(),
    .O33(),
    .O34(),
    .O35(),
    .O36(),
    .RA1(),
    .RA2(),
    .RA3(),
    .RA4(),
    .RA5(),
    .RA6(),
    .RA7(),
    .RA8(),
    .RA9(),
    .RA10(),
    .WA1(PORT_RW_ADDR[0]),
    .WA2(PORT_RW_ADDR[1]),
    .WA3(PORT_RW_ADDR[2]),
    .WA4(PORT_RW_ADDR[3]),
    .WA5(PORT_RW_ADDR[4]),
    .WA6(),
    .WE(PORT_RW_WR_EN),
    .WEA(1'b0)
  );
endmodule

module $__NX_XRFB_2R_1W_ (
  input PORT_W_CLK,
  input [4:0] PORT_W_ADDR,
  input [4:0] PORT_A_ADDR,
  input [4:0] PORT_B_ADDR,
  input [17:0] PORT_W_WR_DATA,
  input PORT_W_WR_EN,
  output [17:0] PORT_A_RD_DATA,
  output [17:0] PORT_B_RD_DATA
);
  parameter INIT = 576'bx;
  parameter PORT_W_CLK_POL = 1'b1;
  parameter BITS_USED = 0;
\`include "rf_init.vh"

  NX_RFB_U #(
    .mode(4),
    .mem_ctxt($sformatf("%s",rf_init_to_string(INIT, 32, 18))),
    .wck_edge(PORT_W_CLK_POL == 1 ? 1'b0 : 1'b1)
  ) _TECHMAP_REPLACE_ (
    .WCK(PORT_W_CLK),
    .I1(PORT_W_WR_DATA[0]),
    .I2(PORT_W_WR_DATA[1]),
    .I3(PORT_W_WR_DATA[2]),
    .I4(PORT_W_WR_DATA[3]),
    .I5(PORT_W_WR_DATA[4]),
    .I6(PORT_W_WR_DATA[5]),
    .I7(PORT_W_WR_DATA[6]),
    .I8(PORT_W_WR_DATA[7]),
    .I9(PORT_W_WR_DATA[8]),
    .I10(PORT_W_WR_DATA[9]),
    .I11(PORT_W_WR_DATA[10]),
    .I12(PORT_W_WR_DATA[11]),
    .I13(PORT_W_WR_DATA[12]),
    .I14(PORT_W_WR_DATA[13]),
    .I15(PORT_W_WR_DATA[14]),
    .I16(PORT_W_WR_DATA[15]),
    .I17(PORT_W_WR_DATA[16]),
    .I18(PORT_W_WR_DATA[17]),
    .I19(),
    .I20(),
    .I21(),
    .I22(),
    .I23(),
    .I24(),
    .I25(),
    .I26(),
    .I27(),
    .I28(),
    .I29(),
    .I30(),
    .I31(),
    .I32(),
    .I33(),
    .I34(),
    .I35(),
    .I36(),
    .O1(PORT_A_RD_DATA[0]),
    .O2(PORT_A_RD_DATA[1]),
    .O3(PORT_A_RD_DATA[2]),
    .O4(PORT_A_RD_DATA[3]),
    .O5(PORT_A_RD_DATA[4]),
    .O6(PORT_A_RD_DATA[5]),
    .O7(PORT_A_RD_DATA[6]),
    .O8(PORT_A_RD_DATA[7]),
    .O9(PORT_A_RD_DATA[8]),
    .O10(PORT_A_RD_DATA[9]),
    .O11(PORT_A_RD_DATA[10]),
    .O12(PORT_A_RD_DATA[11]),
    .O13(PORT_A_RD_DATA[12]),
    .O14(PORT_A_RD_DATA[13]),
    .O15(PORT_A_RD_DATA[14]),
    .O16(PORT_A_RD_DATA[15]),
    .O17(PORT_A_RD_DATA[16]),
    .O18(PORT_A_RD_DATA[17]),
    .O19(PORT_B_RD_DATA[0]),
    .O20(PORT_B_RD_DATA[1]),
    .O21(PORT_B_RD_DATA[2]),
    .O22(PORT_B_RD_DATA[3]),
    .O23(PORT_B_RD_DATA[4]),
    .O24(PORT_B_RD_DATA[5]),
    .O25(PORT_B_RD_DATA[6]),
    .O26(PORT_B_RD_DATA[7]),
    .O27(PORT_B_RD_DATA[8]),
    .O28(PORT_B_RD_DATA[9]),
    .O29(PORT_B_RD_DATA[10]),
    .O30(PORT_B_RD_DATA[11]),
    .O31(PORT_B_RD_DATA[12]),
    .O32(PORT_B_RD_DATA[13]),
    .O33(PORT_B_RD_DATA[14]),
    .O34(PORT_B_RD_DATA[15]),
    .O35(PORT_B_RD_DATA[16]),
    .O36(PORT_B_RD_DATA[17]),
    .RA1(PORT_A_ADDR[0]),
    .RA2(PORT_A_ADDR[1]),
    .RA3(PORT_A_ADDR[2]),
    .RA4(PORT_A_ADDR[3]),
    .RA5(PORT_A_ADDR[4]),
    .RA6(PORT_B_ADDR[0]),
    .RA7(PORT_B_ADDR[1]),
    .RA8(PORT_B_ADDR[2]),
    .RA9(PORT_B_ADDR[3]),
    .RA10(PORT_B_ADDR[4]),
    .WA1(PORT_W_ADDR[0]),
    .WA2(PORT_W_ADDR[1]),
    .WA3(PORT_W_ADDR[2]),
    .WA4(PORT_W_ADDR[3]),
    .WA5(PORT_W_ADDR[4]),
    .WA6(),
    .WE(PORT_W_WR_EN),
    .WEA(1'b0)
  );
endmodule`,"rf_rams_u.txt":`# Register-File  RAMs for NanoXplore NG-ULTRA

# Dual-port RAMs.
# NX_RFB_U in mode 0 (DPREG)
# NX_RFB_U in mode 2 (NX_XRFB_64x18)
# NX_RFB_U in mode 3 (NX_XRFB_32x36)

ram distributed $__NX_RFB_U_DPREG_ {
	option "MODE" 0 {
        cost 30;
        widthscale 30;
		abits 5;
		widths 18 global;
	}
	option "MODE" 2 {
        cost 50;
        widthscale 30;
		abits 6;
		widths 18 global;
	}
	option "MODE" 3 {
        cost 50;
        widthscale 30;
		abits 5;
		widths 36 global;
	}
    init no_undef;

    port sw "W" {
        clock anyedge;
    }
    port ar "R" {
    }
}

# Single-port RAMs.
# NX_RFB_U in mode 1 (SPREG)

ram distributed $__NX_RFB_U_SPREG_ {
	cost 30;
    widthscale;
    abits 5;
    width 18;
	init no_undef;
	port arsw "RW" {
		clock anyedge;
	}
}

# Single write dual read RAMs.
# NX_RFB_U in mode 4 (NX_XRFB_2R_1W)

ram distributed $__NX_XRFB_2R_1W_ {
	cost 40;
    widthscale 30;
    abits 5;
    width 18;
	init no_undef;
    port sw "W" {
        clock anyedge;
    }
    port ar "A" {
    }
    port ar "B" {
    }
}
`},nexus:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_nexus_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2+1:0] FCO, Y1;

	genvar i;

	// Carry feed-in
	CCU2 #(
		.INIT0("0xFFFF"),
		.INIT1("0x00AA"),
		.INJECT("NO")
	) ccu2c_i (
		.A0(1'b1), .B0(1'b1), .C0(1'b1), .D0(1'b1),
		.A1(CI), .B1(1'b1), .C1(1'b1), .D1(1'b1),
		.COUT(FCO[0])
	);

	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2 #(
			.INIT0("0x96AA"),
			.INIT1("0x96AA"),
			.INJECT("NO")
		) ccu2c_i (
			.CIN(FCO[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i+2])
		);

		assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i + 1] = (AA[i + 1] && BB[i + 1]) || ((Y[i + 1] ^ AA[i + 1] ^ BB[i + 1]) && (AA[i + 1] || BB[i + 1]));
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__NX_DP16K_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 129;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		wrbe_separate;
		rdwr no_change;
		portoption "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		portoption "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__NX_PDP16K_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	option "SAME_CLOCK" 1 cost 128;
	option "SAME_CLOCK" 0 cost 129;
	init no_undef;
	port sr "R" {
		option "SAME_CLOCK" 1 clock posedge "C";
		option "SAME_CLOCK" 0 clock posedge;
		clken;
		portoption "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		portoption "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		option "SAME_CLOCK" 1 clock posedge "C";
		option "SAME_CLOCK" 0 clock posedge;
		clken;
		option "SAME_CLOCK" 1 wrtrans all old;
	}
}
`,"brams_map.v":`module $__NX_DP16K_ (...);

parameter INIT = 0;

parameter PORT_A_OPTION_RESETMODE = "SYNC";
parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_OPTION_RESETMODE = "SYNC";
parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i;
	init_slice = 0;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;
wire [13:0] ADA;
wire [13:0] ADB;

generate

case(PORT_A_WIDTH)
1: assign ADA = PORT_A_ADDR;
2: assign ADA = {PORT_A_ADDR[13:1], 1'b1};
4: assign ADA = {PORT_A_ADDR[13:2], 2'b11};
9: assign ADA = {PORT_A_ADDR[13:3], 3'b111};
18: assign ADA = {PORT_A_ADDR[13:4], 2'b11, PORT_A_WR_BE};
endcase

case(PORT_B_WIDTH)
1: assign ADB = PORT_B_ADDR;
2: assign ADB = {PORT_B_ADDR[13:1], 1'b1};
4: assign ADB = {PORT_B_ADDR[13:2], 2'b11};
9: assign ADB = {PORT_B_ADDR[13:3], 3'b111};
18: assign ADB = {PORT_B_ADDR[13:4], 2'b11, PORT_B_WR_BE};
endcase

endgenerate

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_A($sformatf("X%0d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("X%0d", PORT_B_WIDTH)),
	.OUTREG_A("BYPASSED"),
	.OUTREG_B("BYPASSED"),
	.RESETMODE_A(PORT_A_OPTION_RESETMODE),
	.RESETMODE_B(PORT_B_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE_A(PORT_A_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE_B(PORT_B_OPTION_RESETMODE),
	.CSDECODE_A("111"),
	.CSDECODE_B("111"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.RSTA(PORT_A_OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA(3'b111),
	.DIA(DIA),
	.DOA(DOA),
	.ADA(ADA),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.RSTB(PORT_B_OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB(3'b111),
	.ADB(ADB),
	.DIB(DIB),
	.DOB(DOB),
);

endmodule


module $__NX_PDP16K_ (...);

parameter INIT = 0;
parameter OPTION_SAME_CLOCK = 1;

parameter PORT_R_WIDTH = 36;
parameter PORT_R_OPTION_RESETMODE = "SYNC";

input CLK_C;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i;
	init_slice = 0;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = DO;

wire [13:0] ADW;
wire [13:0] ADR;

generate

case (PORT_W_WIDTH)
1: assign ADW = PORT_W_ADDR;
2: assign ADW = {PORT_W_ADDR[13:1], 1'b1};
4: assign ADW = {PORT_W_ADDR[13:2], 2'b11};
9: assign ADW = {PORT_W_ADDR[13:3], 3'b111};
18: assign ADW = {PORT_W_ADDR[13:4], 2'b11, PORT_W_WR_EN};
36: assign ADW = {PORT_W_ADDR[13:5], 1'b1, PORT_W_WR_EN};
endcase

case (PORT_R_WIDTH)
1: assign ADR = PORT_R_ADDR;
2: assign ADR = {PORT_R_ADDR[13:1], 1'b1};
4: assign ADR = {PORT_R_ADDR[13:2], 2'b11};
9: assign ADR = {PORT_R_ADDR[13:3], 3'b111};
18: assign ADR = {PORT_R_ADDR[13:4], 4'b1111};
36: assign ADR = {PORT_R_ADDR[13:5], 5'b11111};
endcase

if (OPTION_SAME_CLOCK) begin

PDPSC16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_W($sformatf("X%0d", PORT_W_WIDTH)),
	.DATA_WIDTH_R($sformatf("X%0d", PORT_R_WIDTH)),
	.OUTREG("BYPASSED"),
	.RESETMODE(PORT_R_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),
	.CSDECODE_W("111"),
	.CSDECODE_R("111"),
	.ECC("DISABLED"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLK(CLK_C),

	.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),
	.CSW(3'b111),
	.ADW(ADW),
	.DI(DI),

	.CER(PORT_R_CLK_EN),
	.RST(PORT_R_OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSR(3'b111),
	.ADR(ADR),
	.DO(DO),
);

end else begin

PDP16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_W($sformatf("X%0d", PORT_W_WIDTH)),
	.DATA_WIDTH_R($sformatf("X%0d", PORT_R_WIDTH)),
	.OUTREG("BYPASSED"),
	.RESETMODE(PORT_R_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),
	.CSDECODE_W("111"),
	.CSDECODE_R("111"),
	.ECC("DISABLED"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLKW(PORT_W_CLK),
	.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),
	.CSW(3'b111),
	.ADW(ADW),
	.DI(DI),

	.CLKR(PORT_R_CLK),
	.CER(PORT_R_CLK_EN),
	.RST(PORT_R_OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSR(3'b111),
	.ADR(ADR),
	.DO(DO),
);

end

endgenerate

endmodule
`,"cells_map.v":`// Flipflop intermediate map level
module \\$__FF_NOLSR (input D, C, E, output Q);
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
	generate
		if (_TECHMAP_WIREINIT_Q_ === 1'b1)
			FD1P3JX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(1'b0), .Q(Q));
		else
			FD1P3IX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(1'b0), .Q(Q));
	endgenerate
endmodule

module \\$__FF_SYNCLSR (input D, C, E, R, output Q);
	parameter SR_VAL = 1'b0;
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
	wire Ci, Ei, Ri, Rg, Dd;
	generate
		if (SR_VAL)
			FD1P3JX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));
		else
			FD1P3IX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));
	endgenerate
endmodule

module \\$__FF_ASYNCLSR (input D, C, E, R, output Q);
	parameter SR_VAL = 1'b0;
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = (_TECHMAP_WIREINIT_Q_ === 1'bx || _TECHMAP_WIREINIT_Q_ === SR_VAL);
	wire Ci, Ei, Ri, Rg, Dd;
	generate
		if (SR_VAL)
			FD1P3BX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));
		else
			FD1P3DX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));
	endgenerate
endmodule


module  \\$_DFF_P_ (input D, C, output Q); \\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(1'b1), .Q(Q)); endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q); \\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(E), .Q(Q)); endmodule

module  \\$_DFF_PP0_ (input D, C, R, output Q); \\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); \\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule

module  \\$_SDFF_PP0_ (input D, C, R, output Q); \\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); \\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule

module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); \\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); \\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule

module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); \\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); \\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
			if (LUT == 2'b01)
				INV _TECHMAP_REPLACE_ (.A(A[0]), .Z(Y));
			else
				LUT4 #(.INIT($sformatf("0x%04x", {{8{LUT[1]}}, {8{LUT[0]}}}))) _TECHMAP_REPLACE_ (.Z(Y),
					.D(A[0]));
		end else
		if (WIDTH == 2) begin
			localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
			LUT4 #(.INIT($sformatf("0x%04x",  INIT))) _TECHMAP_REPLACE_ (.Z(Y),
				.C(A[0]), .D(A[1]));
		end else
		if (WIDTH == 3) begin
			localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
			LUT4 #(.INIT($sformatf("0x%04x", INIT))) _TECHMAP_REPLACE_ (.Z(Y),
				.B(A[0]), .C(A[1]), .D(A[2]));
		end else
		if (WIDTH == 4) begin
			LUT4 #(.INIT($sformatf("0x%04x", LUT))) _TECHMAP_REPLACE_ (.Z(Y),
				.A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
		end else
		if (WIDTH == 5) begin
			WIDEFN9 #(
				.INIT0($sformatf("0x%04x", LUT[15:0 ])),
				.INIT1($sformatf("0x%04x", LUT[31:16])),
			) _TECHMAP_REPLACE_ (
				.A0(A[0]), .B0(A[1]), .C0(A[2]), .D0(A[3]),
				.A1(A[0]), .B1(A[1]), .C1(A[2]), .D1(A[3]),
				.SEL(A[4]), .Z(Y)
			);
		end
	endgenerate
endmodule
\`endif
`,"cells_sim.v":`(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
	parameter INIT = "0x0000";
\`include "parse_init.vh"
	localparam initp = parse_init(INIT);
	wire [7:0] s3 = D ?     initp[15:8] :    initp[7:0];
	wire [3:0] s2 = C ?       s3[ 7:4]  :       s3[3:0];
	wire [1:0] s1 = B ?       s2[ 3:2]  :       s2[1:0];
	assign Z =      A ?          s1[1]  :         s1[0];

	// Per-input delay differences are considered 'interconnect'
	// so not known yet
	specify
		(A => Z) = 233;
		(B => Z) = 233;
		(C => Z) = 233;
		(D => Z) = 233;
	endspecify

endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input SEL, D, C, B, A, output Z);
	specify
		(SEL => Z) = 171;
		(D => Z) = 303;
		(C => Z) = 311;
		(B => Z) = 309;
		(A => Z) = 306;
	endspecify
endmodule

// Two LUT4s and MUX2
module WIDEFN9(input A0, B0, C0, D0, A1, B1, C1, D1, SEL, output Z);
	parameter INIT0 = "0x0000";
	parameter INIT1 = "0x0000";
	wire z0, z1;
	LUT4 #(.INIT(INIT0)) lut4_0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(z0));
	LUT4 #(.INIT(INIT1)) lut4_1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(z1));
	assign Z = SEL ? z1 : z0;
endmodule

(* abc9_box, lib_whitebox *)
module INV(input A, output Z);
	assign Z = !A;

	specify
		(A => Z) = 10;
	endspecify
endmodule

// Bidirectional IO buffer
module BB(input T, I, output O,
	(* iopad_external_pin *) inout B);
	assign B = T ? 1'bz : I;
	assign O = B;
endmodule

// Input buffer
module IB(
	(* iopad_external_pin *) input I,
	output O);
	assign O = I;
endmodule

// Output buffer
module OB(input I,
	(* iopad_external_pin *) output O);
	assign O = I;
endmodule

// Output buffer with tristate
module OBZ(input I, T,
	(* iopad_external_pin *) output O);
	assign O = T ? 1'bz : I;
endmodule

// Constants
module VLO(output Z);
	assign Z = 1'b0;
endmodule

module VHI(output Z);
	assign Z = 1'b1;
endmodule

// Vendor flipflops
// (all have active high clock, enable and set/reset - use INV to invert)

// Async preset
(* abc9_box, lib_whitebox *)
module FD1P3BX(input D, CK, SP, PD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b1;
	always @(posedge CK or posedge PD)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
\`ifndef YOSYS
		if (PD) (posedge CLK => (Q : 1)) = 0;
\`else
		if (PD) (PD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
\`endif
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Async clear
(* abc9_box, lib_whitebox *)
module FD1P3DX(input D, CK, SP, CD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b0;
	always @(posedge CK or posedge CD)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
\`ifndef YOSYS
		if (CD) (posedge CLK => (Q : 0)) = 0;
\`else
		if (CD) (CD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
\`endif
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Sync clear
(* abc9_flop, lib_whitebox *)
module FD1P3IX(input D, CK, SP, CD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b0;
	always @(posedge CK)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Sync preset
(* abc9_flop, lib_whitebox *)
module FD1P3JX(input D, CK, SP, PD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b1;
	always @(posedge CK)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// LUT4 with LUT3 tap for CCU2 use only
(* lib_whitebox *)
module LUT4_3(input A, B, C, D, output Z, Z3);
	parameter INIT = "0x0000";
\`include "parse_init.vh"
	localparam initp = parse_init(INIT);
	wire [7:0] s3 = D ?     initp[15:8] :     initp[7:0];
	wire [3:0] s2 = C ?        s3[ 7:4] :        s3[3:0];
	wire [1:0] s1 = B ?        s2[ 3:2] :        s2[1:0];
	assign Z =      A ?           s1[1] :          s1[0];

	wire [3:0] s2_3 = C ?   initp[ 7:4] :     initp[3:0];
	wire [1:0] s1_3 = B ?    s2_3[ 3:2] :      s2_3[1:0];
	assign Z3 =       A ?       s1_3[1] :        s1_3[0];

endmodule

// Carry primitive (incoporating two LUTs)
(* abc9_box, lib_whitebox *)
module CCU2(
	(* abc9_carry *) input CIN,
	input A1, B1, C1, D1, A0, B0, C0, D0,
	output S1, S0,
	(* abc9_carry *) output COUT);
	parameter INJECT = "YES";
	parameter INIT0 = "0x0000";
	parameter INIT1 = "0x1111";

	localparam inject_p = (INJECT == "YES") ? 1'b1 : 1'b0;

	wire LUT3_0, LUT4_0, LUT3_1, LUT4_1, carry_0;
	LUT4_3 #(.INIT(INIT0)) lut0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0), .Z3(LUT3_0));
	LUT4_3 #(.INIT(INIT1)) lut1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1), .Z3(LUT3_1));

	assign S0 = LUT4_0 ^ (CIN & ~inject_p);
	assign carry_0 = LUT4_0 ? CIN : (LUT3_0 & ~inject_p);
	assign S1 = LUT4_1 ^ (carry_0 & ~inject_p);
	assign COUT = LUT4_1 ? carry_0 : (LUT3_1 & ~inject_p);

	specify
		(A0 => S0) = 233;
		(B0 => S0) = 233;
		(C0 => S0) = 233;
		(D0 => S0) = 233;
		(CIN => S0) = 228;
		(A0 => S1) = 481;
		(B0 => S1) = 481;
		(C0 => S1) = 481;
		(D0 => S1) = 481;
		(A1 => S1) = 233;
		(B1 => S1) = 233;
		(C1 => S1) = 233;
		(D1 => S1) = 233;
		(CIN => S1) = 307;
		(A0 => COUT) = 347;
		(B0 => COUT) = 347;
		(C0 => COUT) = 347;
		(D0 => COUT) = 347;
		(A1 => COUT) = 347;
		(B1 => COUT) = 347;
		(C1 => COUT) = 347;
		(D1 => COUT) = 347;
		(CIN => COUT) = 59;
	endspecify

endmodule

// Packed flipflop
module OXIDE_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter REGDDR = "DISABLED";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (REGDDR == "ENABLED") begin
			if (SRMODE == "ASYNC") begin
				always @(posedge muxclk, negedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk, negedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end else begin
			if (SRMODE == "ASYNC") begin
				always @(posedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end
	endgenerate
endmodule

// Packed combinational logic (for post-pnr sim)
module OXIDE_COMB(
	input A, B, C, D, // LUT inputs
	input SEL, // mux select input
	input F1, // output from LUT 1 for mux
	input FCI, // carry input
	input WAD0, WAD1, WAD2, WAD3, // LUTRAM write address inputs
	input WD, // LUTRAM write data input
	input WCK, WRE, // LUTRAM write clock and enable
	output F, // LUT/carry output
	output OFX // mux output
);
	parameter MODE = "LOGIC"; // LOGIC, CCU2, DPRAM
	parameter [15:0] INIT = 16'h0000;
	parameter INJECT = "YES";

	localparam inject_p = (INJECT == "YES") ? 1'b1 : 1'b0;

	reg [15:0] lut = INIT;

	wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
	wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
	wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
	wire Z =        A ?          s1[1] :         s1[0];

	wire [3:0] s2_3 = C ?   INIT[ 7:4] :     INIT[3:0];
	wire [1:0] s1_3 = B ?   s2_3[ 3:2] :     s2_3[1:0];
	wire Z3 =         A ?      s1_3[1] :       s1_3[0];

	generate
		if (MODE == "DPRAM") begin
			always @(posedge WCK)
				if (WRE)
					lut[{WAD3, WAD2, WAD1, WAD0}] <= WD;
		end
		if (MODE == "CCU2") begin
			assign F = Z ^ (FCI & ~inject_p);
			assign FCO = Z ? FCI : (Z3 & ~inject_p);
		end else begin
			assign F = Z;
		end
	endgenerate

	assign OFX = SEL ? F1 : F;

endmodule

// LUTRAM
module DPR16X4(
	input [3:0] RAD, DI, WAD,
	input WRE, WCK,
	output [3:0] DO
);
	parameter INITVAL = "0x0000000000000000";
\`include "parse_init.vh"
	localparam [63:0] parsed_init = parse_init_64(INITVAL);

	reg [3:0] mem[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i++)
			mem[i] = parsed_init[i * 4 +: 4];
	end

	always @(posedge WCK)
		if (WRE)
			mem[WAD] <= DI;
	assign DO = mem[RAD];
endmodule

// Used for all the DSP models to reduce duplication
module OXIDE_DSP_REG #(
	parameter W = 18,
	parameter USED = "REGISTER",
	parameter RESETMODE = "SYNC"
) (
	input CLK, CE, RST,
	input [W-1:0] D,
	output reg [W-1:0] Q
);
	generate
		if (USED == "BYPASS")
			always @* Q = D;
		else if (USED == "REGISTER") begin
			initial Q = 0;
			if (RESETMODE == "ASYNC")
				always @(posedge CLK, posedge RST) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
			else if (RESETMODE == "SYNC")
				always @(posedge CLK) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
		end
	endgenerate
endmodule

module OXIDE_DSP_SIM #(
	// User facing parameters
	parameter REGINPUTA = "BYPASS",
	parameter REGINPUTB = "BYPASS",
	parameter REGINPUTC = "BYPASS",
	parameter REGADDSUB = "BYPASS",
	parameter REGLOADC = "BYPASS",
	parameter REGLOADC2 = "BYPASS",
	parameter REGCIN = "BYPASS",
	parameter REGPIPELINE = "BYPASS",
	parameter REGOUTPUT = "BYPASS",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC",
	// Internally used parameters
	parameter A_WIDTH = 36,
	parameter B_WIDTH = 36,
	parameter C_WIDTH = 36,
	parameter Z_WIDTH = 72,
	parameter PREADD_USED = 0,
	parameter ADDSUB_USED = 0
) (
	input [A_WIDTH-1:0] A,
	input [B_WIDTH-1:0] B,
	input [C_WIDTH-1:0] C,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input CIN,
	input LOADC,
	input ADDSUB,
	input CLK,
	input CEA, CEB, CEC, CEPIPE, CECTRL, CECIN, CEOUT,
	input RSTA, RSTB, RSTC, RSTPIPE, RSTCTRL, RSTCIN, RSTOUT,
	output wire [Z_WIDTH-1:0] Z
);
	
	localparam M_WIDTH = (A_WIDTH+B_WIDTH);

	/******** REGISTERS ********/

	wire [M_WIDTH-1:0] pipe_d, pipe_q;
	wire [Z_WIDTH-1:0] z_d;

	wire [A_WIDTH-1:0] a_r;
	wire [B_WIDTH-1:0] b_r;
	wire [C_WIDTH-1:0] c_r, c_r2;
	wire asgd_r, bsgd_r, csgd_r, csgd_r2;

	wire addsub_r, addsub_r2, cin_r, cin_r2, sgd_r, sgd_r2;
	wire loadc_r, loadc_r2;

	OXIDE_DSP_REG #(A_WIDTH+1, REGINPUTA, RESETMODE) a_reg(CLK, CEA, RSTA, {SIGNEDA, A}, {asgd_r, a_r});
	OXIDE_DSP_REG #(B_WIDTH+1, REGINPUTB, RESETMODE) b_reg(CLK, CEB, RSTB, {SIGNEDB, B}, {bsgd_r, b_r});
	OXIDE_DSP_REG #(C_WIDTH+1, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNEDC, C}, {csgd_r, c_r});

	OXIDE_DSP_REG #(M_WIDTH, REGPIPELINE, RESETMODE) pipe_reg(CLK, CEPIPE, RSTPIPE, pipe_d, pipe_q);

	OXIDE_DSP_REG #(2, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNEDA, ADDSUB}, {sgd_r, addsub_r});
	OXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);
	OXIDE_DSP_REG #(2, REGPIPELINE, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});
	OXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);

	OXIDE_DSP_REG #(1, REGCIN, RESETMODE) cin_reg(CLK, CECIN, RSTCIN, CIN, cin_r);
	OXIDE_DSP_REG #(1, REGPIPELINE, RESETMODE) cin2_reg(CLK, CECIN, RSTCIN, cin_r, cin_r2);

	OXIDE_DSP_REG #(C_WIDTH+1, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});

	OXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);

	/******** PREADDER ********/

	wire [B_WIDTH-1:0] mult_b;
	wire mult_b_sgd;

	generate
		if (PREADD_USED) begin
			assign mult_b = (b_r + c_r);
			assign mult_b_sgd = (bsgd_r | csgd_r);
		end else begin
			assign mult_b = b_r;
			assign mult_b_sgd = bsgd_r;
		end
	endgenerate

	/******** MULTIPLIER ********/

	// sign extend operands if needed
	wire [M_WIDTH-1:0] mult_a_ext = {{(M_WIDTH-A_WIDTH){asgd_r ? a_r[A_WIDTH-1] : 1'b0}}, a_r};
	wire [M_WIDTH-1:0] mult_b_ext = {{(M_WIDTH-B_WIDTH){mult_b_sgd ? mult_b[B_WIDTH-1] : 1'b0}}, mult_b};

	wire [M_WIDTH-1:0] mult_m = mult_a_ext * mult_b_ext;

	/******** ACCUMULATOR ********/

	wire [Z_WIDTH-1:0] m_ext;

	generate
		if (ADDSUB_USED) begin
			assign pipe_d = mult_m;
			assign m_ext = {{(Z_WIDTH-M_WIDTH){sgd_r2 ? pipe_q[M_WIDTH-1] : 1'b0}}, pipe_q};
			assign z_d = (loadc_r2 ? c_r2 : Z) + cin_r2 + (addsub_r2 ? -m_ext : m_ext);  
		end else begin
			assign z_d = mult_m;
		end
	endgenerate


endmodule

module MULT9X9 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A,
	input [8:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [17:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(9),
		.B_WIDTH(9),
		.Z_WIDTH(18),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [35:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.Z_WIDTH(36),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT18X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [35:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [53:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(36),
		.Z_WIDTH(54),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT36X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [35:0] A,
	input [35:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [71:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(36),
		.B_WIDTH(36),
		.Z_WIDTH(72),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTPREADD9X9 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A,
	input [8:0] B,
	input [8:0] C,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input CEC,
	input RSTC,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input RSTOUT,
	input CEOUT,
	output [17:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(9),
		.B_WIDTH(9),
		.C_WIDTH(9),
		.Z_WIDTH(18),
		.PREADD_USED(1),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTPREADD18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input [17:0] C,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input CEC,
	input RSTC,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input RSTOUT,
	input CEOUT,
	output [35:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.C_WIDTH(18),
		.Z_WIDTH(36),
		.PREADD_USED(1),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTADDSUB18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGCIN = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input [53:0] C,
    input CLK,
    input CEA,
    input RSTA,
    input CEB,
    input RSTB,
    input CEC,
    input RSTC,
    input SIGNED,
    input RSTPIPE,
    input CEPIPE,
    input RSTCTRL,
    input CECTRL,
    input RSTCIN,
    input CECIN,
    input LOADC,
    input ADDSUB,
    output [53:0] Z,
    input RSTOUT,
    input CEOUT,
    input CIN
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGADDSUB(REGADDSUB),
		.REGLOADC(REGLOADC),
		.REGLOADC2(REGLOADC2),
		.REGCIN(REGCIN),
		.REGPIPELINE(REGPIPELINE),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.C_WIDTH(54),
		.Z_WIDTH(54),
		.PREADD_USED(0),
		.ADDSUB_USED(1)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),
		.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),
		.CECIN(CECIN), .RSTCIN(RSTCIN),
		.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),
		.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTADDSUB36X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGCIN = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [35:0] A,
	input [35:0] B,
	input [107:0] C,
    input CLK,
    input CEA,
    input RSTA,
    input CEB,
    input RSTB,
    input CEC,
    input RSTC,
    input SIGNED,
    input RSTPIPE,
    input CEPIPE,
    input RSTCTRL,
    input CECTRL,
    input RSTCIN,
    input CECIN,
    input LOADC,
    input ADDSUB,
    output [107:0] Z,
    input RSTOUT,
    input CEOUT,
    input CIN
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGADDSUB(REGADDSUB),
		.REGLOADC(REGLOADC),
		.REGLOADC2(REGLOADC2),
		.REGCIN(REGCIN),
		.REGPIPELINE(REGPIPELINE),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(36),
		.B_WIDTH(36),
		.C_WIDTH(108),
		.Z_WIDTH(108),
		.PREADD_USED(0),
		.ADDSUB_USED(1)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),
		.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),
		.CECIN(CECIN), .RSTCIN(RSTCIN),
		.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),
		.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULTADDSUB9X9WIDE #(
	parameter REGINPUTAB0 = "REGISTER",
	parameter REGINPUTAB1 = "REGISTER",
	parameter REGINPUTAB2 = "REGISTER",
	parameter REGINPUTAB3 = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A0, B0, A1, B1, A2, B2, A3, B3,
	input [53:0] C,
	input CLK,
	input CEA0A1, CEA2A3,
	input RSTA0A1, RSTA2A3,
	input CEB0B1, CEB2B3,
	input RSTB0B1, RSTB2B3,
	input CEC, RSTC,
	input CECTRL, RSTCTRL,
	input SIGNED,
	input RSTPIPE, CEPIPE,
	input RSTOUT, CEOUT,
	input LOADC,
	input [3:0] ADDSUB,
	output [53:0] Z
);
	wire [17:0] m0, m1, m2, m3;

	localparam M_WIDTH = 18;
	localparam Z_WIDTH = 54;

	MULT9X9 #(
		.REGINPUTA(REGINPUTAB0), .REGINPUTB(REGINPUTAB0), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_0 (
		.A(A0), .B(B0), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA0A1), .RSTA(RSTA0A1),
		.CEB(CEB0B1), .RSTB(RSTB0B1),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m0)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB1), .REGINPUTB(REGINPUTAB1), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_1 (
		.A(A1), .B(B1), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA0A1), .RSTA(RSTA0A1),
		.CEB(CEB0B1), .RSTB(RSTB0B1),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m1)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB2), .REGINPUTB(REGINPUTAB2), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_2 (
		.A(A2), .B(B2), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA2A3), .RSTA(RSTA2A3),
		.CEB(CEB2B3), .RSTB(RSTB2B3),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m2)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB3), .REGINPUTB(REGINPUTAB3), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_3 (
		.A(A3), .B(B3), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA2A3), .RSTA(RSTA2A3),
		.CEB(CEB2B3), .RSTB(RSTB2B3),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m3)
	);

	wire [53:0] c_r, c_r2;
	wire [3:0] addsub_r, addsub_r2;
	wire sgd_r, sgd_r2, csgd_r, csgd_r2;
	wire loadc_r, loadc_r2;

	OXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNED, ADDSUB}, {sgd_r, addsub_r});
	OXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});

	OXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);
	OXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);

	OXIDE_DSP_REG #(55, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNED, C}, {csgd_r, c_r});
	OXIDE_DSP_REG #(55, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});


	wire [18:0] m0_ext, m1_ext, m2_ext, m3_ext;

	assign m0_ext = {sgd_r2 ? m0[M_WIDTH-1] : 1'b0, m0};
	assign m1_ext = {sgd_r2 ? m1[M_WIDTH-1] : 1'b0, m1};
	assign m2_ext = {sgd_r2 ? m2[M_WIDTH-1] : 1'b0, m2};
	assign m3_ext = {sgd_r2 ? m3[M_WIDTH-1] : 1'b0, m3};

	wire [18:0] s0 = addsub_r2[2] ? (m0_ext - m1_ext) : (m0_ext + m1_ext);
	wire [18:0] s1 = addsub_r2[3] ? (m2_ext - m3_ext) : (m2_ext + m3_ext);

	wire [53:0] s0_ext = {{(54-19){sgd_r2 ? s0[18] : 1'b0}}, s0};
	wire [53:0] s1_ext = {{(54-19){sgd_r2 ? s1[18] : 1'b0}}, s1};

	wire [53:0] c_op = loadc_r2 ? c_r2 : Z;

	// The diagram in the docs is wrong! It is not two cascaded 2-input add/subs as shown,
	// but a three-input unit with negation controls on two inputs (i.e. addsub_r2[0]
	// negates s1 not (s1 +/- s0))
	wire [53:0] z_d =  c_op + (addsub_r2[0] ? -s1_ext : s1_ext) + (addsub_r2[1] ? -s0_ext : s0_ext);

	OXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);

endmodule
`,"cells_xtra.v":new URL("cells_xtra-e485fadd.v?hash=e485fadd",import.meta.url),"dsp_map.v":`module \\$__NX_MUL36X36 (input [35:0] A, input [35:0] B, output [71:0] Y);

	parameter A_WIDTH = 36;
	parameter B_WIDTH = 36;
	parameter Y_WIDTH = 72;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT36X36 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL36X18 (input [35:0] A, input [17:0] B, output [53:0] Y);

	parameter A_WIDTH = 36;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 54;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X36 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(B), .B(A),
		.SIGNEDA(B_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(A_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL9X9 (input [8:0] A, input [8:0] B, output [17:0] Y);

	parameter A_WIDTH = 9;
	parameter B_WIDTH = 9;
	parameter Y_WIDTH = 18;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT9X9 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lrams.txt":`ram huge $__NX_DPSC512K_ {
	abits 14;
	width 32;
	byte 8;
	cost 2048;
	init no_undef;
	port srsw "A" "B" {
		clock posedge "C";
		clken;
		wrbe_separate;
		rdwr no_change;
		option "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		wrtrans all old;
	}
}
`,"lrams_map.v":`module $__NX_DPSC512K_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [3:0] PORT_A_WR_BE;
input [31:0] PORT_A_WR_DATA;
output [31:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [3:0] PORT_B_WR_BE;
input [31:0] PORT_B_WR_DATA;
output [31:0] PORT_B_RD_DATA;

function [5119:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 128; i = i + 1) begin
		init_slice[i*40+:32] = INIT[(idx * 128 + i) * 32+:32];
	end
endfunction

DPSC512K #(
	.INITVAL_00($sformatf("0x%01280x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%01280x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%01280x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%01280x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%01280x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%01280x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%01280x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%01280x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%01280x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%01280x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%01280x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%01280x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%01280x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%01280x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%01280x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%01280x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%01280x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%01280x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%01280x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%01280x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%01280x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%01280x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%01280x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%01280x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%01280x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%01280x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%01280x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%01280x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%01280x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%01280x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%01280x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%01280x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%01280x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%01280x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%01280x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%01280x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%01280x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%01280x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%01280x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%01280x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%01280x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%01280x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%01280x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%01280x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%01280x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%01280x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%01280x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%01280x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%01280x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%01280x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%01280x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%01280x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%01280x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%01280x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%01280x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%01280x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%01280x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%01280x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%01280x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%01280x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%01280x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%01280x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%01280x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%01280x", init_slice('h3f))),
	.INITVAL_40($sformatf("0x%01280x", init_slice('h40))),
	.INITVAL_41($sformatf("0x%01280x", init_slice('h41))),
	.INITVAL_42($sformatf("0x%01280x", init_slice('h42))),
	.INITVAL_43($sformatf("0x%01280x", init_slice('h43))),
	.INITVAL_44($sformatf("0x%01280x", init_slice('h44))),
	.INITVAL_45($sformatf("0x%01280x", init_slice('h45))),
	.INITVAL_46($sformatf("0x%01280x", init_slice('h46))),
	.INITVAL_47($sformatf("0x%01280x", init_slice('h47))),
	.INITVAL_48($sformatf("0x%01280x", init_slice('h48))),
	.INITVAL_49($sformatf("0x%01280x", init_slice('h49))),
	.INITVAL_4A($sformatf("0x%01280x", init_slice('h4a))),
	.INITVAL_4B($sformatf("0x%01280x", init_slice('h4b))),
	.INITVAL_4C($sformatf("0x%01280x", init_slice('h4c))),
	.INITVAL_4D($sformatf("0x%01280x", init_slice('h4d))),
	.INITVAL_4E($sformatf("0x%01280x", init_slice('h4e))),
	.INITVAL_4F($sformatf("0x%01280x", init_slice('h4f))),
	.INITVAL_50($sformatf("0x%01280x", init_slice('h50))),
	.INITVAL_51($sformatf("0x%01280x", init_slice('h51))),
	.INITVAL_52($sformatf("0x%01280x", init_slice('h52))),
	.INITVAL_53($sformatf("0x%01280x", init_slice('h53))),
	.INITVAL_54($sformatf("0x%01280x", init_slice('h54))),
	.INITVAL_55($sformatf("0x%01280x", init_slice('h55))),
	.INITVAL_56($sformatf("0x%01280x", init_slice('h56))),
	.INITVAL_57($sformatf("0x%01280x", init_slice('h57))),
	.INITVAL_58($sformatf("0x%01280x", init_slice('h58))),
	.INITVAL_59($sformatf("0x%01280x", init_slice('h59))),
	.INITVAL_5A($sformatf("0x%01280x", init_slice('h5a))),
	.INITVAL_5B($sformatf("0x%01280x", init_slice('h5b))),
	.INITVAL_5C($sformatf("0x%01280x", init_slice('h5c))),
	.INITVAL_5D($sformatf("0x%01280x", init_slice('h5d))),
	.INITVAL_5E($sformatf("0x%01280x", init_slice('h5e))),
	.INITVAL_5F($sformatf("0x%01280x", init_slice('h5f))),
	.INITVAL_60($sformatf("0x%01280x", init_slice('h60))),
	.INITVAL_61($sformatf("0x%01280x", init_slice('h61))),
	.INITVAL_62($sformatf("0x%01280x", init_slice('h62))),
	.INITVAL_63($sformatf("0x%01280x", init_slice('h63))),
	.INITVAL_64($sformatf("0x%01280x", init_slice('h64))),
	.INITVAL_65($sformatf("0x%01280x", init_slice('h65))),
	.INITVAL_66($sformatf("0x%01280x", init_slice('h66))),
	.INITVAL_67($sformatf("0x%01280x", init_slice('h67))),
	.INITVAL_68($sformatf("0x%01280x", init_slice('h68))),
	.INITVAL_69($sformatf("0x%01280x", init_slice('h69))),
	.INITVAL_6A($sformatf("0x%01280x", init_slice('h6a))),
	.INITVAL_6B($sformatf("0x%01280x", init_slice('h6b))),
	.INITVAL_6C($sformatf("0x%01280x", init_slice('h6c))),
	.INITVAL_6D($sformatf("0x%01280x", init_slice('h6d))),
	.INITVAL_6E($sformatf("0x%01280x", init_slice('h6e))),
	.INITVAL_6F($sformatf("0x%01280x", init_slice('h6f))),
	.INITVAL_70($sformatf("0x%01280x", init_slice('h70))),
	.INITVAL_71($sformatf("0x%01280x", init_slice('h71))),
	.INITVAL_72($sformatf("0x%01280x", init_slice('h72))),
	.INITVAL_73($sformatf("0x%01280x", init_slice('h73))),
	.INITVAL_74($sformatf("0x%01280x", init_slice('h74))),
	.INITVAL_75($sformatf("0x%01280x", init_slice('h75))),
	.INITVAL_76($sformatf("0x%01280x", init_slice('h76))),
	.INITVAL_77($sformatf("0x%01280x", init_slice('h77))),
	.INITVAL_78($sformatf("0x%01280x", init_slice('h78))),
	.INITVAL_79($sformatf("0x%01280x", init_slice('h79))),
	.INITVAL_7A($sformatf("0x%01280x", init_slice('h7a))),
	.INITVAL_7B($sformatf("0x%01280x", init_slice('h7b))),
	.INITVAL_7C($sformatf("0x%01280x", init_slice('h7c))),
	.INITVAL_7D($sformatf("0x%01280x", init_slice('h7d))),
	.INITVAL_7E($sformatf("0x%01280x", init_slice('h7e))),
	.INITVAL_7F($sformatf("0x%01280x", init_slice('h7f))),
	.OUTREG_A("NO_REG"),
	.OUTREG_B("NO_REG"),
	.ECC_BYTE_SEL("BYTE_EN"),
	.GSR("DISABLED"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
) _TECHMAP_REPLACE_ (
	.CLK(CLK_C),

	.WEA(PORT_A_WR_EN),
	.CEA(PORT_A_CLK_EN),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA(1'b1),
	.ADA(PORT_A_ADDR),
	.BENA_N(~PORT_A_WR_BE),
	.DIA(PORT_A_WR_DATA),
	.DOA(PORT_A_RD_DATA),

	.WEB(PORT_B_WR_EN),
	.CEB(PORT_B_CLK_EN),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB(1'b1),
	.BENB_N(~PORT_B_WR_BE),
	.ADB(PORT_B_ADDR),
	.DIB(PORT_B_WR_DATA),
	.DOB(PORT_B_RD_DATA),
);

endmodule
`,"lutrams.txt":`ram distributed $__NEXUS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__NEXUS_DPR16X4_ (...);
	parameter INIT = 64'b0;

	input PORT_W_CLK;
	input [3:0] PORT_W_ADDR;
	input [3:0] PORT_W_WR_DATA;
	input PORT_W_WR_EN;

	input [3:0] PORT_R_ADDR;
	output [3:0] PORT_R_RD_DATA;

	DPR16X4 #(
		.INITVAL($sformatf("0x%08x", INIT))
	) _TECHMAP_REPLACE_ (
		.RAD(PORT_R_ADDR),
		.DO(PORT_R_RD_DATA),

		.WAD(PORT_W_ADDR),
		.DI(PORT_W_WR_DATA),
		.WCK(PORT_W_CLK),
		.WRE(PORT_W_WR_EN)
	);
endmodule
`,"parse_init.vh":`function [15:0] parse_init;
	input [((2+(16/4))*8)-1:0] init;
	reg [7:0] c;
	integer i;
	begin
		for (i = 0; i < (16/4); i = i + 1) begin
			c = init[(i * 8) +: 8];
			if (c >= "0" && c <= "9")
				parse_init[(i * 4) +: 4] = (c - "0");
			else if (c >= "A" && c <= "F")
				parse_init[(i * 4) +: 4] = (c - "A") + 10;
			else if (c >= "a" && c <= "f")
				parse_init[(i * 4) +: 4] = (c - "a") + 10;
		end
	end
endfunction

function [63:0] parse_init_64;
	input [((2+(64/4))*8)-1:0] init;
	reg [7:0] c;
	integer i;
	begin
		for (i = 0; i < (64/4); i = i + 1) begin
			c = init[(i * 8) +: 8];
			if (c >= "0" && c <= "9")
				parse_init_64[(i * 4) +: 4] = (c - "0");
			else if (c >= "A" && c <= "F")
				parse_init_64[(i * 4) +: 4] = (c - "A") + 10;
			else if (c >= "a" && c <= "f")
				parse_init_64[(i * 4) +: 4] = (c - "a") + 10;
		end
	end
endfunction
`},"pmux2mux.v":`module \\$pmux (A, B, S, Y);

wire [1023:0] _TECHMAP_DO_ = "proc; clean";

parameter WIDTH = 1;
parameter S_WIDTH = 1;

input [WIDTH-1:0] A;
input [WIDTH*S_WIDTH-1:0] B;
input [S_WIDTH-1:0] S;
output reg [WIDTH-1:0] Y;

integer i;

always @* begin
	Y <= A;
	for (i = 0; i < S_WIDTH; i=i+1)
		if (S[i]) Y <= B[WIDTH*i +: WIDTH];
end

endmodule
`,python3:{"smtio.py":`#
# yosys -- Yosys Open SYnthesis Suite
#
# Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

import sys, re, os, signal, json
import subprocess
if os.name == "posix":
    import resource
from copy import copy
from select import select
from time import time
from queue import Queue, Empty
from threading import Thread


# This is needed so that the recursive SMT2 S-expression parser
# does not run out of stack frames when parsing large expressions
if os.name == "posix":
    smtio_reclimit = 64 * 1024
    if sys.getrecursionlimit() < smtio_reclimit:
        sys.setrecursionlimit(smtio_reclimit)

    current_rlimit_stack = resource.getrlimit(resource.RLIMIT_STACK)
    if current_rlimit_stack[0] != resource.RLIM_INFINITY:
        smtio_stacksize = 128 * 1024 * 1024
        if os.uname().sysname == "Darwin":
            # MacOS has rather conservative stack limits
            smtio_stacksize = 8 * 1024 * 1024
        if current_rlimit_stack[1] != resource.RLIM_INFINITY:
            smtio_stacksize = min(smtio_stacksize, current_rlimit_stack[1])
        if current_rlimit_stack[0] < smtio_stacksize:
            try:
                resource.setrlimit(resource.RLIMIT_STACK, (smtio_stacksize, current_rlimit_stack[1]))
            except ValueError:
                # couldn't get more stack, just run with what we have
                pass


# currently running solvers (so we can kill them)
running_solvers = dict()
forced_shutdown = False
solvers_index = 0

def force_shutdown(signum, frame):
    global forced_shutdown
    if not forced_shutdown:
        forced_shutdown = True
        if signum is not None:
            print("<%s>" % signal.Signals(signum).name)
        for p in running_solvers.values():
            # os.killpg(os.getpgid(p.pid), signal.SIGTERM)
            os.kill(p.pid, signal.SIGTERM)
    sys.exit(1)

if os.name == "posix":
    signal.signal(signal.SIGHUP, force_shutdown)
signal.signal(signal.SIGINT, force_shutdown)
signal.signal(signal.SIGTERM, force_shutdown)

def except_hook(exctype, value, traceback):
    if not forced_shutdown:
        sys.__excepthook__(exctype, value, traceback)
    force_shutdown(None, None)

sys.excepthook = except_hook


def recursion_helper(iteration, *request):
    stack = [iteration(*request)]

    while stack:
        top = stack.pop()
        try:
            request = next(top)
        except StopIteration:
            continue

        stack.append(top)
        stack.append(iteration(*request))


hex_dict = {
    "0": "0000", "1": "0001", "2": "0010", "3": "0011",
    "4": "0100", "5": "0101", "6": "0110", "7": "0111",
    "8": "1000", "9": "1001", "A": "1010", "B": "1011",
    "C": "1100", "D": "1101", "E": "1110", "F": "1111",
    "a": "1010", "b": "1011", "c": "1100", "d": "1101",
    "e": "1110", "f": "1111"
}


class SmtModInfo:
    def __init__(self):
        self.inputs = set()
        self.outputs = set()
        self.registers = set()
        self.memories = dict()
        self.wires = set()
        self.wsize = dict()
        self.clocks = dict()
        self.cells = dict()
        self.asserts = dict()
        self.assumes = dict()
        self.covers = dict()
        self.maximize = set()
        self.minimize = set()
        self.anyconsts = dict()
        self.anyseqs = dict()
        self.allconsts = dict()
        self.allseqs = dict()
        self.asize = dict()
        self.witness = []


class SmtIo:
    def __init__(self, opts=None):
        global solvers_index

        self.logic = None
        self.logic_qf = True
        self.logic_ax = True
        self.logic_uf = True
        self.logic_bv = True
        self.logic_dt = False
        self.forall = False
        self.timeout = 0
        self.produce_models = True
        self.recheck = False
        self.smt2cache = [list()]
        self.smt2_options = dict()
        self.smt2_assumptions = dict()
        self.p = None
        self.p_index = solvers_index
        solvers_index += 1

        if opts is not None:
            self.logic = opts.logic
            self.solver = opts.solver
            self.solver_opts = opts.solver_opts
            self.debug_print = opts.debug_print
            self.debug_file = opts.debug_file
            self.dummy_file = opts.dummy_file
            self.timeinfo = opts.timeinfo
            self.timeout = opts.timeout
            self.unroll = opts.unroll
            self.noincr = opts.noincr
            self.info_stmts = opts.info_stmts
            self.nocomments = opts.nocomments
            self.smt2_options.update(opts.smt2_options)

        else:
            self.solver = "yices"
            self.solver_opts = list()
            self.debug_print = False
            self.debug_file = None
            self.dummy_file = None
            self.timeinfo = os.name != "nt"
            self.timeout = 0
            self.unroll = False
            self.noincr = False
            self.info_stmts = list()
            self.nocomments = False

        self.start_time = time()

        self.modinfo = dict()
        self.curmod = None
        self.topmod = None
        self.setup_done = False

    def __del__(self):
        if self.p is not None and not forced_shutdown:
            os.killpg(os.getpgid(self.p.pid), signal.SIGTERM)
            if running_solvers is not None:
                del running_solvers[self.p_index]

    def setup(self):
        assert not self.setup_done

        if self.forall:
            self.unroll = False

        if self.solver == "yices":
            if self.forall:
                self.noincr = True

            if self.noincr:
                self.popen_vargs = ['yices-smt2'] + self.solver_opts
            else:
                self.popen_vargs = ['yices-smt2', '--incremental'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('-t')
                self.popen_vargs.append('%d' % self.timeout);

        if self.solver == "z3":
            self.popen_vargs = ['z3', '-smt2', '-in'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('-T:%d' % self.timeout);

        if self.solver in ["cvc4", "cvc5"]:
            self.recheck = True
            if self.noincr:
                self.popen_vargs = [self.solver, '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts
            else:
                self.popen_vargs = [self.solver, '--incremental', '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('--tlimit=%d000' % self.timeout);

        if self.solver == "mathsat":
            self.popen_vargs = ['mathsat'] + self.solver_opts
            if self.timeout != 0:
                print('timeout option is not supported for mathsat.')
                sys.exit(1)

        if self.solver in ["boolector", "bitwuzla"]:
            if self.noincr:
                self.popen_vargs = [self.solver, '--smt2'] + self.solver_opts
            else:
                self.popen_vargs = [self.solver, '--smt2', '-i'] + self.solver_opts
            self.unroll = True
            if self.timeout != 0:
                print('timeout option is not supported for %s.' % self.solver)
                sys.exit(1)

        if self.solver == "abc":
            if len(self.solver_opts) > 0:
                self.popen_vargs = ['yosys-abc', '-S', '; '.join(self.solver_opts)]
            else:
                self.popen_vargs = ['yosys-abc', '-S', '%blast; &sweep -C 5000; &syn4; &cec -s -m -C 2000']
            self.logic_ax = False
            self.unroll = True
            self.noincr = True
            if self.timeout != 0:
                print('timeout option is not supported for abc.')
                sys.exit(1)

        if self.solver == "dummy":
            assert self.dummy_file is not None
            self.dummy_fd = open(self.dummy_file, "r")
        else:
            if self.dummy_file is not None:
                self.dummy_fd = open(self.dummy_file, "w")
            if not self.noincr:
                self.p_open()

        if self.unroll:
            assert not self.forall
            self.logic_uf = False
            self.unroll_idcnt = 0
            self.unroll_buffer = ""
            self.unroll_level = 0
            self.unroll_sorts = set()
            self.unroll_objs = set()
            self.unroll_decls = dict()
            self.unroll_cache = dict()
            self.unroll_stack = list()

        if self.logic is None:
            self.logic = ""
            if self.logic_qf: self.logic += "QF_"
            if self.logic_ax: self.logic += "A"
            if self.logic_uf: self.logic += "UF"
            if self.logic_bv: self.logic += "BV"
            if self.logic_dt: self.logic = "ALL"
            if self.solver == "yices" and self.forall: self.logic = "BV"

        self.setup_done = True

        for stmt in self.info_stmts:
            self.write(stmt)

        if self.produce_models:
            self.write("(set-option :produce-models true)")

        #See the SMT-LIB Standard, Section 4.1.7
        modestart_options = [":global-declarations", ":interactive-mode", ":produce-assertions", ":produce-assignments", ":produce-models", ":produce-proofs", ":produce-unsat-assumptions", ":produce-unsat-cores", ":random-seed"]
        for key, val in self.smt2_options.items():
            if key in modestart_options:
                self.write("(set-option {} {})".format(key, val))

        self.write("(set-logic %s)" % self.logic)

        if self.forall and self.solver == "yices":
            self.write("(set-option :yices-ef-max-iters 1000000000)")

        for key, val in self.smt2_options.items():
            if key not in modestart_options:
                self.write("(set-option {} {})".format(key, val))

    def timestamp(self):
        secs = int(time() - self.start_time)
        return "## %3d:%02d:%02d " % (secs // (60*60), (secs // 60) % 60, secs % 60)

    def replace_in_stmt(self, stmt, pat, repl):
        if stmt == pat:
            return repl

        if isinstance(stmt, list):
            return [self.replace_in_stmt(s, pat, repl) for s in stmt]

        return stmt

    def unroll_stmt(self, stmt):
        result = []
        recursion_helper(self._unroll_stmt_into, stmt, result)
        return result.pop()

    def _unroll_stmt_into(self, stmt, output, depth=128):
        if not isinstance(stmt, list):
            output.append(stmt)
            return

        new_stmt = []
        for s in stmt:
            if depth:
                yield from self._unroll_stmt_into(s, new_stmt, depth - 1)
            else:
                yield s, new_stmt
        stmt = new_stmt

        if len(stmt) >= 2 and not isinstance(stmt[0], list) and stmt[0] in self.unroll_decls:
            assert stmt[1] in self.unroll_objs

            key = tuple(stmt)
            if key not in self.unroll_cache:
                decl = copy(self.unroll_decls[key[0]])

                self.unroll_cache[key] = "|UNROLL#%d|" % self.unroll_idcnt
                decl[1] = self.unroll_cache[key]
                self.unroll_idcnt += 1

                if decl[0] == "declare-fun":
                    if isinstance(decl[3], list) or decl[3] not in self.unroll_sorts:
                        self.unroll_objs.add(decl[1])
                        decl[2] = list()
                    else:
                        self.unroll_objs.add(decl[1])
                        decl = list()

                elif decl[0] == "define-fun":
                    arg_index = 1
                    for arg_name, arg_sort in decl[2]:
                        decl[4] = self.replace_in_stmt(decl[4], arg_name, key[arg_index])
                        arg_index += 1
                    decl[2] = list()

                if len(decl) > 0:
                    tmp = []
                    if depth:
                        yield from self._unroll_stmt_into(decl, tmp, depth - 1)
                    else:
                        yield decl, tmp

                    decl = tmp.pop()
                    self.write(self.unparse(decl), unroll=False)

            output.append(self.unroll_cache[key])
            return

        output.append(stmt)

    def p_thread_main(self):
        while True:
            data = self.p.stdout.readline().decode("utf-8")
            if data == "": break
            self.p_queue.put(data)
        self.p_queue.put("")
        self.p_running = False

    def p_open(self):
        assert self.p is None
        try:
            self.p = subprocess.Popen(self.popen_vargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        except FileNotFoundError:
            print("%s SMT Solver '%s' not found in path." % (self.timestamp(), self.popen_vargs[0]), flush=True)
            sys.exit(1)
        running_solvers[self.p_index] = self.p
        self.p_running = True
        self.p_next = None
        self.p_queue = Queue()
        self.p_thread = Thread(target=self.p_thread_main)
        self.p_thread.start()

    def p_write(self, data, flush):
        assert self.p is not None
        self.p.stdin.write(bytes(data, "utf-8"))
        if flush: self.p.stdin.flush()

    def p_read(self):
        assert self.p is not None
        if self.p_next is not None:
            data = self.p_next
            self.p_next = None
            return data
        if not self.p_running:
            return ""
        return self.p_queue.get()

    def p_poll(self, timeout=0.1):
        assert self.p is not None
        assert self.p_running
        if self.p_next is not None:
            return False
        try:
            self.p_next = self.p_queue.get(True, timeout)
            return False
        except Empty:
            return True

    def p_close(self):
        assert self.p is not None
        self.p.stdin.close()
        self.p_thread.join()
        assert not self.p_running
        del running_solvers[self.p_index]
        self.p = None
        self.p_next = None
        self.p_queue = None
        self.p_thread = None

    def write(self, stmt, unroll=True):
        if stmt.startswith(";"):
            self.info(stmt)
            if not self.setup_done:
                self.info_stmts.append(stmt)
                return
        elif not self.setup_done:
            self.setup()

        stmt = stmt.strip()

        if self.nocomments or self.unroll:
            stmt = re.sub(r" *;.*", "", stmt)
            if stmt == "": return

        recheck = None

        if self.solver != "dummy":
            if self.noincr:
                # Don't close the solver yet, if we're just unrolling definitions
                # required for a (get-...) statement
                if self.p is not None and not stmt.startswith("(get-") and unroll:
                    self.p_close()

        if unroll and self.unroll:
            s = re.sub(r"\\|[^|]*\\|", "", stmt)
            self.unroll_level += s.count("(") - s.count(")")
            if self.unroll_level > 0:
                self.unroll_buffer += stmt
                self.unroll_buffer += " "
                return
            else:
                stmt = self.unroll_buffer + stmt
                self.unroll_buffer = ""

            s = self.parse(stmt)

            if self.recheck and s and s[0].startswith("get-"):
                recheck = self.unroll_idcnt

            if self.debug_print:
                print("-> %s" % s)

            if len(s) == 3 and s[0] == "declare-sort" and s[2] == "0":
                self.unroll_sorts.add(s[1])
                return

            elif len(s) == 4 and s[0] == "declare-fun" and s[2] == [] and s[3] in self.unroll_sorts:
                self.unroll_objs.add(s[1])
                return

            elif len(s) >= 4 and s[0] == "declare-fun":
                for arg_sort in s[2]:
                    if arg_sort in self.unroll_sorts:
                        self.unroll_decls[s[1]] = s
                        return

            elif len(s) >= 4 and s[0] == "define-fun":
                for arg_name, arg_sort in s[2]:
                    if arg_sort in self.unroll_sorts:
                        self.unroll_decls[s[1]] = s
                        return

            stmt = self.unparse(self.unroll_stmt(s))

            if recheck is not None and recheck != self.unroll_idcnt:
                self.check_sat(["sat"])

            if stmt == "(push 1)":
                self.unroll_stack.append((
                    copy(self.unroll_sorts),
                    copy(self.unroll_objs),
                    copy(self.unroll_decls),
                    copy(self.unroll_cache),
                ))

            if stmt == "(pop 1)":
                self.unroll_sorts, self.unroll_objs, self.unroll_decls, self.unroll_cache = self.unroll_stack.pop()

        if self.debug_print:
            print("> %s" % stmt)

        if self.debug_file:
            print(stmt, file=self.debug_file)
            self.debug_file.flush()

        if self.solver != "dummy":
            if self.noincr:
                if stmt == "(push 1)":
                    self.smt2cache.append(list())
                elif stmt == "(pop 1)":
                    self.smt2cache.pop()
                else:
                    if self.p is not None:
                        self.p_write(stmt + "\\n", True)
                    self.smt2cache[-1].append(stmt)
            else:
                self.p_write(stmt + "\\n", True)

    def info(self, stmt):
        if not stmt.startswith("; yosys-smt2-"):
            return

        fields = stmt.split()

        if fields[1] == "yosys-smt2-solver-option":
            self.smt2_options[fields[2]] = fields[3]

        if fields[1] == "yosys-smt2-nomem":
            if self.logic is None:
                self.logic_ax = False

        if fields[1] == "yosys-smt2-nobv":
            if self.logic is None:
                self.logic_bv = False

        if fields[1] == "yosys-smt2-stdt":
            if self.logic is None:
                self.logic_dt = True

        if fields[1] == "yosys-smt2-forall":
            if self.logic is None:
                self.logic_qf = False
            self.forall = True

        if fields[1] == "yosys-smt2-module":
            self.curmod = fields[2]
            self.modinfo[self.curmod] = SmtModInfo()

        if fields[1] == "yosys-smt2-cell":
            self.modinfo[self.curmod].cells[fields[3]] = fields[2]

        if fields[1] == "yosys-smt2-topmod":
            self.topmod = fields[2]

        if fields[1] == "yosys-smt2-input":
            self.modinfo[self.curmod].inputs.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-output":
            self.modinfo[self.curmod].outputs.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-register":
            self.modinfo[self.curmod].registers.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-memory":
            self.modinfo[self.curmod].memories[fields[2]] = (int(fields[3]), int(fields[4]), int(fields[5]), int(fields[6]), fields[7] == "async")

        if fields[1] == "yosys-smt2-wire":
            self.modinfo[self.curmod].wires.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-clock":
            for edge in fields[3:]:
                if fields[2] not in self.modinfo[self.curmod].clocks:
                    self.modinfo[self.curmod].clocks[fields[2]] = edge
                elif self.modinfo[self.curmod].clocks[fields[2]] != edge:
                    self.modinfo[self.curmod].clocks[fields[2]] = "event"

        if fields[1] == "yosys-smt2-assert":
            if len(fields) > 4:
                self.modinfo[self.curmod].asserts["%s_a %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].asserts["%s_a %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-cover":
            if len(fields) > 4:
                self.modinfo[self.curmod].covers["%s_c %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].covers["%s_c %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-assume":
            if len(fields) > 4:
                self.modinfo[self.curmod].assumes["%s_u %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].assumes["%s_u %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-maximize":
            self.modinfo[self.curmod].maximize.add(fields[2])

        if fields[1] == "yosys-smt2-minimize":
            self.modinfo[self.curmod].minimize.add(fields[2])

        if fields[1] == "yosys-smt2-anyconst":
            self.modinfo[self.curmod].anyconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-anyseq":
            self.modinfo[self.curmod].anyseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-allconst":
            self.modinfo[self.curmod].allconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-allseq":
            self.modinfo[self.curmod].allseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-witness":
            data = json.loads(stmt.split(None, 2)[2])
            if data.get("type") in ["cell", "mem", "posedge", "negedge", "input", "reg", "init", "seq", "blackbox"]:
                self.modinfo[self.curmod].witness.append(data)

    def hiernets(self, top, regs_only=False):
        def hiernets_worker(nets, mod, cursor):
            for netname in sorted(self.modinfo[mod].wsize.keys()):
                if not regs_only or netname in self.modinfo[mod].registers:
                    nets.append(cursor + [netname])
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                hiernets_worker(nets, celltype, cursor + [cellname])

        nets = list()
        hiernets_worker(nets, top, [])
        return nets

    def hieranyconsts(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].anyconsts.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hieranyseqs(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].anyseqs.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hierallconsts(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].allconsts.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hierallseqs(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].allseqs.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hiermems(self, top):
        def hiermems_worker(mems, mod, cursor):
            for memname in sorted(self.modinfo[mod].memories.keys()):
                mems.append(cursor + [memname])
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                hiermems_worker(mems, celltype, cursor + [cellname])

        mems = list()
        hiermems_worker(mems, top, [])
        return mems

    def hierwitness(self, top, allregs=False, blackbox=True):
        init_witnesses = []
        seq_witnesses = []
        clk_witnesses = []
        mem_witnesses = []

        def absolute(path, cursor, witness):
            return {
                **witness,
                "path": path + tuple(witness["path"]),
                "smtpath": cursor + [witness["smtname"]],
            }

        for witness in self.modinfo[top].witness:
            if witness["type"] == "input":
                seq_witnesses.append(absolute((), [], witness))
            if witness["type"] in ("posedge", "negedge"):
                clk_witnesses.append(absolute((), [], witness))

        init_types = ["init"]
        if allregs:
            init_types.append("reg")

        seq_types = ["seq"]
        if blackbox:
            seq_types.append("blackbox")

        def worker(mod, path, cursor):
            cell_paths = {}
            for witness in self.modinfo[mod].witness:
                if witness["type"] in init_types:
                    init_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] in seq_types:
                    seq_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] == "mem":
                    if allregs and not witness["rom"]:
                        width, size = witness["width"], witness["size"]
                        witness = {**witness, "uninitialized": [{"width": width * size, "offset": 0}]}
                    if not witness["uninitialized"]:
                        continue

                    mem_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] == "cell":
                    cell_paths[witness["smtname"]] = tuple(witness["path"])

            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(celltype, path + cell_paths.get(cellname, ("?" + cellname,)), cursor + [cellname])

        worker(top, (), [])
        return init_witnesses, seq_witnesses, clk_witnesses, mem_witnesses

    def read(self):
        stmt = []
        count_brackets = 0

        while True:
            if self.solver == "dummy":
                line = self.dummy_fd.readline().strip()
            else:
                line = self.p_read().strip()
                if self.dummy_file is not None:
                    self.dummy_fd.write(line + "\\n")

            count_brackets += line.count("(")
            count_brackets -= line.count(")")
            stmt.append(line)

            if self.debug_print:
                print("< %s" % line)
            if count_brackets == 0:
                break
            if self.solver != "dummy" and self.p.poll():
                print("%s Solver terminated unexpectedly: %s" % (self.timestamp(), "".join(stmt)), flush=True)
                sys.exit(1)

        stmt = "".join(stmt)
        if stmt.startswith("(error"):
            print("%s Solver Error: %s" % (self.timestamp(), stmt), flush=True)
            if self.solver != "dummy":
                self.p_close()
            sys.exit(1)

        return stmt

    def check_sat(self, expected=["sat", "unsat", "unknown", "timeout", "interrupted"]):
        if self.smt2_assumptions:
            assume_exprs = " ".join(self.smt2_assumptions.values())
            check_stmt = f"(check-sat-assuming ({assume_exprs}))"
        else:
            check_stmt = "(check-sat)"
        if self.debug_print:
            print(f"> {check_stmt}")
        if self.debug_file and not self.nocomments:
            print("; running check-sat..", file=self.debug_file)
            self.debug_file.flush()

        if self.solver != "dummy":
            if self.noincr:
                if self.p is not None:
                    self.p_close()
                self.p_open()
                for cache_ctx in self.smt2cache:
                    for cache_stmt in cache_ctx:
                        self.p_write(cache_stmt + "\\n", False)

            self.p_write(f"{check_stmt}\\n", True)

            if self.timeinfo:
                i = 0
                s = r"/-\\|"

                count = 0
                num_bs = 0
                while self.p_poll():
                    count += 1

                    if count < 25:
                        continue

                    if count % 10 == 0 or count == 25:
                        secs = count // 10

                        if secs < 60:
                            m = "(%d seconds)" % secs
                        elif secs < 60*60:
                            m = "(%d seconds -- %d:%02d)" % (secs, secs // 60, secs % 60)
                        else:
                            m = "(%d seconds -- %d:%02d:%02d)" % (secs, secs // (60*60), (secs // 60) % 60, secs % 60)

                        print("%s %s %c" % ("\\b \\b" * num_bs, m, s[i]), end="", file=sys.stderr)
                        num_bs = len(m) + 3

                    else:
                        print("\\b" + s[i], end="", file=sys.stderr)

                    sys.stderr.flush()
                    i = (i + 1) % len(s)

                if num_bs != 0:
                    print("\\b \\b" * num_bs, end="", file=sys.stderr)
                    sys.stderr.flush()

            else:
                count = 0
                while self.p_poll(60):
                    count += 1
                    msg = None

                    if count == 1:
                        msg = "1 minute"

                    elif count in [5, 10, 15, 30]:
                        msg = "%d minutes" % count

                    elif count == 60:
                        msg = "1 hour"

                    elif count % 60 == 0:
                        msg = "%d hours" % (count // 60)

                    if msg is not None:
                        print("%s waiting for solver (%s)" % (self.timestamp(), msg), flush=True)

        if self.forall:
            result = self.read()
            while result not in ["sat", "unsat", "unknown", "timeout", "interrupted", ""]:
                print("%s %s: %s" % (self.timestamp(), self.solver, result))
                result = self.read()
        else:
            result = self.read()

        if self.debug_file:
            print("(set-info :status %s)" % result, file=self.debug_file)
            print(check_stmt, file=self.debug_file)
            self.debug_file.flush()

        if result not in expected:
            if result == "":
                print("%s Unexpected EOF response from solver." % (self.timestamp()), flush=True)
            else:
                print("%s Unexpected response from solver: %s" % (self.timestamp(), result), flush=True)
            if self.solver != "dummy":
                self.p_close()
            sys.exit(1)

        return result

    def parse(self, stmt):
        def worker(stmt, cursor=0):
            while stmt[cursor] in [" ", "\\t", "\\r", "\\n"]:
                cursor += 1

            if stmt[cursor] == '(':
                expr = []
                cursor += 1
                while stmt[cursor] != ')':
                    el, cursor = worker(stmt, cursor)
                    expr.append(el)
                return expr, cursor+1

            if stmt[cursor] == '|':
                expr = "|"
                cursor += 1
                while stmt[cursor] != '|':
                    expr += stmt[cursor]
                    cursor += 1
                expr += "|"
                return expr, cursor+1

            expr = ""
            while stmt[cursor] not in ["(", ")", "|", " ", "\\t", "\\r", "\\n"]:
                expr += stmt[cursor]
                cursor += 1
            return expr, cursor
        return worker(stmt)[0]

    def unparse(self, stmt):
        if isinstance(stmt, list):
            return "(" + " ".join([self.unparse(s) for s in stmt]) + ")"
        return stmt

    def bv2hex(self, v):
        h = ""
        v = self.bv2bin(v)
        while len(v) > 0:
            d = 0
            if len(v) > 0 and v[-1] == "1": d += 1
            if len(v) > 1 and v[-2] == "1": d += 2
            if len(v) > 2 and v[-3] == "1": d += 4
            if len(v) > 3 and v[-4] == "1": d += 8
            h = hex(d)[2:] + h
            if len(v) < 4: break
            v = v[:-4]
        return h

    def bv2bin(self, v):
        if type(v) is list and len(v) == 3 and v[0] == "_" and v[1].startswith("bv"):
            x, n = int(v[1][2:]), int(v[2])
            return "".join("1" if (x & (1 << i)) else "0" for i in range(n-1, -1, -1))
        if v == "true": return "1"
        if v == "false": return "0"
        if v.startswith("#b"):
            return v[2:]
        if v.startswith("#x"):
            return "".join(hex_dict.get(x) for x in v[2:])
        assert False

    def bv2int(self, v):
        return int(self.bv2bin(v), 2)

    def get_raw_unsat_assumptions(self):
        if not self.smt2_assumptions:
            return []
        self.write("(get-unsat-assumptions)")
        exprs = set(self.unparse(part) for part in self.parse(self.read()))
        unsat_assumptions = []
        for key, value in self.smt2_assumptions.items():
            # normalize expression
            value = self.unparse(self.parse(value))
            if value in exprs:
                exprs.remove(value)
                unsat_assumptions.append(key)
        return unsat_assumptions

    def get_unsat_assumptions(self, minimize=False):
        if not minimize:
            return self.get_raw_unsat_assumptions()
        orig_assumptions = self.smt2_assumptions

        self.smt2_assumptions = dict(orig_assumptions)

        required_assumptions = {}

        while True:
            candidate_assumptions = {}
            for key in self.get_raw_unsat_assumptions():
                if key not in required_assumptions:
                    candidate_assumptions[key] = self.smt2_assumptions[key]

            while candidate_assumptions:

                candidate_key, candidate_assume = candidate_assumptions.popitem()

                self.smt2_assumptions = {}
                for key, assume in candidate_assumptions.items():
                    self.smt2_assumptions[key] = assume
                for key, assume in required_assumptions.items():
                    self.smt2_assumptions[key] = assume
                result = self.check_sat()

                if result == 'unsat':
                    candidate_assumptions = None
                else:
                    required_assumptions[candidate_key] = candidate_assume

            if candidate_assumptions is not None:
                self.smt2_assumptions = orig_assumptions
                return list(required_assumptions)

    def get(self, expr):
        self.write("(get-value (%s))" % (expr))
        return self.parse(self.read())[0][1]

    def get_list(self, expr_list):
        if len(expr_list) == 0:
            return []
        self.write("(get-value (%s))" % " ".join(expr_list))
        return [n[1] for n in self.parse(self.read()) if n]

    def get_path(self, mod, path):
        assert mod in self.modinfo
        path = path.replace("\\\\", "/").split(".")

        for i in range(len(path)-1):
            first = ".".join(path[0:i+1])
            second = ".".join(path[i+1:])

            if first in self.modinfo[mod].cells:
                nextmod = self.modinfo[mod].cells[first]
                return [first] + self.get_path(nextmod, second)

        return [".".join(path)]

    def net_expr(self, mod, base, path):
        if len(path) == 0:
            return base

        if len(path) == 1:
            assert mod in self.modinfo
            if path[0] == "":
                return base
            if isinstance(path[0], int):
                return "(|%s#%d| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].cells:
                return "(|%s_h %s| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].wsize:
                return "(|%s_n %s| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].memories:
                return "(|%s_m %s| %s)" % (mod, path[0], base)
            assert 0

        assert mod in self.modinfo
        assert path[0] in self.modinfo[mod].cells

        nextmod = self.modinfo[mod].cells[path[0]]
        nextbase = "(|%s_h %s| %s)" % (mod, path[0], base)
        return self.net_expr(nextmod, nextbase, path[1:])

    def witness_net_expr(self, mod, base, witness):
        net = self.net_expr(mod, base, witness["smtpath"])
        is_bool = self.net_width(mod, witness["smtpath"]) == 1
        if is_bool:
            assert witness["width"] == 1
            assert witness["smtoffset"] == 0
            return net
        return "((_ extract %d %d) %s)" % (witness["smtoffset"] + witness["width"] - 1, witness["smtoffset"], net)

    def net_width(self, mod, net_path):
        for i in range(len(net_path)-1):
            assert mod in self.modinfo
            assert net_path[i] in self.modinfo[mod].cells
            mod = self.modinfo[mod].cells[net_path[i]]

        assert mod in self.modinfo
        if isinstance(net_path[-1], int):
            return None
        assert net_path[-1] in self.modinfo[mod].wsize
        return self.modinfo[mod].wsize[net_path[-1]]

    def net_clock(self, mod, net_path):
        for i in range(len(net_path)-1):
            assert mod in self.modinfo
            assert net_path[i] in self.modinfo[mod].cells
            mod = self.modinfo[mod].cells[net_path[i]]

        assert mod in self.modinfo
        if net_path[-1] not in self.modinfo[mod].clocks:
            return None
        return self.modinfo[mod].clocks[net_path[-1]]

    def net_exists(self, mod, net_path):
        for i in range(len(net_path)-1):
            if mod not in self.modinfo: return False
            if net_path[i] not in self.modinfo[mod].cells: return False
            mod = self.modinfo[mod].cells[net_path[i]]

        if mod not in self.modinfo: return False
        if net_path[-1] not in self.modinfo[mod].wsize: return False
        return True

    def mem_exists(self, mod, mem_path):
        for i in range(len(mem_path)-1):
            if mod not in self.modinfo: return False
            if mem_path[i] not in self.modinfo[mod].cells: return False
            mod = self.modinfo[mod].cells[mem_path[i]]

        if mod not in self.modinfo: return False
        if mem_path[-1] not in self.modinfo[mod].memories: return False
        return True

    def mem_expr(self, mod, base, path, port=None, infomode=False):
        if len(path) == 1:
            assert mod in self.modinfo
            assert path[0] in self.modinfo[mod].memories
            if infomode:
                return self.modinfo[mod].memories[path[0]]
            return "(|%s_m%s %s| %s)" % (mod, "" if port is None else ":%s" % port, path[0], base)

        assert mod in self.modinfo
        assert path[0] in self.modinfo[mod].cells

        nextmod = self.modinfo[mod].cells[path[0]]
        nextbase = "(|%s_h %s| %s)" % (mod, path[0], base)
        return self.mem_expr(nextmod, nextbase, path[1:], port=port, infomode=infomode)

    def mem_info(self, mod, path):
        return self.mem_expr(mod, "", path, infomode=True)

    def get_net(self, mod_name, net_path, state_name):
        return self.get(self.net_expr(mod_name, state_name, net_path))

    def get_net_list(self, mod_name, net_path_list, state_name):
        return self.get_list([self.net_expr(mod_name, state_name, n) for n in net_path_list])

    def get_net_hex(self, mod_name, net_path, state_name):
        return self.bv2hex(self.get_net(mod_name, net_path, state_name))

    def get_net_hex_list(self, mod_name, net_path_list, state_name):
        return [self.bv2hex(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]

    def get_net_bin(self, mod_name, net_path, state_name):
        return self.bv2bin(self.get_net(mod_name, net_path, state_name))

    def get_net_bin_list(self, mod_name, net_path_list, state_name):
        return [self.bv2bin(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]

    def wait(self):
        if self.p is not None:
            self.p.wait()
            self.p_close()


class SmtOpts:
    def __init__(self):
        self.shortopts = "s:S:v"
        self.longopts = ["unroll", "noincr", "noprogress", "timeout=", "dump-smt2=", "logic=", "dummy=", "info=", "nocomments", "smt2-option="]
        self.solver = "yices"
        self.solver_opts = list()
        self.debug_print = False
        self.debug_file = None
        self.dummy_file = None
        self.unroll = False
        self.noincr = False
        self.timeinfo = os.name != "nt"
        self.timeout = 0
        self.logic = None
        self.info_stmts = list()
        self.nocomments = False
        self.smt2_options = {}

    def handle(self, o, a):
        if o == "-s":
            self.solver = a
        elif o == "-S":
            self.solver_opts.append(a)
        elif o == "--timeout":
            self.timeout = int(a)
        elif o == "-v":
            self.debug_print = True
        elif o == "--unroll":
            self.unroll = True
        elif o == "--noincr":
            self.noincr = True
        elif o == "--noprogress":
            self.timeinfo = False
        elif o == "--dump-smt2":
            self.debug_file = open(a, "w")
        elif o == "--logic":
            self.logic = a
        elif o == "--dummy":
            self.dummy_file = a
        elif o == "--info":
            self.info_stmts.append(a)
        elif o == "--nocomments":
            self.nocomments = True
        elif o == "--smt2-option":
            args = a.split('=', 1)
            if len(args) != 2:
                print("--smt2-option expects an <option>=<value> argument")
                sys.exit(1)
            option, value = args
            self.smt2_options[option] = value
        else:
            return False
        return True

    def helpmsg(self):
        return """
    -s <solver>
        set SMT solver: z3, yices, boolector, bitwuzla, cvc4, cvc5, mathsat, dummy
        default: yices

    -S <opt>
        pass <opt> as command line argument to the solver

    --timeout <value>
        set the solver timeout to the specified value (in seconds).

    --logic <smt2_logic>
        use the specified SMT2 logic (e.g. QF_AUFBV)

    --dummy <filename>
        if solver is "dummy", read solver output from that file
        otherwise: write solver output to that file

    --smt2-option <option>=<value>
        enable an SMT-LIBv2 option.

    -v
        enable debug output

    --unroll
        unroll uninterpreted functions

    --noincr
        don't use incremental solving, instead restart solver for
        each (check-sat). This also avoids (push) and (pop).

    --noprogress
        disable timer display during solving
        (this option is set implicitly on Windows)

    --dump-smt2 <filename>
        write smt2 statements to file

    --info <smt2-info-stmt>
        include the specified smt2 info statement in the smt2 output

    --nocomments
        strip all comments from the generated smt2 code
"""


class MkVcd:
    def __init__(self, f):
        self.f = f
        self.t = -1
        self.nets = dict()
        self.clocks = dict()

    def add_net(self, path, width):
        path = tuple(path)
        assert self.t == -1
        key = "n%d" % len(self.nets)
        self.nets[path] = (key, width)

    def add_clock(self, path, edge):
        path = tuple(path)
        assert self.t == -1
        key = "n%d" % len(self.nets)
        self.nets[path] = (key, 1)
        self.clocks[path] = (key, edge)

    def set_net(self, path, bits):
        path = tuple(path)
        assert self.t >= 0
        assert path in self.nets
        if path not in self.clocks:
            print("b%s %s" % (bits, self.nets[path][0]), file=self.f)

    def escape_name(self, name):
        name = re.sub(r"\\[([0-9a-zA-Z_]*[a-zA-Z_][0-9a-zA-Z_]*)\\]", r"<\\1>", name)
        if re.match(r"[\\[\\]]", name) and name[0] != "\\\\":
            name = "\\\\" + name
        return name

    def set_time(self, t):
        assert t >= self.t
        if t != self.t:
            if self.t == -1:
                print("$version Generated by Yosys-SMTBMC $end", file=self.f)
                print("$timescale 1ns $end", file=self.f)
                print("$var integer 32 t smt_step $end", file=self.f)
                print("$var event 1 ! smt_clock $end", file=self.f)

                def vcdescape(n):
                    if n.startswith("$") or ":" in n:
                        return "\\\\" + n
                    return n

                scope = []
                for path in sorted(self.nets):
                    key, width = self.nets[path]

                    uipath = list(path)
                    if "." in uipath[-1] and not uipath[-1].startswith("$"):
                        uipath = uipath[0:-1] + uipath[-1].split(".")
                    for i in range(len(uipath)):
                        uipath[i] = re.sub(r"\\[([^\\]]*)\\]", r"<\\1>", uipath[i])

                    while uipath[:len(scope)] != scope:
                        print("$upscope $end", file=self.f)
                        scope = scope[:-1]

                    while uipath[:-1] != scope:
                        scopename = uipath[len(scope)]
                        print("$scope module %s $end" % vcdescape(scopename), file=self.f)
                        scope.append(uipath[len(scope)])

                    if path in self.clocks and self.clocks[path][1] == "event":
                        print("$var event 1 %s %s $end" % (key, vcdescape(uipath[-1])), file=self.f)
                    else:
                        print("$var wire %d %s %s $end" % (width, key, vcdescape(uipath[-1])), file=self.f)

                for i in range(len(scope)):
                    print("$upscope $end", file=self.f)

                print("$enddefinitions $end", file=self.f)

            self.t = t
            assert self.t >= 0

            if self.t > 0:
                print("#%d" % (10 * self.t - 5), file=self.f)
                for path in sorted(self.clocks.keys()):
                    if self.clocks[path][1] == "posedge":
                        print("b0 %s" % self.nets[path][0], file=self.f)
                    elif self.clocks[path][1] == "negedge":
                        print("b1 %s" % self.nets[path][0], file=self.f)

            print("#%d" % (10 * self.t), file=self.f)
            print("1!", file=self.f)
            print("b%s t" % format(self.t, "032b"), file=self.f)

            for path in sorted(self.clocks.keys()):
                if self.clocks[path][1] == "negedge":
                    print("b0 %s" % self.nets[path][0], file=self.f)
                else:
                    print("b1 %s" % self.nets[path][0], file=self.f)
`,"ywio.py":`#
# yosys -- Yosys Open SYnthesis Suite
#
# Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

import json, re

from functools import total_ordering


class PrettyJson:
    def __init__(self, f):
        self.f = f
        self.indent = 0
        self.state = ["value"]

    def line(self):
        indent = len(self.state) - bool(self.state and self.state[-1] == "value")
        print("\\n", end=" " * (2 * indent), file=self.f)

    def raw(self, str):
        print(end=str, file=self.f)

    def begin_object(self):
        self.begin_value()
        self.raw("{")
        self.state.append("object_first")

    def begin_array(self):
        self.begin_value()
        self.raw("[")
        self.state.append("array_first")

    def end_object(self):
        state = self.state.pop()
        if state == "object":
            self.line()
        else:
            assert state == "object_first"
        self.raw("}")
        self.end_value()

    def end_array(self):
        state = self.state.pop()
        if state == "array":
            self.line()
        else:
            assert state == "array_first"
        self.raw("]")
        self.end_value()

    def name(self, name):
        if self.state[-1] == "object_first":
            self.state[-1] = "object"
        else:
            self.raw(",")
        self.line()
        json.dump(str(name), self.f)
        self.raw(": ")
        self.state.append("value")

    def begin_value(self):
        if self.state[-1] == "array_first":
            self.line()
            self.state[-1] = "array"
        elif self.state[-1] == "array":
            self.raw(",")
            self.line()
        else:
            assert self.state.pop() == "value"

    def end_value(self):
        if not self.state:
            print(file=self.f, flush=True)

    def value(self, value):
        self.begin_value()
        json.dump(value, self.f)
        self.end_value()

    def entry(self, name, value):
        self.name(name)
        self.value(value)

    def object(self, entries=None):
        if isinstance(entries, dict):
            entries = dict.items()
        self.begin_object()
        for name, value in entries:
            self.entry(name, value)
        self.end_object()

    def array(self, values=None):
        self.begin_array()
        for value in values:
            self.value(value)
        self.end_array()


addr_re = re.compile(r'\\\\\\[[0-9]+\\]$')
public_name_re = re.compile(r"\\\\([a-zA-Z_][a-zA-Z0-9_]*(\\[[0-9]+\\])?|\\[[0-9]+\\])$")

def pretty_name(id):
    if public_name_re.match(id):
        return id.lstrip("\\\\")
    else:
        return id

def pretty_path(path):
    out = ""
    for name in path:
        name = pretty_name(name)
        if name.startswith("["):
            out += name
            continue
        if out:
            out += "."
        if name.startswith("\\\\") or name.startswith("$"):
            out += name + " "
        else:
            out += name

    return out

@total_ordering
class WitnessSig:
    def __init__(self, path, offset, width=1, init_only=False):
        path = tuple(path)
        self.path, self.width, self.offset, self.init_only = path, width, offset, init_only

        self.memory_path = None
        self.memory_addr = None

        sort_path = path
        sort_id = -1
        if path and addr_re.match(path[-1]):
            self.memory_path = sort_path = path[:-1]
            self.memory_addr = sort_id = int(path[-1][2:-1])

        self.sort_key = (init_only, sort_path, sort_id, offset, width)

    def bits(self):
        return ((self.path, i) for i in range(self.offset, self.offset + self.width))

    def rev_bits(self):
        return ((self.path, i) for i in reversed(range(self.offset, self.offset + self.width)))

    def pretty(self):
        if self.width > 1:
            last_offset = self.offset + self.width - 1
            return f"{pretty_path(self.path)}[{last_offset}:{self.offset}]"
        else:
            return f"{pretty_path(self.path)}[{self.offset}]"

    def __eq__(self, other):
        return self.sort_key == other.sort_key

    def __hash__(self):
        return hash(self.sort_key)

    def __lt__(self, other):
        return self.sort_key < other.sort_key


def coalesce_signals(signals, bits=None):
    if bits is None:
        bits = {}
    for sig in signals:
        for bit in sig.bits():
            if sig.init_only:
                bits.setdefault(bit, False)
            else:
                bits[bit] = True

    active = None

    out = []

    for bit, not_init in sorted(bits.items()):
        if active:
            if active[0] == bit[0] and active[2] == bit[1] and active[3] == not_init:
                active[2] += 1
            else:
                out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))
                active = None

        if active is None:
            active = [bit[0], bit[1], bit[1] + 1, not_init]

    if active:
        out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))

    return sorted(out)


class WitnessSigMap:
    def __init__(self, signals=[]):
        self.signals = []

        self.id_to_bit = []
        self.bit_to_id = {}
        self.bit_to_sig = {}

        for sig in signals:
            self.add_signal(sig)

    def add_signal(self, sig):
        self.signals.append(sig)
        for bit in sig.bits():
            self.add_bit(bit)
            self.bit_to_sig[bit] = sig

    def add_bit(self, bit, id=None):
        if id is None:
            id = len(self.id_to_bit)
            self.id_to_bit.append(bit)
        else:
            if len(self.id_to_bit) <= id:
                self.id_to_bit += [None] * (id - len(self.id_to_bit) + 1)
            self.id_to_bit[id] = bit
        self.bit_to_id[bit] = id


class WitnessValues:
    def __init__(self):
        self.values = {}

    def __setitem__(self, key, value):
        if isinstance(key, tuple) and len(key) == 2:
            if value != "?":
                assert isinstance(value, str)
                assert len(value) == 1
                self.values[key] = value
        else:
            assert isinstance(key, WitnessSig)
            assert key.width == len(value)
            if isinstance(value, str):
                value = reversed(value)
            for bit, bit_value in zip(key.bits(), value):
                if bit_value != "?":
                    self.values[bit] = bit_value

    def __getitem__(self, key):
        if isinstance(key, tuple) and len(key) == 2:
            return self.values.get(key, "?")
        else:
            assert isinstance(key, WitnessSig)
            return "".join([self.values.get(bit, "?") for bit in key.rev_bits()])

    def pack_present(self, sigmap):
        missing = []

        max_id = max((sigmap.bit_to_id.get(bit, -1) for bit in self.values), default=-1)

        vector = ["?"] * (max_id + 1)
        for bit, bit_value in self.values.items():
            id = sigmap.bit_to_id.get(bit, - 1)
            if id < 0:
                missing.append(bit)
            else:
                vector[max_id - sigmap.bit_to_id[bit]] = bit_value

        return "".join(vector), missing

    def pack(self, sigmap):
        packed, missing = self.pack_present(sigmap)
        if missing:
            raise RuntimeError(f"Cannot pack bits {missing!r}")
        return packed

    def unpack(self, sigmap, bits):
        for i, bit_value in enumerate(reversed(bits)):
            if bit_value != "?":
                self.values[sigmap.id_to_bit[i]] = bit_value

    def present_signals(self, sigmap):
        signals = set(sigmap.bit_to_sig.get(bit) for bit in self.values)
        missing_signals = None in signals
        if missing_signals:
            signals.discard(None)

        return sorted(signals), missing_signals

    def __add__(self, other: "WitnessValues"):
        new = WitnessValues()
        new += self
        new += other
        return new

    def __iadd__(self, other: "WitnessValues"):
        for key, value in other.values.items():
            self.values.setdefault(key, value)
        return self

class WriteWitness:
    def __init__(self, f, generator):
        self.out = PrettyJson(f)
        self.t = 0
        self.header_written = False
        self.clocks = []
        self.signals = []

        self.out.begin_object()
        self.out.entry("format", "Yosys Witness Trace")
        self.out.entry("generator", generator)

    def add_clock(self, path, offset, edge):
        assert not self.header_written
        self.clocks.append({
            "path": path,
            "edge": edge,
            "offset": offset,
        })

    def add_sig(self, path, offset, width=1, init_only=False):
        assert not self.header_written
        sig = WitnessSig(path, offset, width, init_only)
        self.signals.append(sig)
        return sig

    def write_header(self):
        assert not self.header_written
        self.header_written = True
        self.out.name("clocks")
        self.out.array(self.clocks)

        self.signals = coalesce_signals(self.signals)
        self.sigmap = WitnessSigMap(self.signals)

        self.out.name("signals")
        self.out.array({
            "path": sig.path,
            "width": sig.width,
            "offset": sig.offset,
            "init_only": sig.init_only,
        } for sig in self.signals)

        self.out.name("steps")
        self.out.begin_array()

    def step(self, values, skip_x=False):
        if not self.header_written:
            self.write_header()

        packed = values.pack(self.sigmap)
        if skip_x:
            packed = packed.replace('x', '?')
        self.out.value({"bits": packed})

        self.t += 1

    def end_trace(self):
        if not self.header_written:
            self.write_header()
        self.out.end_array()
        self.out.end_object()


class ReadWitness:
    def __init__(self, f):
        data = json.load(f)
        if not isinstance(data, dict):
            data = {}

        data_format = data.get("format", "Unknown Format")

        if data_format != "Yosys Witness Trace":
            raise ValueError(f"unsupported format {data_format!r}")

        self.clocks = data["clocks"]
        for clock in self.clocks:
            clock["path"] = tuple(clock["path"])

        self.signals = [
            WitnessSig(sig["path"], sig["offset"], sig["width"], sig["init_only"])
            for sig in data["signals"]
        ]

        self.sigmap = WitnessSigMap(self.signals)

        self.bits = [step["bits"] for step in data["steps"]]

    def skip_x(self):
        self.bits = [step.replace('x', '?') for step in self.bits]

    def init_step(self):
        return self.step(0)
    
    def non_init_bits(self):
        if len(self) > 1:
            return len(self.bits[1])
        else:
            return sum([sig.width for sig in self.signals if not sig.init_only])
    
    def first_step(self):
        values = WitnessValues()
        # may have issues when non_init_bits is 0
        values.unpack(WitnessSigMap([sig for sig in self.signals if not sig.init_only]), self.bits[0][-self.non_init_bits():])
        return values

    def step(self, t):
        values = WitnessValues()
        values.unpack(self.sigmap, self.bits[t])
        return values

    def steps(self, start=0):
        for i in range(start, len(self.bits)):
            yield i, self.step(i)

    def append_steps(self, t):
        if not t:
            pass
        elif t < 0:
            self.bits = self.bits[:t]
        else:
            self.bits.extend(["0"*self.non_init_bits()]*t)

    def __len__(self):
        return len(self.bits)
`},quicklogic:{common:{"cells_sim.v":`module inv (
  output Q,
  input A
);
  assign Q = A ? 0 : 1;
endmodule

module buff (
  output Q,
  input A
);
  assign Q = A;
endmodule

module logic_0 (
  output A
);
  assign A = 0;
endmodule

module logic_1 (
  output A
);
  assign A = 1;
endmodule

module gclkbuff (
  input A,
  output Z
);
  specify
    (A => Z) = 0;
  endspecify

  assign Z = A;
endmodule
`},pp3:{"abc9_map.v":`// This file exists to map purely-synchronous flops to ABC9 flops, while 
// mapping flops with asynchronous-set/clear as boxes, this is because ABC9 
// doesn't support asynchronous-set/clear flops in sequential synthesis.

module dffepc (
  output Q,
  input D,
  input CLK,
  input EN,
  input CLR,
  input PRE
);

parameter INIT = 1'b0;

parameter _TECHMAP_CONSTMSK_CLR_ = 1'b0;
parameter _TECHMAP_CONSTMSK_PRE_ = 1'b0;
parameter _TECHMAP_CONSTVAL_CLR_ = 1'b0;
parameter _TECHMAP_CONSTVAL_PRE_ = 1'b0;

if (_TECHMAP_CONSTMSK_CLR_ != 1'b0 && _TECHMAP_CONSTMSK_PRE_ != 1'b0 && _TECHMAP_CONSTVAL_CLR_ == 1'b0 && _TECHMAP_CONSTVAL_PRE_ == 1'b0)
    $__PP3_DFFEPC_SYNCONLY _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN));
else
    wire _TECHMAP_FAIL_ = 1;

endmodule
`,"abc9_model.v":`(* abc9_flop, lib_whitebox *)
module $__PP3_DFFEPC_SYNCONLY (
  output Q,
  input D,
  input CLK,
  input EN,
);

  dffepc ff (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));

endmodule
`,"abc9_unmap.v":`module $__PP3_DFFEPC_SYNCONLY (
  output Q,
  input D,
  input CLK,
  input EN,
);

// For some reason ABC9 adds init attributes to wires even though they were removed before mapping.
// As a workaround, remove any init attributes that get reintroduced.
wire _TECHMAP_REMOVEINIT_Q_ = 1;

dffepc _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));

endmodule
`,"cells_map.v":`module \\$_MUX8_ (
  A, B, C, D, E, F, G, H, S, T, U, Y
);
  input A, B, C, D, E, F, G, H, S, T, U;
  output Y;
  mux8x0 _TECHMAP_REPLACE_ (
    .A(A),
    .B(B),
    .C(C),
    .D(D),
    .E(E),
    .F(F),
    .G(G),
    .H(H),
    .S0(S),
    .S1(T),
    .S2(U),
    .Q(Y)
  );
endmodule

module \\$_MUX4_ (
  A, B, C, D, S, T, U, Y
);
  input A, B, C, D, S, T, U;
  output Y;
  mux4x0 _TECHMAP_REPLACE_ (
    .A(A),
    .B(B),
    .C(C),
    .D(D),
    .S0(S),
    .S1(T),
    .Q(Y)
  );
endmodule
`,"cells_sim.v":`module inpad (
  output Q,
  (* iopad_external_pin *)
  input P
);
  specify
    (P => Q) = 0;
  endspecify
  assign Q = P;
endmodule

module outpad (
  (* iopad_external_pin *)
  output P,
  input A
);
  specify
    (A => P) = 0;
  endspecify
  assign P = A;
endmodule

module ckpad (
  output Q,
  (* iopad_external_pin *)
  input P
);
  specify
    (P => Q) = 0;
  endspecify
  assign Q = P;
endmodule

module bipad (
  input A,
  input EN,
  output Q,
  (* iopad_external_pin *)
  inout P
);
  assign Q = P;
  assign P = EN ? A : 1'bz;
endmodule

module dff (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;
  always @(posedge CLK) Q <= D;
endmodule

module dffc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input CLR
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR)
    if (CLR) Q <= 1'b0;
    else Q <= D;
endmodule

module dffp (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge PRE)
    if (PRE) Q <= 1'b1;
    else Q <= D;
endmodule

module dffpc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input CLR,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR or posedge PRE)
    if (CLR) Q <= 1'b0;
    else if (PRE) Q <= 1'b1;
    else Q <= D;
endmodule

module dffe (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;
  always @(posedge CLK) if (EN) Q <= D;
endmodule

module dffec (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN,
  (* clkbuf_sink *)
  input CLR
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR)
    if (CLR) Q <= 1'b0;
    else if (EN) Q <= D;
endmodule

(* lib_whitebox *)
module dffepc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN,
  (* clkbuf_sink *)
  input CLR,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;

  specify
    if (EN) (posedge CLK => (Q : D)) = 1701; // QCK -> QZ
    if (CLR) (CLR => Q) = 967; // QRT -> QZ
    if (PRE) (PRE => Q) = 1252; // QST -> QZ
    $setup(D, posedge CLK, 216); // QCK -> QDS
    $setup(EN, posedge CLK, 590); // QCK -> QEN
  endspecify

  initial Q = INIT;
  always @(posedge CLK or posedge CLR or posedge PRE)
    if (CLR) Q <= 1'b0;
    else if (PRE) Q <= 1'b1;
    else if (EN) Q <= D;
endmodule

//                  FZ       FS F2 (F1 TO 0)
(* abc9_box, lib_whitebox *)
module AND2I0 (
  output Q,
  input A, B
);
  specify
    (A => Q) = 698; // FS -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = A ? B : 0;
endmodule

(* abc9_box, lib_whitebox *)
module mux2x0 (
  output Q,
  input S, A, B
);
  specify
    (S => Q) = 698; // FS -> FZ
    (A => Q) = 639; // F1 -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = S ? B : A;
endmodule

(* abc9_box, lib_whitebox *)
module mux2x1 (
  output Q,
  input S, A, B
);
  specify
    (S => Q) = 698; // FS -> FZ
    (A => Q) = 639; // F1 -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = S ? B : A;
endmodule

(* abc9_box, lib_whitebox *)
module mux4x0 (
  output Q,
  input S0, S1, A, B, C, D
);
  specify
    (S0 => Q) = 1251; // TAB -> TZ
    (S1 => Q) = 1406; // TSL -> TZ
    (A => Q) = 1699;  // TA1 -> TZ
    (B => Q) = 1687;  // TA2 -> TZ
    (C => Q) = 1669;  // TB1 -> TZ
    (D => Q) = 1679;  // TB2 -> TZ
  endspecify

  assign Q = S1 ? (S0 ? D : C) : (S0 ? B : A);
endmodule

// S0 BSL TSL
// S1 BAB TAB
// S2 TBS
// A TA1
// B TA2
// C TB1
// D TB2
// E BA1
// F BA2
// G BB1
// H BB2
// Q CZ
(* abc9_box, lib_whitebox *)
module mux8x0 (
  output Q,
  input S0, S1, S2, A, B, C, D, E, F, G, H
);
  specify
    (S0 => Q) = 1593; // ('TSL', 'BSL') -> CZ
    (S1 => Q) = 1437; // ('TAB', 'BAB') -> CZ
    (S2 => Q) = 995; // TBS -> CZ
    (A => Q) = 1887; // TA1 -> CZ
    (B => Q) = 1873; // TA2 -> CZ
    (C => Q) = 1856; // TB1 -> CZ
    (D => Q) = 1860; // TB2 -> CZ
    (E => Q) = 1714; // BA1 -> CZ
    (F => Q) = 1773; // BA2 -> CZ
    (G => Q) = 1749; // BB1 -> CZ
    (H => Q) = 1723; // BB2 -> CZ
  endspecify

  assign Q = S2 ? (S1 ? (S0 ? H : G) : (S0 ? F : E)) : (S1 ? (S0 ? D : C) : (S0 ? B : A));
endmodule

(* blackbox *)
(* keep *)
module qlal4s3b_cell_macro (
  input WB_CLK,
  input WBs_ACK,
  input [31:0] WBs_RD_DAT,
  output [3:0] WBs_BYTE_STB,
  output WBs_CYC,
  output WBs_WE,
  output WBs_RD,
  output WBs_STB,
  output [16:0] WBs_ADR,
  input [3:0] SDMA_Req,
  input [3:0] SDMA_Sreq,
  output [3:0] SDMA_Done,
  output [3:0] SDMA_Active,
  input [3:0] FB_msg_out,
  input [7:0] FB_Int_Clr,
  output FB_Start,
  input FB_Busy,
  output WB_RST,
  output Sys_PKfb_Rst,
  output Clk16,
  output Clk16_Rst,
  output Clk21,
  output Clk21_Rst,
  output Sys_Pclk,
  output Sys_Pclk_Rst,
  input Sys_PKfb_Clk,
  input [31:0] FB_PKfbData,
  output [31:0] WBs_WR_DAT,
  input [3:0] FB_PKfbPush,
  input FB_PKfbSOF,
  input FB_PKfbEOF,
  output [7:0] Sensor_Int,
  output FB_PKfbOverflow,
  output [23:0] TimeStamp,
  input Sys_PSel,
  input [15:0] SPIm_Paddr,
  input SPIm_PEnable,
  input SPIm_PWrite,
  input [31:0] SPIm_PWdata,
  output SPIm_PReady,
  output SPIm_PSlvErr,
  output [31:0] SPIm_Prdata,
  input [15:0] Device_ID,
  input [13:0] FBIO_In_En,
  input [13:0] FBIO_Out,
  input [13:0] FBIO_Out_En,
  output [13:0] FBIO_In,
  inout [13:0] SFBIO,
  input Device_ID_6S,
  input Device_ID_4S,
  input SPIm_PWdata_26S,
  input SPIm_PWdata_24S,
  input SPIm_PWdata_14S,
  input SPIm_PWdata_11S,
  input SPIm_PWdata_0S,
  input SPIm_Paddr_8S,
  input SPIm_Paddr_6S,
  input FB_PKfbPush_1S,
  input FB_PKfbData_31S,
  input FB_PKfbData_21S,
  input FB_PKfbData_19S,
  input FB_PKfbData_9S,
  input FB_PKfbData_6S,
  input Sys_PKfb_ClkS,
  input FB_BusyS,
  input WB_CLKS
);

endmodule

(* abc9_lut=1, lib_whitebox *)
module LUT1 (
  output O,
  input I0
);
  parameter [1:0] INIT = 0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 698; // FS -> FZ
  endspecify

  assign O = I0 ? INIT[1] : INIT[0];
endmodule

//               TZ        TSL TAB
(* abc9_lut=2, lib_whitebox *)
module LUT2 (
  output O,
  input I0, I1
);
  parameter [3:0] INIT = 4'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 1251; // TAB -> TZ
    (I1 => O) = 1406; // TSL -> TZ
  endspecify

  wire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=2, lib_whitebox *)
module LUT3 (
  output O,
  input I0, I1, I2
);
  parameter [7:0] INIT = 8'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 1251; // TAB -> TZ
    (I1 => O) = 1406; // TSL -> TZ
    (I2 => O) = 1699; // ('TA1', 'TA2', 'TB1', 'TB2') -> TZ
  endspecify

  wire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];
  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=4, lib_whitebox *)
module LUT4 (
  output O,
  input I0, I1, I2, I3
);
  parameter [15:0] INIT = 16'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 995;  // TBS -> CZ
    (I1 => O) = 1437; // ('TAB', 'BAB') -> CZ
    (I2 => O) = 1593; // ('TSL', 'BSL') -> CZ
    (I3 => O) = 1887; // ('TA1', 'TA2', 'TB1', 'TB2', 'BA1', 'BA2', 'BB1', 'BB2') -> CZ
  endspecify

  wire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];
  wire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];
  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule
`,"ffs_map.v":`module \\$_DFFSRE_PPPP_ (input C, S, R, E, D, output Q);
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
  dffepc #(.INIT(1'b0)) _TECHMAP_REPLACE_ (.CLK(C), .PRE(S), .CLR(R), .EN(E), .D(D), .Q(Q));
endmodule
`,"latches_map.v":`module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule

module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule
`,"lut_map.v":`module \\$lut (
  A, Y
);
  parameter WIDTH = 0;
  parameter LUT = 0;

  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      LUT1 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0])
      );
    end else if (WIDTH == 2) begin
      LUT2 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1])
      );
    end else if (WIDTH == 3) begin
      LUT3 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1]),
        .I2(A[2])
      );
    end else if (WIDTH == 4) begin
      LUT4 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1]),
        .I2(A[2]),
        .I3(A[3])
      );
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
`},qlf_k6n10f:{"TDP18K_FIFO.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`default_nettype wire
module TDP18K_FIFO (
	RMODE_A_i,
	RMODE_B_i,
	WMODE_A_i,
	WMODE_B_i,
	WEN_A_i,
	WEN_B_i,
	REN_A_i,
	REN_B_i,
	CLK_A_i,
	CLK_B_i,
	BE_A_i,
	BE_B_i,
	ADDR_A_i,
	ADDR_B_i,
	WDATA_A_i,
	WDATA_B_i,
	RDATA_A_o,
	RDATA_B_o,
	EMPTY_o,
	EPO_o,
	EWM_o,
	UNDERRUN_o,
	FULL_o,
	FMO_o,
	FWM_o,
	OVERRUN_o,
	FLUSH_ni,
	FMODE_i,
);
	parameter SYNC_FIFO_i = 1'b0;
	parameter POWERDN_i = 1'b0;
	parameter SLEEP_i = 1'b0;
	parameter PROTECT_i = 1'b0;
	parameter UPAF_i = 11'b0;
	parameter UPAE_i = 11'b0;
	parameter [18*1024-1:0] INIT_i = 18431'bx;

	input wire [2:0] RMODE_A_i;
	input wire [2:0] RMODE_B_i;
	input wire [2:0] WMODE_A_i;
	input wire [2:0] WMODE_B_i;
	input wire WEN_A_i;
	input wire WEN_B_i;
	input wire REN_A_i;
	input wire REN_B_i;
	(* clkbuf_sink *)
	input wire CLK_A_i;
	(* clkbuf_sink *)
	input wire CLK_B_i;
	input wire [1:0] BE_A_i;
	input wire [1:0] BE_B_i;
	input wire [13:0] ADDR_A_i;
	input wire [13:0] ADDR_B_i;
	input wire [17:0] WDATA_A_i;
	input wire [17:0] WDATA_B_i;
	output reg [17:0] RDATA_A_o;
	output reg [17:0] RDATA_B_o;
	output wire EMPTY_o;
	output wire EPO_o;
	output wire EWM_o;
	output wire UNDERRUN_o;
	output wire FULL_o;
	output wire FMO_o;
	output wire FWM_o;
	output wire OVERRUN_o;
	input wire FLUSH_ni;
	input wire FMODE_i;
	reg [17:0] wmsk_a;
	reg [17:0] wmsk_b;
	wire [8:0] addr_a;
	wire [8:0] addr_b;
	reg [4:0] addr_a_d;
	reg [4:0] addr_b_d;
	wire [17:0] ram_rdata_a;
	wire [17:0] ram_rdata_b;
	reg [17:0] aligned_wdata_a;
	reg [17:0] aligned_wdata_b;
	wire ren_o;
	wire [10:0] ff_raddr;
	wire [10:0] ff_waddr;
	wire [13:0] ram_addr_a;
	wire [13:0] ram_addr_b;
	wire [3:0] ram_waddr_a;
	wire [3:0] ram_waddr_b;
	wire initn;
	wire smux_rclk;
	wire smux_wclk;
	wire real_fmode;
	wire [3:0] raw_fflags;
	reg [1:0] fifo_rmode;
	reg [1:0] fifo_wmode;
	wire smux_clk_a;
	wire smux_clk_b;
	wire ram_ren_a;
	wire ram_ren_b;
	wire ram_wen_a;
	wire ram_wen_b;
	wire cen_a;
	wire cen_b;
	wire cen_a_n;
	wire cen_b_n;
	wire ram_wen_a_n;
	wire ram_wen_b_n;
	localparam MODE_9 = 3'b001;
	always @(*) begin
		fifo_rmode = (RMODE_B_i == MODE_9 ? 2'b10 : 2'b01);
		fifo_wmode = (WMODE_A_i == MODE_9 ? 2'b10 : 2'b01);
	end
	assign smux_clk_a = CLK_A_i;
	assign smux_clk_b = CLK_B_i;
	assign real_fmode = FMODE_i;
	assign ram_ren_b = real_fmode ? ren_o : REN_B_i;
	assign ram_wen_a = FMODE_i ? ~FULL_o & WEN_A_i : WEN_A_i;
	assign ram_ren_a = FMODE_i ? 0 : REN_A_i;
	assign ram_wen_b = FMODE_i ? 1'b0 : WEN_B_i;
	assign cen_b = ram_ren_b | ram_wen_b;
	assign cen_a = ram_ren_a | ram_wen_a;
	assign ram_waddr_b = real_fmode ? {ff_raddr[0], 3'b000} : ADDR_B_i[3:0];
	assign ram_waddr_a = real_fmode ? {ff_waddr[0], 3'b000} : ADDR_A_i[3:0];
	assign ram_addr_b = real_fmode ? {ff_raddr[10:0], 3'h0} : {ADDR_B_i[13:4], addr_b_d[3:0]};
	assign ram_addr_a = real_fmode ? {ff_waddr[10:0], 3'h0} : {ADDR_A_i[13:4], addr_a_d[3:0]};
	always @(posedge CLK_A_i) addr_a_d[3:0] <= ADDR_A_i[3:0];
	always @(posedge CLK_B_i) addr_b_d[3:0] <= ADDR_B_i[3:0];
	assign cen_a_n = ~cen_a;
	assign ram_wen_a_n = ~ram_wen_a;
	assign cen_b_n = ~cen_b;
	assign ram_wen_b_n = ~ram_wen_b;

	sram1024x18 #(
		.init(INIT_i)
	) uram(
		.clk_a(smux_clk_a),
		.cen_a(cen_a_n),
		.wen_a(ram_wen_a_n),
		.addr_a(ram_addr_a[13:4]),
		.wmsk_a(wmsk_a),
		.wdata_a(aligned_wdata_a),
		.rdata_a(ram_rdata_a),
		.clk_b(smux_clk_b),
		.cen_b(cen_b_n),
		.wen_b(ram_wen_b_n),
		.addr_b(ram_addr_b[13:4]),
		.wmsk_b(wmsk_b),
		.wdata_b(aligned_wdata_b),
		.rdata_b(ram_rdata_b)
	);
	fifo_ctl #(
		.ADDR_WIDTH(11),
		.FIFO_WIDTH(2),
		.DEPTH(6)
	) fifo_ctl(
		.rclk(smux_clk_b),
		.rst_R_n(FLUSH_ni),
		.wclk(smux_clk_a),
		.rst_W_n(FLUSH_ni),
		.ren(REN_B_i),
		.wen(ram_wen_a),
		.sync(SYNC_FIFO_i),
		.rmode(fifo_rmode),
		.wmode(fifo_wmode),
		.ren_o(ren_o),
		.fflags({FULL_o, FMO_o, FWM_o, OVERRUN_o, EMPTY_o, EPO_o, EWM_o, UNDERRUN_o}),
		.raddr(ff_raddr),
		.waddr(ff_waddr),
		.upaf(UPAF_i),
		.upae(UPAE_i)
	);
	localparam MODE_1 = 3'b101;
	localparam MODE_18 = 3'b010;
	localparam MODE_2 = 3'b110;
	localparam MODE_4 = 3'b100;
	always @(*) begin : WDATA_MODE_SEL
		if (ram_wen_a == 1) begin
			case (WMODE_A_i)
				MODE_18: begin
					aligned_wdata_a = WDATA_A_i;
					{wmsk_a[17], wmsk_a[15:8]} = (FMODE_i ? 9'h000 : (BE_A_i[1] ? 9'h000 : 9'h1ff));
					{wmsk_a[16], wmsk_a[7:0]} = (FMODE_i ? 9'h000 : (BE_A_i[0] ? 9'h000 : 9'h1ff));
				end
				MODE_9: begin
					aligned_wdata_a = {{2 {WDATA_A_i[16]}}, {2 {WDATA_A_i[7:0]}}};
					{wmsk_a[17], wmsk_a[15:8]} = (ram_waddr_a[3] ? 9'h000 : 9'h1ff);
					{wmsk_a[16], wmsk_a[7:0]} = (ram_waddr_a[3] ? 9'h1ff : 9'h000);
				end
				MODE_4: begin
					aligned_wdata_a = {2'b00, {4 {WDATA_A_i[3:0]}}};
					wmsk_a[17:16] = 2'b00;
					wmsk_a[15:12] = (ram_waddr_a[3:2] == 2'b11 ? 4'h0 : 4'hf);
					wmsk_a[11:8] = (ram_waddr_a[3:2] == 2'b10 ? 4'h0 : 4'hf);
					wmsk_a[7:4] = (ram_waddr_a[3:2] == 2'b01 ? 4'h0 : 4'hf);
					wmsk_a[3:0] = (ram_waddr_a[3:2] == 2'b00 ? 4'h0 : 4'hf);
				end
				MODE_2: begin
					aligned_wdata_a = {2'b00, {8 {WDATA_A_i[1:0]}}};
					wmsk_a[17:16] = 2'b00;
					wmsk_a[15:14] = (ram_waddr_a[3:1] == 3'b111 ? 2'h0 : 2'h3);
					wmsk_a[13:12] = (ram_waddr_a[3:1] == 3'b110 ? 2'h0 : 2'h3);
					wmsk_a[11:10] = (ram_waddr_a[3:1] == 3'b101 ? 2'h0 : 2'h3);
					wmsk_a[9:8] = (ram_waddr_a[3:1] == 3'b100 ? 2'h0 : 2'h3);
					wmsk_a[7:6] = (ram_waddr_a[3:1] == 3'b011 ? 2'h0 : 2'h3);
					wmsk_a[5:4] = (ram_waddr_a[3:1] == 3'b010 ? 2'h0 : 2'h3);
					wmsk_a[3:2] = (ram_waddr_a[3:1] == 3'b001 ? 2'h0 : 2'h3);
					wmsk_a[1:0] = (ram_waddr_a[3:1] == 3'b000 ? 2'h0 : 2'h3);
				end
				MODE_1: begin
					aligned_wdata_a = {2'b00, {16 {WDATA_A_i[0]}}};
					wmsk_a = 18'h0ffff;
					wmsk_a[{1'b0, ram_waddr_a[3:0]}] = 0;
				end
				default: wmsk_a = 18'h3ffff;
			endcase
		end
		else begin
			aligned_wdata_a = 18'h00000;
			wmsk_a = 18'h3ffff;
		end
		if (ram_wen_b == 1)
			case (WMODE_B_i)
				MODE_18: begin
					aligned_wdata_b = WDATA_B_i;
					{wmsk_b[17], wmsk_b[15:8]} = (BE_B_i[1] ? 9'h000 : 9'h1ff);
					{wmsk_b[16], wmsk_b[7:0]} = (BE_B_i[0] ? 9'h000 : 9'h1ff);
				end
				MODE_9: begin
					aligned_wdata_b = {{2 {WDATA_B_i[16]}}, {2 {WDATA_B_i[7:0]}}};
					{wmsk_b[17], wmsk_b[15:8]} = (ram_waddr_b[3] ? 9'h000 : 9'h1ff);
					{wmsk_b[16], wmsk_b[7:0]} = (ram_waddr_b[3] ? 9'h1ff : 9'h000);
				end
				MODE_4: begin
					aligned_wdata_b = {2'b00, {4 {WDATA_B_i[3:0]}}};
					wmsk_b[17:16] = 2'b00;
					wmsk_b[15:12] = (ram_waddr_b[3:2] == 2'b11 ? 4'h0 : 4'hf);
					wmsk_b[11:8] = (ram_waddr_b[3:2] == 2'b10 ? 4'h0 : 4'hf);
					wmsk_b[7:4] = (ram_waddr_b[3:2] == 2'b01 ? 4'h0 : 4'hf);
					wmsk_b[3:0] = (ram_waddr_b[3:2] == 2'b00 ? 4'h0 : 4'hf);
				end
				MODE_2: begin
					aligned_wdata_b = {2'b00, {8 {WDATA_B_i[1:0]}}};
					wmsk_b[17:16] = 2'b00;
					wmsk_b[15:14] = (ram_waddr_b[3:1] == 3'b111 ? 2'h0 : 2'h3);
					wmsk_b[13:12] = (ram_waddr_b[3:1] == 3'b110 ? 2'h0 : 2'h3);
					wmsk_b[11:10] = (ram_waddr_b[3:1] == 3'b101 ? 2'h0 : 2'h3);
					wmsk_b[9:8] = (ram_waddr_b[3:1] == 3'b100 ? 2'h0 : 2'h3);
					wmsk_b[7:6] = (ram_waddr_b[3:1] == 3'b011 ? 2'h0 : 2'h3);
					wmsk_b[5:4] = (ram_waddr_b[3:1] == 3'b010 ? 2'h0 : 2'h3);
					wmsk_b[3:2] = (ram_waddr_b[3:1] == 3'b001 ? 2'h0 : 2'h3);
					wmsk_b[1:0] = (ram_waddr_b[3:1] == 3'b000 ? 2'h0 : 2'h3);
				end
				MODE_1: begin
					aligned_wdata_b = {2'b00, {16 {WDATA_B_i[0]}}};
					wmsk_b = 18'h0ffff;
					wmsk_b[{1'b0, ram_waddr_b[3:0]}] = 0;
				end
				default: wmsk_b = 18'h3ffff;
			endcase
		else begin
			aligned_wdata_b = 18'b000000000000000000;
			wmsk_b = 18'h3ffff;
		end
	end
	always @(*) begin : RDATA_A_MODE_SEL
		case (RMODE_A_i)
			default: RDATA_A_o = 18'h00000;
			MODE_18: RDATA_A_o = ram_rdata_a;
			MODE_9: begin
				{RDATA_A_o[17], RDATA_A_o[15:8]} = 9'h000;
				{RDATA_A_o[16], RDATA_A_o[7:0]} = (ram_addr_a[3] ? {ram_rdata_a[17], ram_rdata_a[15:8]} : {ram_rdata_a[16], ram_rdata_a[7:0]});
			end
			MODE_4: begin
				RDATA_A_o[17:4] = 14'h0000;
				case (ram_addr_a[3:2])
					3: RDATA_A_o[3:0] = ram_rdata_a[15:12];
					2: RDATA_A_o[3:0] = ram_rdata_a[11:8];
					1: RDATA_A_o[3:0] = ram_rdata_a[7:4];
					0: RDATA_A_o[3:0] = ram_rdata_a[3:0];
				endcase
			end
			MODE_2: begin
				RDATA_A_o[17:2] = 16'h0000;
				case (ram_addr_a[3:1])
					7: RDATA_A_o[1:0] = ram_rdata_a[15:14];
					6: RDATA_A_o[1:0] = ram_rdata_a[13:12];
					5: RDATA_A_o[1:0] = ram_rdata_a[11:10];
					4: RDATA_A_o[1:0] = ram_rdata_a[9:8];
					3: RDATA_A_o[1:0] = ram_rdata_a[7:6];
					2: RDATA_A_o[1:0] = ram_rdata_a[5:4];
					1: RDATA_A_o[1:0] = ram_rdata_a[3:2];
					0: RDATA_A_o[1:0] = ram_rdata_a[1:0];
				endcase
			end
			MODE_1: begin
				RDATA_A_o[17:1] = 17'h00000;
				RDATA_A_o[0] = ram_rdata_a[ram_addr_a[3:0]];
			end
		endcase
	end
	always @(*)
		case (RMODE_B_i)
			default: RDATA_B_o = 18'h15566;
			MODE_18: RDATA_B_o = ram_rdata_b;
			MODE_9: begin
				{RDATA_B_o[17], RDATA_B_o[15:8]} = 9'b000000000;
				{RDATA_B_o[16], RDATA_B_o[7:0]} = (ram_addr_b[3] ? {ram_rdata_b[17], ram_rdata_b[15:8]} : {ram_rdata_b[16], ram_rdata_b[7:0]});
			end
			MODE_4:
				case (ram_addr_b[3:2])
					3: RDATA_B_o[3:0] = ram_rdata_b[15:12];
					2: RDATA_B_o[3:0] = ram_rdata_b[11:8];
					1: RDATA_B_o[3:0] = ram_rdata_b[7:4];
					0: RDATA_B_o[3:0] = ram_rdata_b[3:0];
				endcase
			MODE_2:
				case (ram_addr_b[3:1])
					7: RDATA_B_o[1:0] = ram_rdata_b[15:14];
					6: RDATA_B_o[1:0] = ram_rdata_b[13:12];
					5: RDATA_B_o[1:0] = ram_rdata_b[11:10];
					4: RDATA_B_o[1:0] = ram_rdata_b[9:8];
					3: RDATA_B_o[1:0] = ram_rdata_b[7:6];
					2: RDATA_B_o[1:0] = ram_rdata_b[5:4];
					1: RDATA_B_o[1:0] = ram_rdata_b[3:2];
					0: RDATA_B_o[1:0] = ram_rdata_b[1:0];
				endcase
			MODE_1: RDATA_B_o[0] = ram_rdata_b[{1'b0, ram_addr_b[3:0]}];
		endcase
endmodule
\`default_nettype none
`,"arith_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
(* techmap_celltype = "$alu" *)
module _80_quicklogic_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 2;
	parameter B_WIDTH = 2;
	parameter Y_WIDTH = 2;
	parameter _TECHMAP_CONSTVAL_CI_ = 0;
	parameter _TECHMAP_CONSTMSK_CI_ = 0;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;


	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	genvar i;
	wire co;

	(* force_downto *)
	//wire [Y_WIDTH-1:0] C = {CO, CI};
	wire [Y_WIDTH:0] C;
	(* force_downto *)
	wire [Y_WIDTH-1:0] S  = {AA ^ BB};
	assign CO[Y_WIDTH-1:0] = C[Y_WIDTH:1];
		//assign CO[Y_WIDTH-1] = co;

	generate
		adder_carry intermediate_adder (
			.cin     ( ),
			.cout    (C[0]),
			.p       (1'b0),
			.g       (CI),
			.sumout  ()
		);
	endgenerate
	genvar i;
	generate if (Y_WIDTH > 2) begin
	  for (i = 0; i < Y_WIDTH-2; i = i + 1) begin:slice
		adder_carry  my_adder (
			.cin     (C[i]),
			.g       (AA[i]),
			.p       (S[i]),
			.cout    (C[i+1]),
			.sumout  (Y[i])
		);
		  end
	end endgenerate
	generate
		adder_carry final_adder (
			.cin     (C[Y_WIDTH-2]),
			.cout    (),
			.p       (1'b0),
			.g       (1'b0),
			.sumout  (co)
		);
	endgenerate

	assign Y[Y_WIDTH-2] = S[Y_WIDTH-2] ^ co;
	assign C[Y_WIDTH-1] = S[Y_WIDTH-2] ? co : AA[Y_WIDTH-2];
	assign Y[Y_WIDTH-1] = S[Y_WIDTH-1] ^ C[Y_WIDTH-1];
	assign C[Y_WIDTH] = S[Y_WIDTH-1] ? C[Y_WIDTH-1] : AA[Y_WIDTH-1];

	assign X = S;
endmodule

`,"bram_types_sim.v":new URL("bram_types_sim-b6e3741a.v?hash=b6e3741a",import.meta.url),"brams_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module RAM_36K_BLK (
		WEN_i,
		REN_i,
		WR_CLK_i,
		RD_CLK_i,
		WR_BE_i,
		WR_ADDR_i,
		RD_ADDR_i,
		WDATA_i,
		RDATA_o
);

parameter WR_ADDR_WIDTH = 10;
parameter RD_ADDR_WIDTH = 10;
parameter WR_DATA_WIDTH = 36;
parameter RD_DATA_WIDTH = 36;
parameter BE_WIDTH = 4;

parameter INIT = 0;

input wire WEN_i;
input wire REN_i;
input wire WR_CLK_i;
input wire RD_CLK_i;
input wire [BE_WIDTH-1:0] WR_BE_i;
input wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;
input wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;
input wire [WR_DATA_WIDTH-1 :0] WDATA_i;
output wire [RD_DATA_WIDTH-1 :0] RDATA_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
32, 36: rwmode = 36;
default: rwmode = 36;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [3:0] WR_BE;

wire [35:0] PORT_B_RDATA;
wire [35:0] PORT_A_WDATA;

wire [14:0] WR_ADDR_INT;
wire [14:0] RD_ADDR_INT;

wire [14:0] PORT_A_ADDR;
wire [14:0] PORT_B_ADDR;

wire PORT_A_CLK;
wire PORT_B_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

assign PORT_A_CLK = WR_CLK_i;
assign PORT_B_CLK = RD_CLK_i;

generate
	if (WR_ADDR_WIDTH == 15) begin
		assign WR_ADDR_INT = WR_ADDR_i;
	end else begin
		assign WR_ADDR_INT[14:WR_ADDR_WIDTH] = 0;
		assign WR_ADDR_INT[WR_ADDR_WIDTH-1:0] = WR_ADDR_i;
	end
endgenerate

case (WR_DATA_WIDTH)
	1: begin
		assign PORT_A_ADDR = WR_ADDR_INT;
	end
	2: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 5;
	end
	default: begin
		assign PORT_A_ADDR = WR_ADDR_INT;
	end
endcase

generate
	if (RD_ADDR_WIDTH == 15) begin
		assign RD_ADDR_INT = RD_ADDR_i;
	end else begin
		assign RD_ADDR_INT[14:RD_ADDR_WIDTH] = 0;
		assign RD_ADDR_INT[RD_ADDR_WIDTH-1:0] = RD_ADDR_i;
	end
endgenerate

case (RD_DATA_WIDTH)
	1: begin
		assign PORT_B_ADDR = RD_ADDR_INT;
	end
	2: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 5;
	end
	default: begin
		assign PORT_B_ADDR = RD_ADDR_INT;
	end
endcase

case (BE_WIDTH)
	4: begin
		assign WR_BE = WR_BE_i[BE_WIDTH-1 :0];
	end
	default: begin
		assign WR_BE[3:BE_WIDTH] = 0;
		assign WR_BE[BE_WIDTH-1 :0] = WR_BE_i[BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN_i;
assign {BE_A2_i, BE_A1_i} = WR_BE;

assign REN_B1_i = REN_i;
assign WEN_B1_i = 1'b0;
assign {BE_B2_i, BE_B1_i} = 4'h0;

generate
	if (WR_DATA_WIDTH == 36) begin
		assign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];
	end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
		assign PORT_A_WDATA[WR_DATA_WIDTH+1:18]  = WDATA_i[WR_DATA_WIDTH-1:16];
		assign PORT_A_WDATA[17:0] = {2'b00,WDATA_i[15:0]};
	end else if (WR_DATA_WIDTH == 9) begin
		assign PORT_A_WDATA = {19'h0, WDATA_i[8], 8'h0, WDATA_i[7:0]};
	end else begin
		assign PORT_A_WDATA[35:WR_DATA_WIDTH] = 0;
		assign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A_WDATA[17:0];
assign WDATA_A2_i = PORT_A_WDATA[35:18];

assign WDATA_B1_i = 18'h0;
assign WDATA_B2_i = 18'h0;

generate
	if (RD_DATA_WIDTH == 36) begin
		assign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};
	end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
		assign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};
	end else if (RD_DATA_WIDTH == 9) begin
		assign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B_RDATA = {18'h0, RDATA_B1_o};
	end
endgenerate

assign RDATA_o = PORT_B_RDATA[RD_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};


(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A_WRWIDTH *)
(* port_b_dwidth = PORT_B_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module RAM_18K_BLK (
		WEN_i,
		REN_i,
		WR_CLK_i,
		RD_CLK_i,
		WR_BE_i,
		WR_ADDR_i,
		RD_ADDR_i,
		WDATA_i,
		RDATA_o
);

parameter WR_ADDR_WIDTH = 10;
parameter RD_ADDR_WIDTH = 10;
parameter WR_DATA_WIDTH = 18;
parameter RD_DATA_WIDTH = 18;
parameter BE_WIDTH = 2;

input wire WEN_i;
input wire REN_i;
input wire WR_CLK_i;
input wire RD_CLK_i;
input wire [BE_WIDTH-1:0] WR_BE_i;
input wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;
input wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;
input wire [WR_DATA_WIDTH-1 :0] WDATA_i;
output wire [RD_DATA_WIDTH-1 :0] RDATA_o;

	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* is_fifo = 0 *)
	BRAM2x18_SP  #(
			.WR1_ADDR_WIDTH(WR_ADDR_WIDTH),
			.RD1_ADDR_WIDTH(RD_ADDR_WIDTH),
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.BE1_WIDTH(BE_WIDTH),
			.WR2_ADDR_WIDTH(),
			.RD2_ADDR_WIDTH(),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.BE2_WIDTH()
			 ) U1
			(
			.RESET_ni(1'b1),

			.WEN1_i(WEN_i),
			.REN1_i(REN_i),
			.WR1_CLK_i(WR_CLK_i),
			.RD1_CLK_i(RD_CLK_i),
			.WR1_BE_i(WR_BE_i),
			.WR1_ADDR_i(WR_ADDR_i),
			.RD1_ADDR_i(RD_ADDR_i),
			.WDATA1_i(WDATA_i),
			.RDATA1_o(RDATA_o),

			.WEN2_i(1'b0),
			.REN2_i(1'b0),
			.WR2_CLK_i(1'b0),
			.RD2_CLK_i(1'b0),
			.WR2_BE_i(2'b00),
			.WR2_ADDR_i(14'h0),
			.RD2_ADDR_i(14'h0),
			.WDATA2_i(18'h0),
			.RDATA2_o()
			);

endmodule

module RAM_18K_X2_BLK (
		RESET_ni,

		WEN1_i,
		REN1_i,
		WR1_CLK_i,
		RD1_CLK_i,
		WR1_BE_i,
		WR1_ADDR_i,
		RD1_ADDR_i,
		WDATA1_i,
		RDATA1_o,

		WEN2_i,
		REN2_i,
		WR2_CLK_i,
		RD2_CLK_i,
		WR2_BE_i,
		WR2_ADDR_i,
		RD2_ADDR_i,
		WDATA2_i,
		RDATA2_o
);

parameter WR1_ADDR_WIDTH = 10;
parameter RD1_ADDR_WIDTH = 10;
parameter WR1_DATA_WIDTH = 18;
parameter RD1_DATA_WIDTH = 18;
parameter BE1_WIDTH = 2;

parameter WR2_ADDR_WIDTH = 10;
parameter RD2_ADDR_WIDTH = 10;
parameter WR2_DATA_WIDTH = 18;
parameter RD2_DATA_WIDTH = 18;
parameter BE2_WIDTH = 2;

input wire RESET_ni;

input wire WEN1_i;
input wire REN1_i;
input wire WR1_CLK_i;
input wire RD1_CLK_i;
input wire [BE1_WIDTH-1:0] WR1_BE_i;
input wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;
input wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;
input wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;
output wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;

input wire WEN2_i;
input wire REN2_i;
input wire WR2_CLK_i;
input wire RD2_CLK_i;
input wire [BE2_WIDTH-1:0] WR2_BE_i;
input wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;
input wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;
input wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;
output wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] WR1_BE;
wire [1:0] WR2_BE;

wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;

wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;

wire [13:0] WR1_ADDR_INT;
wire [13:0] RD1_ADDR_INT;

wire [13:0] WR2_ADDR_INT;
wire [13:0] RD2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

generate
	if (WR1_ADDR_WIDTH == 14) begin
		assign WR1_ADDR_INT = WR1_ADDR_i;
	end else begin
		assign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;
		assign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;
	end
endgenerate

case (WR1_DATA_WIDTH)
	1: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
endcase

generate
	if (RD1_ADDR_WIDTH == 14) begin
		assign RD1_ADDR_INT = RD1_ADDR_i;
	end else begin
		assign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;
		assign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;
	end
endgenerate

case (RD1_DATA_WIDTH)
	1: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
endcase

generate
	if (WR2_ADDR_WIDTH == 14) begin
		assign WR2_ADDR_INT = WR2_ADDR_i;
	end else begin
		assign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;
		assign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;
	end
endgenerate

case (WR2_DATA_WIDTH)
	1: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
endcase

generate
	if (RD2_ADDR_WIDTH == 14) begin
		assign RD2_ADDR_INT = RD2_ADDR_i;
	end else begin
		assign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;
		assign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;
	end
endgenerate

case (RD2_DATA_WIDTH)
	1: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
endcase

case (BE1_WIDTH)
	2: begin
		assign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];
	end
	default: begin
		assign WR1_BE[1:BE1_WIDTH] = 0;
		assign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];
	end
endcase

case (BE2_WIDTH)
	2: begin
		assign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];
	end
	default: begin
		assign WR2_BE[1:BE2_WIDTH] = 0;
		assign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN1_i;
assign BE_A1_i = WR1_BE;
assign REN_A2_i = 1'b0;
assign WEN_A2_i = WEN2_i;
assign BE_A2_i = WR2_BE;

assign REN_B1_i = REN1_i;
assign WEN_B1_i = 1'b0;
assign BE_B1_i = 4'h0;
assign REN_B2_i = REN2_i;
assign WEN_B2_i = 1'b0;
assign BE_B2_i = 4'h0;

generate
	if (WR1_DATA_WIDTH == 18) begin
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end else if (WR1_DATA_WIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA[17:0];
assign WDATA_B1_i = 18'h0;

generate
	if (RD1_DATA_WIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];

generate
	if (WR2_DATA_WIDTH == 18) begin
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end else if (WR2_DATA_WIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA[17:0];
assign WDATA_B2_i = 18'h0;

generate
	if (RD2_DATA_WIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 1 *)
(* is_fifo = 0 *)
(* port_a1_dwidth = PORT_A1_WRWIDTH *)
(* port_a2_dwidth = PORT_A2_WRWIDTH *)
(* port_b1_dwidth = PORT_B1_WRWIDTH *)
(* port_b2_dwidth = PORT_B2_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(WR1_CLK_i),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(WR2_CLK_i),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(RD1_CLK_i),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(RD2_CLK_i),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module DPRAM_36K_BLK (
		PORT_A_CLK_i,
		PORT_A_WEN_i,
		PORT_A_WR_BE_i,
		PORT_A_REN_i,
		PORT_A_ADDR_i,
		PORT_A_WR_DATA_i,
		PORT_A_RD_DATA_o,

		PORT_B_CLK_i,
		PORT_B_WEN_i,
		PORT_B_WR_BE_i,
		PORT_B_REN_i,
		PORT_B_ADDR_i,
		PORT_B_WR_DATA_i,
		PORT_B_RD_DATA_o
);

parameter PORT_A_AWIDTH = 10;
parameter PORT_A_DWIDTH = 36;
parameter PORT_A_WR_BE_WIDTH = 4;

parameter PORT_B_AWIDTH = 10;
parameter PORT_B_DWIDTH = 36;
parameter PORT_B_WR_BE_WIDTH = 4;

input PORT_A_CLK_i;
input [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;
input [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;
input PORT_A_WEN_i;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;
input PORT_A_REN_i;
output [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;

input PORT_B_CLK_i;
input [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;
input [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;
input PORT_B_WEN_i;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;
input PORT_B_REN_i;
output [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
32, 36: rwmode = 36;
default: rwmode = 36;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [3:0] PORT_A_WR_BE;
wire [3:0] PORT_B_WR_BE;

wire [35:0] PORT_B_WDATA;
wire [35:0] PORT_B_RDATA;
wire [35:0] PORT_A_WDATA;
wire [35:0] PORT_A_RDATA;

wire [14:0] PORT_A_ADDR_INT;
wire [14:0] PORT_B_ADDR_INT;

wire [14:0] PORT_A_ADDR;
wire [14:0] PORT_B_ADDR;

wire PORT_A_CLK;
wire PORT_B_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B_DWIDTH);

localparam PORT_A_WRWIDTH = rwmode(PORT_A_DWIDTH);
localparam PORT_B_WRWIDTH = rwmode(PORT_B_DWIDTH);

assign PORT_A_CLK = PORT_A_CLK_i;
assign PORT_B_CLK = PORT_B_CLK_i;

generate
	if (PORT_A_AWIDTH == 15) begin
		assign PORT_A_ADDR_INT = PORT_A_ADDR_i;
	end else begin
		assign PORT_A_ADDR_INT[14:PORT_A_AWIDTH] = 0;
		assign PORT_A_ADDR_INT[PORT_A_AWIDTH-1:0] = PORT_A_ADDR_i;
	end
endgenerate

case (PORT_A_DWIDTH)
	1: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT;
	end
	2: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 5;
	end
	default: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT;
	end
endcase

generate
	if (PORT_B_AWIDTH == 15) begin
		assign PORT_B_ADDR_INT = PORT_B_ADDR_i;
	end else begin
		assign PORT_B_ADDR_INT[14:PORT_B_AWIDTH] = 0;
		assign PORT_B_ADDR_INT[PORT_B_AWIDTH-1:0] = PORT_B_ADDR_i;
	end
endgenerate

case (PORT_B_DWIDTH)
	1: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT;
	end
	2: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 5;
	end
	default: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT;
	end
endcase

case (PORT_A_WR_BE_WIDTH)
	4: begin
		assign PORT_A_WR_BE = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A_WR_BE[3:PORT_A_WR_BE_WIDTH] = 0;
		assign PORT_A_WR_BE[PORT_A_WR_BE_WIDTH-1 :0] = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B_WR_BE_WIDTH)
	4: begin
		assign PORT_B_WR_BE = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B_WR_BE[3:PORT_B_WR_BE_WIDTH] = 0;
		assign PORT_B_WR_BE[PORT_B_WR_BE_WIDTH-1 :0] = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A_REN_i;
assign WEN_A1_i = PORT_A_WEN_i;
assign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;

assign REN_B1_i = PORT_B_REN_i;
assign WEN_B1_i = PORT_B_WEN_i;
assign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;

generate
	if (PORT_A_DWIDTH == 36) begin
		assign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];
	end else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin
		assign PORT_A_WDATA[PORT_A_DWIDTH+1:18]  = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:16];
		assign PORT_A_WDATA[17:0] = {2'b00,PORT_A_WR_DATA_i[15:0]};
	end else if (PORT_A_DWIDTH == 9) begin
		assign PORT_A_WDATA = {19'h0, PORT_A_WR_DATA_i[8], 8'h0, PORT_A_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A_WDATA[35:PORT_A_DWIDTH] = 0;
		assign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A_WDATA[17:0];
assign WDATA_A2_i = PORT_A_WDATA[35:18];

generate
	if (PORT_A_DWIDTH == 36) begin
		assign PORT_A_RDATA = {RDATA_A2_o, RDATA_A1_o};
	end else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin
		assign PORT_A_RDATA  = {2'b00,RDATA_A2_o[17:0],RDATA_A1_o[15:0]};
	end else if (PORT_A_DWIDTH == 9) begin
		assign PORT_A_RDATA = { 27'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A_RDATA = {18'h0, RDATA_A1_o};
	end
endgenerate

assign PORT_A_RD_DATA_o = PORT_A_RDATA[PORT_A_DWIDTH-1:0];

generate
	if (PORT_B_DWIDTH == 36) begin
		assign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];
	end else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin
		assign PORT_B_WDATA[PORT_B_DWIDTH+1:18]  = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:16];
		assign PORT_B_WDATA[17:0] = {2'b00,PORT_B_WR_DATA_i[15:0]};
	end else if (PORT_B_DWIDTH == 9) begin
		assign PORT_B_WDATA = {19'h0, PORT_B_WR_DATA_i[8], 8'h0, PORT_B_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B_WDATA[35:PORT_B_DWIDTH] = 0;
		assign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B_WDATA[17:0];
assign WDATA_B2_i = PORT_B_WDATA[35:18];

generate
	if (PORT_B_DWIDTH == 36) begin
		assign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};
	end else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin
		assign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};
	end else if (PORT_B_DWIDTH == 9) begin
		assign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B_RDATA = {18'h0, RDATA_B1_o};
	end
endgenerate

assign PORT_B_RD_DATA_o = PORT_B_RDATA[PORT_B_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A_WRWIDTH *)
(* port_b_dwidth = PORT_B_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module DPRAM_18K_BLK (
		PORT_A_CLK_i,
		PORT_A_WEN_i,
		PORT_A_WR_BE_i,
		PORT_A_REN_i,
		PORT_A_ADDR_i,
		PORT_A_WR_DATA_i,
		PORT_A_RD_DATA_o,

		PORT_B_CLK_i,
		PORT_B_WEN_i,
		PORT_B_WR_BE_i,
		PORT_B_REN_i,
		PORT_B_ADDR_i,
		PORT_B_WR_DATA_i,
		PORT_B_RD_DATA_o
);

parameter PORT_A_AWIDTH = 10;
parameter PORT_A_DWIDTH = 36;
parameter PORT_A_WR_BE_WIDTH = 4;

parameter PORT_B_AWIDTH = 10;
parameter PORT_B_DWIDTH = 36;
parameter PORT_B_WR_BE_WIDTH = 4;

input PORT_A_CLK_i;
input [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;
input [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;
input PORT_A_WEN_i;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;
input PORT_A_REN_i;
output [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;

input PORT_B_CLK_i;
input [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;
input [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;
input PORT_B_WEN_i;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;
input PORT_B_REN_i;
output [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;


(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
BRAM2x18_dP #(
	.PORT_A1_AWIDTH(PORT_A_AWIDTH),
	.PORT_A1_DWIDTH(PORT_A_DWIDTH),
	.PORT_A1_WR_BE_WIDTH(PORT_A_WR_BE_WIDTH),
	.PORT_B1_AWIDTH(PORT_B_AWIDTH),
	.PORT_B1_DWIDTH(PORT_B_DWIDTH),
	.PORT_B1_WR_BE_WIDTH(PORT_B_WR_BE_WIDTH),
	.PORT_A2_AWIDTH(),
	.PORT_A2_DWIDTH(),
	.PORT_A2_WR_BE_WIDTH(),
	.PORT_B2_AWIDTH(),
	.PORT_B2_DWIDTH(),
	.PORT_B2_WR_BE_WIDTH()
) U1 (
		.PORT_A1_CLK_i(PORT_A_CLK_i),
		.PORT_A1_WEN_i(PORT_A_WEN_i),
		.PORT_A1_WR_BE_i(PORT_A_WR_BE_i),
		.PORT_A1_REN_i(PORT_A_REN_i),
		.PORT_A1_ADDR_i(PORT_A_ADDR_i),
		.PORT_A1_WR_DATA_i(PORT_A_WR_DATA_i),
		.PORT_A1_RD_DATA_o(PORT_A_RD_DATA_o),

		.PORT_B1_CLK_i(PORT_B_CLK_i),
		.PORT_B1_WEN_i(PORT_B_WEN_i),
		.PORT_B1_WR_BE_i(PORT_B_WR_BE_i),
		.PORT_B1_REN_i(PORT_B_REN_i),
		.PORT_B1_ADDR_i(PORT_B_ADDR_i),
		.PORT_B1_WR_DATA_i(PORT_B_WR_DATA_i),
		.PORT_B1_RD_DATA_o(PORT_B_RD_DATA_o),

		.PORT_A2_CLK_i(1'b0),
		.PORT_A2_WEN_i(1'b0),
		.PORT_A2_WR_BE_i(2'b00),
		.PORT_A2_REN_i(1'b0),
		.PORT_A2_ADDR_i(14'h0),
		.PORT_A2_WR_DATA_i(18'h0),
		.PORT_A2_RD_DATA_o(),

		.PORT_B2_CLK_i(1'b0),
		.PORT_B2_WEN_i(1'b0),
		.PORT_B2_WR_BE_i(2'b00),
		.PORT_B2_REN_i(1'b0),
		.PORT_B2_ADDR_i(14'h0),
		.PORT_B2_WR_DATA_i(18'h0),
		.PORT_B2_RD_DATA_o()
);

endmodule


module DPRAM_18K_X2_BLK (
		PORT_A1_CLK_i,
		PORT_A1_WEN_i,
		PORT_A1_WR_BE_i,
		PORT_A1_REN_i,
		PORT_A1_ADDR_i,
		PORT_A1_WR_DATA_i,
		PORT_A1_RD_DATA_o,

		PORT_B1_CLK_i,
		PORT_B1_WEN_i,
		PORT_B1_WR_BE_i,
		PORT_B1_REN_i,
		PORT_B1_ADDR_i,
		PORT_B1_WR_DATA_i,
		PORT_B1_RD_DATA_o,

		PORT_A2_CLK_i,
		PORT_A2_WEN_i,
		PORT_A2_WR_BE_i,
		PORT_A2_REN_i,
		PORT_A2_ADDR_i,
		PORT_A2_WR_DATA_i,
		PORT_A2_RD_DATA_o,

		PORT_B2_CLK_i,
		PORT_B2_WEN_i,
		PORT_B2_WR_BE_i,
		PORT_B2_REN_i,
		PORT_B2_ADDR_i,
		PORT_B2_WR_DATA_i,
		PORT_B2_RD_DATA_o
);

parameter PORT_A1_AWIDTH = 10;
parameter PORT_A1_DWIDTH = 18;
parameter PORT_A1_WR_BE_WIDTH = 2;

parameter PORT_B1_AWIDTH = 10;
parameter PORT_B1_DWIDTH = 18;
parameter PORT_B1_WR_BE_WIDTH = 2;

parameter PORT_A2_AWIDTH = 10;
parameter PORT_A2_DWIDTH = 18;
parameter PORT_A2_WR_BE_WIDTH = 2;

parameter PORT_B2_AWIDTH = 10;
parameter PORT_B2_DWIDTH = 18;
parameter PORT_B2_WR_BE_WIDTH = 2;


input PORT_A1_CLK_i;
input [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;
input [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;
input PORT_A1_WEN_i;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;
input PORT_A1_REN_i;
output [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;

input PORT_B1_CLK_i;
input [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;
input [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;
input PORT_B1_WEN_i;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;
input PORT_B1_REN_i;
output [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;

input PORT_A2_CLK_i;
input [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;
input [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;
input PORT_A2_WEN_i;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;
input PORT_A2_REN_i;
output [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;

input PORT_B2_CLK_i;
input [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;
input [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;
input PORT_B2_WEN_i;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;
input PORT_B2_REN_i;
output [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] PORT_A1_WR_BE;
wire [1:0] PORT_B1_WR_BE;

wire [1:0] PORT_A2_WR_BE;
wire [1:0] PORT_B2_WR_BE;

wire [17:0] PORT_B1_WDATA;
wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;
wire [17:0] PORT_A1_RDATA;

wire [17:0] PORT_B2_WDATA;
wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;
wire [17:0] PORT_A2_RDATA;

wire [13:0] PORT_A1_ADDR_INT;
wire [13:0] PORT_B1_ADDR_INT;

wire [13:0] PORT_A2_ADDR_INT;
wire [13:0] PORT_B2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;

wire PORT_A1_CLK;
wire PORT_B1_CLK;

wire PORT_A2_CLK;
wire PORT_B2_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);

localparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);
localparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);
localparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);
localparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);

assign PORT_A1_CLK = PORT_A1_CLK_i;
assign PORT_B1_CLK = PORT_B1_CLK_i;

assign PORT_A2_CLK = PORT_A2_CLK_i;
assign PORT_B2_CLK = PORT_B2_CLK_i;

generate
	if (PORT_A1_AWIDTH == 14) begin
		assign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;
	end else begin
		assign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;
		assign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;
	end
endgenerate

case (PORT_A1_DWIDTH)
	1: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
endcase

generate
	if (PORT_B1_AWIDTH == 14) begin
		assign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;
	end else begin
		assign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;
		assign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;
	end
endgenerate

case (PORT_B1_DWIDTH)
	1: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
endcase

generate
	if (PORT_A2_AWIDTH == 14) begin
		assign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;
	end else begin
		assign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;
		assign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;
	end
endgenerate

case (PORT_A2_DWIDTH)
	1: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
endcase

generate
	if (PORT_B2_AWIDTH == 14) begin
		assign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;
	end else begin
		assign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;
		assign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;
	end
endgenerate

case (PORT_B2_DWIDTH)
	1: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
endcase

case (PORT_A1_WR_BE_WIDTH)
	2: begin
		assign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;
		assign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B1_WR_BE_WIDTH)
	2: begin
		assign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;
		assign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_A2_WR_BE_WIDTH)
	2: begin
		assign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;
		assign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B2_WR_BE_WIDTH)
	2: begin
		assign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;
		assign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A1_REN_i;
assign WEN_A1_i = PORT_A1_WEN_i;
assign BE_A1_i  = PORT_A1_WR_BE;

assign REN_A2_i = PORT_A2_REN_i;
assign WEN_A2_i = PORT_A2_WEN_i;
assign BE_A2_i  = PORT_A2_WR_BE;

assign REN_B1_i = PORT_B1_REN_i;
assign WEN_B1_i = PORT_B1_WEN_i;
assign BE_B1_i  = PORT_B1_WR_BE;

assign REN_B2_i = PORT_B2_REN_i;
assign WEN_B2_i = PORT_B2_WEN_i;
assign BE_B2_i  = PORT_B2_WR_BE;

generate
	if (PORT_A1_DWIDTH == 18) begin
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end else if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA;

generate
	if (PORT_A2_DWIDTH == 18) begin
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end else if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA;

generate
	if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A1_RDATA = RDATA_A1_o;
	end
endgenerate

assign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];

generate
	if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};
	end else begin
		assign PORT_A2_RDATA = RDATA_A2_o;
	end
endgenerate

assign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];

generate
	if (PORT_B1_DWIDTH == 18) begin
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end else if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B1_WDATA;

generate
	if (PORT_B2_DWIDTH == 18) begin
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end else if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B2_i = PORT_B2_WDATA;

generate
	if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];

generate
	if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 1 *)
(* is_fifo = 0 *)
(* port_a1_dwidth = PORT_A1_WRWIDTH *)
(* port_a2_dwidth = PORT_A2_WRWIDTH *)
(* port_b1_dwidth = PORT_B1_WRWIDTH *)
(* port_b2_dwidth = PORT_B2_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A1_CLK),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A2_CLK),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B1_CLK),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B2_CLK),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module SFIFO_36K_BLK (
		DIN,
		PUSH,
		POP,
		CLK,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 36;
	parameter RD_DATA_WIDTH = 36;
	parameter UPAE_DBITS = 12'd10;
	parameter UPAF_DBITS = 12'd10;

	input wire CLK;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS;
	localparam [11:0] UPAF1_i       = UPAF_DBITS;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd0;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = 11'd10;
	localparam [10:0] UPAF2_i       = 11'd10;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	32, 36: rwmode = 36;
	default: rwmode = 36;
	endcase
	endfunction

	wire [35:0] in_reg;
	wire [35:0] out_reg;
	wire [17:0] fifo_flags;

	wire [35:0] RD_DATA_INT;

	wire Push_Clk, Pop_Clk;

	assign Push_Clk = CLK;
	assign Pop_Clk = CLK;

	assign Overrun_Error = fifo_flags[0];
	assign Full_Watermark = fifo_flags[1];
	assign Almost_Full = fifo_flags[2];
	assign Full = fifo_flags[3];
	assign Underrun_Error = fifo_flags[4];
	assign Empty_Watermark = fifo_flags[5];
	assign Almost_Empty = fifo_flags[6];
	assign Empty = fifo_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

	localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
	localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

	generate
		if (WR_DATA_WIDTH == 36) begin
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
			assign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];
			assign in_reg[17:0] = {2'b00,DIN[15:0]};
		end else if (WR_DATA_WIDTH == 9) begin
			assign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};
		end else begin
			assign in_reg[35:WR_DATA_WIDTH]  = 0;
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD_DATA_WIDTH == 36) begin
			assign RD_DATA_INT = out_reg;
		end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
			assign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};
		end else if (RD_DATA_WIDTH == 9) begin
			assign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};
		end else begin
			assign RD_DATA_INT = {18'h0, out_reg[17:0]};
		end
	endgenerate

	assign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* port_a_dwidth = PORT_A_WRWIDTH *)
	(* port_b_dwidth = PORT_B_WRWIDTH *)
	 TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg[17:0]),
		.WDATA_A2_i(in_reg[35:18]),
		.RDATA_A1_o(fifo_flags),
		.RDATA_A2_o(),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk),
		.CLK_A2_i(1'b0),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b0),
		.WEN_A1_i(PUSH),
		.WEN_A2_i(1'b0),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg[17:0]),
		.RDATA_B2_o(out_reg[35:18]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk),
		.CLK_B2_i(1'b0),
		.REN_B1_i(POP),
		.REN_B2_i(1'b0),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush),
		.FLUSH2_i(1'b0)
	);



endmodule

module AFIFO_36K_BLK (
		DIN,
		PUSH,
		POP,
		Push_Clk,
		Pop_Clk,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 36;
	parameter RD_DATA_WIDTH = 36;
	parameter UPAE_DBITS = 12'd10;
	parameter UPAF_DBITS = 12'd10;

	input wire Push_Clk, Pop_Clk;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS;
	localparam [11:0] UPAF1_i       = UPAF_DBITS;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd0;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = 11'd10;
	localparam [10:0] UPAF2_i       = 11'd10;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	32, 36: rwmode = 36;
	default: rwmode = 36;
	endcase
	endfunction

	wire [35:0] in_reg;
	wire [35:0] out_reg;
	wire [17:0] fifo_flags;

	wire [35:0] RD_DATA_INT;
	wire [35:WR_DATA_WIDTH] WR_DATA_CMPL;

	assign Overrun_Error = fifo_flags[0];
	assign Full_Watermark = fifo_flags[1];
	assign Almost_Full = fifo_flags[2];
	assign Full = fifo_flags[3];
	assign Underrun_Error = fifo_flags[4];
	assign Empty_Watermark = fifo_flags[5];
	assign Almost_Empty = fifo_flags[6];
	assign Empty = fifo_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

	localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
	localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

	generate
		if (WR_DATA_WIDTH == 36) begin
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
			assign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];
			assign in_reg[17:0] = {2'b00,DIN[15:0]};
		end else if (WR_DATA_WIDTH == 9) begin
			assign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};
		end else begin
			assign in_reg[35:WR_DATA_WIDTH]  = 0;
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD_DATA_WIDTH == 36) begin
			assign RD_DATA_INT = out_reg;
		end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
			assign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};
		end else if (RD_DATA_WIDTH == 9) begin
			assign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};
		end else begin
			assign RD_DATA_INT = {18'h0, out_reg[17:0]};
		end
	endgenerate

	assign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* port_a_dwidth = PORT_A_WRWIDTH *)
	(* port_b_dwidth = PORT_B_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg[17:0]),
		.WDATA_A2_i(in_reg[35:18]),
		.RDATA_A1_o(fifo_flags),
		.RDATA_A2_o(),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk),
		.CLK_A2_i(1'b0),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b0),
		.WEN_A1_i(PUSH),
		.WEN_A2_i(1'b0),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg[17:0]),
		.RDATA_B2_o(out_reg[35:18]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk),
		.CLK_B2_i(1'b0),
		.REN_B1_i(POP),
		.REN_B2_i(1'b0),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush),
		.FLUSH2_i(1'b0)
	);



endmodule

module SFIFO_18K_BLK (
		DIN,
		PUSH,
		POP,
		CLK,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 18;
	parameter RD_DATA_WIDTH = 18;
	parameter UPAE_DBITS = 11'd10;
	parameter UPAF_DBITS = 11'd10;

	input wire CLK;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

 	BRAM2x18_SFIFO  #(
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.UPAE_DBITS1(UPAE_DBITS),
			.UPAF_DBITS1(UPAF_DBITS),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.UPAE_DBITS2(),
			.UPAF_DBITS2()
			 ) U1
			(
			.DIN1(DIN),
			.PUSH1(PUSH),
			.POP1(POP),
			.CLK1(CLK),
			.Async_Flush1(Async_Flush),
			.Overrun_Error1(Overrun_Error),
			.Full_Watermark1(Full_Watermark),
			.Almost_Full1(Almost_Full),
			.Full1(Full),
			.Underrun_Error1(Underrun_Error),
			.Empty_Watermark1(Empty_Watermark),
			.Almost_Empty1(Almost_Empty),
			.Empty1(Empty),
			.DOUT1(DOUT),

			.DIN2(18'h0),
			.PUSH2(1'b0),
			.POP2(1'b0),
			.CLK2(1'b0),
			.Async_Flush2(1'b0),
			.Overrun_Error2(),
			.Full_Watermark2(),
			.Almost_Full2(),
			.Full2(),
			.Underrun_Error2(),
			.Empty_Watermark2(),
			.Almost_Empty2(),
			.Empty2(),
			.DOUT2()
	);

endmodule

module SFIFO_18K_X2_BLK (
		DIN1,
		PUSH1,
		POP1,
		CLK1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		CLK2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input CLK1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input CLK2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd1;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;
	assign Push_Clk1 = CLK1;
	assign Pop_Clk1 = CLK1;
	assign Push_Clk2 = CLK2;
	assign Pop_Clk2 = CLK2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_split = 1 *)
	(* is_inferred = 0 *)
	(* port_a1_dwidth = PORT_A1_WRWIDTH *)
	(* port_a2_dwidth = PORT_A2_WRWIDTH *)
	(* port_b1_dwidth = PORT_B1_WRWIDTH *)
	(* port_b2_dwidth = PORT_B2_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule

module AFIFO_18K_BLK (
		DIN,
		PUSH,
		POP,
		Push_Clk,
		Pop_Clk,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 18;
	parameter RD_DATA_WIDTH = 18;
	parameter UPAE_DBITS = 11'd10;
	parameter UPAF_DBITS = 11'd10;

	input wire Push_Clk, Pop_Clk;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

 	BRAM2x18_AFIFO  #(
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.UPAE_DBITS1(UPAE_DBITS),
			.UPAF_DBITS1(UPAF_DBITS),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.UPAE_DBITS2(),
			.UPAF_DBITS2()
			 ) U1
			(
			.DIN1(DIN),
			.PUSH1(PUSH),
			.POP1(POP),
			.Push_Clk1(Push_Clk),
			.Pop_Clk1(Pop_Clk),
			.Async_Flush1(Async_Flush),
			.Overrun_Error1(Overrun_Error),
			.Full_Watermark1(Full_Watermark),
			.Almost_Full1(Almost_Full),
			.Full1(Full),
			.Underrun_Error1(Underrun_Error),
			.Empty_Watermark1(Empty_Watermark),
			.Almost_Empty1(Almost_Empty),
			.Empty1(Empty),
			.DOUT1(DOUT),

			.DIN2(18'h0),
			.PUSH2(1'b0),
			.POP2(1'b0),
			.Push_Clk2(1'b0),
			.Pop_Clk2(1'b0),
			.Async_Flush2(1'b0),
			.Overrun_Error2(),
			.Full_Watermark2(),
			.Almost_Full2(),
			.Full2(),
			.Underrun_Error2(),
			.Empty_Watermark2(),
			.Almost_Empty2(),
			.Empty2(),
			.DOUT2()
	);

endmodule

module AFIFO_18K_X2_BLK (
		DIN1,
		PUSH1,
		POP1,
		Push_Clk1,
	Pop_Clk1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		Push_Clk2,
	Pop_Clk2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input Push_Clk1, Pop_Clk1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input Push_Clk2, Pop_Clk2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_split = 1 *)
	(* is_inferred = 0 *)
	(* port_a1_dwidth = PORT_A1_WRWIDTH *)
	(* port_a2_dwidth = PORT_A2_WRWIDTH *)
	(* port_b1_dwidth = PORT_B1_WRWIDTH *)
	(* port_b2_dwidth = PORT_B2_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule

module BRAM2x18_SP (
		RESET_ni,

		WEN1_i,
		REN1_i,
		WR1_CLK_i,
		RD1_CLK_i,
		WR1_BE_i,
		WR1_ADDR_i,
		RD1_ADDR_i,
		WDATA1_i,
		RDATA1_o,

		WEN2_i,
		REN2_i,
		WR2_CLK_i,
		RD2_CLK_i,
		WR2_BE_i,
		WR2_ADDR_i,
		RD2_ADDR_i,
		WDATA2_i,
		RDATA2_o
);

parameter WR1_ADDR_WIDTH = 10;
parameter RD1_ADDR_WIDTH = 10;
parameter WR1_DATA_WIDTH = 18;
parameter RD1_DATA_WIDTH = 18;
parameter BE1_WIDTH = 2;

parameter WR2_ADDR_WIDTH = 10;
parameter RD2_ADDR_WIDTH = 10;
parameter WR2_DATA_WIDTH = 18;
parameter RD2_DATA_WIDTH = 18;
parameter BE2_WIDTH = 2;

input wire RESET_ni;

input wire WEN1_i;
input wire REN1_i;
input wire WR1_CLK_i;
input wire RD1_CLK_i;
input wire [BE1_WIDTH-1:0] WR1_BE_i;
input wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;
input wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;
input wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;
output wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;

input wire WEN2_i;
input wire REN2_i;
input wire WR2_CLK_i;
input wire RD2_CLK_i;
input wire [BE2_WIDTH-1:0] WR2_BE_i;
input wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;
input wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;
input wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;
output wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] WR1_BE;
wire [1:0] WR2_BE;

wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;

wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;

wire [13:0] WR1_ADDR_INT;
wire [13:0] RD1_ADDR_INT;

wire [13:0] WR2_ADDR_INT;
wire [13:0] RD2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

generate
	if (WR1_ADDR_WIDTH == 14) begin
		assign WR1_ADDR_INT = WR1_ADDR_i;
	end else begin
		assign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;
		assign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;
	end
endgenerate

case (WR1_DATA_WIDTH)
	1: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
endcase

generate
	if (RD1_ADDR_WIDTH == 14) begin
		assign RD1_ADDR_INT = RD1_ADDR_i;
	end else begin
		assign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;
		assign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;
	end
endgenerate

case (RD1_DATA_WIDTH)
	1: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
endcase

generate
	if (WR2_ADDR_WIDTH == 14) begin
		assign WR2_ADDR_INT = WR2_ADDR_i;
	end else begin
		assign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;
		assign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;
	end
endgenerate

case (WR2_DATA_WIDTH)
	1: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
endcase

generate
	if (RD2_ADDR_WIDTH == 14) begin
		assign RD2_ADDR_INT = RD2_ADDR_i;
	end else begin
		assign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;
		assign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;
	end
endgenerate

case (RD2_DATA_WIDTH)
	1: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
endcase

case (BE1_WIDTH)
	2: begin
		assign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];
	end
	default: begin
		assign WR1_BE[1:BE1_WIDTH] = 0;
		assign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];
	end
endcase

case (BE2_WIDTH)
	2: begin
		assign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];
	end
	default: begin
		assign WR2_BE[1:BE2_WIDTH] = 0;
		assign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN1_i;
assign BE_A1_i = WR1_BE;
assign REN_A2_i = 1'b0;
assign WEN_A2_i = WEN2_i;
assign BE_A2_i = WR2_BE;

assign REN_B1_i = REN1_i;
assign WEN_B1_i = 1'b0;
assign BE_B1_i = 4'h0;
assign REN_B2_i = REN2_i;
assign WEN_B2_i = 1'b0;
assign BE_B2_i = 4'h0;

generate
	if (WR1_DATA_WIDTH == 18) begin
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end else if (WR1_DATA_WIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA[17:0];
assign WDATA_B1_i = 18'h0;

generate
	if (RD1_DATA_WIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];

generate
	if (WR2_DATA_WIDTH == 18) begin
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end else if (WR2_DATA_WIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA[17:0];
assign WDATA_B2_i = 18'h0;

generate
	if (RD2_DATA_WIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A1_WRWIDTH *)
(* port_b_dwidth = PORT_B1_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(WR1_CLK_i),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(WR2_CLK_i),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(RD1_CLK_i),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(RD2_CLK_i),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module BRAM2x18_dP (
		PORT_A1_CLK_i,
		PORT_A1_WEN_i,
		PORT_A1_WR_BE_i,
		PORT_A1_REN_i,
		PORT_A1_ADDR_i,
		PORT_A1_WR_DATA_i,
		PORT_A1_RD_DATA_o,

		PORT_B1_CLK_i,
		PORT_B1_WEN_i,
		PORT_B1_WR_BE_i,
		PORT_B1_REN_i,
		PORT_B1_ADDR_i,
		PORT_B1_WR_DATA_i,
		PORT_B1_RD_DATA_o,

		PORT_A2_CLK_i,
		PORT_A2_WEN_i,
		PORT_A2_WR_BE_i,
		PORT_A2_REN_i,
		PORT_A2_ADDR_i,
		PORT_A2_WR_DATA_i,
		PORT_A2_RD_DATA_o,

		PORT_B2_CLK_i,
		PORT_B2_WEN_i,
		PORT_B2_WR_BE_i,
		PORT_B2_REN_i,
		PORT_B2_ADDR_i,
		PORT_B2_WR_DATA_i,
		PORT_B2_RD_DATA_o
);

parameter PORT_A1_AWIDTH = 10;
parameter PORT_A1_DWIDTH = 18;
parameter PORT_A1_WR_BE_WIDTH = 2;

parameter PORT_B1_AWIDTH = 10;
parameter PORT_B1_DWIDTH = 18;
parameter PORT_B1_WR_BE_WIDTH = 2;

parameter PORT_A2_AWIDTH = 10;
parameter PORT_A2_DWIDTH = 18;
parameter PORT_A2_WR_BE_WIDTH = 2;

parameter PORT_B2_AWIDTH = 10;
parameter PORT_B2_DWIDTH = 18;
parameter PORT_B2_WR_BE_WIDTH = 2;

input PORT_A1_CLK_i;
input [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;
input [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;
input PORT_A1_WEN_i;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;
input PORT_A1_REN_i;
output [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;

input PORT_B1_CLK_i;
input [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;
input [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;
input PORT_B1_WEN_i;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;
input PORT_B1_REN_i;
output [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;

input PORT_A2_CLK_i;
input [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;
input [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;
input PORT_A2_WEN_i;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;
input PORT_A2_REN_i;
output [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;

input PORT_B2_CLK_i;
input [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;
input [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;
input PORT_B2_WEN_i;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;
input PORT_B2_REN_i;
output [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] PORT_A1_WR_BE;
wire [1:0] PORT_B1_WR_BE;

wire [1:0] PORT_A2_WR_BE;
wire [1:0] PORT_B2_WR_BE;

wire [17:0] PORT_B1_WDATA;
wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;
wire [17:0] PORT_A1_RDATA;

wire [17:0] PORT_B2_WDATA;
wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;
wire [17:0] PORT_A2_RDATA;

wire [13:0] PORT_A1_ADDR_INT;
wire [13:0] PORT_B1_ADDR_INT;

wire [13:0] PORT_A2_ADDR_INT;
wire [13:0] PORT_B2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;

wire PORT_A1_CLK;
wire PORT_B1_CLK;

wire PORT_A2_CLK;
wire PORT_B2_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);

localparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);
localparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);
localparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);
localparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);

assign PORT_A1_CLK = PORT_A1_CLK_i;
assign PORT_B1_CLK = PORT_B1_CLK_i;

assign PORT_A2_CLK = PORT_A2_CLK_i;
assign PORT_B2_CLK = PORT_B2_CLK_i;

generate
	if (PORT_A1_AWIDTH == 14) begin
		assign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;
	end else begin
		assign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;
		assign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;
	end
endgenerate

case (PORT_A1_DWIDTH)
	1: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
endcase

generate
	if (PORT_B1_AWIDTH == 14) begin
		assign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;
	end else begin
		assign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;
		assign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;
	end
endgenerate

case (PORT_B1_DWIDTH)
	1: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
endcase

generate
	if (PORT_A2_AWIDTH == 14) begin
		assign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;
	end else begin
		assign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;
		assign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;
	end
endgenerate

case (PORT_A2_DWIDTH)
	1: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
endcase

generate
	if (PORT_B2_AWIDTH == 14) begin
		assign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;
	end else begin
		assign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;
		assign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;
	end
endgenerate

case (PORT_B2_DWIDTH)
	1: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
endcase

case (PORT_A1_WR_BE_WIDTH)
	2: begin
		assign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;
		assign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B1_WR_BE_WIDTH)
	2: begin
		assign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;
		assign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_A2_WR_BE_WIDTH)
	2: begin
		assign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;
		assign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B2_WR_BE_WIDTH)
	2: begin
		assign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;
		assign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A1_REN_i;
assign WEN_A1_i = PORT_A1_WEN_i;
assign BE_A1_i  = PORT_A1_WR_BE;

assign REN_A2_i = PORT_A2_REN_i;
assign WEN_A2_i = PORT_A2_WEN_i;
assign BE_A2_i  = PORT_A2_WR_BE;

assign REN_B1_i = PORT_B1_REN_i;
assign WEN_B1_i = PORT_B1_WEN_i;
assign BE_B1_i  = PORT_B1_WR_BE;

assign REN_B2_i = PORT_B2_REN_i;
assign WEN_B2_i = PORT_B2_WEN_i;
assign BE_B2_i  = PORT_B2_WR_BE;

generate
	if (PORT_A1_DWIDTH == 18) begin
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end else if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA;

generate
	if (PORT_A2_DWIDTH == 18) begin
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end else if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA;

generate
	if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A1_RDATA = RDATA_A1_o;
	end
endgenerate

assign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];

generate
	if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};
	end else begin
		assign PORT_A2_RDATA = RDATA_A2_o;
	end
endgenerate

assign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];

generate
	if (PORT_B1_DWIDTH == 18) begin
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end else if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B1_WDATA;

generate
	if (PORT_B2_DWIDTH == 18) begin
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end else if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B2_i = PORT_B2_WDATA;

generate
	if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];

generate
	if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A1_WRWIDTH *)
(* port_b_dwidth = PORT_B1_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A1_CLK),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A2_CLK),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B1_CLK),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B2_CLK),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule


module BRAM2x18_SFIFO (
		DIN1,
		PUSH1,
		POP1,
		CLK1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		CLK2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input CLK1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input CLK2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd1;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;
	assign Push_Clk1 = CLK1;
	assign Pop_Clk1 = CLK1;
	assign Push_Clk2 = CLK2;
	assign Pop_Clk2 = CLK2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_split = 0 *)
	(* is_inferred = 0 *)
	(* port_a_dwidth = PORT_A1_WRWIDTH *)
	(* port_b_dwidth = PORT_B1_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule


module BRAM2x18_AFIFO (
		DIN1,
		PUSH1,
		POP1,
		Push_Clk1,
	Pop_Clk1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		Push_Clk2,
	Pop_Clk2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input Push_Clk1, Pop_Clk1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input Push_Clk2, Pop_Clk2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_split = 0 *)
	(* is_inferred = 0 *)
	(* port_a_dwidth = PORT_A1_WRWIDTH *)
	(* port_b_dwidth = PORT_B1_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule`,"brams_sim.v":new URL("brams_sim-bdd23f4c.v?hash=bdd23f4c",import.meta.url),"cells_sim.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`timescale 1ps/1ps

\`default_nettype none
(* abc9_lut=1 *)
module LUT1(output wire O, input wire I0);
	parameter [1:0] INIT = 0;
	assign O = I0 ? INIT[1] : INIT[0];
	specify
		(I0 => O) = 74;
	endspecify
endmodule

(* abc9_lut=2 *)
module LUT2(output wire O, input wire I0, I1);
	parameter [3:0] INIT = 0;
	wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 116;
		(I1 => O) = 74;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT3(output wire O, input wire I0, I1, I2);
	parameter [7:0] INIT = 0;
	wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 162;
		(I1 => O) = 116;
		(I2 => O) = 174;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT4(output wire O, input wire I0, I1, I2, I3);
	parameter [15:0] INIT = 0;
	wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 201;
		(I1 => O) = 162;
		(I2 => O) = 116;
		(I3 => O) = 74;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT5(output wire O, input wire I0, I1, I2, I3, I4);
	parameter [31:0] INIT = 0;
	wire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];
	wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 228;
		(I1 => O) = 189;
		(I2 => O) = 143;
		(I3 => O) = 100;
		(I4 => O) = 55;
	endspecify
endmodule

(* abc9_lut=5 *)
module LUT6(output wire O, input wire I0, I1, I2, I3, I4, I5);
	parameter [63:0] INIT = 0;
	wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];
	wire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];
	wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 251;
		(I1 => O) = 212;
		(I2 => O) = 166;
		(I3 => O) = 123;
		(I4 => O) = 77;
		(I5 => O) = 43;
	endspecify
endmodule

(* abc9_flop, lib_whitebox *)
module sh_dff(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);

		initial Q = 1'b0;
		always @(posedge C)
				Q <= D;

		specify
			(posedge C => (Q +: D)) = 0;
			$setuphold(posedge C, D, 0, 0);
		endspecify

endmodule

(* abc9_box, lib_whitebox *)
(* keep *)
module adder_carry(
		output wire sumout,
		(* abc9_carry *)
		output wire cout,
		input wire p,
		input wire g,
		(* abc9_carry *)
		input wire cin
);
		assign sumout = p ^ cin;
		assign cout = p ? cin : g;

		specify
				(p => sumout) = 35;
				(g => sumout) = 35;
				(cin => sumout) = 40;
				(p => cout) = 67;
				(g => cout) = 65;
				(cin => cout) = 69;
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dff(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);
		initial Q = 1'b0;

		always @(posedge C)
			Q <= D;

		specify
			(posedge C=>(Q+:D)) = 285;
			$setuphold(posedge C, D, 56, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffn(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);
		initial Q = 1'b0;

		always @(negedge C)
			Q <= D;

		specify
			(negedge C=>(Q+:D)) = 285;
			$setuphold(negedge C, D, 56, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(posedge C or negedge S or negedge R)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
			(posedge C => (Q +: D)) = 280;
			(R => Q) = 0;
			(S => Q) = 0;
			$setuphold(posedge C, D, 56, 0);
			$setuphold(posedge C, E, 32, 0);
			$setuphold(posedge C, R, 0, 0);
			$setuphold(posedge C, S, 0, 0);
			$recrem(posedge R, posedge C, 0, 0);
			$recrem(posedge S, posedge C, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffnsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(negedge C or negedge S or negedge R)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
			(negedge C => (Q +: D)) = 280;
			(R => Q) = 0;
			(S => Q) = 0;
			$setuphold(negedge C, D, 56, 0);
			$setuphold(negedge C, E, 32, 0);
			$setuphold(negedge C, R, 0, 0);
			$setuphold(negedge C, S, 0, 0);
			$recrem(posedge R, negedge C, 0, 0);
			$recrem(posedge S, negedge C, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module sdffsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(posedge C)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
				(posedge C => (Q +: D)) = 280;
				$setuphold(posedge C, D, 56, 0);
				$setuphold(posedge C, R, 32, 0);
				$setuphold(posedge C, S, 0, 0);
				$setuphold(posedge C, E, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module sdffnsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(negedge C)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
				(negedge C => (Q +: D)) = 280;
				$setuphold(negedge C, D, 56, 0);
				$setuphold(negedge C, R, 32, 0);
				$setuphold(negedge C, S, 0, 0);
				$setuphold(negedge C, E, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module latchsre (
		output reg Q,
		input wire S,
		input wire R,
		input wire D,
		input wire G,
		input wire E
);
		initial Q = 1'b0;

		always @*
			begin
				if (!R)
					Q <= 1'b0;
				else if (!S)
					Q <= 1'b1;
				else if (E && G)
					Q <= D;
			end

		specify
			(posedge G => (Q +: D)) = 0;
			$setuphold(posedge G, D, 0, 0);
			$setuphold(posedge G, E, 0, 0);
			$setuphold(posedge G, R, 0, 0);
			$setuphold(posedge G, S, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module latchnsre (
		output reg Q,
		input wire S,
		input wire R,
		input wire D,
		input wire G,
		input wire E
);
		initial Q = 1'b0;

		always @*
			begin
				if (!R)
					Q <= 1'b0;
				else if (!S)
					Q <= 1'b1;
				else if (E && !G)
					Q <= D;
			end

		specify
			(negedge G => (Q +: D)) = 0;
			$setuphold(negedge G, D, 0, 0);
			$setuphold(negedge G, E, 0, 0);
			$setuphold(negedge G, R, 0, 0);
			$setuphold(negedge G, S, 0, 0);
		endspecify

endmodule

`,"dsp_final_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module dsp_t1_20x18x64_cfg_ports (
    input  [19:0] a_i,
    input  [17:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [37:0] z_o,
    output [17:0] dly_b_o,

    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,

    input  [2:0]  output_select_i,
    input         saturate_enable_i,
    input  [5:0]  shift_right_i,
    input         round_i,
    input         subtract_i,
    input         register_inputs_i
);

    parameter [19:0] COEFF_0 = 20'd0;
    parameter [19:0] COEFF_1 = 20'd0;
    parameter [19:0] COEFF_2 = 20'd0;
    parameter [19:0] COEFF_3 = 20'd0;

    QL_DSP2 # (
        .MODE_BITS          ({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
    ) _TECHMAP_REPLACE_ (
        .a                  (a_i),
        .b                  (b_i),
        .acc_fir            (acc_fir_i),
        .z                  (z_o),
        .dly_b              (dly_b_o),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),

        .f_mode             (1'b0), // No fracturation
        .output_select      (output_select_i),
        .saturate_enable    (saturate_enable_i),
        .shift_right        (shift_right_i),
        .round              (round_i),
        .subtract           (subtract_i),
        .register_inputs    (register_inputs_i)
    );

endmodule

module dsp_t1_10x9x32_cfg_ports (
    input  [ 9:0] a_i,
    input  [ 8:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [18:0] z_o,
    output [ 8:0] dly_b_o,

    (* clkbuf_sink *)
    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,

    input  [2:0]  output_select_i,
    input         saturate_enable_i,
    input  [5:0]  shift_right_i,
    input         round_i,
    input         subtract_i,
    input         register_inputs_i
);

    parameter [9:0] COEFF_0 = 10'd0;
    parameter [9:0] COEFF_1 = 10'd0;
    parameter [9:0] COEFF_2 = 10'd0;
    parameter [9:0] COEFF_3 = 10'd0;

    wire [37:0] z;
    wire [17:0] dly_b;

    QL_DSP2 # (
        .MODE_BITS          ({10'd0, COEFF_3,
                              10'd0, COEFF_2,
                              10'd0, COEFF_1,
                              10'd0, COEFF_0})
    ) _TECHMAP_REPLACE_ (
        .a                  ({10'd0, a_i}),
        .b                  ({ 9'd0, b_i}),
        .acc_fir            (acc_fir_i),
        .z                  (z),
        .dly_b              (dly_b),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),

        .f_mode             (1'b1), // Enable fractuation, Use the lower half
        .output_select      (output_select_i),
        .saturate_enable    (saturate_enable_i),
        .shift_right        (shift_right_i),
        .round              (round_i),
        .subtract           (subtract_i),
        .register_inputs    (register_inputs_i)
    );

    assign z_o = z[18:0];
    assign dly_b_o = dly_b_o[8:0];

endmodule

module dsp_t1_20x18x64_cfg_params (
    input  [19:0] a_i,
    input  [17:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [37:0] z_o,
    output [17:0] dly_b_o,

    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,
    input         subtract_i
);

    parameter [19:0] COEFF_0 = 20'd0;
    parameter [19:0] COEFF_1 = 20'd0;
    parameter [19:0] COEFF_2 = 20'd0;
    parameter [19:0] COEFF_3 = 20'd0;

    parameter [2:0] OUTPUT_SELECT   = 3'd0;
    parameter [0:0] SATURATE_ENABLE = 1'd0;
    parameter [5:0] SHIFT_RIGHT     = 6'd0;
    parameter [0:0] ROUND           = 1'd0;
    parameter [0:0] REGISTER_INPUTS = 1'd0;

    QL_DSP3 # (
        .MODE_BITS ({
            REGISTER_INPUTS,
            ROUND,
            SHIFT_RIGHT,
            SATURATE_ENABLE,
            OUTPUT_SELECT,
            1'b0, // Not fractured
            COEFF_3,
            COEFF_2,
            COEFF_1,
            COEFF_0
        })
    ) _TECHMAP_REPLACE_ (
        .a                  (a_i),
        .b                  (b_i),
        .acc_fir            (acc_fir_i),
        .z                  (z_o),
        .dly_b              (dly_b_o),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),
        .subtract           (subtract_i)
    );

endmodule

module dsp_t1_10x9x32_cfg_params (
    input  [ 9:0] a_i,
    input  [ 8:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [18:0] z_o,
    output [ 8:0] dly_b_o,

    (* clkbuf_sink *)
    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,
    input         subtract_i
);

    parameter [9:0] COEFF_0 = 10'd0;
    parameter [9:0] COEFF_1 = 10'd0;
    parameter [9:0] COEFF_2 = 10'd0;
    parameter [9:0] COEFF_3 = 10'd0;

    parameter [2:0] OUTPUT_SELECT   = 3'd0;
    parameter [0:0] SATURATE_ENABLE = 1'd0;
    parameter [5:0] SHIFT_RIGHT     = 6'd0;
    parameter [0:0] ROUND           = 1'd0;
    parameter [0:0] REGISTER_INPUTS = 1'd0;

    wire [37:0] z;
    wire [17:0] dly_b;

    QL_DSP3 # (
        .MODE_BITS  ({
            REGISTER_INPUTS,
            ROUND,
            SHIFT_RIGHT,
            SATURATE_ENABLE,
            OUTPUT_SELECT,
            1'b1, // Fractured
            10'd0, COEFF_3,
            10'd0, COEFF_2,
            10'd0, COEFF_1,
            10'd0, COEFF_0
        })
    ) _TECHMAP_REPLACE_ (
        .a                  ({10'd0, a_i}),
        .b                  ({ 9'd0, b_i}),
        .acc_fir            (acc_fir_i),
        .z                  (z),
        .dly_b              (dly_b),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),
        .subtract           (subtract_i)
    );

    assign z_o = z[18:0];
    assign dly_b_o = dly_b_o[8:0];

endmodule

`,"dsp_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module \\$__QL_MUL20X18 (input [19:0] A, input [17:0] B, output [37:0] Y);
    parameter A_SIGNED = 0;
    parameter B_SIGNED = 0;
    parameter A_WIDTH = 0;
    parameter B_WIDTH = 0;
    parameter Y_WIDTH = 0;

    wire [19:0] a;
    wire [17:0] b;
    wire [37:0] z;

    assign a = (A_WIDTH == 20) ? A :
               (A_SIGNED) ? {{(20 - A_WIDTH){A[A_WIDTH-1]}}, A} :
                            {{(20 - A_WIDTH){1'b0}},         A};

    assign b = (B_WIDTH == 18) ? B :
               (B_SIGNED) ? {{(18 - B_WIDTH){B[B_WIDTH-1]}}, B} :
                            {{(18 - B_WIDTH){1'b0}},         B};

    (* is_inferred=1 *)
    dsp_t1_20x18x64_cfg_ports _TECHMAP_REPLACE_ (
        .a_i                (a),
        .b_i                (b),
        .acc_fir_i          (6'd0),
        .z_o                (z),

        .feedback_i         (3'd0),
        .load_acc_i         (1'b0),
        .unsigned_a_i       (!A_SIGNED),
        .unsigned_b_i       (!B_SIGNED),

        .output_select_i    (3'd0),
        .saturate_enable_i  (1'b0),
        .shift_right_i      (6'd0),
        .round_i            (1'b0),
        .subtract_i         (1'b0),
        .register_inputs_i  (1'b0)
    );

    assign Y = z;

endmodule

module \\$__QL_MUL10X9 (input [9:0] A, input [8:0] B, output [18:0] Y);
    parameter A_SIGNED = 0;
    parameter B_SIGNED = 0;
    parameter A_WIDTH = 0;
    parameter B_WIDTH = 0;
    parameter Y_WIDTH = 0;

    wire [ 9:0] a;
    wire [ 8:0] b;
    wire [18:0] z;

    assign a = (A_WIDTH == 10) ? A :
               (A_SIGNED) ? {{(10 - A_WIDTH){A[A_WIDTH-1]}}, A} :
                            {{(10 - A_WIDTH){1'b0}},         A};

    assign b = (B_WIDTH ==  9) ? B :
               (B_SIGNED) ? {{( 9 - B_WIDTH){B[B_WIDTH-1]}}, B} :
                            {{( 9 - B_WIDTH){1'b0}},         B};

    (* is_inferred=1 *)
    dsp_t1_10x9x32_cfg_ports _TECHMAP_REPLACE_ (
        .a_i                (a),
        .b_i                (b),
        .acc_fir_i          (6'd0),
        .z_o                (z),

        .feedback_i         (3'd0),
        .load_acc_i         (1'b0),
        .unsigned_a_i       (!A_SIGNED),
        .unsigned_b_i       (!B_SIGNED),

        .output_select_i    (3'd0),
        .saturate_enable_i  (1'b0),
        .shift_right_i      (6'd0),
        .round_i            (1'b0),
        .subtract_i         (1'b0),
        .register_inputs_i  (1'b0)
    );


    assign Y = z;

endmodule
`,"dsp_sim.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`timescale 1ps/1ps

\`default_nettype none

(* blackbox *)
module QL_DSP1 (
	input wire [19:0] a,
	input wire [17:0] b,
	(* clkbuf_sink *)
	input wire clk0,
	(* clkbuf_sink *)
	input wire clk1,
	input wire [ 1:0] feedback0,
	input wire [ 1:0] feedback1,
	input wire        load_acc0,
	input wire        load_acc1,
	input wire        reset0,
	input wire        reset1,
	output reg [37:0] z
);
	parameter MODE_BITS = 27'b00000000000000000000000000;
endmodule  /* QL_DSP1 */



// ---------------------------------------- //
// ----- DSP cells simulation modules ----- //
// --------- Control bits in ports -------- //
// ---------------------------------------- //

module QL_DSP2 ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	input  wire [ 5:0] acc_fir,
	output wire [37:0] z,
	output wire [17:0] dly_b,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       load_acc,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       saturate_enable,
	input  wire [5:0] shift_right,
	input  wire       round,
	input  wire       subtract,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	localparam NBITS_ACC = 64;
	localparam NBITS_A = 20;
	localparam NBITS_B = 18;
	localparam NBITS_Z = 38;

	wire [NBITS_Z-1:0] dsp_full_z;
	wire [(NBITS_Z/2)-1:0] dsp_frac0_z;
	wire [(NBITS_Z/2)-1:0] dsp_frac1_z;

	wire [NBITS_B-1:0] dsp_full_dly_b;
	wire [(NBITS_B/2)-1:0] dsp_frac0_dly_b;
	wire [(NBITS_B/2)-1:0] dsp_frac1_dly_b;

	assign z = f_mode ? {dsp_frac1_z, dsp_frac0_z} : dsp_full_z;
	assign dly_b = f_mode ? {dsp_frac1_dly_b, dsp_frac0_dly_b} : dsp_full_dly_b;

	// Output used when fmode == 1
		dsp_t1_sim_cfg_ports #(
		.NBITS_A(NBITS_A/2),
			.NBITS_B(NBITS_B/2),
			.NBITS_ACC(NBITS_ACC/2),
			.NBITS_Z(NBITS_Z/2)
		) dsp_frac0 (
			.a_i(a[(NBITS_A/2)-1:0]),
			.b_i(b[(NBITS_B/2)-1:0]),
			.z_o(dsp_frac0_z),
			.dly_b_o(dsp_frac0_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0[(NBITS_A/2)-1:0]),
			.coef_1_i(COEFF_1[(NBITS_A/2)-1:0]),
			.coef_2_i(COEFF_2[(NBITS_A/2)-1:0]),
			.coef_3_i(COEFF_3[(NBITS_A/2)-1:0])
		);

	// Output used when fmode == 1
		dsp_t1_sim_cfg_ports #(
		.NBITS_A(NBITS_A/2),
			.NBITS_B(NBITS_B/2),
			.NBITS_ACC(NBITS_ACC/2),
			.NBITS_Z(NBITS_Z/2)
		) dsp_frac1 (
			.a_i(a[NBITS_A-1:NBITS_A/2]),
			.b_i(b[NBITS_B-1:NBITS_B/2]),
			.z_o(dsp_frac1_z),
			.dly_b_o(dsp_frac1_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0[NBITS_A-1:NBITS_A/2]),
			.coef_1_i(COEFF_1[NBITS_A-1:NBITS_A/2]),
			.coef_2_i(COEFF_2[NBITS_A-1:NBITS_A/2]),
			.coef_3_i(COEFF_3[NBITS_A-1:NBITS_A/2])
		);

	// Output used when fmode == 0
		dsp_t1_sim_cfg_ports #(
			.NBITS_A(NBITS_A),
			.NBITS_B(NBITS_B),
			.NBITS_ACC(NBITS_ACC),
			.NBITS_Z(NBITS_Z)
		) dsp_full (
			.a_i(a),
			.b_i(b),
			.z_o(dsp_full_z),
			.dly_b_o(dsp_full_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0),
			.coef_1_i(COEFF_1),
			.coef_2_i(COEFF_2),
			.coef_3_i(COEFF_3)
		);
endmodule

module QL_DSP2_MULT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.clk(1'b0),
		.reset(reset),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.output_select(output_select),      // unregistered output: a * b (0)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(a[0] => z[0]) = 0;
		(a[1] => z[0]) = 0;
		(a[2] => z[0]) = 0;
		(a[3] => z[0]) = 0;
		(a[4] => z[0]) = 0;
		(a[5] => z[0]) = 0;
		(a[6] => z[0]) = 0;
		(a[7] => z[0]) = 0;
		(a[8] => z[0]) = 0;
		(a[9] => z[0]) = 0;
		(a[10] => z[0]) = 0;
		(a[11] => z[0]) = 0;
		(a[12] => z[0]) = 0;
		(a[13] => z[0]) = 0;
		(a[14] => z[0]) = 0;
		(a[15] => z[0]) = 0;
		(a[16] => z[0]) = 0;
		(a[17] => z[0]) = 0;
		(a[18] => z[0]) = 0;
		(a[19] => z[0]) = 0;
		(b[0] => z[0]) = 0;
		(b[1] => z[0]) = 0;
		(b[2] => z[0]) = 0;
		(b[3] => z[0]) = 0;
		(b[4] => z[0]) = 0;
		(b[5] => z[0]) = 0;
		(b[6] => z[0]) = 0;
		(b[7] => z[0]) = 0;
		(b[8] => z[0]) = 0;
		(b[9] => z[0]) = 0;
		(b[10] => z[0]) = 0;
		(b[11] => z[0]) = 0;
		(b[12] => z[0]) = 0;
		(b[13] => z[0]) = 0;
		(b[14] => z[0]) = 0;
		(b[15] => z[0]) = 0;
		(b[16] => z[0]) = 0;
		(b[17] => z[0]) = 0;
		(a[0] => z[1]) = 0;
		(a[1] => z[1]) = 0;
		(a[2] => z[1]) = 0;
		(a[3] => z[1]) = 0;
		(a[4] => z[1]) = 0;
		(a[5] => z[1]) = 0;
		(a[6] => z[1]) = 0;
		(a[7] => z[1]) = 0;
		(a[8] => z[1]) = 0;
		(a[9] => z[1]) = 0;
		(a[10] => z[1]) = 0;
		(a[11] => z[1]) = 0;
		(a[12] => z[1]) = 0;
		(a[13] => z[1]) = 0;
		(a[14] => z[1]) = 0;
		(a[15] => z[1]) = 0;
		(a[16] => z[1]) = 0;
		(a[17] => z[1]) = 0;
		(a[18] => z[1]) = 0;
		(a[19] => z[1]) = 0;
		(b[0] => z[1]) = 0;
		(b[1] => z[1]) = 0;
		(b[2] => z[1]) = 0;
		(b[3] => z[1]) = 0;
		(b[4] => z[1]) = 0;
		(b[5] => z[1]) = 0;
		(b[6] => z[1]) = 0;
		(b[7] => z[1]) = 0;
		(b[8] => z[1]) = 0;
		(b[9] => z[1]) = 0;
		(b[10] => z[1]) = 0;
		(b[11] => z[1]) = 0;
		(b[12] => z[1]) = 0;
		(b[13] => z[1]) = 0;
		(b[14] => z[1]) = 0;
		(b[15] => z[1]) = 0;
		(b[16] => z[1]) = 0;
		(b[17] => z[1]) = 0;
		(a[0] => z[2]) = 0;
		(a[1] => z[2]) = 0;
		(a[2] => z[2]) = 0;
		(a[3] => z[2]) = 0;
		(a[4] => z[2]) = 0;
		(a[5] => z[2]) = 0;
		(a[6] => z[2]) = 0;
		(a[7] => z[2]) = 0;
		(a[8] => z[2]) = 0;
		(a[9] => z[2]) = 0;
		(a[10] => z[2]) = 0;
		(a[11] => z[2]) = 0;
		(a[12] => z[2]) = 0;
		(a[13] => z[2]) = 0;
		(a[14] => z[2]) = 0;
		(a[15] => z[2]) = 0;
		(a[16] => z[2]) = 0;
		(a[17] => z[2]) = 0;
		(a[18] => z[2]) = 0;
		(a[19] => z[2]) = 0;
		(b[0] => z[2]) = 0;
		(b[1] => z[2]) = 0;
		(b[2] => z[2]) = 0;
		(b[3] => z[2]) = 0;
		(b[4] => z[2]) = 0;
		(b[5] => z[2]) = 0;
		(b[6] => z[2]) = 0;
		(b[7] => z[2]) = 0;
		(b[8] => z[2]) = 0;
		(b[9] => z[2]) = 0;
		(b[10] => z[2]) = 0;
		(b[11] => z[2]) = 0;
		(b[12] => z[2]) = 0;
		(b[13] => z[2]) = 0;
		(b[14] => z[2]) = 0;
		(b[15] => z[2]) = 0;
		(b[16] => z[2]) = 0;
		(b[17] => z[2]) = 0;
		(a[0] => z[3]) = 0;
		(a[1] => z[3]) = 0;
		(a[2] => z[3]) = 0;
		(a[3] => z[3]) = 0;
		(a[4] => z[3]) = 0;
		(a[5] => z[3]) = 0;
		(a[6] => z[3]) = 0;
		(a[7] => z[3]) = 0;
		(a[8] => z[3]) = 0;
		(a[9] => z[3]) = 0;
		(a[10] => z[3]) = 0;
		(a[11] => z[3]) = 0;
		(a[12] => z[3]) = 0;
		(a[13] => z[3]) = 0;
		(a[14] => z[3]) = 0;
		(a[15] => z[3]) = 0;
		(a[16] => z[3]) = 0;
		(a[17] => z[3]) = 0;
		(a[18] => z[3]) = 0;
		(a[19] => z[3]) = 0;
		(b[0] => z[3]) = 0;
		(b[1] => z[3]) = 0;
		(b[2] => z[3]) = 0;
		(b[3] => z[3]) = 0;
		(b[4] => z[3]) = 0;
		(b[5] => z[3]) = 0;
		(b[6] => z[3]) = 0;
		(b[7] => z[3]) = 0;
		(b[8] => z[3]) = 0;
		(b[9] => z[3]) = 0;
		(b[10] => z[3]) = 0;
		(b[11] => z[3]) = 0;
		(b[12] => z[3]) = 0;
		(b[13] => z[3]) = 0;
		(b[14] => z[3]) = 0;
		(b[15] => z[3]) = 0;
		(b[16] => z[3]) = 0;
		(b[17] => z[3]) = 0;
		(a[0] => z[4]) = 0;
		(a[1] => z[4]) = 0;
		(a[2] => z[4]) = 0;
		(a[3] => z[4]) = 0;
		(a[4] => z[4]) = 0;
		(a[5] => z[4]) = 0;
		(a[6] => z[4]) = 0;
		(a[7] => z[4]) = 0;
		(a[8] => z[4]) = 0;
		(a[9] => z[4]) = 0;
		(a[10] => z[4]) = 0;
		(a[11] => z[4]) = 0;
		(a[12] => z[4]) = 0;
		(a[13] => z[4]) = 0;
		(a[14] => z[4]) = 0;
		(a[15] => z[4]) = 0;
		(a[16] => z[4]) = 0;
		(a[17] => z[4]) = 0;
		(a[18] => z[4]) = 0;
		(a[19] => z[4]) = 0;
		(b[0] => z[4]) = 0;
		(b[1] => z[4]) = 0;
		(b[2] => z[4]) = 0;
		(b[3] => z[4]) = 0;
		(b[4] => z[4]) = 0;
		(b[5] => z[4]) = 0;
		(b[6] => z[4]) = 0;
		(b[7] => z[4]) = 0;
		(b[8] => z[4]) = 0;
		(b[9] => z[4]) = 0;
		(b[10] => z[4]) = 0;
		(b[11] => z[4]) = 0;
		(b[12] => z[4]) = 0;
		(b[13] => z[4]) = 0;
		(b[14] => z[4]) = 0;
		(b[15] => z[4]) = 0;
		(b[16] => z[4]) = 0;
		(b[17] => z[4]) = 0;
		(a[0] => z[5]) = 0;
		(a[1] => z[5]) = 0;
		(a[2] => z[5]) = 0;
		(a[3] => z[5]) = 0;
		(a[4] => z[5]) = 0;
		(a[5] => z[5]) = 0;
		(a[6] => z[5]) = 0;
		(a[7] => z[5]) = 0;
		(a[8] => z[5]) = 0;
		(a[9] => z[5]) = 0;
		(a[10] => z[5]) = 0;
		(a[11] => z[5]) = 0;
		(a[12] => z[5]) = 0;
		(a[13] => z[5]) = 0;
		(a[14] => z[5]) = 0;
		(a[15] => z[5]) = 0;
		(a[16] => z[5]) = 0;
		(a[17] => z[5]) = 0;
		(a[18] => z[5]) = 0;
		(a[19] => z[5]) = 0;
		(b[0] => z[5]) = 0;
		(b[1] => z[5]) = 0;
		(b[2] => z[5]) = 0;
		(b[3] => z[5]) = 0;
		(b[4] => z[5]) = 0;
		(b[5] => z[5]) = 0;
		(b[6] => z[5]) = 0;
		(b[7] => z[5]) = 0;
		(b[8] => z[5]) = 0;
		(b[9] => z[5]) = 0;
		(b[10] => z[5]) = 0;
		(b[11] => z[5]) = 0;
		(b[12] => z[5]) = 0;
		(b[13] => z[5]) = 0;
		(b[14] => z[5]) = 0;
		(b[15] => z[5]) = 0;
		(b[16] => z[5]) = 0;
		(b[17] => z[5]) = 0;
		(a[0] => z[6]) = 0;
		(a[1] => z[6]) = 0;
		(a[2] => z[6]) = 0;
		(a[3] => z[6]) = 0;
		(a[4] => z[6]) = 0;
		(a[5] => z[6]) = 0;
		(a[6] => z[6]) = 0;
		(a[7] => z[6]) = 0;
		(a[8] => z[6]) = 0;
		(a[9] => z[6]) = 0;
		(a[10] => z[6]) = 0;
		(a[11] => z[6]) = 0;
		(a[12] => z[6]) = 0;
		(a[13] => z[6]) = 0;
		(a[14] => z[6]) = 0;
		(a[15] => z[6]) = 0;
		(a[16] => z[6]) = 0;
		(a[17] => z[6]) = 0;
		(a[18] => z[6]) = 0;
		(a[19] => z[6]) = 0;
		(b[0] => z[6]) = 0;
		(b[1] => z[6]) = 0;
		(b[2] => z[6]) = 0;
		(b[3] => z[6]) = 0;
		(b[4] => z[6]) = 0;
		(b[5] => z[6]) = 0;
		(b[6] => z[6]) = 0;
		(b[7] => z[6]) = 0;
		(b[8] => z[6]) = 0;
		(b[9] => z[6]) = 0;
		(b[10] => z[6]) = 0;
		(b[11] => z[6]) = 0;
		(b[12] => z[6]) = 0;
		(b[13] => z[6]) = 0;
		(b[14] => z[6]) = 0;
		(b[15] => z[6]) = 0;
		(b[16] => z[6]) = 0;
		(b[17] => z[6]) = 0;
		(a[0] => z[7]) = 0;
		(a[1] => z[7]) = 0;
		(a[2] => z[7]) = 0;
		(a[3] => z[7]) = 0;
		(a[4] => z[7]) = 0;
		(a[5] => z[7]) = 0;
		(a[6] => z[7]) = 0;
		(a[7] => z[7]) = 0;
		(a[8] => z[7]) = 0;
		(a[9] => z[7]) = 0;
		(a[10] => z[7]) = 0;
		(a[11] => z[7]) = 0;
		(a[12] => z[7]) = 0;
		(a[13] => z[7]) = 0;
		(a[14] => z[7]) = 0;
		(a[15] => z[7]) = 0;
		(a[16] => z[7]) = 0;
		(a[17] => z[7]) = 0;
		(a[18] => z[7]) = 0;
		(a[19] => z[7]) = 0;
		(b[0] => z[7]) = 0;
		(b[1] => z[7]) = 0;
		(b[2] => z[7]) = 0;
		(b[3] => z[7]) = 0;
		(b[4] => z[7]) = 0;
		(b[5] => z[7]) = 0;
		(b[6] => z[7]) = 0;
		(b[7] => z[7]) = 0;
		(b[8] => z[7]) = 0;
		(b[9] => z[7]) = 0;
		(b[10] => z[7]) = 0;
		(b[11] => z[7]) = 0;
		(b[12] => z[7]) = 0;
		(b[13] => z[7]) = 0;
		(b[14] => z[7]) = 0;
		(b[15] => z[7]) = 0;
		(b[16] => z[7]) = 0;
		(b[17] => z[7]) = 0;
		(a[0] => z[8]) = 0;
		(a[1] => z[8]) = 0;
		(a[2] => z[8]) = 0;
		(a[3] => z[8]) = 0;
		(a[4] => z[8]) = 0;
		(a[5] => z[8]) = 0;
		(a[6] => z[8]) = 0;
		(a[7] => z[8]) = 0;
		(a[8] => z[8]) = 0;
		(a[9] => z[8]) = 0;
		(a[10] => z[8]) = 0;
		(a[11] => z[8]) = 0;
		(a[12] => z[8]) = 0;
		(a[13] => z[8]) = 0;
		(a[14] => z[8]) = 0;
		(a[15] => z[8]) = 0;
		(a[16] => z[8]) = 0;
		(a[17] => z[8]) = 0;
		(a[18] => z[8]) = 0;
		(a[19] => z[8]) = 0;
		(b[0] => z[8]) = 0;
		(b[1] => z[8]) = 0;
		(b[2] => z[8]) = 0;
		(b[3] => z[8]) = 0;
		(b[4] => z[8]) = 0;
		(b[5] => z[8]) = 0;
		(b[6] => z[8]) = 0;
		(b[7] => z[8]) = 0;
		(b[8] => z[8]) = 0;
		(b[9] => z[8]) = 0;
		(b[10] => z[8]) = 0;
		(b[11] => z[8]) = 0;
		(b[12] => z[8]) = 0;
		(b[13] => z[8]) = 0;
		(b[14] => z[8]) = 0;
		(b[15] => z[8]) = 0;
		(b[16] => z[8]) = 0;
		(b[17] => z[8]) = 0;
		(a[0] => z[9]) = 0;
		(a[1] => z[9]) = 0;
		(a[2] => z[9]) = 0;
		(a[3] => z[9]) = 0;
		(a[4] => z[9]) = 0;
		(a[5] => z[9]) = 0;
		(a[6] => z[9]) = 0;
		(a[7] => z[9]) = 0;
		(a[8] => z[9]) = 0;
		(a[9] => z[9]) = 0;
		(a[10] => z[9]) = 0;
		(a[11] => z[9]) = 0;
		(a[12] => z[9]) = 0;
		(a[13] => z[9]) = 0;
		(a[14] => z[9]) = 0;
		(a[15] => z[9]) = 0;
		(a[16] => z[9]) = 0;
		(a[17] => z[9]) = 0;
		(a[18] => z[9]) = 0;
		(a[19] => z[9]) = 0;
		(b[0] => z[9]) = 0;
		(b[1] => z[9]) = 0;
		(b[2] => z[9]) = 0;
		(b[3] => z[9]) = 0;
		(b[4] => z[9]) = 0;
		(b[5] => z[9]) = 0;
		(b[6] => z[9]) = 0;
		(b[7] => z[9]) = 0;
		(b[8] => z[9]) = 0;
		(b[9] => z[9]) = 0;
		(b[10] => z[9]) = 0;
		(b[11] => z[9]) = 0;
		(b[12] => z[9]) = 0;
		(b[13] => z[9]) = 0;
		(b[14] => z[9]) = 0;
		(b[15] => z[9]) = 0;
		(b[16] => z[9]) = 0;
		(b[17] => z[9]) = 0;
		(a[0] => z[10]) = 0;
		(a[1] => z[10]) = 0;
		(a[2] => z[10]) = 0;
		(a[3] => z[10]) = 0;
		(a[4] => z[10]) = 0;
		(a[5] => z[10]) = 0;
		(a[6] => z[10]) = 0;
		(a[7] => z[10]) = 0;
		(a[8] => z[10]) = 0;
		(a[9] => z[10]) = 0;
		(a[10] => z[10]) = 0;
		(a[11] => z[10]) = 0;
		(a[12] => z[10]) = 0;
		(a[13] => z[10]) = 0;
		(a[14] => z[10]) = 0;
		(a[15] => z[10]) = 0;
		(a[16] => z[10]) = 0;
		(a[17] => z[10]) = 0;
		(a[18] => z[10]) = 0;
		(a[19] => z[10]) = 0;
		(b[0] => z[10]) = 0;
		(b[1] => z[10]) = 0;
		(b[2] => z[10]) = 0;
		(b[3] => z[10]) = 0;
		(b[4] => z[10]) = 0;
		(b[5] => z[10]) = 0;
		(b[6] => z[10]) = 0;
		(b[7] => z[10]) = 0;
		(b[8] => z[10]) = 0;
		(b[9] => z[10]) = 0;
		(b[10] => z[10]) = 0;
		(b[11] => z[10]) = 0;
		(b[12] => z[10]) = 0;
		(b[13] => z[10]) = 0;
		(b[14] => z[10]) = 0;
		(b[15] => z[10]) = 0;
		(b[16] => z[10]) = 0;
		(b[17] => z[10]) = 0;
		(a[0] => z[11]) = 0;
		(a[1] => z[11]) = 0;
		(a[2] => z[11]) = 0;
		(a[3] => z[11]) = 0;
		(a[4] => z[11]) = 0;
		(a[5] => z[11]) = 0;
		(a[6] => z[11]) = 0;
		(a[7] => z[11]) = 0;
		(a[8] => z[11]) = 0;
		(a[9] => z[11]) = 0;
		(a[10] => z[11]) = 0;
		(a[11] => z[11]) = 0;
		(a[12] => z[11]) = 0;
		(a[13] => z[11]) = 0;
		(a[14] => z[11]) = 0;
		(a[15] => z[11]) = 0;
		(a[16] => z[11]) = 0;
		(a[17] => z[11]) = 0;
		(a[18] => z[11]) = 0;
		(a[19] => z[11]) = 0;
		(b[0] => z[11]) = 0;
		(b[1] => z[11]) = 0;
		(b[2] => z[11]) = 0;
		(b[3] => z[11]) = 0;
		(b[4] => z[11]) = 0;
		(b[5] => z[11]) = 0;
		(b[6] => z[11]) = 0;
		(b[7] => z[11]) = 0;
		(b[8] => z[11]) = 0;
		(b[9] => z[11]) = 0;
		(b[10] => z[11]) = 0;
		(b[11] => z[11]) = 0;
		(b[12] => z[11]) = 0;
		(b[13] => z[11]) = 0;
		(b[14] => z[11]) = 0;
		(b[15] => z[11]) = 0;
		(b[16] => z[11]) = 0;
		(b[17] => z[11]) = 0;
		(a[0] => z[12]) = 0;
		(a[1] => z[12]) = 0;
		(a[2] => z[12]) = 0;
		(a[3] => z[12]) = 0;
		(a[4] => z[12]) = 0;
		(a[5] => z[12]) = 0;
		(a[6] => z[12]) = 0;
		(a[7] => z[12]) = 0;
		(a[8] => z[12]) = 0;
		(a[9] => z[12]) = 0;
		(a[10] => z[12]) = 0;
		(a[11] => z[12]) = 0;
		(a[12] => z[12]) = 0;
		(a[13] => z[12]) = 0;
		(a[14] => z[12]) = 0;
		(a[15] => z[12]) = 0;
		(a[16] => z[12]) = 0;
		(a[17] => z[12]) = 0;
		(a[18] => z[12]) = 0;
		(a[19] => z[12]) = 0;
		(b[0] => z[12]) = 0;
		(b[1] => z[12]) = 0;
		(b[2] => z[12]) = 0;
		(b[3] => z[12]) = 0;
		(b[4] => z[12]) = 0;
		(b[5] => z[12]) = 0;
		(b[6] => z[12]) = 0;
		(b[7] => z[12]) = 0;
		(b[8] => z[12]) = 0;
		(b[9] => z[12]) = 0;
		(b[10] => z[12]) = 0;
		(b[11] => z[12]) = 0;
		(b[12] => z[12]) = 0;
		(b[13] => z[12]) = 0;
		(b[14] => z[12]) = 0;
		(b[15] => z[12]) = 0;
		(b[16] => z[12]) = 0;
		(b[17] => z[12]) = 0;
		(a[0] => z[13]) = 0;
		(a[1] => z[13]) = 0;
		(a[2] => z[13]) = 0;
		(a[3] => z[13]) = 0;
		(a[4] => z[13]) = 0;
		(a[5] => z[13]) = 0;
		(a[6] => z[13]) = 0;
		(a[7] => z[13]) = 0;
		(a[8] => z[13]) = 0;
		(a[9] => z[13]) = 0;
		(a[10] => z[13]) = 0;
		(a[11] => z[13]) = 0;
		(a[12] => z[13]) = 0;
		(a[13] => z[13]) = 0;
		(a[14] => z[13]) = 0;
		(a[15] => z[13]) = 0;
		(a[16] => z[13]) = 0;
		(a[17] => z[13]) = 0;
		(a[18] => z[13]) = 0;
		(a[19] => z[13]) = 0;
		(b[0] => z[13]) = 0;
		(b[1] => z[13]) = 0;
		(b[2] => z[13]) = 0;
		(b[3] => z[13]) = 0;
		(b[4] => z[13]) = 0;
		(b[5] => z[13]) = 0;
		(b[6] => z[13]) = 0;
		(b[7] => z[13]) = 0;
		(b[8] => z[13]) = 0;
		(b[9] => z[13]) = 0;
		(b[10] => z[13]) = 0;
		(b[11] => z[13]) = 0;
		(b[12] => z[13]) = 0;
		(b[13] => z[13]) = 0;
		(b[14] => z[13]) = 0;
		(b[15] => z[13]) = 0;
		(b[16] => z[13]) = 0;
		(b[17] => z[13]) = 0;
		(a[0] => z[14]) = 0;
		(a[1] => z[14]) = 0;
		(a[2] => z[14]) = 0;
		(a[3] => z[14]) = 0;
		(a[4] => z[14]) = 0;
		(a[5] => z[14]) = 0;
		(a[6] => z[14]) = 0;
		(a[7] => z[14]) = 0;
		(a[8] => z[14]) = 0;
		(a[9] => z[14]) = 0;
		(a[10] => z[14]) = 0;
		(a[11] => z[14]) = 0;
		(a[12] => z[14]) = 0;
		(a[13] => z[14]) = 0;
		(a[14] => z[14]) = 0;
		(a[15] => z[14]) = 0;
		(a[16] => z[14]) = 0;
		(a[17] => z[14]) = 0;
		(a[18] => z[14]) = 0;
		(a[19] => z[14]) = 0;
		(b[0] => z[14]) = 0;
		(b[1] => z[14]) = 0;
		(b[2] => z[14]) = 0;
		(b[3] => z[14]) = 0;
		(b[4] => z[14]) = 0;
		(b[5] => z[14]) = 0;
		(b[6] => z[14]) = 0;
		(b[7] => z[14]) = 0;
		(b[8] => z[14]) = 0;
		(b[9] => z[14]) = 0;
		(b[10] => z[14]) = 0;
		(b[11] => z[14]) = 0;
		(b[12] => z[14]) = 0;
		(b[13] => z[14]) = 0;
		(b[14] => z[14]) = 0;
		(b[15] => z[14]) = 0;
		(b[16] => z[14]) = 0;
		(b[17] => z[14]) = 0;
		(a[0] => z[15]) = 0;
		(a[1] => z[15]) = 0;
		(a[2] => z[15]) = 0;
		(a[3] => z[15]) = 0;
		(a[4] => z[15]) = 0;
		(a[5] => z[15]) = 0;
		(a[6] => z[15]) = 0;
		(a[7] => z[15]) = 0;
		(a[8] => z[15]) = 0;
		(a[9] => z[15]) = 0;
		(a[10] => z[15]) = 0;
		(a[11] => z[15]) = 0;
		(a[12] => z[15]) = 0;
		(a[13] => z[15]) = 0;
		(a[14] => z[15]) = 0;
		(a[15] => z[15]) = 0;
		(a[16] => z[15]) = 0;
		(a[17] => z[15]) = 0;
		(a[18] => z[15]) = 0;
		(a[19] => z[15]) = 0;
		(b[0] => z[15]) = 0;
		(b[1] => z[15]) = 0;
		(b[2] => z[15]) = 0;
		(b[3] => z[15]) = 0;
		(b[4] => z[15]) = 0;
		(b[5] => z[15]) = 0;
		(b[6] => z[15]) = 0;
		(b[7] => z[15]) = 0;
		(b[8] => z[15]) = 0;
		(b[9] => z[15]) = 0;
		(b[10] => z[15]) = 0;
		(b[11] => z[15]) = 0;
		(b[12] => z[15]) = 0;
		(b[13] => z[15]) = 0;
		(b[14] => z[15]) = 0;
		(b[15] => z[15]) = 0;
		(b[16] => z[15]) = 0;
		(b[17] => z[15]) = 0;
		(a[0] => z[16]) = 0;
		(a[1] => z[16]) = 0;
		(a[2] => z[16]) = 0;
		(a[3] => z[16]) = 0;
		(a[4] => z[16]) = 0;
		(a[5] => z[16]) = 0;
		(a[6] => z[16]) = 0;
		(a[7] => z[16]) = 0;
		(a[8] => z[16]) = 0;
		(a[9] => z[16]) = 0;
		(a[10] => z[16]) = 0;
		(a[11] => z[16]) = 0;
		(a[12] => z[16]) = 0;
		(a[13] => z[16]) = 0;
		(a[14] => z[16]) = 0;
		(a[15] => z[16]) = 0;
		(a[16] => z[16]) = 0;
		(a[17] => z[16]) = 0;
		(a[18] => z[16]) = 0;
		(a[19] => z[16]) = 0;
		(b[0] => z[16]) = 0;
		(b[1] => z[16]) = 0;
		(b[2] => z[16]) = 0;
		(b[3] => z[16]) = 0;
		(b[4] => z[16]) = 0;
		(b[5] => z[16]) = 0;
		(b[6] => z[16]) = 0;
		(b[7] => z[16]) = 0;
		(b[8] => z[16]) = 0;
		(b[9] => z[16]) = 0;
		(b[10] => z[16]) = 0;
		(b[11] => z[16]) = 0;
		(b[12] => z[16]) = 0;
		(b[13] => z[16]) = 0;
		(b[14] => z[16]) = 0;
		(b[15] => z[16]) = 0;
		(b[16] => z[16]) = 0;
		(b[17] => z[16]) = 0;
		(a[0] => z[17]) = 0;
		(a[1] => z[17]) = 0;
		(a[2] => z[17]) = 0;
		(a[3] => z[17]) = 0;
		(a[4] => z[17]) = 0;
		(a[5] => z[17]) = 0;
		(a[6] => z[17]) = 0;
		(a[7] => z[17]) = 0;
		(a[8] => z[17]) = 0;
		(a[9] => z[17]) = 0;
		(a[10] => z[17]) = 0;
		(a[11] => z[17]) = 0;
		(a[12] => z[17]) = 0;
		(a[13] => z[17]) = 0;
		(a[14] => z[17]) = 0;
		(a[15] => z[17]) = 0;
		(a[16] => z[17]) = 0;
		(a[17] => z[17]) = 0;
		(a[18] => z[17]) = 0;
		(a[19] => z[17]) = 0;
		(b[0] => z[17]) = 0;
		(b[1] => z[17]) = 0;
		(b[2] => z[17]) = 0;
		(b[3] => z[17]) = 0;
		(b[4] => z[17]) = 0;
		(b[5] => z[17]) = 0;
		(b[6] => z[17]) = 0;
		(b[7] => z[17]) = 0;
		(b[8] => z[17]) = 0;
		(b[9] => z[17]) = 0;
		(b[10] => z[17]) = 0;
		(b[11] => z[17]) = 0;
		(b[12] => z[17]) = 0;
		(b[13] => z[17]) = 0;
		(b[14] => z[17]) = 0;
		(b[15] => z[17]) = 0;
		(b[16] => z[17]) = 0;
		(b[17] => z[17]) = 0;
		(a[0] => z[18]) = 0;
		(a[1] => z[18]) = 0;
		(a[2] => z[18]) = 0;
		(a[3] => z[18]) = 0;
		(a[4] => z[18]) = 0;
		(a[5] => z[18]) = 0;
		(a[6] => z[18]) = 0;
		(a[7] => z[18]) = 0;
		(a[8] => z[18]) = 0;
		(a[9] => z[18]) = 0;
		(a[10] => z[18]) = 0;
		(a[11] => z[18]) = 0;
		(a[12] => z[18]) = 0;
		(a[13] => z[18]) = 0;
		(a[14] => z[18]) = 0;
		(a[15] => z[18]) = 0;
		(a[16] => z[18]) = 0;
		(a[17] => z[18]) = 0;
		(a[18] => z[18]) = 0;
		(a[19] => z[18]) = 0;
		(b[0] => z[18]) = 0;
		(b[1] => z[18]) = 0;
		(b[2] => z[18]) = 0;
		(b[3] => z[18]) = 0;
		(b[4] => z[18]) = 0;
		(b[5] => z[18]) = 0;
		(b[6] => z[18]) = 0;
		(b[7] => z[18]) = 0;
		(b[8] => z[18]) = 0;
		(b[9] => z[18]) = 0;
		(b[10] => z[18]) = 0;
		(b[11] => z[18]) = 0;
		(b[12] => z[18]) = 0;
		(b[13] => z[18]) = 0;
		(b[14] => z[18]) = 0;
		(b[15] => z[18]) = 0;
		(b[16] => z[18]) = 0;
		(b[17] => z[18]) = 0;
		(a[0] => z[19]) = 0;
		(a[1] => z[19]) = 0;
		(a[2] => z[19]) = 0;
		(a[3] => z[19]) = 0;
		(a[4] => z[19]) = 0;
		(a[5] => z[19]) = 0;
		(a[6] => z[19]) = 0;
		(a[7] => z[19]) = 0;
		(a[8] => z[19]) = 0;
		(a[9] => z[19]) = 0;
		(a[10] => z[19]) = 0;
		(a[11] => z[19]) = 0;
		(a[12] => z[19]) = 0;
		(a[13] => z[19]) = 0;
		(a[14] => z[19]) = 0;
		(a[15] => z[19]) = 0;
		(a[16] => z[19]) = 0;
		(a[17] => z[19]) = 0;
		(a[18] => z[19]) = 0;
		(a[19] => z[19]) = 0;
		(b[0] => z[19]) = 0;
		(b[1] => z[19]) = 0;
		(b[2] => z[19]) = 0;
		(b[3] => z[19]) = 0;
		(b[4] => z[19]) = 0;
		(b[5] => z[19]) = 0;
		(b[6] => z[19]) = 0;
		(b[7] => z[19]) = 0;
		(b[8] => z[19]) = 0;
		(b[9] => z[19]) = 0;
		(b[10] => z[19]) = 0;
		(b[11] => z[19]) = 0;
		(b[12] => z[19]) = 0;
		(b[13] => z[19]) = 0;
		(b[14] => z[19]) = 0;
		(b[15] => z[19]) = 0;
		(b[16] => z[19]) = 0;
		(b[17] => z[19]) = 0;
		(a[0] => z[20]) = 0;
		(a[1] => z[20]) = 0;
		(a[2] => z[20]) = 0;
		(a[3] => z[20]) = 0;
		(a[4] => z[20]) = 0;
		(a[5] => z[20]) = 0;
		(a[6] => z[20]) = 0;
		(a[7] => z[20]) = 0;
		(a[8] => z[20]) = 0;
		(a[9] => z[20]) = 0;
		(a[10] => z[20]) = 0;
		(a[11] => z[20]) = 0;
		(a[12] => z[20]) = 0;
		(a[13] => z[20]) = 0;
		(a[14] => z[20]) = 0;
		(a[15] => z[20]) = 0;
		(a[16] => z[20]) = 0;
		(a[17] => z[20]) = 0;
		(a[18] => z[20]) = 0;
		(a[19] => z[20]) = 0;
		(b[0] => z[20]) = 0;
		(b[1] => z[20]) = 0;
		(b[2] => z[20]) = 0;
		(b[3] => z[20]) = 0;
		(b[4] => z[20]) = 0;
		(b[5] => z[20]) = 0;
		(b[6] => z[20]) = 0;
		(b[7] => z[20]) = 0;
		(b[8] => z[20]) = 0;
		(b[9] => z[20]) = 0;
		(b[10] => z[20]) = 0;
		(b[11] => z[20]) = 0;
		(b[12] => z[20]) = 0;
		(b[13] => z[20]) = 0;
		(b[14] => z[20]) = 0;
		(b[15] => z[20]) = 0;
		(b[16] => z[20]) = 0;
		(b[17] => z[20]) = 0;
		(a[0] => z[21]) = 0;
		(a[1] => z[21]) = 0;
		(a[2] => z[21]) = 0;
		(a[3] => z[21]) = 0;
		(a[4] => z[21]) = 0;
		(a[5] => z[21]) = 0;
		(a[6] => z[21]) = 0;
		(a[7] => z[21]) = 0;
		(a[8] => z[21]) = 0;
		(a[9] => z[21]) = 0;
		(a[10] => z[21]) = 0;
		(a[11] => z[21]) = 0;
		(a[12] => z[21]) = 0;
		(a[13] => z[21]) = 0;
		(a[14] => z[21]) = 0;
		(a[15] => z[21]) = 0;
		(a[16] => z[21]) = 0;
		(a[17] => z[21]) = 0;
		(a[18] => z[21]) = 0;
		(a[19] => z[21]) = 0;
		(b[0] => z[21]) = 0;
		(b[1] => z[21]) = 0;
		(b[2] => z[21]) = 0;
		(b[3] => z[21]) = 0;
		(b[4] => z[21]) = 0;
		(b[5] => z[21]) = 0;
		(b[6] => z[21]) = 0;
		(b[7] => z[21]) = 0;
		(b[8] => z[21]) = 0;
		(b[9] => z[21]) = 0;
		(b[10] => z[21]) = 0;
		(b[11] => z[21]) = 0;
		(b[12] => z[21]) = 0;
		(b[13] => z[21]) = 0;
		(b[14] => z[21]) = 0;
		(b[15] => z[21]) = 0;
		(b[16] => z[21]) = 0;
		(b[17] => z[21]) = 0;
		(a[0] => z[22]) = 0;
		(a[1] => z[22]) = 0;
		(a[2] => z[22]) = 0;
		(a[3] => z[22]) = 0;
		(a[4] => z[22]) = 0;
		(a[5] => z[22]) = 0;
		(a[6] => z[22]) = 0;
		(a[7] => z[22]) = 0;
		(a[8] => z[22]) = 0;
		(a[9] => z[22]) = 0;
		(a[10] => z[22]) = 0;
		(a[11] => z[22]) = 0;
		(a[12] => z[22]) = 0;
		(a[13] => z[22]) = 0;
		(a[14] => z[22]) = 0;
		(a[15] => z[22]) = 0;
		(a[16] => z[22]) = 0;
		(a[17] => z[22]) = 0;
		(a[18] => z[22]) = 0;
		(a[19] => z[22]) = 0;
		(b[0] => z[22]) = 0;
		(b[1] => z[22]) = 0;
		(b[2] => z[22]) = 0;
		(b[3] => z[22]) = 0;
		(b[4] => z[22]) = 0;
		(b[5] => z[22]) = 0;
		(b[6] => z[22]) = 0;
		(b[7] => z[22]) = 0;
		(b[8] => z[22]) = 0;
		(b[9] => z[22]) = 0;
		(b[10] => z[22]) = 0;
		(b[11] => z[22]) = 0;
		(b[12] => z[22]) = 0;
		(b[13] => z[22]) = 0;
		(b[14] => z[22]) = 0;
		(b[15] => z[22]) = 0;
		(b[16] => z[22]) = 0;
		(b[17] => z[22]) = 0;
		(a[0] => z[23]) = 0;
		(a[1] => z[23]) = 0;
		(a[2] => z[23]) = 0;
		(a[3] => z[23]) = 0;
		(a[4] => z[23]) = 0;
		(a[5] => z[23]) = 0;
		(a[6] => z[23]) = 0;
		(a[7] => z[23]) = 0;
		(a[8] => z[23]) = 0;
		(a[9] => z[23]) = 0;
		(a[10] => z[23]) = 0;
		(a[11] => z[23]) = 0;
		(a[12] => z[23]) = 0;
		(a[13] => z[23]) = 0;
		(a[14] => z[23]) = 0;
		(a[15] => z[23]) = 0;
		(a[16] => z[23]) = 0;
		(a[17] => z[23]) = 0;
		(a[18] => z[23]) = 0;
		(a[19] => z[23]) = 0;
		(b[0] => z[23]) = 0;
		(b[1] => z[23]) = 0;
		(b[2] => z[23]) = 0;
		(b[3] => z[23]) = 0;
		(b[4] => z[23]) = 0;
		(b[5] => z[23]) = 0;
		(b[6] => z[23]) = 0;
		(b[7] => z[23]) = 0;
		(b[8] => z[23]) = 0;
		(b[9] => z[23]) = 0;
		(b[10] => z[23]) = 0;
		(b[11] => z[23]) = 0;
		(b[12] => z[23]) = 0;
		(b[13] => z[23]) = 0;
		(b[14] => z[23]) = 0;
		(b[15] => z[23]) = 0;
		(b[16] => z[23]) = 0;
		(b[17] => z[23]) = 0;
		(a[0] => z[24]) = 0;
		(a[1] => z[24]) = 0;
		(a[2] => z[24]) = 0;
		(a[3] => z[24]) = 0;
		(a[4] => z[24]) = 0;
		(a[5] => z[24]) = 0;
		(a[6] => z[24]) = 0;
		(a[7] => z[24]) = 0;
		(a[8] => z[24]) = 0;
		(a[9] => z[24]) = 0;
		(a[10] => z[24]) = 0;
		(a[11] => z[24]) = 0;
		(a[12] => z[24]) = 0;
		(a[13] => z[24]) = 0;
		(a[14] => z[24]) = 0;
		(a[15] => z[24]) = 0;
		(a[16] => z[24]) = 0;
		(a[17] => z[24]) = 0;
		(a[18] => z[24]) = 0;
		(a[19] => z[24]) = 0;
		(b[0] => z[24]) = 0;
		(b[1] => z[24]) = 0;
		(b[2] => z[24]) = 0;
		(b[3] => z[24]) = 0;
		(b[4] => z[24]) = 0;
		(b[5] => z[24]) = 0;
		(b[6] => z[24]) = 0;
		(b[7] => z[24]) = 0;
		(b[8] => z[24]) = 0;
		(b[9] => z[24]) = 0;
		(b[10] => z[24]) = 0;
		(b[11] => z[24]) = 0;
		(b[12] => z[24]) = 0;
		(b[13] => z[24]) = 0;
		(b[14] => z[24]) = 0;
		(b[15] => z[24]) = 0;
		(b[16] => z[24]) = 0;
		(b[17] => z[24]) = 0;
		(a[0] => z[25]) = 0;
		(a[1] => z[25]) = 0;
		(a[2] => z[25]) = 0;
		(a[3] => z[25]) = 0;
		(a[4] => z[25]) = 0;
		(a[5] => z[25]) = 0;
		(a[6] => z[25]) = 0;
		(a[7] => z[25]) = 0;
		(a[8] => z[25]) = 0;
		(a[9] => z[25]) = 0;
		(a[10] => z[25]) = 0;
		(a[11] => z[25]) = 0;
		(a[12] => z[25]) = 0;
		(a[13] => z[25]) = 0;
		(a[14] => z[25]) = 0;
		(a[15] => z[25]) = 0;
		(a[16] => z[25]) = 0;
		(a[17] => z[25]) = 0;
		(a[18] => z[25]) = 0;
		(a[19] => z[25]) = 0;
		(b[0] => z[25]) = 0;
		(b[1] => z[25]) = 0;
		(b[2] => z[25]) = 0;
		(b[3] => z[25]) = 0;
		(b[4] => z[25]) = 0;
		(b[5] => z[25]) = 0;
		(b[6] => z[25]) = 0;
		(b[7] => z[25]) = 0;
		(b[8] => z[25]) = 0;
		(b[9] => z[25]) = 0;
		(b[10] => z[25]) = 0;
		(b[11] => z[25]) = 0;
		(b[12] => z[25]) = 0;
		(b[13] => z[25]) = 0;
		(b[14] => z[25]) = 0;
		(b[15] => z[25]) = 0;
		(b[16] => z[25]) = 0;
		(b[17] => z[25]) = 0;
		(a[0] => z[26]) = 0;
		(a[1] => z[26]) = 0;
		(a[2] => z[26]) = 0;
		(a[3] => z[26]) = 0;
		(a[4] => z[26]) = 0;
		(a[5] => z[26]) = 0;
		(a[6] => z[26]) = 0;
		(a[7] => z[26]) = 0;
		(a[8] => z[26]) = 0;
		(a[9] => z[26]) = 0;
		(a[10] => z[26]) = 0;
		(a[11] => z[26]) = 0;
		(a[12] => z[26]) = 0;
		(a[13] => z[26]) = 0;
		(a[14] => z[26]) = 0;
		(a[15] => z[26]) = 0;
		(a[16] => z[26]) = 0;
		(a[17] => z[26]) = 0;
		(a[18] => z[26]) = 0;
		(a[19] => z[26]) = 0;
		(b[0] => z[26]) = 0;
		(b[1] => z[26]) = 0;
		(b[2] => z[26]) = 0;
		(b[3] => z[26]) = 0;
		(b[4] => z[26]) = 0;
		(b[5] => z[26]) = 0;
		(b[6] => z[26]) = 0;
		(b[7] => z[26]) = 0;
		(b[8] => z[26]) = 0;
		(b[9] => z[26]) = 0;
		(b[10] => z[26]) = 0;
		(b[11] => z[26]) = 0;
		(b[12] => z[26]) = 0;
		(b[13] => z[26]) = 0;
		(b[14] => z[26]) = 0;
		(b[15] => z[26]) = 0;
		(b[16] => z[26]) = 0;
		(b[17] => z[26]) = 0;
		(a[0] => z[27]) = 0;
		(a[1] => z[27]) = 0;
		(a[2] => z[27]) = 0;
		(a[3] => z[27]) = 0;
		(a[4] => z[27]) = 0;
		(a[5] => z[27]) = 0;
		(a[6] => z[27]) = 0;
		(a[7] => z[27]) = 0;
		(a[8] => z[27]) = 0;
		(a[9] => z[27]) = 0;
		(a[10] => z[27]) = 0;
		(a[11] => z[27]) = 0;
		(a[12] => z[27]) = 0;
		(a[13] => z[27]) = 0;
		(a[14] => z[27]) = 0;
		(a[15] => z[27]) = 0;
		(a[16] => z[27]) = 0;
		(a[17] => z[27]) = 0;
		(a[18] => z[27]) = 0;
		(a[19] => z[27]) = 0;
		(b[0] => z[27]) = 0;
		(b[1] => z[27]) = 0;
		(b[2] => z[27]) = 0;
		(b[3] => z[27]) = 0;
		(b[4] => z[27]) = 0;
		(b[5] => z[27]) = 0;
		(b[6] => z[27]) = 0;
		(b[7] => z[27]) = 0;
		(b[8] => z[27]) = 0;
		(b[9] => z[27]) = 0;
		(b[10] => z[27]) = 0;
		(b[11] => z[27]) = 0;
		(b[12] => z[27]) = 0;
		(b[13] => z[27]) = 0;
		(b[14] => z[27]) = 0;
		(b[15] => z[27]) = 0;
		(b[16] => z[27]) = 0;
		(b[17] => z[27]) = 0;
		(a[0] => z[28]) = 0;
		(a[1] => z[28]) = 0;
		(a[2] => z[28]) = 0;
		(a[3] => z[28]) = 0;
		(a[4] => z[28]) = 0;
		(a[5] => z[28]) = 0;
		(a[6] => z[28]) = 0;
		(a[7] => z[28]) = 0;
		(a[8] => z[28]) = 0;
		(a[9] => z[28]) = 0;
		(a[10] => z[28]) = 0;
		(a[11] => z[28]) = 0;
		(a[12] => z[28]) = 0;
		(a[13] => z[28]) = 0;
		(a[14] => z[28]) = 0;
		(a[15] => z[28]) = 0;
		(a[16] => z[28]) = 0;
		(a[17] => z[28]) = 0;
		(a[18] => z[28]) = 0;
		(a[19] => z[28]) = 0;
		(b[0] => z[28]) = 0;
		(b[1] => z[28]) = 0;
		(b[2] => z[28]) = 0;
		(b[3] => z[28]) = 0;
		(b[4] => z[28]) = 0;
		(b[5] => z[28]) = 0;
		(b[6] => z[28]) = 0;
		(b[7] => z[28]) = 0;
		(b[8] => z[28]) = 0;
		(b[9] => z[28]) = 0;
		(b[10] => z[28]) = 0;
		(b[11] => z[28]) = 0;
		(b[12] => z[28]) = 0;
		(b[13] => z[28]) = 0;
		(b[14] => z[28]) = 0;
		(b[15] => z[28]) = 0;
		(b[16] => z[28]) = 0;
		(b[17] => z[28]) = 0;
		(a[0] => z[29]) = 0;
		(a[1] => z[29]) = 0;
		(a[2] => z[29]) = 0;
		(a[3] => z[29]) = 0;
		(a[4] => z[29]) = 0;
		(a[5] => z[29]) = 0;
		(a[6] => z[29]) = 0;
		(a[7] => z[29]) = 0;
		(a[8] => z[29]) = 0;
		(a[9] => z[29]) = 0;
		(a[10] => z[29]) = 0;
		(a[11] => z[29]) = 0;
		(a[12] => z[29]) = 0;
		(a[13] => z[29]) = 0;
		(a[14] => z[29]) = 0;
		(a[15] => z[29]) = 0;
		(a[16] => z[29]) = 0;
		(a[17] => z[29]) = 0;
		(a[18] => z[29]) = 0;
		(a[19] => z[29]) = 0;
		(b[0] => z[29]) = 0;
		(b[1] => z[29]) = 0;
		(b[2] => z[29]) = 0;
		(b[3] => z[29]) = 0;
		(b[4] => z[29]) = 0;
		(b[5] => z[29]) = 0;
		(b[6] => z[29]) = 0;
		(b[7] => z[29]) = 0;
		(b[8] => z[29]) = 0;
		(b[9] => z[29]) = 0;
		(b[10] => z[29]) = 0;
		(b[11] => z[29]) = 0;
		(b[12] => z[29]) = 0;
		(b[13] => z[29]) = 0;
		(b[14] => z[29]) = 0;
		(b[15] => z[29]) = 0;
		(b[16] => z[29]) = 0;
		(b[17] => z[29]) = 0;
		(a[0] => z[30]) = 0;
		(a[1] => z[30]) = 0;
		(a[2] => z[30]) = 0;
		(a[3] => z[30]) = 0;
		(a[4] => z[30]) = 0;
		(a[5] => z[30]) = 0;
		(a[6] => z[30]) = 0;
		(a[7] => z[30]) = 0;
		(a[8] => z[30]) = 0;
		(a[9] => z[30]) = 0;
		(a[10] => z[30]) = 0;
		(a[11] => z[30]) = 0;
		(a[12] => z[30]) = 0;
		(a[13] => z[30]) = 0;
		(a[14] => z[30]) = 0;
		(a[15] => z[30]) = 0;
		(a[16] => z[30]) = 0;
		(a[17] => z[30]) = 0;
		(a[18] => z[30]) = 0;
		(a[19] => z[30]) = 0;
		(b[0] => z[30]) = 0;
		(b[1] => z[30]) = 0;
		(b[2] => z[30]) = 0;
		(b[3] => z[30]) = 0;
		(b[4] => z[30]) = 0;
		(b[5] => z[30]) = 0;
		(b[6] => z[30]) = 0;
		(b[7] => z[30]) = 0;
		(b[8] => z[30]) = 0;
		(b[9] => z[30]) = 0;
		(b[10] => z[30]) = 0;
		(b[11] => z[30]) = 0;
		(b[12] => z[30]) = 0;
		(b[13] => z[30]) = 0;
		(b[14] => z[30]) = 0;
		(b[15] => z[30]) = 0;
		(b[16] => z[30]) = 0;
		(b[17] => z[30]) = 0;
		(a[0] => z[31]) = 0;
		(a[1] => z[31]) = 0;
		(a[2] => z[31]) = 0;
		(a[3] => z[31]) = 0;
		(a[4] => z[31]) = 0;
		(a[5] => z[31]) = 0;
		(a[6] => z[31]) = 0;
		(a[7] => z[31]) = 0;
		(a[8] => z[31]) = 0;
		(a[9] => z[31]) = 0;
		(a[10] => z[31]) = 0;
		(a[11] => z[31]) = 0;
		(a[12] => z[31]) = 0;
		(a[13] => z[31]) = 0;
		(a[14] => z[31]) = 0;
		(a[15] => z[31]) = 0;
		(a[16] => z[31]) = 0;
		(a[17] => z[31]) = 0;
		(a[18] => z[31]) = 0;
		(a[19] => z[31]) = 0;
		(b[0] => z[31]) = 0;
		(b[1] => z[31]) = 0;
		(b[2] => z[31]) = 0;
		(b[3] => z[31]) = 0;
		(b[4] => z[31]) = 0;
		(b[5] => z[31]) = 0;
		(b[6] => z[31]) = 0;
		(b[7] => z[31]) = 0;
		(b[8] => z[31]) = 0;
		(b[9] => z[31]) = 0;
		(b[10] => z[31]) = 0;
		(b[11] => z[31]) = 0;
		(b[12] => z[31]) = 0;
		(b[13] => z[31]) = 0;
		(b[14] => z[31]) = 0;
		(b[15] => z[31]) = 0;
		(b[16] => z[31]) = 0;
		(b[17] => z[31]) = 0;
		(a[0] => z[32]) = 0;
		(a[1] => z[32]) = 0;
		(a[2] => z[32]) = 0;
		(a[3] => z[32]) = 0;
		(a[4] => z[32]) = 0;
		(a[5] => z[32]) = 0;
		(a[6] => z[32]) = 0;
		(a[7] => z[32]) = 0;
		(a[8] => z[32]) = 0;
		(a[9] => z[32]) = 0;
		(a[10] => z[32]) = 0;
		(a[11] => z[32]) = 0;
		(a[12] => z[32]) = 0;
		(a[13] => z[32]) = 0;
		(a[14] => z[32]) = 0;
		(a[15] => z[32]) = 0;
		(a[16] => z[32]) = 0;
		(a[17] => z[32]) = 0;
		(a[18] => z[32]) = 0;
		(a[19] => z[32]) = 0;
		(b[0] => z[32]) = 0;
		(b[1] => z[32]) = 0;
		(b[2] => z[32]) = 0;
		(b[3] => z[32]) = 0;
		(b[4] => z[32]) = 0;
		(b[5] => z[32]) = 0;
		(b[6] => z[32]) = 0;
		(b[7] => z[32]) = 0;
		(b[8] => z[32]) = 0;
		(b[9] => z[32]) = 0;
		(b[10] => z[32]) = 0;
		(b[11] => z[32]) = 0;
		(b[12] => z[32]) = 0;
		(b[13] => z[32]) = 0;
		(b[14] => z[32]) = 0;
		(b[15] => z[32]) = 0;
		(b[16] => z[32]) = 0;
		(b[17] => z[32]) = 0;
		(a[0] => z[33]) = 0;
		(a[1] => z[33]) = 0;
		(a[2] => z[33]) = 0;
		(a[3] => z[33]) = 0;
		(a[4] => z[33]) = 0;
		(a[5] => z[33]) = 0;
		(a[6] => z[33]) = 0;
		(a[7] => z[33]) = 0;
		(a[8] => z[33]) = 0;
		(a[9] => z[33]) = 0;
		(a[10] => z[33]) = 0;
		(a[11] => z[33]) = 0;
		(a[12] => z[33]) = 0;
		(a[13] => z[33]) = 0;
		(a[14] => z[33]) = 0;
		(a[15] => z[33]) = 0;
		(a[16] => z[33]) = 0;
		(a[17] => z[33]) = 0;
		(a[18] => z[33]) = 0;
		(a[19] => z[33]) = 0;
		(b[0] => z[33]) = 0;
		(b[1] => z[33]) = 0;
		(b[2] => z[33]) = 0;
		(b[3] => z[33]) = 0;
		(b[4] => z[33]) = 0;
		(b[5] => z[33]) = 0;
		(b[6] => z[33]) = 0;
		(b[7] => z[33]) = 0;
		(b[8] => z[33]) = 0;
		(b[9] => z[33]) = 0;
		(b[10] => z[33]) = 0;
		(b[11] => z[33]) = 0;
		(b[12] => z[33]) = 0;
		(b[13] => z[33]) = 0;
		(b[14] => z[33]) = 0;
		(b[15] => z[33]) = 0;
		(b[16] => z[33]) = 0;
		(b[17] => z[33]) = 0;
		(a[0] => z[34]) = 0;
		(a[1] => z[34]) = 0;
		(a[2] => z[34]) = 0;
		(a[3] => z[34]) = 0;
		(a[4] => z[34]) = 0;
		(a[5] => z[34]) = 0;
		(a[6] => z[34]) = 0;
		(a[7] => z[34]) = 0;
		(a[8] => z[34]) = 0;
		(a[9] => z[34]) = 0;
		(a[10] => z[34]) = 0;
		(a[11] => z[34]) = 0;
		(a[12] => z[34]) = 0;
		(a[13] => z[34]) = 0;
		(a[14] => z[34]) = 0;
		(a[15] => z[34]) = 0;
		(a[16] => z[34]) = 0;
		(a[17] => z[34]) = 0;
		(a[18] => z[34]) = 0;
		(a[19] => z[34]) = 0;
		(b[0] => z[34]) = 0;
		(b[1] => z[34]) = 0;
		(b[2] => z[34]) = 0;
		(b[3] => z[34]) = 0;
		(b[4] => z[34]) = 0;
		(b[5] => z[34]) = 0;
		(b[6] => z[34]) = 0;
		(b[7] => z[34]) = 0;
		(b[8] => z[34]) = 0;
		(b[9] => z[34]) = 0;
		(b[10] => z[34]) = 0;
		(b[11] => z[34]) = 0;
		(b[12] => z[34]) = 0;
		(b[13] => z[34]) = 0;
		(b[14] => z[34]) = 0;
		(b[15] => z[34]) = 0;
		(b[16] => z[34]) = 0;
		(b[17] => z[34]) = 0;
		(a[0] => z[35]) = 0;
		(a[1] => z[35]) = 0;
		(a[2] => z[35]) = 0;
		(a[3] => z[35]) = 0;
		(a[4] => z[35]) = 0;
		(a[5] => z[35]) = 0;
		(a[6] => z[35]) = 0;
		(a[7] => z[35]) = 0;
		(a[8] => z[35]) = 0;
		(a[9] => z[35]) = 0;
		(a[10] => z[35]) = 0;
		(a[11] => z[35]) = 0;
		(a[12] => z[35]) = 0;
		(a[13] => z[35]) = 0;
		(a[14] => z[35]) = 0;
		(a[15] => z[35]) = 0;
		(a[16] => z[35]) = 0;
		(a[17] => z[35]) = 0;
		(a[18] => z[35]) = 0;
		(a[19] => z[35]) = 0;
		(b[0] => z[35]) = 0;
		(b[1] => z[35]) = 0;
		(b[2] => z[35]) = 0;
		(b[3] => z[35]) = 0;
		(b[4] => z[35]) = 0;
		(b[5] => z[35]) = 0;
		(b[6] => z[35]) = 0;
		(b[7] => z[35]) = 0;
		(b[8] => z[35]) = 0;
		(b[9] => z[35]) = 0;
		(b[10] => z[35]) = 0;
		(b[11] => z[35]) = 0;
		(b[12] => z[35]) = 0;
		(b[13] => z[35]) = 0;
		(b[14] => z[35]) = 0;
		(b[15] => z[35]) = 0;
		(b[16] => z[35]) = 0;
		(b[17] => z[35]) = 0;
		(a[0] => z[36]) = 0;
		(a[1] => z[36]) = 0;
		(a[2] => z[36]) = 0;
		(a[3] => z[36]) = 0;
		(a[4] => z[36]) = 0;
		(a[5] => z[36]) = 0;
		(a[6] => z[36]) = 0;
		(a[7] => z[36]) = 0;
		(a[8] => z[36]) = 0;
		(a[9] => z[36]) = 0;
		(a[10] => z[36]) = 0;
		(a[11] => z[36]) = 0;
		(a[12] => z[36]) = 0;
		(a[13] => z[36]) = 0;
		(a[14] => z[36]) = 0;
		(a[15] => z[36]) = 0;
		(a[16] => z[36]) = 0;
		(a[17] => z[36]) = 0;
		(a[18] => z[36]) = 0;
		(a[19] => z[36]) = 0;
		(b[0] => z[36]) = 0;
		(b[1] => z[36]) = 0;
		(b[2] => z[36]) = 0;
		(b[3] => z[36]) = 0;
		(b[4] => z[36]) = 0;
		(b[5] => z[36]) = 0;
		(b[6] => z[36]) = 0;
		(b[7] => z[36]) = 0;
		(b[8] => z[36]) = 0;
		(b[9] => z[36]) = 0;
		(b[10] => z[36]) = 0;
		(b[11] => z[36]) = 0;
		(b[12] => z[36]) = 0;
		(b[13] => z[36]) = 0;
		(b[14] => z[36]) = 0;
		(b[15] => z[36]) = 0;
		(b[16] => z[36]) = 0;
		(b[17] => z[36]) = 0;
		(a[0] => z[37]) = 0;
		(a[1] => z[37]) = 0;
		(a[2] => z[37]) = 0;
		(a[3] => z[37]) = 0;
		(a[4] => z[37]) = 0;
		(a[5] => z[37]) = 0;
		(a[6] => z[37]) = 0;
		(a[7] => z[37]) = 0;
		(a[8] => z[37]) = 0;
		(a[9] => z[37]) = 0;
		(a[10] => z[37]) = 0;
		(a[11] => z[37]) = 0;
		(a[12] => z[37]) = 0;
		(a[13] => z[37]) = 0;
		(a[14] => z[37]) = 0;
		(a[15] => z[37]) = 0;
		(a[16] => z[37]) = 0;
		(a[17] => z[37]) = 0;
		(a[18] => z[37]) = 0;
		(a[19] => z[37]) = 0;
		(b[0] => z[37]) = 0;
		(b[1] => z[37]) = 0;
		(b[2] => z[37]) = 0;
		(b[3] => z[37]) = 0;
		(b[4] => z[37]) = 0;
		(b[5] => z[37]) = 0;
		(b[6] => z[37]) = 0;
		(b[7] => z[37]) = 0;
		(b[8] => z[37]) = 0;
		(b[9] => z[37]) = 0;
		(b[10] => z[37]) = 0;
		(b[11] => z[37]) = 0;
		(b[12] => z[37]) = 0;
		(b[13] => z[37]) = 0;
		(b[14] => z[37]) = 0;
		(b[15] => z[37]) = 0;
		(b[16] => z[37]) = 0;
		(b[17] => z[37]) = 0;
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGIN ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: a * b (0)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGOUT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,
	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: a * b (4)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGIN_REGOUT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,
	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: a * b (4)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		//.clk(1'b0),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCin (2, 3)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(a[0] => z[0]) = 0;
		(a[1] => z[0]) = 0;
		(a[2] => z[0]) = 0;
		(a[3] => z[0]) = 0;
		(a[4] => z[0]) = 0;
		(a[5] => z[0]) = 0;
		(a[6] => z[0]) = 0;
		(a[7] => z[0]) = 0;
		(a[8] => z[0]) = 0;
		(a[9] => z[0]) = 0;
		(a[10] => z[0]) = 0;
		(a[11] => z[0]) = 0;
		(a[12] => z[0]) = 0;
		(a[13] => z[0]) = 0;
		(a[14] => z[0]) = 0;
		(a[15] => z[0]) = 0;
		(a[16] => z[0]) = 0;
		(a[17] => z[0]) = 0;
		(a[18] => z[0]) = 0;
		(a[19] => z[0]) = 0;
		(b[0] => z[0]) = 0;
		(b[1] => z[0]) = 0;
		(b[2] => z[0]) = 0;
		(b[3] => z[0]) = 0;
		(b[4] => z[0]) = 0;
		(b[5] => z[0]) = 0;
		(b[6] => z[0]) = 0;
		(b[7] => z[0]) = 0;
		(b[8] => z[0]) = 0;
		(b[9] => z[0]) = 0;
		(b[10] => z[0]) = 0;
		(b[11] => z[0]) = 0;
		(b[12] => z[0]) = 0;
		(b[13] => z[0]) = 0;
		(b[14] => z[0]) = 0;
		(b[15] => z[0]) = 0;
		(b[16] => z[0]) = 0;
		(b[17] => z[0]) = 0;
		(a[0] => z[1]) = 0;
		(a[1] => z[1]) = 0;
		(a[2] => z[1]) = 0;
		(a[3] => z[1]) = 0;
		(a[4] => z[1]) = 0;
		(a[5] => z[1]) = 0;
		(a[6] => z[1]) = 0;
		(a[7] => z[1]) = 0;
		(a[8] => z[1]) = 0;
		(a[9] => z[1]) = 0;
		(a[10] => z[1]) = 0;
		(a[11] => z[1]) = 0;
		(a[12] => z[1]) = 0;
		(a[13] => z[1]) = 0;
		(a[14] => z[1]) = 0;
		(a[15] => z[1]) = 0;
		(a[16] => z[1]) = 0;
		(a[17] => z[1]) = 0;
		(a[18] => z[1]) = 0;
		(a[19] => z[1]) = 0;
		(b[0] => z[1]) = 0;
		(b[1] => z[1]) = 0;
		(b[2] => z[1]) = 0;
		(b[3] => z[1]) = 0;
		(b[4] => z[1]) = 0;
		(b[5] => z[1]) = 0;
		(b[6] => z[1]) = 0;
		(b[7] => z[1]) = 0;
		(b[8] => z[1]) = 0;
		(b[9] => z[1]) = 0;
		(b[10] => z[1]) = 0;
		(b[11] => z[1]) = 0;
		(b[12] => z[1]) = 0;
		(b[13] => z[1]) = 0;
		(b[14] => z[1]) = 0;
		(b[15] => z[1]) = 0;
		(b[16] => z[1]) = 0;
		(b[17] => z[1]) = 0;
		(a[0] => z[2]) = 0;
		(a[1] => z[2]) = 0;
		(a[2] => z[2]) = 0;
		(a[3] => z[2]) = 0;
		(a[4] => z[2]) = 0;
		(a[5] => z[2]) = 0;
		(a[6] => z[2]) = 0;
		(a[7] => z[2]) = 0;
		(a[8] => z[2]) = 0;
		(a[9] => z[2]) = 0;
		(a[10] => z[2]) = 0;
		(a[11] => z[2]) = 0;
		(a[12] => z[2]) = 0;
		(a[13] => z[2]) = 0;
		(a[14] => z[2]) = 0;
		(a[15] => z[2]) = 0;
		(a[16] => z[2]) = 0;
		(a[17] => z[2]) = 0;
		(a[18] => z[2]) = 0;
		(a[19] => z[2]) = 0;
		(b[0] => z[2]) = 0;
		(b[1] => z[2]) = 0;
		(b[2] => z[2]) = 0;
		(b[3] => z[2]) = 0;
		(b[4] => z[2]) = 0;
		(b[5] => z[2]) = 0;
		(b[6] => z[2]) = 0;
		(b[7] => z[2]) = 0;
		(b[8] => z[2]) = 0;
		(b[9] => z[2]) = 0;
		(b[10] => z[2]) = 0;
		(b[11] => z[2]) = 0;
		(b[12] => z[2]) = 0;
		(b[13] => z[2]) = 0;
		(b[14] => z[2]) = 0;
		(b[15] => z[2]) = 0;
		(b[16] => z[2]) = 0;
		(b[17] => z[2]) = 0;
		(a[0] => z[3]) = 0;
		(a[1] => z[3]) = 0;
		(a[2] => z[3]) = 0;
		(a[3] => z[3]) = 0;
		(a[4] => z[3]) = 0;
		(a[5] => z[3]) = 0;
		(a[6] => z[3]) = 0;
		(a[7] => z[3]) = 0;
		(a[8] => z[3]) = 0;
		(a[9] => z[3]) = 0;
		(a[10] => z[3]) = 0;
		(a[11] => z[3]) = 0;
		(a[12] => z[3]) = 0;
		(a[13] => z[3]) = 0;
		(a[14] => z[3]) = 0;
		(a[15] => z[3]) = 0;
		(a[16] => z[3]) = 0;
		(a[17] => z[3]) = 0;
		(a[18] => z[3]) = 0;
		(a[19] => z[3]) = 0;
		(b[0] => z[3]) = 0;
		(b[1] => z[3]) = 0;
		(b[2] => z[3]) = 0;
		(b[3] => z[3]) = 0;
		(b[4] => z[3]) = 0;
		(b[5] => z[3]) = 0;
		(b[6] => z[3]) = 0;
		(b[7] => z[3]) = 0;
		(b[8] => z[3]) = 0;
		(b[9] => z[3]) = 0;
		(b[10] => z[3]) = 0;
		(b[11] => z[3]) = 0;
		(b[12] => z[3]) = 0;
		(b[13] => z[3]) = 0;
		(b[14] => z[3]) = 0;
		(b[15] => z[3]) = 0;
		(b[16] => z[3]) = 0;
		(b[17] => z[3]) = 0;
		(a[0] => z[4]) = 0;
		(a[1] => z[4]) = 0;
		(a[2] => z[4]) = 0;
		(a[3] => z[4]) = 0;
		(a[4] => z[4]) = 0;
		(a[5] => z[4]) = 0;
		(a[6] => z[4]) = 0;
		(a[7] => z[4]) = 0;
		(a[8] => z[4]) = 0;
		(a[9] => z[4]) = 0;
		(a[10] => z[4]) = 0;
		(a[11] => z[4]) = 0;
		(a[12] => z[4]) = 0;
		(a[13] => z[4]) = 0;
		(a[14] => z[4]) = 0;
		(a[15] => z[4]) = 0;
		(a[16] => z[4]) = 0;
		(a[17] => z[4]) = 0;
		(a[18] => z[4]) = 0;
		(a[19] => z[4]) = 0;
		(b[0] => z[4]) = 0;
		(b[1] => z[4]) = 0;
		(b[2] => z[4]) = 0;
		(b[3] => z[4]) = 0;
		(b[4] => z[4]) = 0;
		(b[5] => z[4]) = 0;
		(b[6] => z[4]) = 0;
		(b[7] => z[4]) = 0;
		(b[8] => z[4]) = 0;
		(b[9] => z[4]) = 0;
		(b[10] => z[4]) = 0;
		(b[11] => z[4]) = 0;
		(b[12] => z[4]) = 0;
		(b[13] => z[4]) = 0;
		(b[14] => z[4]) = 0;
		(b[15] => z[4]) = 0;
		(b[16] => z[4]) = 0;
		(b[17] => z[4]) = 0;
		(a[0] => z[5]) = 0;
		(a[1] => z[5]) = 0;
		(a[2] => z[5]) = 0;
		(a[3] => z[5]) = 0;
		(a[4] => z[5]) = 0;
		(a[5] => z[5]) = 0;
		(a[6] => z[5]) = 0;
		(a[7] => z[5]) = 0;
		(a[8] => z[5]) = 0;
		(a[9] => z[5]) = 0;
		(a[10] => z[5]) = 0;
		(a[11] => z[5]) = 0;
		(a[12] => z[5]) = 0;
		(a[13] => z[5]) = 0;
		(a[14] => z[5]) = 0;
		(a[15] => z[5]) = 0;
		(a[16] => z[5]) = 0;
		(a[17] => z[5]) = 0;
		(a[18] => z[5]) = 0;
		(a[19] => z[5]) = 0;
		(b[0] => z[5]) = 0;
		(b[1] => z[5]) = 0;
		(b[2] => z[5]) = 0;
		(b[3] => z[5]) = 0;
		(b[4] => z[5]) = 0;
		(b[5] => z[5]) = 0;
		(b[6] => z[5]) = 0;
		(b[7] => z[5]) = 0;
		(b[8] => z[5]) = 0;
		(b[9] => z[5]) = 0;
		(b[10] => z[5]) = 0;
		(b[11] => z[5]) = 0;
		(b[12] => z[5]) = 0;
		(b[13] => z[5]) = 0;
		(b[14] => z[5]) = 0;
		(b[15] => z[5]) = 0;
		(b[16] => z[5]) = 0;
		(b[17] => z[5]) = 0;
		(a[0] => z[6]) = 0;
		(a[1] => z[6]) = 0;
		(a[2] => z[6]) = 0;
		(a[3] => z[6]) = 0;
		(a[4] => z[6]) = 0;
		(a[5] => z[6]) = 0;
		(a[6] => z[6]) = 0;
		(a[7] => z[6]) = 0;
		(a[8] => z[6]) = 0;
		(a[9] => z[6]) = 0;
		(a[10] => z[6]) = 0;
		(a[11] => z[6]) = 0;
		(a[12] => z[6]) = 0;
		(a[13] => z[6]) = 0;
		(a[14] => z[6]) = 0;
		(a[15] => z[6]) = 0;
		(a[16] => z[6]) = 0;
		(a[17] => z[6]) = 0;
		(a[18] => z[6]) = 0;
		(a[19] => z[6]) = 0;
		(b[0] => z[6]) = 0;
		(b[1] => z[6]) = 0;
		(b[2] => z[6]) = 0;
		(b[3] => z[6]) = 0;
		(b[4] => z[6]) = 0;
		(b[5] => z[6]) = 0;
		(b[6] => z[6]) = 0;
		(b[7] => z[6]) = 0;
		(b[8] => z[6]) = 0;
		(b[9] => z[6]) = 0;
		(b[10] => z[6]) = 0;
		(b[11] => z[6]) = 0;
		(b[12] => z[6]) = 0;
		(b[13] => z[6]) = 0;
		(b[14] => z[6]) = 0;
		(b[15] => z[6]) = 0;
		(b[16] => z[6]) = 0;
		(b[17] => z[6]) = 0;
		(a[0] => z[7]) = 0;
		(a[1] => z[7]) = 0;
		(a[2] => z[7]) = 0;
		(a[3] => z[7]) = 0;
		(a[4] => z[7]) = 0;
		(a[5] => z[7]) = 0;
		(a[6] => z[7]) = 0;
		(a[7] => z[7]) = 0;
		(a[8] => z[7]) = 0;
		(a[9] => z[7]) = 0;
		(a[10] => z[7]) = 0;
		(a[11] => z[7]) = 0;
		(a[12] => z[7]) = 0;
		(a[13] => z[7]) = 0;
		(a[14] => z[7]) = 0;
		(a[15] => z[7]) = 0;
		(a[16] => z[7]) = 0;
		(a[17] => z[7]) = 0;
		(a[18] => z[7]) = 0;
		(a[19] => z[7]) = 0;
		(b[0] => z[7]) = 0;
		(b[1] => z[7]) = 0;
		(b[2] => z[7]) = 0;
		(b[3] => z[7]) = 0;
		(b[4] => z[7]) = 0;
		(b[5] => z[7]) = 0;
		(b[6] => z[7]) = 0;
		(b[7] => z[7]) = 0;
		(b[8] => z[7]) = 0;
		(b[9] => z[7]) = 0;
		(b[10] => z[7]) = 0;
		(b[11] => z[7]) = 0;
		(b[12] => z[7]) = 0;
		(b[13] => z[7]) = 0;
		(b[14] => z[7]) = 0;
		(b[15] => z[7]) = 0;
		(b[16] => z[7]) = 0;
		(b[17] => z[7]) = 0;
		(a[0] => z[8]) = 0;
		(a[1] => z[8]) = 0;
		(a[2] => z[8]) = 0;
		(a[3] => z[8]) = 0;
		(a[4] => z[8]) = 0;
		(a[5] => z[8]) = 0;
		(a[6] => z[8]) = 0;
		(a[7] => z[8]) = 0;
		(a[8] => z[8]) = 0;
		(a[9] => z[8]) = 0;
		(a[10] => z[8]) = 0;
		(a[11] => z[8]) = 0;
		(a[12] => z[8]) = 0;
		(a[13] => z[8]) = 0;
		(a[14] => z[8]) = 0;
		(a[15] => z[8]) = 0;
		(a[16] => z[8]) = 0;
		(a[17] => z[8]) = 0;
		(a[18] => z[8]) = 0;
		(a[19] => z[8]) = 0;
		(b[0] => z[8]) = 0;
		(b[1] => z[8]) = 0;
		(b[2] => z[8]) = 0;
		(b[3] => z[8]) = 0;
		(b[4] => z[8]) = 0;
		(b[5] => z[8]) = 0;
		(b[6] => z[8]) = 0;
		(b[7] => z[8]) = 0;
		(b[8] => z[8]) = 0;
		(b[9] => z[8]) = 0;
		(b[10] => z[8]) = 0;
		(b[11] => z[8]) = 0;
		(b[12] => z[8]) = 0;
		(b[13] => z[8]) = 0;
		(b[14] => z[8]) = 0;
		(b[15] => z[8]) = 0;
		(b[16] => z[8]) = 0;
		(b[17] => z[8]) = 0;
		(a[0] => z[9]) = 0;
		(a[1] => z[9]) = 0;
		(a[2] => z[9]) = 0;
		(a[3] => z[9]) = 0;
		(a[4] => z[9]) = 0;
		(a[5] => z[9]) = 0;
		(a[6] => z[9]) = 0;
		(a[7] => z[9]) = 0;
		(a[8] => z[9]) = 0;
		(a[9] => z[9]) = 0;
		(a[10] => z[9]) = 0;
		(a[11] => z[9]) = 0;
		(a[12] => z[9]) = 0;
		(a[13] => z[9]) = 0;
		(a[14] => z[9]) = 0;
		(a[15] => z[9]) = 0;
		(a[16] => z[9]) = 0;
		(a[17] => z[9]) = 0;
		(a[18] => z[9]) = 0;
		(a[19] => z[9]) = 0;
		(b[0] => z[9]) = 0;
		(b[1] => z[9]) = 0;
		(b[2] => z[9]) = 0;
		(b[3] => z[9]) = 0;
		(b[4] => z[9]) = 0;
		(b[5] => z[9]) = 0;
		(b[6] => z[9]) = 0;
		(b[7] => z[9]) = 0;
		(b[8] => z[9]) = 0;
		(b[9] => z[9]) = 0;
		(b[10] => z[9]) = 0;
		(b[11] => z[9]) = 0;
		(b[12] => z[9]) = 0;
		(b[13] => z[9]) = 0;
		(b[14] => z[9]) = 0;
		(b[15] => z[9]) = 0;
		(b[16] => z[9]) = 0;
		(b[17] => z[9]) = 0;
		(a[0] => z[10]) = 0;
		(a[1] => z[10]) = 0;
		(a[2] => z[10]) = 0;
		(a[3] => z[10]) = 0;
		(a[4] => z[10]) = 0;
		(a[5] => z[10]) = 0;
		(a[6] => z[10]) = 0;
		(a[7] => z[10]) = 0;
		(a[8] => z[10]) = 0;
		(a[9] => z[10]) = 0;
		(a[10] => z[10]) = 0;
		(a[11] => z[10]) = 0;
		(a[12] => z[10]) = 0;
		(a[13] => z[10]) = 0;
		(a[14] => z[10]) = 0;
		(a[15] => z[10]) = 0;
		(a[16] => z[10]) = 0;
		(a[17] => z[10]) = 0;
		(a[18] => z[10]) = 0;
		(a[19] => z[10]) = 0;
		(b[0] => z[10]) = 0;
		(b[1] => z[10]) = 0;
		(b[2] => z[10]) = 0;
		(b[3] => z[10]) = 0;
		(b[4] => z[10]) = 0;
		(b[5] => z[10]) = 0;
		(b[6] => z[10]) = 0;
		(b[7] => z[10]) = 0;
		(b[8] => z[10]) = 0;
		(b[9] => z[10]) = 0;
		(b[10] => z[10]) = 0;
		(b[11] => z[10]) = 0;
		(b[12] => z[10]) = 0;
		(b[13] => z[10]) = 0;
		(b[14] => z[10]) = 0;
		(b[15] => z[10]) = 0;
		(b[16] => z[10]) = 0;
		(b[17] => z[10]) = 0;
		(a[0] => z[11]) = 0;
		(a[1] => z[11]) = 0;
		(a[2] => z[11]) = 0;
		(a[3] => z[11]) = 0;
		(a[4] => z[11]) = 0;
		(a[5] => z[11]) = 0;
		(a[6] => z[11]) = 0;
		(a[7] => z[11]) = 0;
		(a[8] => z[11]) = 0;
		(a[9] => z[11]) = 0;
		(a[10] => z[11]) = 0;
		(a[11] => z[11]) = 0;
		(a[12] => z[11]) = 0;
		(a[13] => z[11]) = 0;
		(a[14] => z[11]) = 0;
		(a[15] => z[11]) = 0;
		(a[16] => z[11]) = 0;
		(a[17] => z[11]) = 0;
		(a[18] => z[11]) = 0;
		(a[19] => z[11]) = 0;
		(b[0] => z[11]) = 0;
		(b[1] => z[11]) = 0;
		(b[2] => z[11]) = 0;
		(b[3] => z[11]) = 0;
		(b[4] => z[11]) = 0;
		(b[5] => z[11]) = 0;
		(b[6] => z[11]) = 0;
		(b[7] => z[11]) = 0;
		(b[8] => z[11]) = 0;
		(b[9] => z[11]) = 0;
		(b[10] => z[11]) = 0;
		(b[11] => z[11]) = 0;
		(b[12] => z[11]) = 0;
		(b[13] => z[11]) = 0;
		(b[14] => z[11]) = 0;
		(b[15] => z[11]) = 0;
		(b[16] => z[11]) = 0;
		(b[17] => z[11]) = 0;
		(a[0] => z[12]) = 0;
		(a[1] => z[12]) = 0;
		(a[2] => z[12]) = 0;
		(a[3] => z[12]) = 0;
		(a[4] => z[12]) = 0;
		(a[5] => z[12]) = 0;
		(a[6] => z[12]) = 0;
		(a[7] => z[12]) = 0;
		(a[8] => z[12]) = 0;
		(a[9] => z[12]) = 0;
		(a[10] => z[12]) = 0;
		(a[11] => z[12]) = 0;
		(a[12] => z[12]) = 0;
		(a[13] => z[12]) = 0;
		(a[14] => z[12]) = 0;
		(a[15] => z[12]) = 0;
		(a[16] => z[12]) = 0;
		(a[17] => z[12]) = 0;
		(a[18] => z[12]) = 0;
		(a[19] => z[12]) = 0;
		(b[0] => z[12]) = 0;
		(b[1] => z[12]) = 0;
		(b[2] => z[12]) = 0;
		(b[3] => z[12]) = 0;
		(b[4] => z[12]) = 0;
		(b[5] => z[12]) = 0;
		(b[6] => z[12]) = 0;
		(b[7] => z[12]) = 0;
		(b[8] => z[12]) = 0;
		(b[9] => z[12]) = 0;
		(b[10] => z[12]) = 0;
		(b[11] => z[12]) = 0;
		(b[12] => z[12]) = 0;
		(b[13] => z[12]) = 0;
		(b[14] => z[12]) = 0;
		(b[15] => z[12]) = 0;
		(b[16] => z[12]) = 0;
		(b[17] => z[12]) = 0;
		(a[0] => z[13]) = 0;
		(a[1] => z[13]) = 0;
		(a[2] => z[13]) = 0;
		(a[3] => z[13]) = 0;
		(a[4] => z[13]) = 0;
		(a[5] => z[13]) = 0;
		(a[6] => z[13]) = 0;
		(a[7] => z[13]) = 0;
		(a[8] => z[13]) = 0;
		(a[9] => z[13]) = 0;
		(a[10] => z[13]) = 0;
		(a[11] => z[13]) = 0;
		(a[12] => z[13]) = 0;
		(a[13] => z[13]) = 0;
		(a[14] => z[13]) = 0;
		(a[15] => z[13]) = 0;
		(a[16] => z[13]) = 0;
		(a[17] => z[13]) = 0;
		(a[18] => z[13]) = 0;
		(a[19] => z[13]) = 0;
		(b[0] => z[13]) = 0;
		(b[1] => z[13]) = 0;
		(b[2] => z[13]) = 0;
		(b[3] => z[13]) = 0;
		(b[4] => z[13]) = 0;
		(b[5] => z[13]) = 0;
		(b[6] => z[13]) = 0;
		(b[7] => z[13]) = 0;
		(b[8] => z[13]) = 0;
		(b[9] => z[13]) = 0;
		(b[10] => z[13]) = 0;
		(b[11] => z[13]) = 0;
		(b[12] => z[13]) = 0;
		(b[13] => z[13]) = 0;
		(b[14] => z[13]) = 0;
		(b[15] => z[13]) = 0;
		(b[16] => z[13]) = 0;
		(b[17] => z[13]) = 0;
		(a[0] => z[14]) = 0;
		(a[1] => z[14]) = 0;
		(a[2] => z[14]) = 0;
		(a[3] => z[14]) = 0;
		(a[4] => z[14]) = 0;
		(a[5] => z[14]) = 0;
		(a[6] => z[14]) = 0;
		(a[7] => z[14]) = 0;
		(a[8] => z[14]) = 0;
		(a[9] => z[14]) = 0;
		(a[10] => z[14]) = 0;
		(a[11] => z[14]) = 0;
		(a[12] => z[14]) = 0;
		(a[13] => z[14]) = 0;
		(a[14] => z[14]) = 0;
		(a[15] => z[14]) = 0;
		(a[16] => z[14]) = 0;
		(a[17] => z[14]) = 0;
		(a[18] => z[14]) = 0;
		(a[19] => z[14]) = 0;
		(b[0] => z[14]) = 0;
		(b[1] => z[14]) = 0;
		(b[2] => z[14]) = 0;
		(b[3] => z[14]) = 0;
		(b[4] => z[14]) = 0;
		(b[5] => z[14]) = 0;
		(b[6] => z[14]) = 0;
		(b[7] => z[14]) = 0;
		(b[8] => z[14]) = 0;
		(b[9] => z[14]) = 0;
		(b[10] => z[14]) = 0;
		(b[11] => z[14]) = 0;
		(b[12] => z[14]) = 0;
		(b[13] => z[14]) = 0;
		(b[14] => z[14]) = 0;
		(b[15] => z[14]) = 0;
		(b[16] => z[14]) = 0;
		(b[17] => z[14]) = 0;
		(a[0] => z[15]) = 0;
		(a[1] => z[15]) = 0;
		(a[2] => z[15]) = 0;
		(a[3] => z[15]) = 0;
		(a[4] => z[15]) = 0;
		(a[5] => z[15]) = 0;
		(a[6] => z[15]) = 0;
		(a[7] => z[15]) = 0;
		(a[8] => z[15]) = 0;
		(a[9] => z[15]) = 0;
		(a[10] => z[15]) = 0;
		(a[11] => z[15]) = 0;
		(a[12] => z[15]) = 0;
		(a[13] => z[15]) = 0;
		(a[14] => z[15]) = 0;
		(a[15] => z[15]) = 0;
		(a[16] => z[15]) = 0;
		(a[17] => z[15]) = 0;
		(a[18] => z[15]) = 0;
		(a[19] => z[15]) = 0;
		(b[0] => z[15]) = 0;
		(b[1] => z[15]) = 0;
		(b[2] => z[15]) = 0;
		(b[3] => z[15]) = 0;
		(b[4] => z[15]) = 0;
		(b[5] => z[15]) = 0;
		(b[6] => z[15]) = 0;
		(b[7] => z[15]) = 0;
		(b[8] => z[15]) = 0;
		(b[9] => z[15]) = 0;
		(b[10] => z[15]) = 0;
		(b[11] => z[15]) = 0;
		(b[12] => z[15]) = 0;
		(b[13] => z[15]) = 0;
		(b[14] => z[15]) = 0;
		(b[15] => z[15]) = 0;
		(b[16] => z[15]) = 0;
		(b[17] => z[15]) = 0;
		(a[0] => z[16]) = 0;
		(a[1] => z[16]) = 0;
		(a[2] => z[16]) = 0;
		(a[3] => z[16]) = 0;
		(a[4] => z[16]) = 0;
		(a[5] => z[16]) = 0;
		(a[6] => z[16]) = 0;
		(a[7] => z[16]) = 0;
		(a[8] => z[16]) = 0;
		(a[9] => z[16]) = 0;
		(a[10] => z[16]) = 0;
		(a[11] => z[16]) = 0;
		(a[12] => z[16]) = 0;
		(a[13] => z[16]) = 0;
		(a[14] => z[16]) = 0;
		(a[15] => z[16]) = 0;
		(a[16] => z[16]) = 0;
		(a[17] => z[16]) = 0;
		(a[18] => z[16]) = 0;
		(a[19] => z[16]) = 0;
		(b[0] => z[16]) = 0;
		(b[1] => z[16]) = 0;
		(b[2] => z[16]) = 0;
		(b[3] => z[16]) = 0;
		(b[4] => z[16]) = 0;
		(b[5] => z[16]) = 0;
		(b[6] => z[16]) = 0;
		(b[7] => z[16]) = 0;
		(b[8] => z[16]) = 0;
		(b[9] => z[16]) = 0;
		(b[10] => z[16]) = 0;
		(b[11] => z[16]) = 0;
		(b[12] => z[16]) = 0;
		(b[13] => z[16]) = 0;
		(b[14] => z[16]) = 0;
		(b[15] => z[16]) = 0;
		(b[16] => z[16]) = 0;
		(b[17] => z[16]) = 0;
		(a[0] => z[17]) = 0;
		(a[1] => z[17]) = 0;
		(a[2] => z[17]) = 0;
		(a[3] => z[17]) = 0;
		(a[4] => z[17]) = 0;
		(a[5] => z[17]) = 0;
		(a[6] => z[17]) = 0;
		(a[7] => z[17]) = 0;
		(a[8] => z[17]) = 0;
		(a[9] => z[17]) = 0;
		(a[10] => z[17]) = 0;
		(a[11] => z[17]) = 0;
		(a[12] => z[17]) = 0;
		(a[13] => z[17]) = 0;
		(a[14] => z[17]) = 0;
		(a[15] => z[17]) = 0;
		(a[16] => z[17]) = 0;
		(a[17] => z[17]) = 0;
		(a[18] => z[17]) = 0;
		(a[19] => z[17]) = 0;
		(b[0] => z[17]) = 0;
		(b[1] => z[17]) = 0;
		(b[2] => z[17]) = 0;
		(b[3] => z[17]) = 0;
		(b[4] => z[17]) = 0;
		(b[5] => z[17]) = 0;
		(b[6] => z[17]) = 0;
		(b[7] => z[17]) = 0;
		(b[8] => z[17]) = 0;
		(b[9] => z[17]) = 0;
		(b[10] => z[17]) = 0;
		(b[11] => z[17]) = 0;
		(b[12] => z[17]) = 0;
		(b[13] => z[17]) = 0;
		(b[14] => z[17]) = 0;
		(b[15] => z[17]) = 0;
		(b[16] => z[17]) = 0;
		(b[17] => z[17]) = 0;
		(a[0] => z[18]) = 0;
		(a[1] => z[18]) = 0;
		(a[2] => z[18]) = 0;
		(a[3] => z[18]) = 0;
		(a[4] => z[18]) = 0;
		(a[5] => z[18]) = 0;
		(a[6] => z[18]) = 0;
		(a[7] => z[18]) = 0;
		(a[8] => z[18]) = 0;
		(a[9] => z[18]) = 0;
		(a[10] => z[18]) = 0;
		(a[11] => z[18]) = 0;
		(a[12] => z[18]) = 0;
		(a[13] => z[18]) = 0;
		(a[14] => z[18]) = 0;
		(a[15] => z[18]) = 0;
		(a[16] => z[18]) = 0;
		(a[17] => z[18]) = 0;
		(a[18] => z[18]) = 0;
		(a[19] => z[18]) = 0;
		(b[0] => z[18]) = 0;
		(b[1] => z[18]) = 0;
		(b[2] => z[18]) = 0;
		(b[3] => z[18]) = 0;
		(b[4] => z[18]) = 0;
		(b[5] => z[18]) = 0;
		(b[6] => z[18]) = 0;
		(b[7] => z[18]) = 0;
		(b[8] => z[18]) = 0;
		(b[9] => z[18]) = 0;
		(b[10] => z[18]) = 0;
		(b[11] => z[18]) = 0;
		(b[12] => z[18]) = 0;
		(b[13] => z[18]) = 0;
		(b[14] => z[18]) = 0;
		(b[15] => z[18]) = 0;
		(b[16] => z[18]) = 0;
		(b[17] => z[18]) = 0;
		(a[0] => z[19]) = 0;
		(a[1] => z[19]) = 0;
		(a[2] => z[19]) = 0;
		(a[3] => z[19]) = 0;
		(a[4] => z[19]) = 0;
		(a[5] => z[19]) = 0;
		(a[6] => z[19]) = 0;
		(a[7] => z[19]) = 0;
		(a[8] => z[19]) = 0;
		(a[9] => z[19]) = 0;
		(a[10] => z[19]) = 0;
		(a[11] => z[19]) = 0;
		(a[12] => z[19]) = 0;
		(a[13] => z[19]) = 0;
		(a[14] => z[19]) = 0;
		(a[15] => z[19]) = 0;
		(a[16] => z[19]) = 0;
		(a[17] => z[19]) = 0;
		(a[18] => z[19]) = 0;
		(a[19] => z[19]) = 0;
		(b[0] => z[19]) = 0;
		(b[1] => z[19]) = 0;
		(b[2] => z[19]) = 0;
		(b[3] => z[19]) = 0;
		(b[4] => z[19]) = 0;
		(b[5] => z[19]) = 0;
		(b[6] => z[19]) = 0;
		(b[7] => z[19]) = 0;
		(b[8] => z[19]) = 0;
		(b[9] => z[19]) = 0;
		(b[10] => z[19]) = 0;
		(b[11] => z[19]) = 0;
		(b[12] => z[19]) = 0;
		(b[13] => z[19]) = 0;
		(b[14] => z[19]) = 0;
		(b[15] => z[19]) = 0;
		(b[16] => z[19]) = 0;
		(b[17] => z[19]) = 0;
		(a[0] => z[20]) = 0;
		(a[1] => z[20]) = 0;
		(a[2] => z[20]) = 0;
		(a[3] => z[20]) = 0;
		(a[4] => z[20]) = 0;
		(a[5] => z[20]) = 0;
		(a[6] => z[20]) = 0;
		(a[7] => z[20]) = 0;
		(a[8] => z[20]) = 0;
		(a[9] => z[20]) = 0;
		(a[10] => z[20]) = 0;
		(a[11] => z[20]) = 0;
		(a[12] => z[20]) = 0;
		(a[13] => z[20]) = 0;
		(a[14] => z[20]) = 0;
		(a[15] => z[20]) = 0;
		(a[16] => z[20]) = 0;
		(a[17] => z[20]) = 0;
		(a[18] => z[20]) = 0;
		(a[19] => z[20]) = 0;
		(b[0] => z[20]) = 0;
		(b[1] => z[20]) = 0;
		(b[2] => z[20]) = 0;
		(b[3] => z[20]) = 0;
		(b[4] => z[20]) = 0;
		(b[5] => z[20]) = 0;
		(b[6] => z[20]) = 0;
		(b[7] => z[20]) = 0;
		(b[8] => z[20]) = 0;
		(b[9] => z[20]) = 0;
		(b[10] => z[20]) = 0;
		(b[11] => z[20]) = 0;
		(b[12] => z[20]) = 0;
		(b[13] => z[20]) = 0;
		(b[14] => z[20]) = 0;
		(b[15] => z[20]) = 0;
		(b[16] => z[20]) = 0;
		(b[17] => z[20]) = 0;
		(a[0] => z[21]) = 0;
		(a[1] => z[21]) = 0;
		(a[2] => z[21]) = 0;
		(a[3] => z[21]) = 0;
		(a[4] => z[21]) = 0;
		(a[5] => z[21]) = 0;
		(a[6] => z[21]) = 0;
		(a[7] => z[21]) = 0;
		(a[8] => z[21]) = 0;
		(a[9] => z[21]) = 0;
		(a[10] => z[21]) = 0;
		(a[11] => z[21]) = 0;
		(a[12] => z[21]) = 0;
		(a[13] => z[21]) = 0;
		(a[14] => z[21]) = 0;
		(a[15] => z[21]) = 0;
		(a[16] => z[21]) = 0;
		(a[17] => z[21]) = 0;
		(a[18] => z[21]) = 0;
		(a[19] => z[21]) = 0;
		(b[0] => z[21]) = 0;
		(b[1] => z[21]) = 0;
		(b[2] => z[21]) = 0;
		(b[3] => z[21]) = 0;
		(b[4] => z[21]) = 0;
		(b[5] => z[21]) = 0;
		(b[6] => z[21]) = 0;
		(b[7] => z[21]) = 0;
		(b[8] => z[21]) = 0;
		(b[9] => z[21]) = 0;
		(b[10] => z[21]) = 0;
		(b[11] => z[21]) = 0;
		(b[12] => z[21]) = 0;
		(b[13] => z[21]) = 0;
		(b[14] => z[21]) = 0;
		(b[15] => z[21]) = 0;
		(b[16] => z[21]) = 0;
		(b[17] => z[21]) = 0;
		(a[0] => z[22]) = 0;
		(a[1] => z[22]) = 0;
		(a[2] => z[22]) = 0;
		(a[3] => z[22]) = 0;
		(a[4] => z[22]) = 0;
		(a[5] => z[22]) = 0;
		(a[6] => z[22]) = 0;
		(a[7] => z[22]) = 0;
		(a[8] => z[22]) = 0;
		(a[9] => z[22]) = 0;
		(a[10] => z[22]) = 0;
		(a[11] => z[22]) = 0;
		(a[12] => z[22]) = 0;
		(a[13] => z[22]) = 0;
		(a[14] => z[22]) = 0;
		(a[15] => z[22]) = 0;
		(a[16] => z[22]) = 0;
		(a[17] => z[22]) = 0;
		(a[18] => z[22]) = 0;
		(a[19] => z[22]) = 0;
		(b[0] => z[22]) = 0;
		(b[1] => z[22]) = 0;
		(b[2] => z[22]) = 0;
		(b[3] => z[22]) = 0;
		(b[4] => z[22]) = 0;
		(b[5] => z[22]) = 0;
		(b[6] => z[22]) = 0;
		(b[7] => z[22]) = 0;
		(b[8] => z[22]) = 0;
		(b[9] => z[22]) = 0;
		(b[10] => z[22]) = 0;
		(b[11] => z[22]) = 0;
		(b[12] => z[22]) = 0;
		(b[13] => z[22]) = 0;
		(b[14] => z[22]) = 0;
		(b[15] => z[22]) = 0;
		(b[16] => z[22]) = 0;
		(b[17] => z[22]) = 0;
		(a[0] => z[23]) = 0;
		(a[1] => z[23]) = 0;
		(a[2] => z[23]) = 0;
		(a[3] => z[23]) = 0;
		(a[4] => z[23]) = 0;
		(a[5] => z[23]) = 0;
		(a[6] => z[23]) = 0;
		(a[7] => z[23]) = 0;
		(a[8] => z[23]) = 0;
		(a[9] => z[23]) = 0;
		(a[10] => z[23]) = 0;
		(a[11] => z[23]) = 0;
		(a[12] => z[23]) = 0;
		(a[13] => z[23]) = 0;
		(a[14] => z[23]) = 0;
		(a[15] => z[23]) = 0;
		(a[16] => z[23]) = 0;
		(a[17] => z[23]) = 0;
		(a[18] => z[23]) = 0;
		(a[19] => z[23]) = 0;
		(b[0] => z[23]) = 0;
		(b[1] => z[23]) = 0;
		(b[2] => z[23]) = 0;
		(b[3] => z[23]) = 0;
		(b[4] => z[23]) = 0;
		(b[5] => z[23]) = 0;
		(b[6] => z[23]) = 0;
		(b[7] => z[23]) = 0;
		(b[8] => z[23]) = 0;
		(b[9] => z[23]) = 0;
		(b[10] => z[23]) = 0;
		(b[11] => z[23]) = 0;
		(b[12] => z[23]) = 0;
		(b[13] => z[23]) = 0;
		(b[14] => z[23]) = 0;
		(b[15] => z[23]) = 0;
		(b[16] => z[23]) = 0;
		(b[17] => z[23]) = 0;
		(a[0] => z[24]) = 0;
		(a[1] => z[24]) = 0;
		(a[2] => z[24]) = 0;
		(a[3] => z[24]) = 0;
		(a[4] => z[24]) = 0;
		(a[5] => z[24]) = 0;
		(a[6] => z[24]) = 0;
		(a[7] => z[24]) = 0;
		(a[8] => z[24]) = 0;
		(a[9] => z[24]) = 0;
		(a[10] => z[24]) = 0;
		(a[11] => z[24]) = 0;
		(a[12] => z[24]) = 0;
		(a[13] => z[24]) = 0;
		(a[14] => z[24]) = 0;
		(a[15] => z[24]) = 0;
		(a[16] => z[24]) = 0;
		(a[17] => z[24]) = 0;
		(a[18] => z[24]) = 0;
		(a[19] => z[24]) = 0;
		(b[0] => z[24]) = 0;
		(b[1] => z[24]) = 0;
		(b[2] => z[24]) = 0;
		(b[3] => z[24]) = 0;
		(b[4] => z[24]) = 0;
		(b[5] => z[24]) = 0;
		(b[6] => z[24]) = 0;
		(b[7] => z[24]) = 0;
		(b[8] => z[24]) = 0;
		(b[9] => z[24]) = 0;
		(b[10] => z[24]) = 0;
		(b[11] => z[24]) = 0;
		(b[12] => z[24]) = 0;
		(b[13] => z[24]) = 0;
		(b[14] => z[24]) = 0;
		(b[15] => z[24]) = 0;
		(b[16] => z[24]) = 0;
		(b[17] => z[24]) = 0;
		(a[0] => z[25]) = 0;
		(a[1] => z[25]) = 0;
		(a[2] => z[25]) = 0;
		(a[3] => z[25]) = 0;
		(a[4] => z[25]) = 0;
		(a[5] => z[25]) = 0;
		(a[6] => z[25]) = 0;
		(a[7] => z[25]) = 0;
		(a[8] => z[25]) = 0;
		(a[9] => z[25]) = 0;
		(a[10] => z[25]) = 0;
		(a[11] => z[25]) = 0;
		(a[12] => z[25]) = 0;
		(a[13] => z[25]) = 0;
		(a[14] => z[25]) = 0;
		(a[15] => z[25]) = 0;
		(a[16] => z[25]) = 0;
		(a[17] => z[25]) = 0;
		(a[18] => z[25]) = 0;
		(a[19] => z[25]) = 0;
		(b[0] => z[25]) = 0;
		(b[1] => z[25]) = 0;
		(b[2] => z[25]) = 0;
		(b[3] => z[25]) = 0;
		(b[4] => z[25]) = 0;
		(b[5] => z[25]) = 0;
		(b[6] => z[25]) = 0;
		(b[7] => z[25]) = 0;
		(b[8] => z[25]) = 0;
		(b[9] => z[25]) = 0;
		(b[10] => z[25]) = 0;
		(b[11] => z[25]) = 0;
		(b[12] => z[25]) = 0;
		(b[13] => z[25]) = 0;
		(b[14] => z[25]) = 0;
		(b[15] => z[25]) = 0;
		(b[16] => z[25]) = 0;
		(b[17] => z[25]) = 0;
		(a[0] => z[26]) = 0;
		(a[1] => z[26]) = 0;
		(a[2] => z[26]) = 0;
		(a[3] => z[26]) = 0;
		(a[4] => z[26]) = 0;
		(a[5] => z[26]) = 0;
		(a[6] => z[26]) = 0;
		(a[7] => z[26]) = 0;
		(a[8] => z[26]) = 0;
		(a[9] => z[26]) = 0;
		(a[10] => z[26]) = 0;
		(a[11] => z[26]) = 0;
		(a[12] => z[26]) = 0;
		(a[13] => z[26]) = 0;
		(a[14] => z[26]) = 0;
		(a[15] => z[26]) = 0;
		(a[16] => z[26]) = 0;
		(a[17] => z[26]) = 0;
		(a[18] => z[26]) = 0;
		(a[19] => z[26]) = 0;
		(b[0] => z[26]) = 0;
		(b[1] => z[26]) = 0;
		(b[2] => z[26]) = 0;
		(b[3] => z[26]) = 0;
		(b[4] => z[26]) = 0;
		(b[5] => z[26]) = 0;
		(b[6] => z[26]) = 0;
		(b[7] => z[26]) = 0;
		(b[8] => z[26]) = 0;
		(b[9] => z[26]) = 0;
		(b[10] => z[26]) = 0;
		(b[11] => z[26]) = 0;
		(b[12] => z[26]) = 0;
		(b[13] => z[26]) = 0;
		(b[14] => z[26]) = 0;
		(b[15] => z[26]) = 0;
		(b[16] => z[26]) = 0;
		(b[17] => z[26]) = 0;
		(a[0] => z[27]) = 0;
		(a[1] => z[27]) = 0;
		(a[2] => z[27]) = 0;
		(a[3] => z[27]) = 0;
		(a[4] => z[27]) = 0;
		(a[5] => z[27]) = 0;
		(a[6] => z[27]) = 0;
		(a[7] => z[27]) = 0;
		(a[8] => z[27]) = 0;
		(a[9] => z[27]) = 0;
		(a[10] => z[27]) = 0;
		(a[11] => z[27]) = 0;
		(a[12] => z[27]) = 0;
		(a[13] => z[27]) = 0;
		(a[14] => z[27]) = 0;
		(a[15] => z[27]) = 0;
		(a[16] => z[27]) = 0;
		(a[17] => z[27]) = 0;
		(a[18] => z[27]) = 0;
		(a[19] => z[27]) = 0;
		(b[0] => z[27]) = 0;
		(b[1] => z[27]) = 0;
		(b[2] => z[27]) = 0;
		(b[3] => z[27]) = 0;
		(b[4] => z[27]) = 0;
		(b[5] => z[27]) = 0;
		(b[6] => z[27]) = 0;
		(b[7] => z[27]) = 0;
		(b[8] => z[27]) = 0;
		(b[9] => z[27]) = 0;
		(b[10] => z[27]) = 0;
		(b[11] => z[27]) = 0;
		(b[12] => z[27]) = 0;
		(b[13] => z[27]) = 0;
		(b[14] => z[27]) = 0;
		(b[15] => z[27]) = 0;
		(b[16] => z[27]) = 0;
		(b[17] => z[27]) = 0;
		(a[0] => z[28]) = 0;
		(a[1] => z[28]) = 0;
		(a[2] => z[28]) = 0;
		(a[3] => z[28]) = 0;
		(a[4] => z[28]) = 0;
		(a[5] => z[28]) = 0;
		(a[6] => z[28]) = 0;
		(a[7] => z[28]) = 0;
		(a[8] => z[28]) = 0;
		(a[9] => z[28]) = 0;
		(a[10] => z[28]) = 0;
		(a[11] => z[28]) = 0;
		(a[12] => z[28]) = 0;
		(a[13] => z[28]) = 0;
		(a[14] => z[28]) = 0;
		(a[15] => z[28]) = 0;
		(a[16] => z[28]) = 0;
		(a[17] => z[28]) = 0;
		(a[18] => z[28]) = 0;
		(a[19] => z[28]) = 0;
		(b[0] => z[28]) = 0;
		(b[1] => z[28]) = 0;
		(b[2] => z[28]) = 0;
		(b[3] => z[28]) = 0;
		(b[4] => z[28]) = 0;
		(b[5] => z[28]) = 0;
		(b[6] => z[28]) = 0;
		(b[7] => z[28]) = 0;
		(b[8] => z[28]) = 0;
		(b[9] => z[28]) = 0;
		(b[10] => z[28]) = 0;
		(b[11] => z[28]) = 0;
		(b[12] => z[28]) = 0;
		(b[13] => z[28]) = 0;
		(b[14] => z[28]) = 0;
		(b[15] => z[28]) = 0;
		(b[16] => z[28]) = 0;
		(b[17] => z[28]) = 0;
		(a[0] => z[29]) = 0;
		(a[1] => z[29]) = 0;
		(a[2] => z[29]) = 0;
		(a[3] => z[29]) = 0;
		(a[4] => z[29]) = 0;
		(a[5] => z[29]) = 0;
		(a[6] => z[29]) = 0;
		(a[7] => z[29]) = 0;
		(a[8] => z[29]) = 0;
		(a[9] => z[29]) = 0;
		(a[10] => z[29]) = 0;
		(a[11] => z[29]) = 0;
		(a[12] => z[29]) = 0;
		(a[13] => z[29]) = 0;
		(a[14] => z[29]) = 0;
		(a[15] => z[29]) = 0;
		(a[16] => z[29]) = 0;
		(a[17] => z[29]) = 0;
		(a[18] => z[29]) = 0;
		(a[19] => z[29]) = 0;
		(b[0] => z[29]) = 0;
		(b[1] => z[29]) = 0;
		(b[2] => z[29]) = 0;
		(b[3] => z[29]) = 0;
		(b[4] => z[29]) = 0;
		(b[5] => z[29]) = 0;
		(b[6] => z[29]) = 0;
		(b[7] => z[29]) = 0;
		(b[8] => z[29]) = 0;
		(b[9] => z[29]) = 0;
		(b[10] => z[29]) = 0;
		(b[11] => z[29]) = 0;
		(b[12] => z[29]) = 0;
		(b[13] => z[29]) = 0;
		(b[14] => z[29]) = 0;
		(b[15] => z[29]) = 0;
		(b[16] => z[29]) = 0;
		(b[17] => z[29]) = 0;
		(a[0] => z[30]) = 0;
		(a[1] => z[30]) = 0;
		(a[2] => z[30]) = 0;
		(a[3] => z[30]) = 0;
		(a[4] => z[30]) = 0;
		(a[5] => z[30]) = 0;
		(a[6] => z[30]) = 0;
		(a[7] => z[30]) = 0;
		(a[8] => z[30]) = 0;
		(a[9] => z[30]) = 0;
		(a[10] => z[30]) = 0;
		(a[11] => z[30]) = 0;
		(a[12] => z[30]) = 0;
		(a[13] => z[30]) = 0;
		(a[14] => z[30]) = 0;
		(a[15] => z[30]) = 0;
		(a[16] => z[30]) = 0;
		(a[17] => z[30]) = 0;
		(a[18] => z[30]) = 0;
		(a[19] => z[30]) = 0;
		(b[0] => z[30]) = 0;
		(b[1] => z[30]) = 0;
		(b[2] => z[30]) = 0;
		(b[3] => z[30]) = 0;
		(b[4] => z[30]) = 0;
		(b[5] => z[30]) = 0;
		(b[6] => z[30]) = 0;
		(b[7] => z[30]) = 0;
		(b[8] => z[30]) = 0;
		(b[9] => z[30]) = 0;
		(b[10] => z[30]) = 0;
		(b[11] => z[30]) = 0;
		(b[12] => z[30]) = 0;
		(b[13] => z[30]) = 0;
		(b[14] => z[30]) = 0;
		(b[15] => z[30]) = 0;
		(b[16] => z[30]) = 0;
		(b[17] => z[30]) = 0;
		(a[0] => z[31]) = 0;
		(a[1] => z[31]) = 0;
		(a[2] => z[31]) = 0;
		(a[3] => z[31]) = 0;
		(a[4] => z[31]) = 0;
		(a[5] => z[31]) = 0;
		(a[6] => z[31]) = 0;
		(a[7] => z[31]) = 0;
		(a[8] => z[31]) = 0;
		(a[9] => z[31]) = 0;
		(a[10] => z[31]) = 0;
		(a[11] => z[31]) = 0;
		(a[12] => z[31]) = 0;
		(a[13] => z[31]) = 0;
		(a[14] => z[31]) = 0;
		(a[15] => z[31]) = 0;
		(a[16] => z[31]) = 0;
		(a[17] => z[31]) = 0;
		(a[18] => z[31]) = 0;
		(a[19] => z[31]) = 0;
		(b[0] => z[31]) = 0;
		(b[1] => z[31]) = 0;
		(b[2] => z[31]) = 0;
		(b[3] => z[31]) = 0;
		(b[4] => z[31]) = 0;
		(b[5] => z[31]) = 0;
		(b[6] => z[31]) = 0;
		(b[7] => z[31]) = 0;
		(b[8] => z[31]) = 0;
		(b[9] => z[31]) = 0;
		(b[10] => z[31]) = 0;
		(b[11] => z[31]) = 0;
		(b[12] => z[31]) = 0;
		(b[13] => z[31]) = 0;
		(b[14] => z[31]) = 0;
		(b[15] => z[31]) = 0;
		(b[16] => z[31]) = 0;
		(b[17] => z[31]) = 0;
		(a[0] => z[32]) = 0;
		(a[1] => z[32]) = 0;
		(a[2] => z[32]) = 0;
		(a[3] => z[32]) = 0;
		(a[4] => z[32]) = 0;
		(a[5] => z[32]) = 0;
		(a[6] => z[32]) = 0;
		(a[7] => z[32]) = 0;
		(a[8] => z[32]) = 0;
		(a[9] => z[32]) = 0;
		(a[10] => z[32]) = 0;
		(a[11] => z[32]) = 0;
		(a[12] => z[32]) = 0;
		(a[13] => z[32]) = 0;
		(a[14] => z[32]) = 0;
		(a[15] => z[32]) = 0;
		(a[16] => z[32]) = 0;
		(a[17] => z[32]) = 0;
		(a[18] => z[32]) = 0;
		(a[19] => z[32]) = 0;
		(b[0] => z[32]) = 0;
		(b[1] => z[32]) = 0;
		(b[2] => z[32]) = 0;
		(b[3] => z[32]) = 0;
		(b[4] => z[32]) = 0;
		(b[5] => z[32]) = 0;
		(b[6] => z[32]) = 0;
		(b[7] => z[32]) = 0;
		(b[8] => z[32]) = 0;
		(b[9] => z[32]) = 0;
		(b[10] => z[32]) = 0;
		(b[11] => z[32]) = 0;
		(b[12] => z[32]) = 0;
		(b[13] => z[32]) = 0;
		(b[14] => z[32]) = 0;
		(b[15] => z[32]) = 0;
		(b[16] => z[32]) = 0;
		(b[17] => z[32]) = 0;
		(a[0] => z[33]) = 0;
		(a[1] => z[33]) = 0;
		(a[2] => z[33]) = 0;
		(a[3] => z[33]) = 0;
		(a[4] => z[33]) = 0;
		(a[5] => z[33]) = 0;
		(a[6] => z[33]) = 0;
		(a[7] => z[33]) = 0;
		(a[8] => z[33]) = 0;
		(a[9] => z[33]) = 0;
		(a[10] => z[33]) = 0;
		(a[11] => z[33]) = 0;
		(a[12] => z[33]) = 0;
		(a[13] => z[33]) = 0;
		(a[14] => z[33]) = 0;
		(a[15] => z[33]) = 0;
		(a[16] => z[33]) = 0;
		(a[17] => z[33]) = 0;
		(a[18] => z[33]) = 0;
		(a[19] => z[33]) = 0;
		(b[0] => z[33]) = 0;
		(b[1] => z[33]) = 0;
		(b[2] => z[33]) = 0;
		(b[3] => z[33]) = 0;
		(b[4] => z[33]) = 0;
		(b[5] => z[33]) = 0;
		(b[6] => z[33]) = 0;
		(b[7] => z[33]) = 0;
		(b[8] => z[33]) = 0;
		(b[9] => z[33]) = 0;
		(b[10] => z[33]) = 0;
		(b[11] => z[33]) = 0;
		(b[12] => z[33]) = 0;
		(b[13] => z[33]) = 0;
		(b[14] => z[33]) = 0;
		(b[15] => z[33]) = 0;
		(b[16] => z[33]) = 0;
		(b[17] => z[33]) = 0;
		(a[0] => z[34]) = 0;
		(a[1] => z[34]) = 0;
		(a[2] => z[34]) = 0;
		(a[3] => z[34]) = 0;
		(a[4] => z[34]) = 0;
		(a[5] => z[34]) = 0;
		(a[6] => z[34]) = 0;
		(a[7] => z[34]) = 0;
		(a[8] => z[34]) = 0;
		(a[9] => z[34]) = 0;
		(a[10] => z[34]) = 0;
		(a[11] => z[34]) = 0;
		(a[12] => z[34]) = 0;
		(a[13] => z[34]) = 0;
		(a[14] => z[34]) = 0;
		(a[15] => z[34]) = 0;
		(a[16] => z[34]) = 0;
		(a[17] => z[34]) = 0;
		(a[18] => z[34]) = 0;
		(a[19] => z[34]) = 0;
		(b[0] => z[34]) = 0;
		(b[1] => z[34]) = 0;
		(b[2] => z[34]) = 0;
		(b[3] => z[34]) = 0;
		(b[4] => z[34]) = 0;
		(b[5] => z[34]) = 0;
		(b[6] => z[34]) = 0;
		(b[7] => z[34]) = 0;
		(b[8] => z[34]) = 0;
		(b[9] => z[34]) = 0;
		(b[10] => z[34]) = 0;
		(b[11] => z[34]) = 0;
		(b[12] => z[34]) = 0;
		(b[13] => z[34]) = 0;
		(b[14] => z[34]) = 0;
		(b[15] => z[34]) = 0;
		(b[16] => z[34]) = 0;
		(b[17] => z[34]) = 0;
		(a[0] => z[35]) = 0;
		(a[1] => z[35]) = 0;
		(a[2] => z[35]) = 0;
		(a[3] => z[35]) = 0;
		(a[4] => z[35]) = 0;
		(a[5] => z[35]) = 0;
		(a[6] => z[35]) = 0;
		(a[7] => z[35]) = 0;
		(a[8] => z[35]) = 0;
		(a[9] => z[35]) = 0;
		(a[10] => z[35]) = 0;
		(a[11] => z[35]) = 0;
		(a[12] => z[35]) = 0;
		(a[13] => z[35]) = 0;
		(a[14] => z[35]) = 0;
		(a[15] => z[35]) = 0;
		(a[16] => z[35]) = 0;
		(a[17] => z[35]) = 0;
		(a[18] => z[35]) = 0;
		(a[19] => z[35]) = 0;
		(b[0] => z[35]) = 0;
		(b[1] => z[35]) = 0;
		(b[2] => z[35]) = 0;
		(b[3] => z[35]) = 0;
		(b[4] => z[35]) = 0;
		(b[5] => z[35]) = 0;
		(b[6] => z[35]) = 0;
		(b[7] => z[35]) = 0;
		(b[8] => z[35]) = 0;
		(b[9] => z[35]) = 0;
		(b[10] => z[35]) = 0;
		(b[11] => z[35]) = 0;
		(b[12] => z[35]) = 0;
		(b[13] => z[35]) = 0;
		(b[14] => z[35]) = 0;
		(b[15] => z[35]) = 0;
		(b[16] => z[35]) = 0;
		(b[17] => z[35]) = 0;
		(a[0] => z[36]) = 0;
		(a[1] => z[36]) = 0;
		(a[2] => z[36]) = 0;
		(a[3] => z[36]) = 0;
		(a[4] => z[36]) = 0;
		(a[5] => z[36]) = 0;
		(a[6] => z[36]) = 0;
		(a[7] => z[36]) = 0;
		(a[8] => z[36]) = 0;
		(a[9] => z[36]) = 0;
		(a[10] => z[36]) = 0;
		(a[11] => z[36]) = 0;
		(a[12] => z[36]) = 0;
		(a[13] => z[36]) = 0;
		(a[14] => z[36]) = 0;
		(a[15] => z[36]) = 0;
		(a[16] => z[36]) = 0;
		(a[17] => z[36]) = 0;
		(a[18] => z[36]) = 0;
		(a[19] => z[36]) = 0;
		(b[0] => z[36]) = 0;
		(b[1] => z[36]) = 0;
		(b[2] => z[36]) = 0;
		(b[3] => z[36]) = 0;
		(b[4] => z[36]) = 0;
		(b[5] => z[36]) = 0;
		(b[6] => z[36]) = 0;
		(b[7] => z[36]) = 0;
		(b[8] => z[36]) = 0;
		(b[9] => z[36]) = 0;
		(b[10] => z[36]) = 0;
		(b[11] => z[36]) = 0;
		(b[12] => z[36]) = 0;
		(b[13] => z[36]) = 0;
		(b[14] => z[36]) = 0;
		(b[15] => z[36]) = 0;
		(b[16] => z[36]) = 0;
		(b[17] => z[36]) = 0;
		(a[0] => z[37]) = 0;
		(a[1] => z[37]) = 0;
		(a[2] => z[37]) = 0;
		(a[3] => z[37]) = 0;
		(a[4] => z[37]) = 0;
		(a[5] => z[37]) = 0;
		(a[6] => z[37]) = 0;
		(a[7] => z[37]) = 0;
		(a[8] => z[37]) = 0;
		(a[9] => z[37]) = 0;
		(a[10] => z[37]) = 0;
		(a[11] => z[37]) = 0;
		(a[12] => z[37]) = 0;
		(a[13] => z[37]) = 0;
		(a[14] => z[37]) = 0;
		(a[15] => z[37]) = 0;
		(a[16] => z[37]) = 0;
		(a[17] => z[37]) = 0;
		(a[18] => z[37]) = 0;
		(a[19] => z[37]) = 0;
		(b[0] => z[37]) = 0;
		(b[1] => z[37]) = 0;
		(b[2] => z[37]) = 0;
		(b[3] => z[37]) = 0;
		(b[4] => z[37]) = 0;
		(b[5] => z[37]) = 0;
		(b[6] => z[37]) = 0;
		(b[7] => z[37]) = 0;
		(b[8] => z[37]) = 0;
		(b[9] => z[37]) = 0;
		(b[10] => z[37]) = 0;
		(b[11] => z[37]) = 0;
		(b[12] => z[37]) = 0;
		(b[13] => z[37]) = 0;
		(b[14] => z[37]) = 0;
		(b[15] => z[37]) = 0;
		(b[16] => z[37]) = 0;
		(b[17] => z[37]) = 0;
		(subtract => z[0]) = 0;
		(subtract => z[1]) = 0;
		(subtract => z[2]) = 0;
		(subtract => z[3]) = 0;
		(subtract => z[4]) = 0;
		(subtract => z[5]) = 0;
		(subtract => z[6]) = 0;
		(subtract => z[7]) = 0;
		(subtract => z[8]) = 0;
		(subtract => z[9]) = 0;
		(subtract => z[10]) = 0;
		(subtract => z[11]) = 0;
		(subtract => z[12]) = 0;
		(subtract => z[13]) = 0;
		(subtract => z[14]) = 0;
		(subtract => z[15]) = 0;
		(subtract => z[16]) = 0;
		(subtract => z[17]) = 0;
		(subtract => z[18]) = 0;
		(subtract => z[19]) = 0;
		(subtract => z[20]) = 0;
		(subtract => z[21]) = 0;
		(subtract => z[22]) = 0;
		(subtract => z[23]) = 0;
		(subtract => z[24]) = 0;
		(subtract => z[25]) = 0;
		(subtract => z[26]) = 0;
		(subtract => z[27]) = 0;
		(subtract => z[28]) = 0;
		(subtract => z[29]) = 0;
		(subtract => z[30]) = 0;
		(subtract => z[31]) = 0;
		(subtract => z[32]) = 0;
		(subtract => z[33]) = 0;
		(subtract => z[34]) = 0;
		(subtract => z[35]) = 0;
		(subtract => z[36]) = 0;
		(subtract => z[37]) = 0;
		(acc_fir[0] => z[0]) = 0;
		(acc_fir[1] => z[0]) = 0;
		(acc_fir[2] => z[0]) = 0;
		(acc_fir[3] => z[0]) = 0;
		(acc_fir[4] => z[0]) = 0;
		(acc_fir[5] => z[0]) = 0;
		(acc_fir[0] => z[1]) = 0;
		(acc_fir[1] => z[1]) = 0;
		(acc_fir[2] => z[1]) = 0;
		(acc_fir[3] => z[1]) = 0;
		(acc_fir[4] => z[1]) = 0;
		(acc_fir[5] => z[1]) = 0;
		(acc_fir[0] => z[2]) = 0;
		(acc_fir[1] => z[2]) = 0;
		(acc_fir[2] => z[2]) = 0;
		(acc_fir[3] => z[2]) = 0;
		(acc_fir[4] => z[2]) = 0;
		(acc_fir[5] => z[2]) = 0;
		(acc_fir[0] => z[3]) = 0;
		(acc_fir[1] => z[3]) = 0;
		(acc_fir[2] => z[3]) = 0;
		(acc_fir[3] => z[3]) = 0;
		(acc_fir[4] => z[3]) = 0;
		(acc_fir[5] => z[3]) = 0;
		(acc_fir[0] => z[4]) = 0;
		(acc_fir[1] => z[4]) = 0;
		(acc_fir[2] => z[4]) = 0;
		(acc_fir[3] => z[4]) = 0;
		(acc_fir[4] => z[4]) = 0;
		(acc_fir[5] => z[4]) = 0;
		(acc_fir[0] => z[5]) = 0;
		(acc_fir[1] => z[5]) = 0;
		(acc_fir[2] => z[5]) = 0;
		(acc_fir[3] => z[5]) = 0;
		(acc_fir[4] => z[5]) = 0;
		(acc_fir[5] => z[5]) = 0;
		(acc_fir[0] => z[6]) = 0;
		(acc_fir[1] => z[6]) = 0;
		(acc_fir[2] => z[6]) = 0;
		(acc_fir[3] => z[6]) = 0;
		(acc_fir[4] => z[6]) = 0;
		(acc_fir[5] => z[6]) = 0;
		(acc_fir[0] => z[7]) = 0;
		(acc_fir[1] => z[7]) = 0;
		(acc_fir[2] => z[7]) = 0;
		(acc_fir[3] => z[7]) = 0;
		(acc_fir[4] => z[7]) = 0;
		(acc_fir[5] => z[7]) = 0;
		(acc_fir[0] => z[8]) = 0;
		(acc_fir[1] => z[8]) = 0;
		(acc_fir[2] => z[8]) = 0;
		(acc_fir[3] => z[8]) = 0;
		(acc_fir[4] => z[8]) = 0;
		(acc_fir[5] => z[8]) = 0;
		(acc_fir[0] => z[9]) = 0;
		(acc_fir[1] => z[9]) = 0;
		(acc_fir[2] => z[9]) = 0;
		(acc_fir[3] => z[9]) = 0;
		(acc_fir[4] => z[9]) = 0;
		(acc_fir[5] => z[9]) = 0;
		(acc_fir[0] => z[10]) = 0;
		(acc_fir[1] => z[10]) = 0;
		(acc_fir[2] => z[10]) = 0;
		(acc_fir[3] => z[10]) = 0;
		(acc_fir[4] => z[10]) = 0;
		(acc_fir[5] => z[10]) = 0;
		(acc_fir[0] => z[11]) = 0;
		(acc_fir[1] => z[11]) = 0;
		(acc_fir[2] => z[11]) = 0;
		(acc_fir[3] => z[11]) = 0;
		(acc_fir[4] => z[11]) = 0;
		(acc_fir[5] => z[11]) = 0;
		(acc_fir[0] => z[12]) = 0;
		(acc_fir[1] => z[12]) = 0;
		(acc_fir[2] => z[12]) = 0;
		(acc_fir[3] => z[12]) = 0;
		(acc_fir[4] => z[12]) = 0;
		(acc_fir[5] => z[12]) = 0;
		(acc_fir[0] => z[13]) = 0;
		(acc_fir[1] => z[13]) = 0;
		(acc_fir[2] => z[13]) = 0;
		(acc_fir[3] => z[13]) = 0;
		(acc_fir[4] => z[13]) = 0;
		(acc_fir[5] => z[13]) = 0;
		(acc_fir[0] => z[14]) = 0;
		(acc_fir[1] => z[14]) = 0;
		(acc_fir[2] => z[14]) = 0;
		(acc_fir[3] => z[14]) = 0;
		(acc_fir[4] => z[14]) = 0;
		(acc_fir[5] => z[14]) = 0;
		(acc_fir[0] => z[15]) = 0;
		(acc_fir[1] => z[15]) = 0;
		(acc_fir[2] => z[15]) = 0;
		(acc_fir[3] => z[15]) = 0;
		(acc_fir[4] => z[15]) = 0;
		(acc_fir[5] => z[15]) = 0;
		(acc_fir[0] => z[16]) = 0;
		(acc_fir[1] => z[16]) = 0;
		(acc_fir[2] => z[16]) = 0;
		(acc_fir[3] => z[16]) = 0;
		(acc_fir[4] => z[16]) = 0;
		(acc_fir[5] => z[16]) = 0;
		(acc_fir[0] => z[17]) = 0;
		(acc_fir[1] => z[17]) = 0;
		(acc_fir[2] => z[17]) = 0;
		(acc_fir[3] => z[17]) = 0;
		(acc_fir[4] => z[17]) = 0;
		(acc_fir[5] => z[17]) = 0;
		(acc_fir[0] => z[18]) = 0;
		(acc_fir[1] => z[18]) = 0;
		(acc_fir[2] => z[18]) = 0;
		(acc_fir[3] => z[18]) = 0;
		(acc_fir[4] => z[18]) = 0;
		(acc_fir[5] => z[18]) = 0;
		(acc_fir[0] => z[19]) = 0;
		(acc_fir[1] => z[19]) = 0;
		(acc_fir[2] => z[19]) = 0;
		(acc_fir[3] => z[19]) = 0;
		(acc_fir[4] => z[19]) = 0;
		(acc_fir[5] => z[19]) = 0;
		(acc_fir[0] => z[20]) = 0;
		(acc_fir[1] => z[20]) = 0;
		(acc_fir[2] => z[20]) = 0;
		(acc_fir[3] => z[20]) = 0;
		(acc_fir[4] => z[20]) = 0;
		(acc_fir[5] => z[20]) = 0;
		(acc_fir[0] => z[21]) = 0;
		(acc_fir[1] => z[21]) = 0;
		(acc_fir[2] => z[21]) = 0;
		(acc_fir[3] => z[21]) = 0;
		(acc_fir[4] => z[21]) = 0;
		(acc_fir[5] => z[21]) = 0;
		(acc_fir[0] => z[22]) = 0;
		(acc_fir[1] => z[22]) = 0;
		(acc_fir[2] => z[22]) = 0;
		(acc_fir[3] => z[22]) = 0;
		(acc_fir[4] => z[22]) = 0;
		(acc_fir[5] => z[22]) = 0;
		(acc_fir[0] => z[23]) = 0;
		(acc_fir[1] => z[23]) = 0;
		(acc_fir[2] => z[23]) = 0;
		(acc_fir[3] => z[23]) = 0;
		(acc_fir[4] => z[23]) = 0;
		(acc_fir[5] => z[23]) = 0;
		(acc_fir[0] => z[24]) = 0;
		(acc_fir[1] => z[24]) = 0;
		(acc_fir[2] => z[24]) = 0;
		(acc_fir[3] => z[24]) = 0;
		(acc_fir[4] => z[24]) = 0;
		(acc_fir[5] => z[24]) = 0;
		(acc_fir[0] => z[25]) = 0;
		(acc_fir[1] => z[25]) = 0;
		(acc_fir[2] => z[25]) = 0;
		(acc_fir[3] => z[25]) = 0;
		(acc_fir[4] => z[25]) = 0;
		(acc_fir[5] => z[25]) = 0;
		(acc_fir[0] => z[26]) = 0;
		(acc_fir[1] => z[26]) = 0;
		(acc_fir[2] => z[26]) = 0;
		(acc_fir[3] => z[26]) = 0;
		(acc_fir[4] => z[26]) = 0;
		(acc_fir[5] => z[26]) = 0;
		(acc_fir[0] => z[27]) = 0;
		(acc_fir[1] => z[27]) = 0;
		(acc_fir[2] => z[27]) = 0;
		(acc_fir[3] => z[27]) = 0;
		(acc_fir[4] => z[27]) = 0;
		(acc_fir[5] => z[27]) = 0;
		(acc_fir[0] => z[28]) = 0;
		(acc_fir[1] => z[28]) = 0;
		(acc_fir[2] => z[28]) = 0;
		(acc_fir[3] => z[28]) = 0;
		(acc_fir[4] => z[28]) = 0;
		(acc_fir[5] => z[28]) = 0;
		(acc_fir[0] => z[29]) = 0;
		(acc_fir[1] => z[29]) = 0;
		(acc_fir[2] => z[29]) = 0;
		(acc_fir[3] => z[29]) = 0;
		(acc_fir[4] => z[29]) = 0;
		(acc_fir[5] => z[29]) = 0;
		(acc_fir[0] => z[30]) = 0;
		(acc_fir[1] => z[30]) = 0;
		(acc_fir[2] => z[30]) = 0;
		(acc_fir[3] => z[30]) = 0;
		(acc_fir[4] => z[30]) = 0;
		(acc_fir[5] => z[30]) = 0;
		(acc_fir[0] => z[31]) = 0;
		(acc_fir[1] => z[31]) = 0;
		(acc_fir[2] => z[31]) = 0;
		(acc_fir[3] => z[31]) = 0;
		(acc_fir[4] => z[31]) = 0;
		(acc_fir[5] => z[31]) = 0;
		(acc_fir[0] => z[32]) = 0;
		(acc_fir[1] => z[32]) = 0;
		(acc_fir[2] => z[32]) = 0;
		(acc_fir[3] => z[32]) = 0;
		(acc_fir[4] => z[32]) = 0;
		(acc_fir[5] => z[32]) = 0;
		(acc_fir[0] => z[33]) = 0;
		(acc_fir[1] => z[33]) = 0;
		(acc_fir[2] => z[33]) = 0;
		(acc_fir[3] => z[33]) = 0;
		(acc_fir[4] => z[33]) = 0;
		(acc_fir[5] => z[33]) = 0;
		(acc_fir[0] => z[34]) = 0;
		(acc_fir[1] => z[34]) = 0;
		(acc_fir[2] => z[34]) = 0;
		(acc_fir[3] => z[34]) = 0;
		(acc_fir[4] => z[34]) = 0;
		(acc_fir[5] => z[34]) = 0;
		(acc_fir[0] => z[35]) = 0;
		(acc_fir[1] => z[35]) = 0;
		(acc_fir[2] => z[35]) = 0;
		(acc_fir[3] => z[35]) = 0;
		(acc_fir[4] => z[35]) = 0;
		(acc_fir[5] => z[35]) = 0;
		(acc_fir[0] => z[36]) = 0;
		(acc_fir[1] => z[36]) = 0;
		(acc_fir[2] => z[36]) = 0;
		(acc_fir[3] => z[36]) = 0;
		(acc_fir[4] => z[36]) = 0;
		(acc_fir[5] => z[36]) = 0;
		(acc_fir[0] => z[37]) = 0;
		(acc_fir[1] => z[37]) = 0;
		(acc_fir[2] => z[37]) = 0;
		(acc_fir[3] => z[37]) = 0;
		(acc_fir[4] => z[37]) = 0;
		(acc_fir[5] => z[37]) = 0;
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGIN (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCin (2, 3)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCin (6, 7)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGIN_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCin (6, 7)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire        load_acc,
	input  wire [ 2:0] feedback,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCout (1)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGIN (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCout (1)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCout (5)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGIN_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCout (5)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module dsp_t1_20x18x64_cfg_ports (
	input  wire [19:0] a_i,
	input  wire [17:0] b_i,
	input  wire [ 5:0] acc_fir_i,
	output wire [37:0] z_o,
	output wire [17:0] dly_b_o,

	(* clkbuf_sink *)
	input  wire        clock_i,
	input  wire        reset_i,

	input  wire [ 2:0] feedback_i,
	input  wire        load_acc_i,
	input  wire        unsigned_a_i,
	input  wire        unsigned_b_i,

	input  wire [ 2:0] output_select_i,
	input  wire        saturate_enable_i,
	input  wire [ 5:0] shift_right_i,
	input  wire        round_i,
	input  wire        subtract_i,
	input  wire        register_inputs_i
);

	parameter [19:0] COEFF_0 = 20'd0;
	parameter [19:0] COEFF_1 = 20'd0;
	parameter [19:0] COEFF_2 = 20'd0;
	parameter [19:0] COEFF_3 = 20'd0;

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a_i),
		.b(b_i),
		.z(z_o),
		.dly_b(dly_b_o),

		.f_mode(1'b0),  // 20x18x64 DSP

		.acc_fir(acc_fir_i),
		.feedback(feedback_i),
		.load_acc(load_acc_i),

		.unsigned_a(unsigned_a_i),
		.unsigned_b(unsigned_b_i),

		.clk(clock_i),
		.reset(reset_i),

		.saturate_enable(saturate_enable_i),
		.output_select(output_select_i),
		.round(round_i),
		.shift_right(shift_right_i),
		.subtract(subtract_i),
		.register_inputs(register_inputs_i)
	);
endmodule

module dsp_t1_10x9x32_cfg_ports (
	input  wire [ 9:0] a_i,
	input  wire [ 8:0] b_i,
	input  wire [ 5:0] acc_fir_i,
	output wire [18:0] z_o,
	output wire [ 8:0] dly_b_o,

	(* clkbuf_sink *)
	input  wire        clock_i,
	input  wire        reset_i,

	input  wire [ 2:0] feedback_i,
	input  wire        load_acc_i,
	input  wire        unsigned_a_i,
	input  wire        unsigned_b_i,

	input  wire [ 2:0] output_select_i,
	input  wire        saturate_enable_i,
	input  wire [ 5:0] shift_right_i,
	input  wire        round_i,
	input  wire        subtract_i,
	input  wire        register_inputs_i
);

	parameter [9:0] COEFF_0 = 10'd0;
	parameter [9:0] COEFF_1 = 10'd0;
	parameter [9:0] COEFF_2 = 10'd0;
	parameter [9:0] COEFF_3 = 10'd0;

	wire [18:0] z_rem;
	wire [8:0] dly_b_rem;

	QL_DSP2 #(
		.MODE_BITS({10'd0, COEFF_3,
					10'd0, COEFF_2,
					10'd0, COEFF_1,
					10'd0, COEFF_0})
	) dsp (
		.a({10'd0, a_i}),
		.b({9'd0, b_i}),
		.z({z_rem, z_o}),
		.dly_b({dly_b_rem, dly_b_o}),

		.f_mode(1'b1),  // 10x9x32 DSP

		.acc_fir(acc_fir_i),
		.feedback(feedback_i),
		.load_acc(load_acc_i),

		.unsigned_a(unsigned_a_i),
		.unsigned_b(unsigned_b_i),

		.clk(clock_i),
		.reset(reset_i),

		.saturate_enable(saturate_enable_i),
		.output_select(output_select_i),
		.round(round_i),
		.shift_right(shift_right_i),
		.subtract(subtract_i),
		.register_inputs(register_inputs_i)
	);
endmodule

module dsp_t1_sim_cfg_ports # (
	parameter NBITS_ACC  = 64,
	parameter NBITS_A    = 20,
	parameter NBITS_B    = 18,
	parameter NBITS_Z    = 38
)(
	input  wire [NBITS_A-1:0] a_i,
	input  wire [NBITS_B-1:0] b_i,
	output wire [NBITS_Z-1:0] z_o,
	output reg  [NBITS_B-1:0] dly_b_o,

	input  wire [5:0]         acc_fir_i,
	input  wire [2:0]         feedback_i,
	input  wire               load_acc_i,

	input  wire               unsigned_a_i,
	input  wire               unsigned_b_i,

	input  wire               clock_i,
	input  wire               s_reset,

	input  wire               saturate_enable_i,
	input  wire [2:0]         output_select_i,
	input  wire               round_i,
	input  wire [5:0]         shift_right_i,
	input  wire               subtract_i,
	input  wire               register_inputs_i,
	input  wire [NBITS_A-1:0] coef_0_i,
	input  wire [NBITS_A-1:0] coef_1_i,
	input  wire [NBITS_A-1:0] coef_2_i,
	input  wire [NBITS_A-1:0] coef_3_i
);

// FIXME: The version of Icarus Verilog from Conda seems not to recognize the
// $error macro. Disable this sanity check for now because of that.


	// Input registers
	reg  [NBITS_A-1:0]  r_a;
	reg  [NBITS_B-1:0]  r_b;
	reg  [5:0]          r_acc_fir;
	reg                 r_unsigned_a;
	reg                 r_unsigned_b;
	reg                 r_load_acc;
	reg  [2:0]          r_feedback;
	reg  [5:0]          r_shift_d1;
	reg  [5:0]          r_shift_d2;
	reg         r_subtract;
	reg         r_sat;
	reg         r_rnd;
	reg [NBITS_ACC-1:0] acc;

	initial begin
		r_a          <= 0;
		r_b          <= 0;

		r_acc_fir    <= 0;
		r_unsigned_a <= 0;
		r_unsigned_b <= 0;
		r_feedback   <= 0;
		r_shift_d1   <= 0;
		r_shift_d2   <= 0;
		r_subtract   <= 0;
		r_load_acc   <= 0;
		r_sat        <= 0;
		r_rnd        <= 0;
	end

	always @(posedge clock_i or posedge s_reset) begin
		if (s_reset) begin

			r_a <= 'h0;
			r_b <= 'h0;

			r_acc_fir    <= 0;
			r_unsigned_a <= 0;
			r_unsigned_b <= 0;
			r_feedback   <= 0;
			r_shift_d1   <= 0;
			r_shift_d2   <= 0;
			r_subtract   <= 0;
			r_load_acc   <= 0;
			r_sat    <= 0;
			r_rnd    <= 0;

		end else begin

			r_a <= a_i;
			r_b <= b_i;

			r_acc_fir    <= acc_fir_i;
			r_unsigned_a <= unsigned_a_i;
			r_unsigned_b <= unsigned_b_i;
			r_feedback   <= feedback_i;
			r_shift_d1   <= shift_right_i;
			r_shift_d2   <= r_shift_d1;
			r_subtract   <= subtract_i;
			r_load_acc   <= load_acc_i;
			r_sat    <= r_sat;
			r_rnd    <= r_rnd;

		end
	end

	// Registered / non-registered input path select
	wire [NBITS_A-1:0]  a = register_inputs_i ? r_a : a_i;
	wire [NBITS_B-1:0]  b = register_inputs_i ? r_b : b_i;

	wire [5:0] acc_fir = register_inputs_i ? r_acc_fir : acc_fir_i;
	wire       unsigned_a = register_inputs_i ? r_unsigned_a : unsigned_a_i;
	wire       unsigned_b = register_inputs_i ? r_unsigned_b : unsigned_b_i;
	wire [2:0] feedback   = register_inputs_i ? r_feedback   : feedback_i;
	wire       load_acc   = register_inputs_i ? r_load_acc   : load_acc_i;
	wire       subtract   = register_inputs_i ? r_subtract   : subtract_i;
	wire       sat    = register_inputs_i ? r_sat : saturate_enable_i;
	wire       rnd    = register_inputs_i ? r_rnd : round_i;

	// Shift right control
	wire [5:0] shift_d1 = register_inputs_i ? r_shift_d1 : shift_right_i;
	wire [5:0] shift_d2 = output_select_i[1] ? shift_d1 : r_shift_d2;

	// Multiplier
	wire unsigned_mode = unsigned_a & unsigned_b;
	wire [NBITS_A-1:0] mult_a;
	assign mult_a = (feedback == 3'h0) ?   a :
					(feedback == 3'h1) ?   a :
					(feedback == 3'h2) ?   a :
					(feedback == 3'h3) ?   acc[NBITS_A-1:0] :
					(feedback == 3'h4) ?   coef_0_i :
					(feedback == 3'h5) ?   coef_1_i :
					(feedback == 3'h6) ?   coef_2_i :
					   coef_3_i;    // if feedback == 3'h7

	wire [NBITS_B-1:0] mult_b = (feedback == 2'h2) ? {NBITS_B{1'b0}}  : b;

	wire [NBITS_A-1:0] mult_sgn_a = mult_a[NBITS_A-1];
	wire [NBITS_A-1:0] mult_mag_a = (mult_sgn_a && !unsigned_a) ? (~mult_a + 1) : mult_a;
	wire [NBITS_B-1:0] mult_sgn_b = mult_b[NBITS_B-1];
	wire [NBITS_B-1:0] mult_mag_b = (mult_sgn_b && !unsigned_b) ? (~mult_b + 1) : mult_b;

	wire [NBITS_A+NBITS_B-1:0] mult_mag = mult_mag_a * mult_mag_b;
	wire mult_sgn = (mult_sgn_a && !unsigned_a) ^ (mult_sgn_b && !unsigned_b);

	wire [NBITS_A+NBITS_B-1:0] mult = (unsigned_a && unsigned_b) ?
		(mult_a * mult_b) : (mult_sgn ? (~mult_mag + 1) : mult_mag);

	// Sign extension
	wire [NBITS_ACC-1:0] mult_xtnd = unsigned_mode ?
		{{(NBITS_ACC-NBITS_A-NBITS_B){1'b0}},                    mult[NBITS_A+NBITS_B-1:0]} :
		{{(NBITS_ACC-NBITS_A-NBITS_B){mult[NBITS_A+NBITS_B-1]}}, mult[NBITS_A+NBITS_B-1:0]};

	// Adder
	wire [NBITS_ACC-1:0] acc_fir_int = unsigned_a ? {{(NBITS_ACC-NBITS_A){1'b0}},         a} :
													{{(NBITS_ACC-NBITS_A){a[NBITS_A-1]}}, a} ;

	wire [NBITS_ACC-1:0] add_a = (subtract) ? (~mult_xtnd + 1) : mult_xtnd;
	wire [NBITS_ACC-1:0] add_b = (feedback_i == 3'h0) ? acc :
								 (feedback_i == 3'h1) ? {{NBITS_ACC}{1'b0}} : (acc_fir_int << acc_fir);

	wire [NBITS_ACC-1:0] add_o = add_a + add_b;

	// Accumulator
	initial acc <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset) acc <= 'h0;
		else begin
			if (load_acc)
				acc <= add_o;
			else
				acc <= acc;
		end

	// Adder/accumulator output selection
	wire [NBITS_ACC-1:0] acc_out = (output_select_i[1]) ? add_o : acc;

	// Round, shift, saturate
	wire [NBITS_ACC-1:0] acc_rnd = (rnd && (shift_right_i != 0)) ? (acc_out + ({{(NBITS_ACC-1){1'b0}}, 1'b1} << (shift_right_i - 1))) :
																	acc_out;

	wire [NBITS_ACC-1:0] acc_shr = (unsigned_mode) ? (acc_rnd  >> shift_right_i) :
													 (acc_rnd >>> shift_right_i);

	wire [NBITS_ACC-1:0] acc_sat_u = (acc_shr[NBITS_ACC-1:NBITS_Z] != 0) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{NBITS_Z{1'b1}}} :
																		   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}};

	wire [NBITS_ACC-1:0] acc_sat_s = ((|acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b0) ||
									  (&acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b1)) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}} :
																				   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_ACC-1],{NBITS_Z-1{~acc_shr[NBITS_ACC-1]}}}};

	wire [NBITS_ACC-1:0] acc_sat = (sat) ? ((unsigned_mode) ? acc_sat_u : acc_sat_s) : acc_shr;

	// Output signals
	wire [NBITS_Z-1:0]  z0;
	reg  [NBITS_Z-1:0]  z1;
	wire [NBITS_Z-1:0]  z2;

	assign z0 = mult_xtnd[NBITS_Z-1:0];
	assign z2 = acc_sat[NBITS_Z-1:0];

	initial z1 <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset)
			z1 <= 0;
		else begin
			z1 <= (output_select_i == 3'b100) ? z0 : z2;
		end

	// Output mux
	assign z_o = (output_select_i == 3'h0) ?   z0 :
				 (output_select_i == 3'h1) ?   z2 :
				 (output_select_i == 3'h2) ?   z2 :
				 (output_select_i == 3'h3) ?   z2 :
				 (output_select_i == 3'h4) ?   z1 :
				 (output_select_i == 3'h5) ?   z1 :
				 (output_select_i == 3'h6) ?   z1 :
						   z1;  // if output_select_i == 3'h7

	// B input delayed passthrough
	initial dly_b_o <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset)
			dly_b_o <= 0;
		else
			dly_b_o <= b_i;

endmodule
`,"ffs_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

// DFF, asynchronous set/reset, enable
module \\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);
	input  C;
	input  S;
	input  R;
	input  E;
	input  D;
	output Q;
	dffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));
endmodule

module \\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);
	input  C;
	input  S;
	input  R;
	input  E;
	input  D;
	output Q;
	dffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));
endmodule

// DFF, synchronous set or reset, enable
module \\$_SDFFE_PN0P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));
endmodule

module \\$_SDFFE_PN1P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));
endmodule

module \\$_SDFFE_NN0P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));
endmodule

module \\$_SDFFE_NN1P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));
endmodule

// Latch, no set/reset, no enable
module  \\$_DLATCH_P_ (input E, D, output Q);
	latchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));
endmodule

module  \\$_DLATCH_N_ (input E, D, output Q);
	latchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));
endmodule

// Latch with async set and reset and enable
module  \\$_DLATCHSR_PPP_ (input E, S, R, D, output Q);
	latchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));
endmodule

module  \\$_DLATCHSR_NPP_ (input E, S, R, D, output Q);
	latchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));
endmodule

module \\$__SHREG_DFF_P_ (D, Q, C);
	input  D;
	input  C;
	output Q;

	parameter DEPTH = 2;

	reg [DEPTH-2:0] q;

	genvar i;
	generate for (i = 0; i < DEPTH; i = i + 1) begin: slice

		// First in chain
		generate if (i == 0) begin
				 sh_dff #() shreg_beg (
					.Q(q[i]),
					.D(D),
					.C(C)
				);
		end endgenerate
		// Middle in chain
		generate if (i > 0 && i != DEPTH-1) begin
				 sh_dff #() shreg_mid (
					.Q(q[i]),
					.D(q[i-1]),
					.C(C)
				);
		end endgenerate
		// Last in chain
		generate if (i == DEPTH-1) begin
				 sh_dff #() shreg_end (
					.Q(Q),
					.D(q[i-1]),
					.C(C)
				);
		end endgenerate
   end: slice
   endgenerate

endmodule

`,"libmap_brams.txt":`ram block $__QLF_TDP36K {
	init any;
	byte 9;
	option "SPLIT" 0 {
		abits 15;
		widths 1 2 4 9 18 36 per_port;
	}
	option "SPLIT" 1 {
		abits 14;
		widths 1 2 4 9 18 per_port;
	}
	cost 65;
	port srsw "A" "B" {
		width tied;
		clock posedge;
		# wen causes read even when ren is low
		# map clken = wen || ren
		clken;
		wrbe_separate;
		rdwr old;
	}
}
`,"libmap_brams_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module \\$__QLF_TDP36K (PORT_A_CLK, PORT_A_ADDR, PORT_A_WR_DATA, PORT_A_WR_EN, PORT_A_WR_BE, PORT_A_CLK_EN, PORT_A_RD_DATA,
					   PORT_B_CLK, PORT_B_ADDR, PORT_B_WR_DATA, PORT_B_WR_EN, PORT_B_WR_BE, PORT_B_CLK_EN, PORT_B_RD_DATA);  

parameter INIT = 0;

parameter OPTION_SPLIT = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_BE_WIDTH = 1;

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_BE_WIDTH = 1;

input PORT_A_CLK;
input [14:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input PORT_A_WR_EN;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input PORT_A_CLK_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input [14:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input PORT_B_WR_EN;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input PORT_B_CLK_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function [36863:0] pack_init;
	integer i;
	reg [35:0] ri;
	for (i = 0; i < (OPTION_SPLIT ? 512 : 1024); i = i + 1) begin
		ri = INIT[i*36 +: 36];
		pack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18],
								 ri[17], ri[8], ri[16:9], ri[7:0]};
	end
	if (OPTION_SPLIT)
		pack_init[36863:18432] = 18432'bx;
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B_WIDTH);

assign REN_A1_i = PORT_A_CLK_EN;
assign WEN_A1_i = PORT_A_CLK_EN & PORT_A_WR_EN;
assign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;

assign REN_B1_i = PORT_B_CLK_EN;
assign WEN_B1_i = PORT_B_CLK_EN & PORT_B_WR_EN;
assign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;

case (PORT_A_WIDTH)
9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;
18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;
36: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0], WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0]} = PORT_A_WR_DATA;
default: assign WDATA_A1_i = PORT_A_WR_DATA; // 1,2,4
endcase

case (PORT_B_WIDTH)
9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;
18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;
36: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0], WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0]} = PORT_B_WR_DATA;
default: assign WDATA_B1_i = PORT_B_WR_DATA; // 1,2,4
endcase

case (PORT_A_WIDTH)
9: assign PORT_A_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };
18: assign PORT_A_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };
36: assign PORT_A_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0], RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0]};
default: assign PORT_A_RD_DATA = RDATA_A1_o; // 1,2,4
endcase

case (PORT_B_WIDTH)
9: assign PORT_B_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };
18: assign PORT_B_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };
36: assign PORT_B_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0], RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0]};
default: assign PORT_B_RD_DATA = RDATA_B1_o; // 1,2,4
endcase

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 1 *)
(* is_split = 0 *)
(* was_split_candidate = OPTION_SPLIT *)
(* port_a_width = PORT_A_WIDTH *)
(* port_b_width = PORT_B_WIDTH *)
TDP36K #(
	.RAM_INIT(pack_init()),
) _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule


module \\$__QLF_TDP36K_MERGED (...);

parameter INIT1 = 0;

parameter PORT_A1_WIDTH = 1;
parameter PORT_B1_WIDTH = 1;

parameter PORT_A1_WR_BE_WIDTH = 1;
parameter PORT_B1_WR_BE_WIDTH = 1;

input PORT_A1_CLK;
input [14:0] PORT_A1_ADDR;
input [PORT_A1_WIDTH-1:0] PORT_A1_WR_DATA;
input PORT_A1_WR_EN;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE;
input PORT_A1_CLK_EN;
output [PORT_A1_WIDTH-1:0] PORT_A1_RD_DATA;

input PORT_B1_CLK;
input [14:0] PORT_B1_ADDR;
input [PORT_B1_WIDTH-1:0] PORT_B1_WR_DATA;
input PORT_B1_WR_EN;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE;
input PORT_B1_CLK_EN;
output [PORT_B1_WIDTH-1:0] PORT_B1_RD_DATA;

parameter INIT2 = 0;

parameter PORT_A2_WIDTH = 1;
parameter PORT_B2_WIDTH = 1;
parameter PORT_A2_WR_BE_WIDTH = 1;
parameter PORT_B2_WR_BE_WIDTH = 1;

input PORT_A2_CLK;
input [14:0] PORT_A2_ADDR;
input [PORT_A2_WIDTH-1:0] PORT_A2_WR_DATA;
input PORT_A2_WR_EN;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE;
input PORT_A2_CLK_EN;
output [PORT_A2_WIDTH-1:0] PORT_A2_RD_DATA;

input PORT_B2_CLK;
input [14:0] PORT_B2_ADDR;
input [PORT_B2_WIDTH-1:0] PORT_B2_WR_DATA;
input PORT_B2_WR_EN;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE;
input PORT_B2_CLK_EN;
output [PORT_B2_WIDTH-1:0] PORT_B2_RD_DATA;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
default: mode = 3'b000;
endcase
endfunction

function [36863:0] pack_init;
	integer i;
	reg [35:0] ri;
	for (i = 0; i < 1024; i = i + 1) begin
		ri = {INIT2[i*18 +: 18], INIT1[i*18 +: 18]};
		pack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18], ri[17], ri[8], ri[16:9], ri[7:0]};
	end
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_WIDTH);
localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_WIDTH);

localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_WIDTH);

assign REN_A1_i = PORT_A1_CLK_EN;
assign WEN_A1_i = PORT_A1_CLK_EN & PORT_A1_WR_EN;
assign BE_A1_i = PORT_A1_WR_BE;

assign REN_B1_i = PORT_B1_CLK_EN;
assign WEN_B1_i = PORT_B1_CLK_EN & PORT_B1_WR_EN;
assign BE_B1_i = PORT_B1_WR_BE;

assign REN_A2_i = PORT_A2_CLK_EN;
assign WEN_A2_i = PORT_A2_CLK_EN & PORT_A2_WR_EN;
assign BE_A2_i = PORT_A2_WR_BE;

assign REN_B2_i = PORT_B2_CLK_EN;
assign WEN_B2_i = PORT_B2_CLK_EN & PORT_B2_WR_EN;
assign BE_B2_i = PORT_B2_WR_BE;

assign ADDR_A1_i = PORT_A1_ADDR;
assign ADDR_B1_i = PORT_B1_ADDR;
assign ADDR_A2_i = PORT_A2_ADDR;
assign ADDR_B2_i = PORT_B2_ADDR;

case (PORT_A1_WIDTH)
9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;
18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;
default: assign WDATA_A1_i = PORT_A1_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_B1_WIDTH)
9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;
18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;
default: assign WDATA_B1_i = PORT_B1_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_A1_WIDTH)
9: assign PORT_A1_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };
18: assign PORT_A1_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };
default: assign PORT_A1_RD_DATA = RDATA_A1_o; // 1,2,4,8,16
endcase

case (PORT_B1_WIDTH)
9: assign PORT_B1_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };
18: assign PORT_B1_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };
default: assign PORT_B1_RD_DATA = RDATA_B1_o; // 1,2,4,8,16
endcase

case (PORT_A2_WIDTH)
9: assign { WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;
18: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;
default: assign WDATA_A2_i = PORT_A2_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_B2_WIDTH)
9: assign { WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;
18: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;
default: assign WDATA_B2_i = PORT_B2_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_A2_WIDTH)
9: assign PORT_A2_RD_DATA = { RDATA_A2_o[16], RDATA_A2_o[7:0] };
18: assign PORT_A2_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0] };
default: assign PORT_A2_RD_DATA = RDATA_A2_o; // 1,2,4,8,16
endcase

case (PORT_B2_WIDTH)
9: assign PORT_B2_RD_DATA = { RDATA_B2_o[16], RDATA_B2_o[7:0] };
18: assign PORT_B2_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0] };
default: assign PORT_B2_RD_DATA = RDATA_B2_o; // 1,2,4,8,16
endcase

defparam _TECHMAP_REPLACE_.MODE_BITS = {1'b1,
			UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
			UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
		};

(* is_inferred = 1 *)
(* is_split = 1 *)
(* port_a1_width = PORT_A1_WIDTH *)
(* port_a2_width = PORT_A2_WIDTH *)
(* port_b1_width = PORT_B1_WIDTH *)
(* port_b2_width = PORT_B2_WIDTH *)
TDP36K #(
	.RAM_INIT(pack_init()),
) _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),
	.WDATA_A1_i(WDATA_A1_i),
	.WDATA_A2_i(WDATA_A2_i),
	.RDATA_A1_o(RDATA_A1_o),
	.RDATA_A2_o(RDATA_A2_o),
	.ADDR_A1_i(ADDR_A1_i),
	.ADDR_A2_i(ADDR_A2_i),
	.CLK_A1_i(PORT_A1_CLK),
	.CLK_A2_i(PORT_A2_CLK),
	.REN_A1_i(REN_A1_i),
	.REN_A2_i(REN_A2_i),
	.WEN_A1_i(WEN_A1_i),
	.WEN_A2_i(WEN_A2_i),
	.BE_A1_i(BE_A1_i),
	.BE_A2_i(BE_A2_i),

	.WDATA_B1_i(WDATA_B1_i),
	.WDATA_B2_i(WDATA_B2_i),
	.RDATA_B1_o(RDATA_B1_o),
	.RDATA_B2_o(RDATA_B2_o),
	.ADDR_B1_i(ADDR_B1_i),
	.ADDR_B2_i(ADDR_B2_i),
	.CLK_B1_i(PORT_B1_CLK),
	.CLK_B2_i(PORT_B2_CLK),
	.REN_B1_i(REN_B1_i),
	.REN_B2_i(REN_B2_i),
	.WEN_B1_i(WEN_B1_i),
	.WEN_B2_i(WEN_B2_i),
	.BE_B1_i(BE_B1_i),
	.BE_B2_i(BE_B2_i),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule`,"sram1024x18_mem.v":`\`default_nettype none
module sram1024x18 (
	clk_a,
	cen_a,
	wen_a,
	addr_a,
	wmsk_a,
	wdata_a,
	rdata_a,
	clk_b,
	cen_b,
	wen_b,
	addr_b,
	wmsk_b,
	wdata_b,
	rdata_b
);
	parameter [1024*18-1:0] init = 18431'bx;
	(* clkbuf_sink *)
	input wire clk_a;
	input wire cen_a;
	input wire wen_a;
	input wire [9:0] addr_a;
	input wire [17:0] wmsk_a;
	input wire [17:0] wdata_a;
	output reg [17:0] rdata_a;
	(* clkbuf_sink *)
	input wire clk_b;
	input wire cen_b;
	input wire wen_b;
	input wire [9:0] addr_b;
	input wire [17:0] wmsk_b;
	input wire [17:0] wdata_b;
	output reg [17:0] rdata_b;
	reg [17:0] ram [1023:0];
	integer i;
	initial begin
		for (i = 0; i < 1024; i = i + 1) begin
			ram[i] = init[18*i +: 18];
		end
	end

	always @(posedge clk_a) begin
		if (!cen_a) begin
	 		if (!wen_a)
				for (i = 0; i < 18; i++) begin
					if (!wmsk_a[i]) ram[addr_a][i] <= wdata_a[i];
				end
			rdata_a <= ram[addr_a];
		end
	end

	always @(posedge clk_b) begin
		if (!cen_b) begin
	 		if (!wen_b)
				for (i = 0; i < 18; i++) begin
					if (!wmsk_b[i]) ram[addr_b][i] <= wdata_b[i];
				end
			rdata_b <= ram[addr_b];
		end
	end

endmodule

`,"ufifo_ctl.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`default_nettype wire
module fifo_ctl (
	raddr,
	waddr,
	fflags,
	ren_o,
	sync,
	rmode,
	wmode,
	rclk,
	rst_R_n,
	wclk,
	rst_W_n,
	ren,
	wen,
	upaf,
	upae
);
	parameter ADDR_WIDTH = 11;
	parameter FIFO_WIDTH = 3'd2;
	parameter DEPTH = 6;
	output wire [ADDR_WIDTH - 1:0] raddr;
	output wire [ADDR_WIDTH - 1:0] waddr;
	output wire [7:0] fflags;
	output wire ren_o;
	input wire sync;
	input wire [1:0] rmode;
	input wire [1:0] wmode;
	(* clkbuf_sink *)
	input wire rclk;
	input wire rst_R_n;
	(* clkbuf_sink *)
	input wire wclk;
	input wire rst_W_n;
	input wire ren;
	input wire wen;
	input wire [ADDR_WIDTH - 1:0] upaf;
	input wire [ADDR_WIDTH - 1:0] upae;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg [ADDR_WIDTH:0] pushtopop1;
	reg [ADDR_WIDTH:0] pushtopop2;
	reg [ADDR_WIDTH:0] poptopush1;
	reg [ADDR_WIDTH:0] poptopush2;
	wire [ADDR_WIDTH:0] pushtopop0;
	wire [ADDR_WIDTH:0] poptopush0;
	wire [ADDR_WIDTH:0] smux_poptopush;
	wire [ADDR_WIDTH:0] smux_pushtopop;
	assign smux_poptopush = (sync ? poptopush0 : poptopush2);
	assign smux_pushtopop = (sync ? pushtopop0 : pushtopop2);
	always @(posedge rclk or negedge rst_R_n)
		if (~rst_R_n) begin
			pushtopop1 <= 'h0;
			pushtopop2 <= 'h0;
		end
		else begin
			pushtopop1 = pushtopop0;
			pushtopop2 = pushtopop1;
		end
	always @(posedge wclk or negedge rst_W_n)
		if (~rst_W_n) begin
			poptopush1 <= 'h0;
			poptopush2 <= 'h0;
		end
		else begin
			poptopush1 <= poptopush0;
			poptopush2 <= poptopush1;
		end
	fifo_push #(
		.ADDR_WIDTH(ADDR_WIDTH),
		.DEPTH(DEPTH)
	) u_fifo_push(
		.wclk(wclk),
		.wen(wen),
		.rst_n(rst_W_n),
		.rmode(rmode),
		.wmode(wmode),
		.gcout(pushtopop0),
		.gcin(smux_poptopush),
		.ff_waddr(waddr),
		.pushflags(fflags[7:4]),
		.upaf(upaf)
	);
	fifo_pop #(
		.ADDR_WIDTH(ADDR_WIDTH),
		.FIFO_WIDTH(FIFO_WIDTH),
		.DEPTH(DEPTH)
	) u_fifo_pop(
		.rclk(rclk),
		.ren_in(ren),
		.rst_n(rst_R_n),
		.rmode(rmode),
		.wmode(wmode),
		.ren_o(ren_o),
		.gcout(poptopush0),
		.gcin(smux_pushtopop),
		.out_raddr(raddr),
		.popflags(fflags[3:0]),
		.upae(upae)
	);
endmodule
module fifo_push (
	pushflags,
	gcout,
	ff_waddr,
	rst_n,
	wclk,
	wen,
	rmode,
	wmode,
	gcin,
	upaf
);
	parameter ADDR_WIDTH = 11;
	parameter DEPTH = 6;
	output wire [3:0] pushflags;
	output wire [ADDR_WIDTH:0] gcout;
	output wire [ADDR_WIDTH - 1:0] ff_waddr;
	input rst_n;
	(* clkbuf_sink *)
	input wclk;
	input wen;
	input [1:0] rmode;
	input [1:0] wmode;
	input [ADDR_WIDTH:0] gcin;
	input [ADDR_WIDTH - 1:0] upaf;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg full_next;
	reg full;
	reg paf_next;
	reg paf;
	reg fmo;
	reg fmo_next;
	reg overflow;
	reg p1;
	reg p2;
	reg f1;
	reg f2;
	reg q1;
	reg q2;
	reg [1:0] gmode;
	reg [ADDR_WIDTH:0] waddr;
	reg [ADDR_WIDTH:0] raddr;
	reg [ADDR_WIDTH:0] gcout_reg;
	reg [ADDR_WIDTH:0] gcout_next;
	reg [ADDR_WIDTH:0] raddr_next;
	reg [ADDR_WIDTH - 1:0] paf_thresh;
	wire overflow_next;
	wire [ADDR_WIDTH:0] waddr_next;
	wire [ADDR_WIDTH:0] gc8out_next;
	wire [ADDR_WIDTH - 1:0] gc16out_next;
	wire [ADDR_WIDTH - 2:0] gc32out_next;
	wire [ADDR_WIDTH:0] tmp;
	wire [ADDR_WIDTH:0] next_count;
	wire [ADDR_WIDTH:0] count;
	wire [ADDR_WIDTH:0] fbytes;
	genvar i;
	assign next_count = fbytes - (waddr_next >= raddr_next ? waddr_next - raddr_next : (~raddr_next + waddr_next) + 1);
	assign count = fbytes - (waddr >= raddr ? waddr - raddr : (~raddr + waddr) + 1);
	assign fbytes = 1 << (DEPTH + 5);
	always @(*) begin
		paf_thresh = wmode[1] ? upaf : (wmode[0] ? upaf << 1 : upaf << 2);
	end
	always @(*)
		case (wmode)
			2'h0, 2'h1, 2'h2: begin
				full_next = (wen ? f1 : f2);
				fmo_next = (wen ? p1 : p2);
				paf_next = (wen ? q1 : q2);
			end
			default: begin
				full_next = 1'b0;
				fmo_next = 1'b0;
				paf_next = 1'b0;
			end
		endcase
	always @(*) begin : PUSH_FULL_FLAGS
		f1 = 1'b0;
		f2 = 1'b0;
		p1 = 1'b0;
		p2 = 1'b0;
		q1 = next_count < {1'b0, paf_thresh};
		q2 = count < {1'b0, paf_thresh};
		case (wmode)
			2'h0:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:2]} == raddr_next[11:2];
						f2 = {~waddr[11], waddr[10:2]} == raddr_next[11:2];
						p1 = ((waddr_next[10:2] + 1) & 9'h1ff) == raddr_next[10:2];
						p2 = ((waddr[10:2] + 1) & 9'h1ff) == raddr_next[10:2];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:2]} == raddr_next[10:2];
						f2 = {~waddr[10], waddr[9:2]} == raddr_next[10:2];
						p1 = ((waddr_next[9:2] + 1) & 8'hff) == raddr_next[9:2];
						p2 = ((waddr[9:2] + 1) & 8'hff) == raddr_next[9:2];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:2]} == raddr_next[9:2];
						f2 = {~waddr[9], waddr[8:2]} == raddr_next[9:2];
						p1 = ((waddr_next[8:2] + 1) & 7'h7f) == raddr_next[8:2];
						p2 = ((waddr[8:2] + 1) & 7'h7f) == raddr_next[8:2];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:2]} == raddr_next[8:2];
						f2 = {~waddr[8], waddr[7:2]} == raddr_next[8:2];
						p1 = ((waddr_next[7:2] + 1) & 6'h3f) == raddr_next[7:2];
						p2 = ((waddr[7:2] + 1) & 6'h3f) == raddr_next[7:2];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:2]} == raddr_next[7:2];
						f2 = {~waddr[7], waddr[6:2]} == raddr_next[7:2];
						p1 = ((waddr_next[6:2] + 1) & 5'h1f) == raddr_next[6:2];
						p2 = ((waddr[6:2] + 1) & 5'h1f) == raddr_next[6:2];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:2]} == raddr_next[6:2];
						f2 = {~waddr[6], waddr[5:2]} == raddr_next[6:2];
						p1 = ((waddr_next[5:2] + 1) & 4'hf) == raddr_next[5:2];
						p2 = ((waddr[5:2] + 1) & 4'hf) == raddr_next[5:2];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:2]} == raddr_next[5:2];
						f2 = {~waddr[5], waddr[4:2]} == raddr_next[5:2];
						p1 = ((waddr_next[4:2] + 1) & 3'h7) == raddr_next[4:2];
						p2 = ((waddr[4:2] + 1) & 3'h7) == raddr_next[4:2];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];
						p1 = ((waddr_next[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];
						p2 = ((waddr[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];
					end
				endcase
			2'h1:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:1]} == raddr_next[11:1];
						f2 = {~waddr[11], waddr[10:1]} == raddr_next[11:1];
						p1 = ((waddr_next[10:1] + 1) & 10'h3ff) == raddr_next[10:1];
						p2 = ((waddr[10:1] + 1) & 10'h3ff) == raddr_next[10:1];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:1]} == raddr_next[10:1];
						f2 = {~waddr[10], waddr[9:1]} == raddr_next[10:1];
						p1 = ((waddr_next[9:1] + 1) & 9'h1ff) == raddr_next[9:1];
						p2 = ((waddr[9:1] + 1) & 9'h1ff) == raddr_next[9:1];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:1]} == raddr_next[9:1];
						f2 = {~waddr[9], waddr[8:1]} == raddr_next[9:1];
						p1 = ((waddr_next[8:1] + 1) & 8'hff) == raddr_next[8:1];
						p2 = ((waddr[8:1] + 1) & 8'hff) == raddr_next[8:1];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:1]} == raddr_next[8:1];
						f2 = {~waddr[8], waddr[7:1]} == raddr_next[8:1];
						p1 = ((waddr_next[7:1] + 1) & 7'h7f) == raddr_next[7:1];
						p2 = ((waddr[7:1] + 1) & 7'h7f) == raddr_next[7:1];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:1]} == raddr_next[7:1];
						f2 = {~waddr[7], waddr[6:1]} == raddr_next[7:1];
						p1 = ((waddr_next[6:1] + 1) & 6'h3f) == raddr_next[6:1];
						p2 = ((waddr[6:1] + 1) & 6'h3f) == raddr_next[6:1];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:1]} == raddr_next[6:1];
						f2 = {~waddr[6], waddr[5:1]} == raddr_next[6:1];
						p1 = ((waddr_next[5:1] + 1) & 5'h1f) == raddr_next[5:1];
						p2 = ((waddr[5:1] + 1) & 5'h1f) == raddr_next[5:1];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:1]} == raddr_next[5:1];
						f2 = {~waddr[5], waddr[4:1]} == raddr_next[5:1];
						p1 = ((waddr_next[4:1] + 1) & 4'hf) == raddr_next[4:1];
						p2 = ((waddr[4:1] + 1) & 4'hf) == raddr_next[4:1];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];
						p1 = ((waddr_next[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];
						p2 = ((waddr[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];
					end
				endcase
			2'h2:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:0]} == raddr_next[11:0];
						f2 = {~waddr[11], waddr[10:0]} == raddr_next[11:0];
						p1 = ((waddr_next[10:0] + 1) & 11'h7ff) == raddr_next[10:0];
						p2 = ((waddr[10:0] + 1) & 11'h7ff) == raddr_next[10:0];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:0]} == raddr_next[10:0];
						f2 = {~waddr[10], waddr[9:0]} == raddr_next[10:0];
						p1 = ((waddr_next[9:0] + 1) & 10'h3ff) == raddr_next[9:0];
						p2 = ((waddr[9:0] + 1) & 10'h3ff) == raddr_next[9:0];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:0]} == raddr_next[9:0];
						f2 = {~waddr[9], waddr[8:0]} == raddr_next[9:0];
						p1 = ((waddr_next[8:0] + 1) & 9'h1ff) == raddr_next[8:0];
						p2 = ((waddr[8:0] + 1) & 9'h1ff) == raddr_next[8:0];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:0]} == raddr_next[8:0];
						f2 = {~waddr[8], waddr[7:0]} == raddr_next[8:0];
						p1 = ((waddr_next[7:0] + 1) & 8'hff) == raddr_next[7:0];
						p2 = ((waddr[7:0] + 1) & 8'hff) == raddr_next[7:0];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:0]} == raddr_next[7:0];
						f2 = {~waddr[7], waddr[6:0]} == raddr_next[7:0];
						p1 = ((waddr_next[6:0] + 1) & 7'h7f) == raddr_next[6:0];
						p2 = ((waddr[6:0] + 1) & 7'h7f) == raddr_next[6:0];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:0]} == raddr_next[6:0];
						f2 = {~waddr[6], waddr[5:0]} == raddr_next[6:0];
						p1 = ((waddr_next[5:0] + 1) & 6'h3f) == raddr_next[5:0];
						p2 = ((waddr[5:0] + 1) & 6'h3f) == raddr_next[5:0];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:0]} == raddr_next[5:0];
						f2 = {~waddr[5], waddr[4:0]} == raddr_next[5:0];
						p1 = ((waddr_next[4:0] + 1) & 5'h1f) == raddr_next[4:0];
						p2 = ((waddr[4:0] + 1) & 5'h1f) == raddr_next[4:0];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];
						p1 = ((waddr_next[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];
						p2 = ((waddr[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];
					end
				endcase
			2'h3: begin
				f1 = 1'b0;
				f2 = 1'b0;
				p1 = 1'b0;
				p2 = 1'b0;
			end
		endcase
	end
	always @(*)
		case (wmode)
			2'h0: gmode = 2'h0;
			2'h1: gmode = (rmode == 2'h0 ? 2'h0 : 2'h1);
			2'h2: gmode = (rmode == 2'h2 ? 2'h2 : rmode);
			2'h3: gmode = 2'h3;
		endcase
	assign gc8out_next = (waddr_next >> 1) ^ waddr_next;
	assign gc16out_next = (waddr_next >> 2) ^ (waddr_next >> 1);
	assign gc32out_next = (waddr_next >> 3) ^ (waddr_next >> 2);
	always @(*)
		if (wen)
			case (gmode)
				2'h2: gcout_next = gc8out_next;
				2'h1: gcout_next = {1'b0, gc16out_next};
				2'h0: gcout_next = {2'b00, gc32out_next};
				default: gcout_next = {ADDR_PLUS_ONE {1'b0}};
			endcase
		else
			gcout_next = {ADDR_PLUS_ONE {1'b0}};
	always @(posedge wclk or negedge rst_n)
		if (~rst_n) begin
			full <= 1'b0;
			fmo <= 1'b0;
			paf <= 1'b0;
			raddr <= {ADDR_PLUS_ONE {1'b0}};
		end
		else begin
			full <= full_next;
			fmo <= fmo_next;
			paf <= paf_next;
			case (gmode)
				0: raddr <= raddr_next & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
				1: raddr <= raddr_next & {{ADDR_WIDTH {1'b1}}, 1'b0};
				2: raddr <= raddr_next & {ADDR_WIDTH + 1 {1'b1}};
				3: raddr <= 12'h000;
			endcase
		end
	assign overflow_next = full & wen;
	always @(posedge wclk or negedge rst_n)
		if (~rst_n)
			overflow <= 1'b0;
		else if (wen == 1'b1)
			overflow <= overflow_next;
	always @(posedge wclk or negedge rst_n)
		if (~rst_n) begin
			waddr <= {ADDR_WIDTH + 1 {1'b0}};
			gcout_reg <= {ADDR_WIDTH + 1 {1'b0}};
		end
		else if (wen == 1'b1) begin
			waddr <= waddr_next;
			gcout_reg <= gcout_next;
		end
	assign gcout = gcout_reg;
	generate
		for (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1
			assign tmp[i] = ^(gcin >> i);
		end
	endgenerate
	always @(*)
		case (gmode)
			2'h0: raddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
			2'h1: raddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};
			2'h2: raddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_WIDTH + 1 {1'b1}};
			default: raddr_next = {ADDR_WIDTH + 1 {1'b0}};
		endcase
	assign ff_waddr = waddr[ADDR_WIDTH - 1:0];
	assign pushflags = {full, fmo, paf, overflow};
	assign waddr_next = waddr + (wmode == 2'h0 ? 'h4 : (wmode == 2'h1 ? 'h2 : 'h1));
endmodule
module fifo_pop (
	ren_o,
	popflags,
	out_raddr,
	gcout,
	rst_n,
	rclk,
	ren_in,
	rmode,
	wmode,
	gcin,
	upae
);
	parameter ADDR_WIDTH = 11;
	parameter FIFO_WIDTH = 3'd2;
	parameter DEPTH = 6;
	output wire ren_o;
	output wire [3:0] popflags;
	output reg [ADDR_WIDTH - 1:0] out_raddr;
	output wire [ADDR_WIDTH:0] gcout;
	input rst_n;
	(* clkbuf_sink *)
	input rclk;
	input ren_in;
	input [1:0] rmode;
	input [1:0] wmode;
	input [ADDR_WIDTH:0] gcin;
	input [ADDR_WIDTH - 1:0] upae;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg empty;
	reg epo;
	reg pae;
	reg underflow;
	reg e1;
	reg e2;
	reg o1;
	reg o2;
	reg q1;
	reg q2;
	reg [1:0] bwl_sel;
	reg [1:0] gmode;
	reg [ADDR_WIDTH - 1:0] ff_raddr;
	reg [ADDR_WIDTH:0] waddr;
	reg [ADDR_WIDTH:0] raddr;
	reg [ADDR_WIDTH:0] gcout_reg;
	reg [ADDR_WIDTH:0] gcout_next;
	reg [ADDR_WIDTH:0] waddr_next;
	reg [ADDR_WIDTH - 1:0] pae_thresh;
	wire ren_out;
	wire empty_next;
	wire pae_next;
	wire epo_next;
	wire [ADDR_WIDTH - 2:0] gc32out_next;
	wire [ADDR_WIDTH - 1:0] gc16out_next;
	wire [ADDR_WIDTH:0] gc8out_next;
	wire [ADDR_WIDTH:0] raddr_next;
	wire [ADDR_WIDTH - 1:0] ff_raddr_next;
	wire [ADDR_WIDTH:0] tmp;
	wire [ADDR_PLUS_ONE:0] next_count;
	wire [ADDR_PLUS_ONE:0] count;
	wire [ADDR_PLUS_ONE:0] fbytes;
	genvar i;
	assign next_count = waddr - raddr_next;
	assign count = waddr - raddr;
	assign fbytes = 1 << (DEPTH + 5);
	always @(*) pae_thresh = rmode[1] ? upae : (rmode[0] ? upae << 1 : upae << 2);
	assign ren_out = (empty ? 1'b1 : ren_in);
	always @(*)
		case (rmode)
			2'h0: gmode = 2'h0;
			2'h1: gmode = (wmode == 2'h0 ? 2'h0 : 2'h1);
			2'h2: gmode = (wmode == 2'h2 ? 2'h2 : wmode);
			2'h3: gmode = 2'h3;
		endcase
	always @(*) begin
		e1 = 1'b0;
		e2 = 1'b0;
		o1 = 1'b0;
		o2 = 1'b0;
		q1 = next_count < {1'b0, pae_thresh};
		q2 = count < {1'b0, pae_thresh};
		case (rmode)
			2'h0: begin
				e1 = raddr_next[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];
				e2 = raddr[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];
				o1 = (raddr_next[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];
				o2 = (raddr[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];
			end
			2'h1: begin
				e1 = raddr_next[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];
				e2 = raddr[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];
				o1 = (raddr_next[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];
				o2 = (raddr[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];
			end
			2'h2: begin
				e1 = raddr_next[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];
				e2 = raddr[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];
				o1 = (raddr_next[ADDR_WIDTH:0] + 1) == waddr_next[ADDR_WIDTH:0];
				o2 = (raddr[ADDR_WIDTH:0] + 1) == waddr_next[11:0];
			end
			2'h3: begin
				e1 = 1'b0;
				e2 = 1'b0;
				o1 = 1'b0;
				o2 = 1'b0;
			end
		endcase
	end
	assign empty_next = (ren_in & !empty ? e1 : e2);
	assign epo_next = (ren_in & !empty ? o1 : o2);
	assign pae_next = (ren_in & !empty ? q1 : q2);
	always @(posedge rclk or negedge rst_n)
		if (~rst_n) begin
			empty <= 1'b1;
			pae <= 1'b1;
			epo <= 1'b0;
		end
		else begin
			empty <= empty_next;
			pae <= pae_next;
			epo <= epo_next;
		end
	assign gc8out_next = (raddr_next >> 1) ^ raddr_next;
	assign gc16out_next = (raddr_next >> 2) ^ (raddr_next >> 1);
	assign gc32out_next = (raddr_next >> 3) ^ (raddr_next >> 2);
	always @(*)
		if (ren_in)
			case (gmode)
				2'h2: gcout_next = gc8out_next;
				2'h1: gcout_next = {1'b0, gc16out_next};
				2'h0: gcout_next = {2'b00, gc32out_next};
				default: gcout_next = 'h0;
			endcase
		else
			gcout_next = 'h0;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			waddr <= 12'h000;
		else
			waddr <= waddr_next;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n) begin
			underflow <= 1'b0;
			bwl_sel <= 2'h0;
			gcout_reg <= 12'h000;
		end
		else if (ren_in) begin
			underflow <= empty;
			if (!empty) begin
				bwl_sel <= raddr_next[1:0];
				gcout_reg <= gcout_next;
			end
		end
	generate
		for (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1
			assign tmp[i] = ^(gcin >> i);
		end
	endgenerate
	always @(*)
		case (gmode)
			2'h0: waddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
			2'h1: waddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};
			2'h2: waddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_PLUS_ONE {1'b1}};
			default: waddr_next = {ADDR_PLUS_ONE {1'b0}};
		endcase
	assign ff_raddr_next = ff_raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));
	assign raddr_next = raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			ff_raddr <= 1'sb0;
		else if (empty & ~empty_next)
			ff_raddr <= raddr_next[ADDR_WIDTH - 1:0];
		else if ((ren_in & !empty) & ~empty_next)
			ff_raddr <= ff_raddr_next;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			raddr <= 12'h000;
		else if (ren_in & !empty)
			raddr <= raddr_next;
	always @(*)
		case (FIFO_WIDTH)
			3'h2: out_raddr = {ff_raddr[ADDR_WIDTH - 1:1], bwl_sel[0]};
			3'h4: out_raddr = {ff_raddr[ADDR_WIDTH - 1:2], bwl_sel};
			default: out_raddr = ff_raddr[ADDR_WIDTH - 1:0];
		endcase
	assign ren_o = ren_out;
	assign gcout = gcout_reg;
	assign popflags = {empty, epo, pae, underflow};
endmodule
\`default_nettype none
`}},sf2:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module \\$__SF2_ALU (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA, BB;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(AA));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(BB));

	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		ARI1 #(
			// G = F1 = A[i] & (B[i]^BI)
			// Y = F0 = A[i]^B[i]^BI
			// P = Y
			//		 ADCB
			.INIT(20'b 01_11_0010_1000_1001_0110)
		) carry (
			.A(1'b0),
			.B(AA[i]),
			.C(BB[i]),
			.D(BI),
			.FCI(C[i]),
			.Y(X[i]),
			.S(Y[i]),
			.FCO(CO[i])
		);
	end endgenerate
endmodule

`,"cells_map.v":`module \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_DFFE_PN1P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_SDFFCE_PN0P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_SDFFCE_PN1P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b1), .LAT(1'b0), .Q(Q));
endmodule

module \\$_DLATCH_PN0_ (input D, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

module \\$_DLATCH_PN1_ (input D, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      CFG1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]));
    end else
    if (WIDTH == 2) begin
      CFG2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]));
    end else
    if (WIDTH == 3) begin
      CFG3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]));
    end else
    if (WIDTH == 4) begin
      CFG4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`// https://coredocs.s3.amazonaws.com/Libero/12_0_0/Tool/sf2_mlg.pdf

module AND2 (
	input A, B,
	output Y
);
	assign Y = A & B;
endmodule

module AND3 (
	input A, B, C,
	output Y
);
	assign Y = A & B & C;
endmodule

module AND4 (
	input A, B, C, D,
	output Y
);
	assign Y = A & B & C & D;
endmodule

module CFG1 (
	output Y,
	input A
);
	parameter [1:0] INIT = 2'h0;
	assign Y = INIT >> A;
endmodule

module CFG2 (
	output Y,
	input A,
	input B
);
	parameter [3:0] INIT = 4'h0;
	assign Y = INIT >> {B, A};
endmodule

module CFG3 (
	output Y,
	input A,
	input B,
	input C
);
	parameter [7:0] INIT = 8'h0;
	assign Y = INIT >> {C, B, A};
endmodule

module CFG4 (
	output Y,
	input A,
	input B,
	input C,
	input D
);
	parameter [15:0] INIT = 16'h0;
	assign Y = INIT >> {D, C, B, A};
endmodule

module BUFF (
	input A,
	output Y
);
	assign Y = A;
endmodule

module BUFD (
	input A,
	output Y
);
	assign Y = A;
endmodule

module CLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module CLKINT_PRESERVE (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module GCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

module RCLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module RGCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

module SLE (
	output Q,
	input ADn,
	input ALn,
	(* clkbuf_sink *)
	input CLK,
	input D,
	input LAT,
	input SD,
	input EN,
	input SLn
);
	reg q_latch, q_ff;

	always @(posedge CLK, negedge ALn) begin
		if (!ALn) begin
			q_ff <= !ADn;
		end else if (EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	always @* begin
		if (!ALn) begin
			q_latch <= !ADn;
		end else if (CLK && EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	assign Q = LAT ? q_latch : q_ff;
endmodule

module ARI1 (
	input A, B, C, D, FCI,
	output Y, S, FCO
);
	parameter [19:0] INIT = 20'h0;
	wire [2:0] Fsel = {D, C, B};
	wire F0 = INIT[Fsel];
	wire F1 = INIT[8 + Fsel];
	wire Yout = A ? F1 : F0;
	assign Y = Yout;
	assign S = FCI ^ Yout;
	wire G = INIT[16] ? (INIT[17] ? F1 : F0) : INIT[17];
	wire P = INIT[19] ? 1'b1 : (INIT[18] ? Yout : 1'b0);
	assign FCO = P ? FCI : G;
endmodule

// module FCEND_BUFF
// module FCINIT_BUFF
// module FLASH_FREEZE
// module OSCILLATOR
// module SYSCTRL_RESET_STATUS
// module LIVE_PROBE_FB

(* blackbox *)
module GCLKBUF (
	(* iopad_external_pin *)
	input PAD,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

(* blackbox *)
module GCLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

(* blackbox *)
module GCLKBIBUF (
	input D,
	input E,
	input EN,
	(* iopad_external_pin *)
	inout PAD,
	(* clkbuf_driver *)
	output Y
);
endmodule

// module DFN1
// module DFN1C0
// module DFN1E1
// module DFN1E1C0
// module DFN1E1P0
// module DFN1P0
// module DLN1
// module DLN1C0
// module DLN1P0

module INV (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module INVD (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module MX2 (
	input A, B, S,
	output Y
);
	assign Y = S ? B : A;
endmodule

module MX4 (
	input D0, D1, D2, D3, S0, S1,
	output Y
);
	assign Y = S1 ? (S0 ? D3 : D2) : (S0 ? D1 : D0);
endmodule

module NAND2 (
	input A, B,
	output Y
);
	assign Y = !(A & B);
endmodule

module NAND3 (
	input A, B, C,
	output Y
);
	assign Y = !(A & B & C);
endmodule

module NAND4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A & B & C & D);
endmodule

module NOR2 (
	input A, B,
	output Y
);
	assign Y = !(A | B);
endmodule

module NOR3 (
	input A, B, C,
	output Y
);
	assign Y = !(A | B | C);
endmodule

module NOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A | B | C | D);
endmodule

module OR2 (
	input A, B,
	output Y
);
	assign Y = A | B;
endmodule

module OR3 (
	input A, B, C,
	output Y
);
	assign Y = A | B | C;
endmodule

module OR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A | B | C | D;
endmodule

module XOR2 (
	input A, B,
	output Y
);
	assign Y = A ^ B;
endmodule

module XOR3 (
	input A, B, C,
	output Y
);
	assign Y = A ^ B ^ C;
endmodule

module XOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A ^ B ^ C ^ D;
endmodule

module XOR8 (
	input A, B, C, D, E, F, G, H,
	output Y
);
	assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H;
endmodule

// module UJTAG

module BIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

(* blackbox *)
module BIBUF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PADP,
	(* iopad_external_pin *)
	inout PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module CLKBIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

module CLKBUF (
	(* iopad_external_pin *)
	input PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
endmodule

(* blackbox *)
module CLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
endmodule

module INBUF (
	(* iopad_external_pin *)
	input PAD,
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
endmodule

(* blackbox *)
module INBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module OUTBUF (
	input D,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = D;
endmodule

(* blackbox *)
module OUTBUF_DIFF (
	input D,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

module TRIBUFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
endmodule

(* blackbox *)
module TRIBUFF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

// module DDR_IN
// module DDR_OUT
// module RAM1K18
// module RAM64x18
// module MACC

(* blackbox *)
module SYSRESET (
	(* iopad_external_pin *)
	input  DEVRST_N,
	output POWER_ON_RESET_N);
endmodule


(* blackbox *)
module XTLOSC (
	(* iopad_external_pin *)
	input  XTL,
	output CLKOUT);
	parameter [1:0] MODE = 2'h3;
	parameter real FREQUENCY = 20.0;
endmodule

(* blackbox *)
module RAM1K18 (
	input [13:0]  A_ADDR,
	input [2:0]   A_BLK,
	(* clkbuf_sink *)
	input	      A_CLK,
	input [17:0]  A_DIN,
	output [17:0] A_DOUT,
	input [1:0]   A_WEN,
	input [2:0]   A_WIDTH,
	input	      A_WMODE,
	input	      A_ARST_N,
	input	      A_DOUT_LAT,
	input	      A_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      A_DOUT_CLK,
	input	      A_DOUT_EN,
	input	      A_DOUT_SRST_N,

	input [13:0]  B_ADDR,
	input [2:0]   B_BLK,
	(* clkbuf_sink *)
	input	      B_CLK,
	input [17:0]  B_DIN,
	output [17:0] B_DOUT,
	input [1:0]   B_WEN,
	input [2:0]   B_WIDTH,
	input	      B_WMODE,
	input	      B_ARST_N,
	input	      B_DOUT_LAT,
	input	      B_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      B_DOUT_CLK,
	input	      B_DOUT_EN,
	input	      B_DOUT_SRST_N,

	input	      A_EN,
	input	      B_EN,
	input	      SII_LOCK,
	output	      BUSY);
endmodule

(* blackbox *)
module RAM64x18 (
	input [9:0]   A_ADDR,
	input [1:0]   A_BLK,
	input [2:0]   A_WIDTH,
	output [17:0] A_DOUT,
	input	      A_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      A_DOUT_CLK,
	input	      A_DOUT_EN,
	input	      A_DOUT_LAT,
	input	      A_DOUT_SRST_N,
	(* clkbuf_sink *)
	input	      A_ADDR_CLK,
	input	      A_ADDR_EN,
	input	      A_ADDR_LAT,
	input	      A_ADDR_SRST_N,
	input	      A_ADDR_ARST_N,

	input [9:0]   B_ADDR,
	input [1:0]   B_BLK,
	input [2:0]   B_WIDTH,
	output [17:0] B_DOUT,
	input	      B_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      B_DOUT_CLK,
	input	      B_DOUT_EN,
	input	      B_DOUT_LAT,
	input	      B_DOUT_SRST_N,
	(* clkbuf_sink *)
	input	      B_ADDR_CLK,
	input	      B_ADDR_EN,
	input	      B_ADDR_LAT,
	input	      B_ADDR_SRST_N,
	input	      B_ADDR_ARST_N,

	input [9:0]   C_ADDR,
	(* clkbuf_sink *)
	input	      C_CLK,
	input [17:0]  C_DIN,
	input	      C_WEN,
	input [1:0]   C_BLK,
	input [2:0]   C_WIDTH,

	input	      A_EN,
	input	      B_EN,
	input	      C_EN,
	input	      SII_LOCK,
	output	      BUSY);
endmodule
`},"simcells.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The internal logic cell simulation library.
 *
 *  This Verilog library contains simple simulation models for the internal
 *  logic cells ($_NOT_ , $_AND_ , ...) that are generated by the default technology
 *  mapper (see "techmap.v" in this directory) and expected by the "abc" pass.
 *
 */

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_BUF_ (A, Y)
//* group comb_simple
//-
//- A buffer. This cell type is always optimized away by the opt_clean pass.
//-
//- Truth table:    A | Y
//-                ---+---
//-                 0 | 0
//-                 1 | 1
//-
module \\$_BUF_ (A, Y);
input A;
output Y;
assign Y = A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NOT_ (A, Y)
//* group comb_simple
//-
//- An inverter gate.
//-
//- Truth table:    A | Y
//-                ---+---
//-                 0 | 1
//-                 1 | 0
//-
module \\$_NOT_ (A, Y);
input A;
output Y;
assign Y = ~A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AND_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input AND gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 1
//-
module \\$_AND_ (A, B, Y);
input A, B;
output Y;
assign Y = A & B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NAND_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input NAND gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_NAND_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A & B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OR_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input OR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 1
//-
module \\$_OR_ (A, B, Y);
input A, B;
output Y;
assign Y = A | B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NOR_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input NOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 0
//-
module \\$_NOR_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A | B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_XOR_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input XOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_XOR_ (A, B, Y);
input A, B;
output Y;
assign Y = A ^ B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_XNOR_ (A, B, Y)
//* group comb_simple
//-
//- A 2-input XNOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 1
//-
module \\$_XNOR_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A ^ B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ANDNOT_ (A, B, Y)
//* group comb_combined
//-
//- A 2-input AND-NOT gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 0
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_ANDNOT_ (A, B, Y);
input A, B;
output Y;
assign Y = A & (~B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ORNOT_ (A, B, Y)
//* group comb_combined
//-
//- A 2-input OR-NOT gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 1
//-                 1 1 | 1
//-
module \\$_ORNOT_ (A, B, Y);
input A, B;
output Y;
assign Y = A | (~B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX_ (A, B, S, Y)
//* group comb_simple
//-
//- A 2-input MUX gate.
//-
//- Truth table:    A B S | Y
//-                -------+---
//-                 a - 0 | a
//-                 - b 1 | b
//-
module \\$_MUX_ (A, B, S, Y);
input A, B, S;
output Y;
assign Y = S ? B : A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NMUX_ (A, B, S, Y)
//-
//- A 2-input inverting MUX gate.
//* group comb_combined
//-
//- Truth table:    A B S | Y
//-                -------+---
//-                 0 - 0 | 1
//-                 1 - 0 | 0
//-                 - 0 1 | 1
//-                 - 1 1 | 0
//-
module \\$_NMUX_ (A, B, S, Y);
input A, B, S;
output Y;
assign Y = S ? !B : !A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX4_ (A, B, C, D, S, T, Y)
//* group comb_combined
//-
//- A 4-input MUX gate.
//-
//- Truth table:    A B C D S T | Y
//-                -------------+---
//-                 a - - - 0 0 | a
//-                 - b - - 1 0 | b
//-                 - - c - 0 1 | c
//-                 - - - d 1 1 | d
//-
module \\$_MUX4_ (A, B, C, D, S, T, Y);
input A, B, C, D, S, T;
output Y;
assign Y = T ? (S ? D : C) :
               (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y)
//* group comb_combined
//-
//- An 8-input MUX gate.
//-
//- Truth table:    A B C D E F G H S T U | Y
//-                -----------------------+---
//-                 a - - - - - - - 0 0 0 | a
//-                 - b - - - - - - 1 0 0 | b
//-                 - - c - - - - - 0 1 0 | c
//-                 - - - d - - - - 1 1 0 | d
//-                 - - - - e - - - 0 0 1 | e
//-                 - - - - - f - - 1 0 1 | f
//-                 - - - - - - g - 0 1 1 | g
//-                 - - - - - - - h 1 1 1 | h
//-
module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);
input A, B, C, D, E, F, G, H, S, T, U;
output Y;
assign Y = U ? T ? (S ? H : G) :
                   (S ? F : E) :
               T ? (S ? D : C) :
                   (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y)
//* group comb_combined
//-
//- A 16-input MUX gate.
//-
//- Truth table:    A B C D E F G H I J K L M N O P S T U V | Y
//-                -----------------------------------------+---
//-                 a - - - - - - - - - - - - - - - 0 0 0 0 | a
//-                 - b - - - - - - - - - - - - - - 1 0 0 0 | b
//-                 - - c - - - - - - - - - - - - - 0 1 0 0 | c
//-                 - - - d - - - - - - - - - - - - 1 1 0 0 | d
//-                 - - - - e - - - - - - - - - - - 0 0 1 0 | e
//-                 - - - - - f - - - - - - - - - - 1 0 1 0 | f
//-                 - - - - - - g - - - - - - - - - 0 1 1 0 | g
//-                 - - - - - - - h - - - - - - - - 1 1 1 0 | h
//-                 - - - - - - - - i - - - - - - - 0 0 0 1 | i
//-                 - - - - - - - - - j - - - - - - 1 0 0 1 | j
//-                 - - - - - - - - - - k - - - - - 0 1 0 1 | k
//-                 - - - - - - - - - - - l - - - - 1 1 0 1 | l
//-                 - - - - - - - - - - - - m - - - 0 0 1 1 | m
//-                 - - - - - - - - - - - - - n - - 1 0 1 1 | n
//-                 - - - - - - - - - - - - - - o - 0 1 1 1 | o
//-                 - - - - - - - - - - - - - - - p 1 1 1 1 | p
//-
module \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);
input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;
output Y;
assign Y = V ? U ? T ? (S ? P : O) :
                       (S ? N : M) :
                   T ? (S ? L : K) :
                       (S ? J : I) :
               U ? T ? (S ? H : G) :
                       (S ? F : E) :
                   T ? (S ? D : C) :
                       (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AOI3_ (A, B, C, Y)
//* group comb_combined
//-
//- A 3-input And-Or-Invert gate.
//-
//- Truth table:    A B C | Y
//-                -------+---
//-                 0 0 0 | 1
//-                 0 0 1 | 0
//-                 0 1 0 | 1
//-                 0 1 1 | 0
//-                 1 0 0 | 1
//-                 1 0 1 | 0
//-                 1 1 0 | 0
//-                 1 1 1 | 0
//-
module \\$_AOI3_ (A, B, C, Y);
input A, B, C;
output Y;
assign Y = ~((A & B) | C);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OAI3_ (A, B, C, Y)
//* group comb_combined
//-
//- A 3-input Or-And-Invert gate.
//-
//- Truth table:    A B C | Y
//-                -------+---
//-                 0 0 0 | 1
//-                 0 0 1 | 1
//-                 0 1 0 | 1
//-                 0 1 1 | 0
//-                 1 0 0 | 1
//-                 1 0 1 | 0
//-                 1 1 0 | 1
//-                 1 1 1 | 0
//-
module \\$_OAI3_ (A, B, C, Y);
input A, B, C;
output Y;
assign Y = ~((A | B) & C);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AOI4_ (A, B, C, Y)
//* group comb_combined
//-
//- A 4-input And-Or-Invert gate.
//-
//- Truth table:    A B C D | Y
//-                ---------+---
//-                 0 0 0 0 | 1
//-                 0 0 0 1 | 1
//-                 0 0 1 0 | 1
//-                 0 0 1 1 | 0
//-                 0 1 0 0 | 1
//-                 0 1 0 1 | 1
//-                 0 1 1 0 | 1
//-                 0 1 1 1 | 0
//-                 1 0 0 0 | 1
//-                 1 0 0 1 | 1
//-                 1 0 1 0 | 1
//-                 1 0 1 1 | 0
//-                 1 1 0 0 | 0
//-                 1 1 0 1 | 0
//-                 1 1 1 0 | 0
//-                 1 1 1 1 | 0
//-
module \\$_AOI4_ (A, B, C, D, Y);
input A, B, C, D;
output Y;
assign Y = ~((A & B) | (C & D));
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OAI4_ (A, B, C, Y)
//* group comb_combined
//-
//- A 4-input Or-And-Invert gate.
//-
//- Truth table:    A B C D | Y
//-                ---------+---
//-                 0 0 0 0 | 1
//-                 0 0 0 1 | 1
//-                 0 0 1 0 | 1
//-                 0 0 1 1 | 1
//-                 0 1 0 0 | 1
//-                 0 1 0 1 | 0
//-                 0 1 1 0 | 0
//-                 0 1 1 1 | 0
//-                 1 0 0 0 | 1
//-                 1 0 0 1 | 0
//-                 1 0 1 0 | 0
//-                 1 0 1 1 | 0
//-                 1 1 0 0 | 1
//-                 1 1 0 1 | 0
//-                 1 1 1 0 | 0
//-                 1 1 1 1 | 0
//-
module \\$_OAI4_ (A, B, C, D, Y);
input A, B, C, D;
output Y;
assign Y = ~((A | B) & (C | D));
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_TBUF_ (A, E, Y)
//* group gate_other
//-
//- A tri-state buffer.
//-
//- Truth table:    A E | Y
//-                -----+---
//-                 a 1 | a
//-                 - 0 | z
//-
module \\$_TBUF_ (A, E, Y);
input A, E;
output Y;
assign Y = E ? A : 1'bz;
endmodule

// NOTE: the following cell types are autogenerated.  DO NOT EDIT them manually,
// instead edit the templates in gen_ff_types.py and rerun it.

// START AUTOGENERATED CELL TYPES

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_NN_ (S, R, Q)
//* group reg_latch
//-
//- A set-reset latch with negative polarity SET and negative polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 0 | 0
//-                 0 - | 1
//-                 - - | q
//-
module \\$_SR_NN_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_NP_ (S, R, Q)
//* group reg_latch
//-
//- A set-reset latch with negative polarity SET and positive polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 1 | 0
//-                 0 - | 1
//-                 - - | q
//-
module \\$_SR_NP_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_PN_ (S, R, Q)
//* group reg_latch
//-
//- A set-reset latch with positive polarity SET and negative polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 0 | 0
//-                 1 - | 1
//-                 - - | q
//-
module \\$_SR_PN_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_PP_ (S, R, Q)
//* group reg_latch
//-
//- A set-reset latch with positive polarity SET and positive polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 1 | 0
//-                 1 - | 1
//-                 - - | q
//-
module \\$_SR_PP_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
end
endmodule

\`ifdef SIMCELLS_FF
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_FF_ (D, Q)
//* group reg_ff
//-
//- A D-type flip-flop that is clocked from the implicit global clock. (This cell
//- type is usually only used in netlists for formal verification.)
//-
module \\$_FF_ (D, Q);
input D;
output reg Q;
always @($global_clock) begin
	Q <= D;
end
endmodule
\`endif

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_N_ (D, C, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop.
//-
//- Truth table:    D C | Q
//-                -----+---
//-                 d \\ | d
//-                 - - | q
//-
module \\$_DFF_N_ (D, C, Q);
input D, C;
output reg Q;
always @(negedge C) begin
	Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_P_ (D, C, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop.
//-
//- Truth table:    D C | Q
//-                -----+---
//-                 d / | d
//-                 - - | q
//-
module \\$_DFF_P_ (D, C, Q);
input D, C;
output reg Q;
always @(posedge C) begin
	Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN_ (D, C, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d \\ 0 | d
//-                 - - - | q
//-
module \\$_DFFE_NN_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(negedge C) begin
	if (!E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP_ (D, C, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d \\ 1 | d
//-                 - - - | q
//-
module \\$_DFFE_NP_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(negedge C) begin
	if (E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN_ (D, C, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d / 0 | d
//-                 - - - | q
//-
module \\$_DFFE_PN_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(posedge C) begin
	if (!E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP_ (D, C, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d / 1 | d
//-                 - - - | q
//-
module \\$_DFFE_PP_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(posedge C) begin
	if (E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NN0_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NN1_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NP0_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NP1_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PN0_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PN1_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PP0_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PP1_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_NN_ (D, C, L, AD, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 0 a  | a
//-                 d \\ - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_NN_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_NP_ (D, C, L, AD, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 1 a  | a
//-                 d \\ - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_NP_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_PN_ (D, C, L, AD, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 0 a  | a
//-                 d / - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_PN_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_PP_ (D, C, L, AD, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 1 a  | a
//-                 d / - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_PP_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NNN_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d \\ - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NNN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NNP_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d \\ - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NNP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NPN_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d \\ - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NPN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NPP_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d \\ - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NPP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PNN_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d / - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PNN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PNP_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d / - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PNP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PPN_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d / - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PPN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PPP_ (D, C, L, AD, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d / - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PPP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NNN_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NNN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NNP_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NNP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NPN_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NPN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NPP_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NPP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PNN_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PNN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PNP_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PNP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PPN_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PPN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PPP_ (C, S, R, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PPP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNNN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNNP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNPN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNPP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPNN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPNP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPPN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPPP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNNN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNNP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNPN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNPP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPNN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPNP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPPN_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPPP_ (C, S, R, E, D, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NN0_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 0 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NN1_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 0 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NP0_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 1 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NP1_ (D, C, R, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 1 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PN0_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 0 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PN1_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 0 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PP0_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 1 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PP1_ (D, C, R, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 1 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 0 | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 1 | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 0 | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 1 | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 0 | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 1 | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 0 | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 1 | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 0 | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 1 | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 0 | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 1 | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP0N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 0 | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP0P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 1 | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP1N_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 0 | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP1P_ (D, C, R, E, Q)
//* group reg_ff
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 1 | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_N_ (E, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch.
//-
//- Truth table:    E D | Q
//-                -----+---
//-                 0 d | d
//-                 - - | q
//-
module \\$_DLATCH_N_ (E, D, Q);
input E, D;
output reg Q;
always @* begin
	if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_P_ (E, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch.
//-
//- Truth table:    E D | Q
//-                -----+---
//-                 1 d | d
//-                 - - | q
//-
module \\$_DLATCH_P_ (E, D, Q);
input E, D;
output reg Q;
always @* begin
	if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NN0_ (E, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with negative polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 0
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NN0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NN1_ (E, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with negative polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 1
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NN1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NP0_ (E, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with positive polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 0
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NP0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NP1_ (E, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with positive polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 1
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NP1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PN0_ (E, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with negative polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 0
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PN0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PN1_ (E, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with negative polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 1
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PN1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PP0_ (E, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with positive polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 0
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PP0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PP1_ (E, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with positive polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 1
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PP1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NNN_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NNN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NNP_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NNP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NPN_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NPN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NPP_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A negative enable D-type latch with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NPP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PNN_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PNN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PNP_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PNP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PPN_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PPN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PPP_ (E, S, R, D, Q)
//* group reg_latch
//-
//- A positive enable D-type latch with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PPP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule
`,"simlib.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The Simulation Library.
 *
 *  This Verilog library contains simple simulation models for the internal
 *  cells ($not, ...) generated by the frontends and used in most passes.
 *
 *  This library can be used to verify the internal netlists as generated
 *  by the different frontends and passes.
 *
 *  Note that memory can only be simulated when all $memrd and $memwr cells
 *  have been merged to stand-alone $mem cells (this is what the "memory_collect"
 *  pass is doing).
 *
 */

// --------------------------------------------------------
//* ver 2
//* title Bit-wise inverter
//* group unary
//- This corresponds to the Verilog unary prefix '~' operator.
//-
module \\$not (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ~$signed(A);
	end else begin:BLOCK2
		assign Y = ~A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $pos (A, Y)
//* group unary
//-
//- A buffer. This corresponds to the Verilog unary prefix '+' operator.
//-
module \\$pos (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A);
	end else begin:BLOCK2
		assign Y = A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $buf (A, Y)
//* group unary
//-
//- A simple coarse-grain buffer cell type for the experimental buffered-normalized
//- mode. Note this cell does't get removed by 'opt_clean' and is not recommended
//- for general use.
//-
module \\$buf (A, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $neg (A, Y)
//* group unary
//-
//- An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.
//-
module \\$neg (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = -$signed(A);
	end else begin:BLOCK2
		assign Y = -A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $and (A, B, Y)
//* group binary
//-
//- A bit-wise AND. This corresponds to the Verilog '&' operator.
//-
module \\$and (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) & $signed(B);
	end else begin:BLOCK2
		assign Y = A & B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $or (A, B, Y)
//* group binary
//-
//- A bit-wise OR. This corresponds to the Verilog '|' operator.
//-
module \\$or (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) | $signed(B);
	end else begin:BLOCK2
		assign Y = A | B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $xor (A, B, Y)
//* group binary
//-
//- A bit-wise XOR. This corresponds to the Verilog '^' operator.
//-
module \\$xor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ^ $signed(B);
	end else begin:BLOCK2
		assign Y = A ^ B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $xnor (A, B, Y)
//* group binary
//-
//- A bit-wise XNOR. This corresponds to the Verilog '~^' operator.
//-
module \\$xnor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ~^ $signed(B);
	end else begin:BLOCK2
		assign Y = A ~^ B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_and (A, Y)
//* group unary
//-
//- An AND reduction. This corresponds to the Verilog unary prefix '&' operator.
//-
module \\$reduce_and (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = &$signed(A);
	end else begin:BLOCK2
		assign Y = &A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_or (A, Y)
//* group unary
//-
//- An OR reduction. This corresponds to the Verilog unary prefix '|' operator.
//-
module \\$reduce_or (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = |$signed(A);
	end else begin:BLOCK2
		assign Y = |A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_xor (A, Y)
//* group unary
//-
//- A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.
//-
module \\$reduce_xor (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ^$signed(A);
	end else begin:BLOCK2
		assign Y = ^A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_xnor (A, Y)
//* group unary
//-
//- A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.
//-
module \\$reduce_xnor (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ~^$signed(A);
	end else begin:BLOCK2
		assign Y = ~^A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_bool (A, Y)
//* group unary
//-
//- An OR reduction. This cell type is used instead of $reduce_or when a signal is
//- implicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.
//-
module \\$reduce_bool (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = !(!$signed(A));
	end else begin:BLOCK2
		assign Y = !(!A);
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $shl (A, B, Y)
//* group binary
//-
//- A logical shift-left operation. This corresponds to the Verilog '<<' operator.
//-
module \\$shl (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) << B;
	end else begin:BLOCK2
		assign Y = A << B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $shr (A, B, Y)
//* group binary
//-
//- A logical shift-right operation. This corresponds to the Verilog '>>' operator.
//-
module \\$shr (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >> B;
	end else begin:BLOCK2
		assign Y = A >> B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $sshl (A, B, Y)
//* group binary
//-
//- An arithmatic shift-left operation. 
//- This corresponds to the Verilog '<<<' operator.
//-
module \\$sshl (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) <<< B;
	end else begin:BLOCK2
		assign Y = A <<< B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $sshr (A, B, Y)
//* group binary
//-
//- An arithmatic shift-right operation.
//- This corresponds to the Verilog '>>>' operator.
//-
module \\$sshr (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >>> B;
	end else begin:BLOCK2
		assign Y = A >>> B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Variable shifter
//* group binary
//- Performs a right logical shift if the second operand is positive (or
//- unsigned), and a left logical shift if it is negative.
//-
module \\$shift (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		if (B_SIGNED) begin:BLOCK2
			assign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B;
		end else begin:BLOCK3
			assign Y = $signed(A) >> B;
		end
	end else begin:BLOCK4
		if (B_SIGNED) begin:BLOCK5
			assign Y = $signed(B) < 0 ? A << -B : A >> B;
		end else begin:BLOCK6
			assign Y = A >> B;
		end
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Indexed part-select
//* group binary
//* tags x-output
//- Same as the \`$shift\` cell, but fills with 'x'.
//-
module \\$shiftx (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (Y_WIDTH > 0)
		if (B_SIGNED) begin:BLOCK1
			assign Y = A[$signed(B) +: Y_WIDTH];
		end else begin:BLOCK2
			assign Y = A[B +: Y_WIDTH];
		end
endgenerate

endmodule

// --------------------------------------------------------
//* group arith
module \\$fa (A, B, C, X, Y);

parameter WIDTH = 1;

input [WIDTH-1:0] A, B, C;
output [WIDTH-1:0] X, Y;

wire [WIDTH-1:0] t1, t2, t3;

assign t1 = A ^ B, t2 = A & B, t3 = C & t1;
assign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);

endmodule

// --------------------------------------------------------
//* group arith

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $lcu (P, G, CI, CO)
//-
//- Lookahead carry unit
//- A building block dedicated to fast computation of carry-bits used in binary
//- arithmetic operations. By replacing the ripple carry structure used in full-adder
//- blocks, the more significant  bits of the sum can be expected to be computed more
//- quickly.
//- Typically created during \`techmap\` of $alu cells (see the "_90_alu" rule in
//- +/techmap.v).
module \\$lcu (P, G, CI, CO);

parameter WIDTH = 1;

input [WIDTH-1:0] P;    // Propagate
input [WIDTH-1:0] G;    // Generate
input CI;               // Carry-in

output reg [WIDTH-1:0] CO; // Carry-out

integer i;
always @* begin
	CO = 'bx;
	if (^{P, G, CI} !== 1'bx) begin
		CO[0] = G[0] || (P[0] && CI);
		for (i = 1; i < WIDTH; i = i+1)
			CO[i] = G[i] || (P[i] && CO[i-1]);
	end
end

endmodule

// --------------------------------------------------------
//* ver 2
//* title Arithmetic logic unit
//* group arith
//- A building block supporting both binary addition/subtraction operations, and
//- indirectly, comparison operations.
//- Typically created by the \`alumacc\` pass, which transforms:
//- \`$add\`, \`$sub\`, \`$lt\`, \`$le\`, \`$ge\`, \`$gt\`, \`$eq\`, \`$eqx\`, \`$ne\`, \`$nex\`
//- cells into this \`$alu\` cell.
//-
module \\$alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

input [A_WIDTH-1:0] A;      // Input operand
input [B_WIDTH-1:0] B;      // Input operand
output [Y_WIDTH-1:0] X;     // A xor B (sign-extended, optional B inversion,
                            //          used in combination with
                            //          reduction-AND for $eq/$ne ops)
output [Y_WIDTH-1:0] Y;     // Sum

input CI;                   // Carry-in (set for $sub)
input BI;                   // Invert-B (set for $sub)
output [Y_WIDTH-1:0] CO;    // Carry-out

wire [Y_WIDTH-1:0] AA, BB;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);
	end else begin:BLOCK2
		assign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);
	end
endgenerate

// this is 'x' if Y and CO should be all 'x', and '0' otherwise
wire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};

assign X = AA ^ BB;
// Full adder
assign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};

function get_carry;
	input a, b, c;
	get_carry = (a&b) | (a&c) | (b&c);
endfunction

genvar i;
generate
	assign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;
	for (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3
		assign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $lt (A, B, Y)
//* group binary
//-
//- A less-than comparison between inputs 'A' and 'B'. 
//- This corresponds to the Verilog '<' operator.
//-
module \\$lt (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) < $signed(B);
	end else begin:BLOCK2
		assign Y = A < B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $le (A, B, Y)
//* group binary
//-
//- A less-than-or-equal-to comparison between inputs 'A' and 'B'. 
//- This corresponds to the Verilog '<=' operator.
//-
module \\$le (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) <= $signed(B);
	end else begin:BLOCK2
		assign Y = A <= B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $eq (A, B, Y)
//* group binary
//-
//- An equality comparison between inputs 'A' and 'B'. 
//- This corresponds to the Verilog '==' operator.
//-
module \\$eq (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) == $signed(B);
	end else begin:BLOCK2
		assign Y = A == B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $ne (A, B, Y)
//* group binary
//-
//- An inequality comparison between inputs 'A' and 'B'. 
//- This corresponds to the Verilog '!=' operator.
//-
module \\$ne (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) != $signed(B);
	end else begin:BLOCK2
		assign Y = A != B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Case equality
//* group binary
//* tags x-aware
//- An exact equality comparison between inputs 'A' and 'B'. Also known as the
//- case equality operator. This corresponds to the Verilog '===' operator.
//- Unlike equality comparison that can give 'x' as output, an exact equality
//- comparison will strictly give '0' or '1' as output, even if input includes
//- 'x' or 'z' values.
//-
module \\$eqx (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) === $signed(B);
	end else begin:BLOCK2
		assign Y = A === B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Case inequality
//* group binary
//* tags x-aware
//- This corresponds to the Verilog '!==' operator.
//-
//- Refer to \`$eqx\` for more details.
//-
module \\$nex (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) !== $signed(B);
	end else begin:BLOCK2
		assign Y = A !== B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $ge (A, B, Y)
//* group binary
//-
//- A greater-than-or-equal-to comparison between inputs 'A' and 'B'.
//- This corresponds to the Verilog '>=' operator.
//-
module \\$ge (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >= $signed(B);
	end else begin:BLOCK2
		assign Y = A >= B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $gt (A, B, Y)
//* group binary
//-
//- A greater-than comparison between inputs 'A' and 'B'. 
//- This corresponds to the Verilog '>' operator.
//-
module \\$gt (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) > $signed(B);
	end else begin:BLOCK2
		assign Y = A > B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $add (A, B, Y)
//* group binary
//-
//-  Addition of inputs 'A' and 'B'. This corresponds to the Verilog '+' operator.
//-
module \\$add (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) + $signed(B);
	end else begin:BLOCK2
		assign Y = A + B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $sub (A, B, Y)
//* group binary
//-
//- Subtraction between inputs 'A' and 'B'.
//- This corresponds to the Verilog '-' operator.
//-
module \\$sub (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) - $signed(B);
	end else begin:BLOCK2
		assign Y = A - B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $mul (A, B, Y)
//* group binary
//-
//- Multiplication of inputs 'A' and 'B'.
//- This corresponds to the Verilog '*' operator.
//-
module \\$mul (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) * $signed(B);
	end else begin:BLOCK2
		assign Y = A * B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $macc (A, B, Y)
//* group arith
//-
//- Multiply and accumulate.
//- A building block for summing any number of negated and unnegated signals
//- and arithmetic products of pairs of signals. Cell port A concatenates pairs
//- of signals to be multiplied together. When the second signal in a pair is zero
//- length, a constant 1 is used instead as the second factor. Cell port B
//- concatenates 1-bit-wide signals to also be summed, such as "carry in" in adders.
//- Typically created by the \`alumacc\` pass, which transforms $add and $mul
//- into $macc cells.
module \\$macc (A, B, Y);

parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;
// CONFIG determines the layout of A, as explained below
parameter CONFIG = 4'b0000;
parameter CONFIG_WIDTH = 4;

// In the terms used for this cell, there's mixed meanings for the term "port". To disambiguate:
// A cell port is for example the A input (it is constructed in C++ as cell->setPort(ID::A, ...))
// Multiplier ports are pairs of multiplier inputs ("factors").
// If the second signal in such a pair is zero length, no multiplication is necessary, and the first signal is just added to the sum.
input [A_WIDTH-1:0] A; // Cell port A is the concatenation of all arithmetic ports
input [B_WIDTH-1:0] B; // Cell port B is the concatenation of single-bit unsigned signals to be also added to the sum
output reg [Y_WIDTH-1:0] Y; // Output sum

// Xilinx XSIM does not like $clog2() below..
function integer my_clog2;
	input integer v;
	begin
		if (v > 0)
			v = v - 1;
		my_clog2 = 0;
		while (v) begin
			v = v >> 1;
			my_clog2 = my_clog2 + 1;
		end
	end
endfunction

// Bits that a factor's length field in CONFIG per factor in cell port A
localparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;
// Number of multiplier ports
localparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);
// Minium bit width of an induction variable to iterate over all bits of cell port A
localparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;

// In this pseudocode, u(foo) means an unsigned int that's foo bits long.
// The CONFIG parameter carries the following information:
//	struct CONFIG {
//		u4 num_bits;
//		struct port_field {
//			bool is_signed;
//			bool is_subtract;
//			u(num_bits) factor1_len;
//			u(num_bits) factor2_len;
//		}[num_ports];
//	};

// The A cell port carries the following information:
//	struct A {
//		u(CONFIG.port_field[0].factor1_len) port0factor1;
//		u(CONFIG.port_field[0].factor2_len) port0factor2;
//		u(CONFIG.port_field[1].factor1_len) port1factor1;
//		u(CONFIG.port_field[1].factor2_len) port1factor2;
//		...
//	};
// and log(sizeof(A)) is num_abits.
// No factor1 may have a zero length.
// A factor2 having a zero length implies factor2 is replaced with a constant 1.

// Additionally, B is an array of 1-bit-wide unsigned integers to also be summed up.
// Finally, we have:
// Y = port0factor1 * port0factor2 + port1factor1 * port1factor2 + ...
//     * B[0] + B[1] + ...

function [2*num_ports*num_abits-1:0] get_port_offsets;
	input [CONFIG_WIDTH-1:0] cfg;
	integer i, cursor;
	begin
		cursor = 0;
		get_port_offsets = 0;
		for (i = 0; i < num_ports; i = i+1) begin
			get_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;
			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];
			get_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;
			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];
		end
	end
endfunction

localparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);

\`define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])
\`define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])
\`define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])
\`define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])
\`define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])
\`define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])

integer i, j;
reg [Y_WIDTH-1:0] tmp_a, tmp_b;

always @* begin
	Y = 0;
	for (i = 0; i < num_ports; i = i+1)
	begin
		tmp_a = 0;
		tmp_b = 0;

		for (j = 0; j < \`PORT_SIZE_A; j = j+1)
			tmp_a[j] = A[\`PORT_OFFSET_A + j];

		if (\`PORT_IS_SIGNED && \`PORT_SIZE_A > 0)
			for (j = \`PORT_SIZE_A; j < Y_WIDTH; j = j+1)
				tmp_a[j] = tmp_a[\`PORT_SIZE_A-1];

		for (j = 0; j < \`PORT_SIZE_B; j = j+1)
			tmp_b[j] = A[\`PORT_OFFSET_B + j];

		if (\`PORT_IS_SIGNED && \`PORT_SIZE_B > 0)
			for (j = \`PORT_SIZE_B; j < Y_WIDTH; j = j+1)
				tmp_b[j] = tmp_b[\`PORT_SIZE_B-1];

		if (\`PORT_SIZE_B > 0)
			tmp_a = tmp_a * tmp_b;

		if (\`PORT_DO_SUBTRACT)
			Y = Y - tmp_a;
		else
			Y = Y + tmp_a;
	end
	for (i = 0; i < B_WIDTH; i = i+1) begin
		Y = Y + B[i];
	end
end

\`undef PORT_IS_SIGNED
\`undef PORT_DO_SUBTRACT
\`undef PORT_SIZE_A
\`undef PORT_SIZE_B
\`undef PORT_OFFSET_A
\`undef PORT_OFFSET_B

endmodule

// --------------------------------------------------------
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $macc_v2 (A, B, C, Y)
//* group arith
//-
//- Multiply and add.
//- This cell represents a generic fused multiply-add operation, it supersedes the
//- earlier $macc cell.
//-
module \\$macc_v2 (A, B, C, Y);

parameter NPRODUCTS = 0;
parameter NADDENDS = 0;
parameter A_WIDTHS = 16'h0000;
parameter B_WIDTHS = 16'h0000;
parameter C_WIDTHS = 16'h0000;
parameter Y_WIDTH = 0;

parameter PRODUCT_NEGATED = 1'bx;
parameter ADDEND_NEGATED = 1'bx;
parameter A_SIGNED = 1'bx;
parameter B_SIGNED = 1'bx;
parameter C_SIGNED = 1'bx;

function integer sum_widths1;
	input [(16*NPRODUCTS)-1:0] widths;
	integer i;
	begin
		sum_widths1 = 0;
		for (i = 0; i < NPRODUCTS; i++) begin
			sum_widths1 = sum_widths1 + widths[16*i+:16];
		end
	end
endfunction

function integer sum_widths2;
	input [(16*NADDENDS)-1:0] widths;
	integer i;
	begin
		sum_widths2 = 0;
		for (i = 0; i < NADDENDS; i++) begin
			sum_widths2 = sum_widths2 + widths[16*i+:16];
		end
	end
endfunction

input [sum_widths1(A_WIDTHS)-1:0] A; // concatenation of LHS factors
input [sum_widths1(B_WIDTHS)-1:0] B; // concatenation of RHS factors
input [sum_widths2(C_WIDTHS)-1:0] C; // concatenation of summands
output reg [Y_WIDTH-1:0] Y; // output sum

integer i, j, ai, bi, ci, aw, bw, cw;
reg [Y_WIDTH-1:0] product;
reg [Y_WIDTH-1:0] addend, oper_a, oper_b;

always @* begin
	Y = 0;
	ai = 0;
	bi = 0;
	for (i = 0; i < NPRODUCTS; i = i+1)
	begin
		aw = A_WIDTHS[16*i+:16];
		bw = B_WIDTHS[16*i+:16];

		oper_a = 0;
		oper_b = 0;
		for (j = 0; j < Y_WIDTH && j < aw; j = j + 1)
			oper_a[j] = A[ai + j];
		for (j = 0; j < Y_WIDTH && j < bw; j = j + 1)
			oper_b[j] = B[bi + j];
		// A_SIGNED[i] == B_SIGNED[i] as RTLIL invariant
		if (A_SIGNED[i] && B_SIGNED[i]) begin
			for (j = aw; j > 0 && j < Y_WIDTH; j = j + 1)
				oper_a[j] = oper_a[j - 1];
			for (j = bw; j > 0 && j < Y_WIDTH; j = j + 1)
				oper_b[j] = oper_b[j - 1];
		end

		product = oper_a * oper_b;

		if (PRODUCT_NEGATED[i])
			Y = Y - product;
		else
			Y = Y + product;

		ai = ai + aw;
		bi = bi + bw;
	end

	ci = 0;
	for (i = 0; i < NADDENDS; i = i+1)
	begin
		cw = C_WIDTHS[16*i+:16];

		addend = 0;
		for (j = 0; j < Y_WIDTH && j < cw; j = j + 1)
			addend[j] = C[ci + j];
		if (C_SIGNED[i]) begin
			for (j = cw; j > 0 && j < Y_WIDTH; j = j + 1)
				addend[j] = addend[j - 1];
		end

		if (ADDEND_NEGATED[i])
			Y = Y - addend;
		else
			Y = Y + addend;

		ci = ci + cw;
	end
end

endmodule

// --------------------------------------------------------
//* ver 2
//* title Divider
//* group binary
//* tags x-output
//- This corresponds to the Verilog '/' operator, performing division and
//- truncating the result (rounding towards 0).
//-
module \\$div (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) / $signed(B);
	end else begin:BLOCK2
		assign Y = A / B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Modulo
//* group binary
//* tags x-output
//- This corresponds to the Verilog '%' operator, giving the module (or
//- remainder) of division and truncating the result (rounding towards 0).
//-
//- Invariant: $div(A, B) * B + $mod(A, B) == A
//-
module \\$mod (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) % $signed(B);
	end else begin:BLOCK2
		assign Y = A % B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $divfloor (A, B, Y)
//* group binary
//-
//- Division with floored result (rounded towards negative infinity).
//-
module \\$divfloor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		localparam WIDTH =
				A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
				B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;
		wire [WIDTH:0] A_buf, B_buf, N_buf;
		assign A_buf = $signed(A);
		assign B_buf = $signed(B);
		assign N_buf = (A[A_WIDTH-1] == B[B_WIDTH-1]) || A == 0 ? A_buf : $signed(A_buf - (B[B_WIDTH-1] ? B_buf+1 : B_buf-1));
		assign Y = $signed(N_buf) / $signed(B_buf);
	end else begin:BLOCK2
		assign Y = A / B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $modfloor (A, B, Y)
//* group binary
//-
//- Modulo/remainder of division with floored result (rounded towards negative infinity).
//-
//- Invariant: $divfloor(A, B) * B + $modfloor(A, B) == A
//-
module \\$modfloor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		localparam WIDTH = B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;
		wire [WIDTH-1:0] B_buf, Y_trunc;
		assign B_buf = $signed(B);
		assign Y_trunc = $signed(A) % $signed(B);
		// flooring mod is the same as truncating mod for positive division results (A and B have
		// the same sign), as well as when there's no remainder.
		// For all other cases, they behave as \`floor - trunc = B\`
		assign Y = (A[A_WIDTH-1] == B[B_WIDTH-1]) || Y_trunc == 0 ? Y_trunc : $signed(B_buf) + $signed(Y_trunc);
	end else begin:BLOCK2
		// no difference between truncating and flooring for unsigned
		assign Y = A % B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $pow (A, B, Y)
//* group binary
//-
//- Exponentiation of an input (Y = A ** B). 
//- This corresponds to the Verilog '**' operator.
//-
\`ifndef SIMLIB_NOPOW

module \\$pow (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ** $signed(B);
	end else if (A_SIGNED) begin:BLOCK2
		assign Y = $signed(A) ** B;
	end else if (B_SIGNED) begin:BLOCK3
		assign Y = A ** $signed(B);
	end else begin:BLOCK4
		assign Y = A ** B;
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $logic_not (A, Y)
//* group unary
//-
//- A logical inverter. This corresponds to the Verilog unary prefix '!' operator.
//-
module \\$logic_not (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = !$signed(A);
	end else begin:BLOCK2
		assign Y = !A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $logic_and (A, B, Y)
//* group binary
//-
//- A logical AND. This corresponds to the Verilog '&&' operator.
//-
module \\$logic_and (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) && $signed(B);
	end else begin:BLOCK2
		assign Y = A && B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $logic_or (A, B, Y)
//* group binary
//-
//- A logical OR. This corresponds to the Verilog '||' operator.
//-
module \\$logic_or (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) || $signed(B);
	end else begin:BLOCK2
		assign Y = A || B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* group wire
module \\$slice (A, Y);

parameter OFFSET = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

assign Y = A >> OFFSET;

endmodule

// --------------------------------------------------------
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $concat (A, B, Y)
//* group wire
//-
//- Concatenation of inputs into a single output ( Y = {B, A} ).
//-
module \\$concat (A, B, Y);

parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [A_WIDTH+B_WIDTH-1:0] Y;

assign Y = {B, A};

endmodule

// --------------------------------------------------------
//* group mux

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $mux (A, B, S, Y)
//-
//- Multiplexer i.e selecting between two inputs based on select signal.
//-
module \\$mux (A, B, S, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
input S;
output [WIDTH-1:0] Y;

assign Y = S ? B : A;

endmodule

// --------------------------------------------------------
//* ver 2
//* title Binary-encoded multiplexer
//* group mux
//- Selects between 'slices' of A where each value of S corresponds to a unique
//- slice.
//-
module \\$bmux (A, S, Y);

parameter WIDTH = 0;
parameter S_WIDTH = 0;

input [(WIDTH << S_WIDTH)-1:0] A;
input [S_WIDTH-1:0] S;
output [WIDTH-1:0] Y;

wire [WIDTH-1:0] bm0_out, bm1_out;

generate
	if (S_WIDTH > 1) begin:muxlogic
		\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm0 (.A(A[(WIDTH << (S_WIDTH - 1))-1:0]), .S(S[S_WIDTH-2:0]), .Y(bm0_out));
		\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm1 (.A(A[(WIDTH << S_WIDTH)-1:WIDTH << (S_WIDTH - 1)]), .S(S[S_WIDTH-2:0]), .Y(bm1_out));
		assign Y = S[S_WIDTH-1] ? bm1_out : bm0_out;
	end else if (S_WIDTH == 1) begin:simple
		assign Y = S ? A[2*WIDTH-1:WIDTH] : A[WIDTH-1:0];
	end else begin:passthru
		assign Y = A;
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Priority-encoded multiplexer
//* group mux
//* tags x-output
//- Selects between 'slices' of B where each slice corresponds to a single bit
//- of S. Outputs A when all bits of S are low.
//-
module \\$pmux (A, B, S, Y);

parameter WIDTH = 0;
parameter S_WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH*S_WIDTH-1:0] B;
input [S_WIDTH-1:0] S;
output reg [WIDTH-1:0] Y;

integer i;
reg found_active_sel_bit;

always @* begin
	Y = A;
	found_active_sel_bit = 0;
	for (i = 0; i < S_WIDTH; i = i+1)
		case (S[i])
			1'b1: begin
				Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i);
				found_active_sel_bit = 1;
			end
			1'b0: ;
			1'bx: begin
				Y = 'bx;
				found_active_sel_bit = 'bx;
			end
		endcase
end

endmodule

// --------------------------------------------------------
//* group mux

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $demux (A, S, Y)
//-
//- Demultiplexer i.e routing single input to several outputs based on select signal.
//- Unselected outputs are driven to zero.
//-
module \\$demux (A, S, Y);

parameter WIDTH = 1;
parameter S_WIDTH = 1;

input [WIDTH-1:0] A;
input [S_WIDTH-1:0] S;
output [(WIDTH << S_WIDTH)-1:0] Y;

genvar i;
generate
	for (i = 0; i < (1 << S_WIDTH); i = i + 1) begin:slices
		assign Y[i*WIDTH+:WIDTH] = (S == i) ? A : 0;
	end
endgenerate

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOLUT
//* group logic

module \\$lut (A, Y);

parameter WIDTH = 0;
parameter LUT = 0;

input [WIDTH-1:0] A;
output Y;

\\$bmux #(.WIDTH(1), .S_WIDTH(WIDTH)) mux(.A(LUT[(1<<WIDTH)-1:0]), .S(A), .Y(Y));

endmodule

\`endif
// --------------------------------------------------------
//* group logic

module \\$sop (A, Y);

parameter WIDTH = 0;
parameter DEPTH = 0;
parameter TABLE = 0;

input [WIDTH-1:0] A;
output reg Y;

integer i, j;
reg match;

always @* begin
	Y = 0;
	for (i = 0; i < DEPTH; i=i+1) begin
		match = 1;
		for (j = 0; j < WIDTH; j=j+1) begin
			if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;
			if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;
		end
		if (match) Y = 1;
	end
end

endmodule

// --------------------------------------------------------
//* group mux

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $tribuf (A, EN, Y)
//-
//- A tri-state buffer. 
//- This buffer conditionally drives the output with the value of the input
//- based on the enable signal.
//-
module \\$tribuf (A, EN, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A;
input EN;
output [WIDTH-1:0] Y;

assign Y = EN ? A : 'bz;

endmodule

// --------------------------------------------------------
//* group spec

module \\$specify2 (EN, SRC, DST);

parameter FULL = 0;
parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter SRC_DST_PEN = 0;
parameter SRC_DST_POL = 0;

parameter T_RISE_MIN = 0;
parameter T_RISE_TYP = 0;
parameter T_RISE_MAX = 0;

parameter T_FALL_MIN = 0;
parameter T_FALL_TYP = 0;
parameter T_FALL_MAX = 0;

input EN;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST;

localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;

\`ifdef SIMLIB_SPECIFY
specify
	if (EN && SD==0 && !FULL) (SRC  => DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==0 &&  FULL) (SRC  *> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==1 && !FULL) (SRC +=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==1 &&  FULL) (SRC +*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==2 && !FULL) (SRC -=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==2 &&  FULL) (SRC -*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
endspecify
\`endif

endmodule

// --------------------------------------------------------
//* group spec

module \\$specify3 (EN, SRC, DST, DAT);

parameter FULL = 0;
parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter EDGE_EN = 0;
parameter EDGE_POL = 0;

parameter SRC_DST_PEN = 0;
parameter SRC_DST_POL = 0;

parameter DAT_DST_PEN = 0;
parameter DAT_DST_POL = 0;

parameter T_RISE_MIN = 0;
parameter T_RISE_TYP = 0;
parameter T_RISE_MAX = 0;

parameter T_FALL_MIN = 0;
parameter T_FALL_TYP = 0;
parameter T_FALL_MAX = 0;

input EN;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST, DAT;

localparam ED = EDGE_EN     ? (EDGE_POL    ? 1 : 2) : 0;
localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;
localparam DD = DAT_DST_PEN ? (DAT_DST_POL ? 1 : 2) : 0;

\`ifdef SIMLIB_SPECIFY
specify
	// DD=0

	if (EN && DD==0 && SD==0 && ED==0 && !FULL) (        SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==0 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==0 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	// DD=1

	if (EN && DD==1 && SD==0 && ED==0 && !FULL) (        SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==1 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==1 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	// DD=2

	if (EN && DD==2 && SD==0 && ED==0 && !FULL) (        SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==2 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==2 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
endspecify
\`endif

endmodule

// --------------------------------------------------------
//* group spec

module \\$specrule (EN_SRC, EN_DST, SRC, DST);

parameter TYPE = "";
parameter T_LIMIT = 0;
parameter T_LIMIT2 = 0;

parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter SRC_PEN = 0;
parameter SRC_POL = 0;

parameter DST_PEN = 0;
parameter DST_POL = 0;

input EN_SRC, EN_DST;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST;

\`ifdef SIMLIB_SPECIFY
specify
	// TBD
endspecify
\`endif

endmodule

// --------------------------------------------------------
//* ver 2
//* title Bit-wise case equality
//* group binary
//* tags x-aware
//- A bit-wise version of \`$eqx\`.
//-
module \\$bweqx (A, B, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
output [WIDTH-1:0] Y;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i + 1) begin:slices
		assign Y[i] = A[i] === B[i];
	end
endgenerate

endmodule

// --------------------------------------------------------
//* ver 2
//* title Bit-wise multiplexer
//* group mux
//- Equivalent to a series of 1-bit wide \`$mux\` cells.
//-
module \\$bwmux (A, B, S, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
input [WIDTH-1:0] S;
output [WIDTH-1:0] Y;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i + 1) begin:slices
		assign Y[i] = S[i] ? B[i] : A[i];
	end
endgenerate

endmodule

// --------------------------------------------------------
//* group formal

module \\$assert (A, EN);

input A, EN;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'b1 && EN === 1'b1) begin
		$display("Assertion %m failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------
//* group formal

module \\$assume (A, EN);

input A, EN;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'b1 && EN === 1'b1) begin
		$display("Assumption %m failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------
//* group formal

module \\$live (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------
//* group formal

module \\$fair (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------
//* group formal

module \\$cover (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------
//* group formal

module \\$initstate (Y);

output reg Y = 1;
reg [3:0] cnt = 1;
reg trig = 0;

initial trig <= 1;

always @(cnt, trig) begin
	Y <= |cnt;
	cnt <= cnt + |cnt;
end

endmodule

// --------------------------------------------------------
//* group formal

module \\$anyconst (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------
//* group formal

module \\$anyseq (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------
\`ifdef SIMLIB_FF
\`ifndef SIMLIB_GLOBAL_CLOCK
\`define SIMLIB_GLOBAL_CLOCK $global_clk
\`endif
//* group formal
module \\$anyinit (D, Q);

parameter WIDTH = 0;

input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

initial Q <= 'bx;

always @(\`SIMLIB_GLOBAL_CLOCK) begin
	Q <= D;
end

endmodule
\`endif
// --------------------------------------------------------
//* group formal

module \\$allconst (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------
//* group formal

module \\$allseq (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------
//* group formal

module \\$equiv (A, B, Y);

input A, B;
output Y;

assign Y = (A !== 1'bx && A !== B) ? 1'bx : A;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'bx && A !== B) begin
		$display("Equivalence failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------
//* group debug

module \\$print (EN, TRG, ARGS);

parameter PRIORITY = 0;

parameter FORMAT = "";
parameter signed ARGS_WIDTH = 0;

parameter TRG_ENABLE = 1;
parameter signed TRG_WIDTH = 0;
parameter TRG_POLARITY = 0;

input EN;
input [TRG_WIDTH-1:0] TRG;
input [ARGS_WIDTH-1:0] ARGS;

endmodule

// --------------------------------------------------------
//* group debug

module \\$check (A, EN, TRG, ARGS);

parameter FLAVOR = "";
parameter PRIORITY = 0;

parameter FORMAT = "";
parameter ARGS_WIDTH = 0;

parameter TRG_ENABLE = 1;
parameter TRG_WIDTH = 0;
parameter TRG_POLARITY = 0;

input A;
input EN;
input [TRG_WIDTH-1:0] TRG;
input [ARGS_WIDTH-1:0] ARGS;

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR
//* group reg

module \\$sr (SET, CLR, Q);

parameter WIDTH = 0;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input [WIDTH-1:0] SET, CLR;
output reg [WIDTH-1:0] Q;

wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @*
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------
\`ifdef SIMLIB_FF
\`ifndef SIMLIB_GLOBAL_CLOCK
\`define SIMLIB_GLOBAL_CLOCK $global_clk
\`endif
//* group formal

module \\$ff (D, Q);

parameter WIDTH = 0;

input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @(\`SIMLIB_GLOBAL_CLOCK) begin
	Q <= D;
end

endmodule

\`endif
// --------------------------------------------------------
//* group reg

module \\$dff (CLK, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;

input CLK;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;

always @(posedge pos_clk) begin
	Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$dffe (CLK, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;

input CLK, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;

always @(posedge pos_clk) begin
	if (EN == EN_POLARITY) Q <= D;
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR
//* group reg

module \\$dffsr (CLK, SET, CLR, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input CLK;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_clk = CLK == CLK_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
			else
				Q[i] <= D[i];
	end
endgenerate

endmodule

// --------------------------------------------------------
//* group reg

module \\$dffsre (CLK, SET, CLR, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;

input CLK, EN;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_clk = CLK == CLK_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
			else if (EN == EN_POLARITY)
				Q[i] <= D[i];
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------
//* group reg

module \\$adff (CLK, ARST, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input CLK, ARST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst)
		Q <= ARST_VALUE;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$aldff (CLK, ALOAD, AD, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter ALOAD_POLARITY = 1'b1;

input CLK, ALOAD;
input [WIDTH-1:0] AD;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_aload = ALOAD == ALOAD_POLARITY;

always @(posedge pos_clk, posedge pos_aload) begin
	if (pos_aload)
		Q <= AD;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$sdff (CLK, SRST, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (pos_srst)
		Q <= SRST_VALUE;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$adffe (CLK, ARST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input CLK, ARST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst)
		Q <= ARST_VALUE;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$aldffe (CLK, ALOAD, AD, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter ALOAD_POLARITY = 1'b1;

input CLK, ALOAD, EN;
input [WIDTH-1:0] D;
input [WIDTH-1:0] AD;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_aload = ALOAD == ALOAD_POLARITY;

always @(posedge pos_clk, posedge pos_aload) begin
	if (pos_aload)
		Q <= AD;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$sdffe (CLK, SRST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (pos_srst)
		Q <= SRST_VALUE;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$sdffce (CLK, SRST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (EN == EN_POLARITY) begin
		if (pos_srst)
			Q <= SRST_VALUE;
		else
			Q <= D;
	end
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$dlatch (EN, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;

input EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @* begin
	if (EN == EN_POLARITY)
		Q = D;
end

endmodule

// --------------------------------------------------------
//* group reg

module \\$adlatch (EN, ARST, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input EN, ARST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @* begin
	if (ARST == ARST_POLARITY)
		Q = ARST_VALUE;
	else if (EN == EN_POLARITY)
		Q = D;
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR
//* group reg

module \\$dlatchsr (EN, SET, CLR, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input EN;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_en = EN == EN_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @*
			if (pos_clr[i])
				Q[i] = 0;
			else if (pos_set[i])
				Q[i] = 1;
			else if (pos_en)
				Q[i] = D[i];
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------
//* group fsm

module \\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);

parameter NAME = "";

parameter CLK_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;

parameter CTRL_IN_WIDTH = 1;
parameter CTRL_OUT_WIDTH = 1;

parameter STATE_BITS = 1;
parameter STATE_NUM = 1;
parameter STATE_NUM_LOG2 = 1;
parameter STATE_RST = 0;
parameter STATE_TABLE = 1'b0;

parameter TRANS_NUM = 1;
parameter TRANS_TABLE = 4'b0x0x;

input CLK, ARST;
input [CTRL_IN_WIDTH-1:0] CTRL_IN;
output reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;

wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

reg [STATE_BITS-1:0] state;
reg [STATE_BITS-1:0] state_tmp;
reg [STATE_BITS-1:0] next_state;

reg [STATE_BITS-1:0] tr_state_in;
reg [STATE_BITS-1:0] tr_state_out;
reg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;
reg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;

integer i;

task tr_fetch;
	input [31:0] tr_num;
	reg [31:0] tr_pos;
	reg [STATE_NUM_LOG2-1:0] state_num;
	begin
		tr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;
		tr_ctrl_out = TRANS_TABLE >> tr_pos;
		tr_pos = tr_pos + CTRL_OUT_WIDTH;
		state_num = TRANS_TABLE >> tr_pos;
		tr_state_out = STATE_TABLE >> (STATE_BITS*state_num);
		tr_pos = tr_pos + STATE_NUM_LOG2;
		tr_ctrl_in = TRANS_TABLE >> tr_pos;
		tr_pos = tr_pos + CTRL_IN_WIDTH;
		state_num = TRANS_TABLE >> tr_pos;
		tr_state_in = STATE_TABLE >> (STATE_BITS*state_num);
		tr_pos = tr_pos + STATE_NUM_LOG2;
	end
endtask

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst) begin
		state_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];
		for (i = 0; i < STATE_BITS; i = i+1)
			if (state_tmp[i] === 1'bz)
				state_tmp[i] = 0;
		state <= state_tmp;
	end else begin
		state_tmp = next_state;
		for (i = 0; i < STATE_BITS; i = i+1)
			if (state_tmp[i] === 1'bz)
				state_tmp[i] = 0;
		state <= state_tmp;
	end
end

always @(state, CTRL_IN) begin
	next_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];
	CTRL_OUT <= 'bx;
	// $display("---");
	// $display("Q: %b %b", state, CTRL_IN);
	for (i = 0; i < TRANS_NUM; i = i+1) begin
		tr_fetch(i);
		// $display("T: %b %b -> %b %b [%d]", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);
		casez ({state, CTRL_IN})
			{tr_state_in, tr_ctrl_in}: begin
				// $display("-> %b %b <-   MATCH", state, CTRL_IN);
				{next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};
			end
		endcase
	end
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOMEM
//* group mem

module \\$memrd (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter TRANSPARENT = 0;

input CLK, EN;
input [ABITS-1:0] ADDR;
output [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memrd!");
		$finish;
	end
end

endmodule

//* group mem

module \\$memrd_v2 (CLK, EN, ARST, SRST, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter TRANSPARENCY_MASK = 0;
parameter COLLISION_X_MASK = 0;
parameter ARST_VALUE = 0;
parameter SRST_VALUE = 0;
parameter INIT_VALUE = 0;
parameter CE_OVER_SRST = 0;

input CLK, EN, ARST, SRST;
input [ABITS-1:0] ADDR;
output [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memrd_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------
//* group mem

module \\$memwr (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter PRIORITY = 0;

input CLK;
input [WIDTH-1:0] EN;
input [ABITS-1:0] ADDR;
input [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memwr!");
		$finish;
	end
end

endmodule

//* group mem
module \\$memwr_v2 (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter PORTID = 0;
parameter PRIORITY_MASK = 0;

input CLK;
input [WIDTH-1:0] EN;
input [ABITS-1:0] ADDR;
input [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memwr_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------
//* group mem

module \\$meminit (ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;
parameter WORDS = 1;

parameter PRIORITY = 0;

input [ABITS-1:0] ADDR;
input [WORDS*WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $meminit!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------
//* group mem

module \\$meminit_v2 (ADDR, DATA, EN);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;
parameter WORDS = 1;

parameter PRIORITY = 0;

input [ABITS-1:0] ADDR;
input [WORDS*WIDTH-1:0] DATA;
input [WIDTH-1:0] EN;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $meminit_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------
//* group mem

module \\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);

parameter MEMID = "";
parameter signed SIZE = 4;
parameter signed OFFSET = 0;
parameter signed ABITS = 2;
parameter signed WIDTH = 8;
parameter signed INIT = 1'bx;

parameter signed RD_PORTS = 1;
parameter RD_CLK_ENABLE = 1'b1;
parameter RD_CLK_POLARITY = 1'b1;
parameter RD_TRANSPARENT = 1'b1;

parameter signed WR_PORTS = 1;
parameter WR_CLK_ENABLE = 1'b1;
parameter WR_CLK_POLARITY = 1'b1;

input [RD_PORTS-1:0] RD_CLK;
input [RD_PORTS-1:0] RD_EN;
input [RD_PORTS*ABITS-1:0] RD_ADDR;
output reg [RD_PORTS*WIDTH-1:0] RD_DATA;

input [WR_PORTS-1:0] WR_CLK;
input [WR_PORTS*WIDTH-1:0] WR_EN;
input [WR_PORTS*ABITS-1:0] WR_ADDR;
input [WR_PORTS*WIDTH-1:0] WR_DATA;

reg [WIDTH-1:0] memory [SIZE-1:0];

integer i, j;
reg [WR_PORTS-1:0] LAST_WR_CLK;
reg [RD_PORTS-1:0] LAST_RD_CLK;

function port_active;
	input clk_enable;
	input clk_polarity;
	input last_clk;
	input this_clk;
	begin
		casez ({clk_enable, clk_polarity, last_clk, this_clk})
			4'b0???: port_active = 1;
			4'b1101: port_active = 1;
			4'b1010: port_active = 1;
			default: port_active = 0;
		endcase
	end
endfunction

initial begin
	for (i = 0; i < SIZE; i = i+1)
		memory[i] = INIT >>> (i*WIDTH);
end

always @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin
\`ifdef SIMLIB_MEMDELAY
	#\`SIMLIB_MEMDELAY;
\`endif
	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	for (i = 0; i < WR_PORTS; i = i+1) begin
		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))
			for (j = 0; j < WIDTH; j = j+1)
				if (WR_EN[i*WIDTH+j]) begin
					// $display("Write to %s: addr=%b data=%b", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);
					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];
				end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Transparent read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	LAST_RD_CLK <= RD_CLK;
	LAST_WR_CLK <= WR_CLK;
end

endmodule

//* group mem

module \\$mem_v2 (RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);

parameter MEMID = "";
parameter signed SIZE = 4;
parameter signed OFFSET = 0;
parameter signed ABITS = 2;
parameter signed WIDTH = 8;
parameter signed INIT = 1'bx;

parameter signed RD_PORTS = 1;
parameter RD_CLK_ENABLE = 1'b1;
parameter RD_CLK_POLARITY = 1'b1;
parameter RD_TRANSPARENCY_MASK = 1'b0;
parameter RD_COLLISION_X_MASK = 1'b0;
parameter RD_WIDE_CONTINUATION = 1'b0;
parameter RD_CE_OVER_SRST = 1'b0;
parameter RD_ARST_VALUE = 1'b0;
parameter RD_SRST_VALUE = 1'b0;
parameter RD_INIT_VALUE = 1'b0;

parameter signed WR_PORTS = 1;
parameter WR_CLK_ENABLE = 1'b1;
parameter WR_CLK_POLARITY = 1'b1;
parameter WR_PRIORITY_MASK = 1'b0;
parameter WR_WIDE_CONTINUATION = 1'b0;

input [RD_PORTS-1:0] RD_CLK;
input [RD_PORTS-1:0] RD_EN;
input [RD_PORTS-1:0] RD_ARST;
input [RD_PORTS-1:0] RD_SRST;
input [RD_PORTS*ABITS-1:0] RD_ADDR;
output reg [RD_PORTS*WIDTH-1:0] RD_DATA;

input [WR_PORTS-1:0] WR_CLK;
input [WR_PORTS*WIDTH-1:0] WR_EN;
input [WR_PORTS*ABITS-1:0] WR_ADDR;
input [WR_PORTS*WIDTH-1:0] WR_DATA;

reg [WIDTH-1:0] memory [SIZE-1:0];

integer i, j, k;
reg [WR_PORTS-1:0] LAST_WR_CLK;
reg [RD_PORTS-1:0] LAST_RD_CLK;

function port_active;
	input clk_enable;
	input clk_polarity;
	input last_clk;
	input this_clk;
	begin
		casez ({clk_enable, clk_polarity, last_clk, this_clk})
			4'b0???: port_active = 1;
			4'b1101: port_active = 1;
			4'b1010: port_active = 1;
			default: port_active = 0;
		endcase
	end
endfunction

initial begin
	for (i = 0; i < SIZE; i = i+1)
		memory[i] = INIT >>> (i*WIDTH);
	RD_DATA = RD_INIT_VALUE;
end

always @(RD_CLK, RD_ARST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin
\`ifdef SIMLIB_MEMDELAY
	#\`SIMLIB_MEMDELAY;
\`endif
	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];

			for (j = 0; j < WR_PORTS; j = j+1) begin
				if (RD_TRANSPARENCY_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])
					for (k = 0; k < WIDTH; k = k+1)
						if (WR_EN[j*WIDTH+k])
							RD_DATA[i*WIDTH+k] <= WR_DATA[j*WIDTH+k];
				if (RD_COLLISION_X_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])
					for (k = 0; k < WIDTH; k = k+1)
						if (WR_EN[j*WIDTH+k])
							RD_DATA[i*WIDTH+k] <= 1'bx;
			end
		end
	end

	for (i = 0; i < WR_PORTS; i = i+1) begin
		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))
			for (j = 0; j < WIDTH; j = j+1)
				if (WR_EN[i*WIDTH+j]) begin
					// $display("Write to %s: addr=%b data=%b", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);
					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];
				end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (!RD_CLK_ENABLE[i]) begin
			// $display("Combinatorial read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (RD_SRST[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i]) && (RD_EN[i] || !RD_CE_OVER_SRST[i]))
			RD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];
		if (RD_ARST[i])
			RD_DATA[i*WIDTH +: WIDTH] <= RD_ARST_VALUE[i*WIDTH +: WIDTH];
	end

	LAST_RD_CLK <= RD_CLK;
	LAST_WR_CLK <= WR_CLK;
end

endmodule

\`endif

// --------------------------------------------------------
//* group formal_tag
module \\$set_tag (A, SET, CLR, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH-1:0] SET;
input [WIDTH-1:0] CLR;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------
//* group formal_tag
module \\$get_tag (A, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------
//* group formal_tag
module \\$overwrite_tag (A, SET, CLR);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH-1:0] SET;
input [WIDTH-1:0] CLR;

endmodule

// --------------------------------------------------------
//* group formal_tag
module \\$original_tag (A, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------
//* group formal_tag
module \\$future_ff (A, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------
//* group debug
(* noblackbox *)
module \\$scopeinfo ();

parameter TYPE = "";

endmodule
`,"smtmap.v":`(* techmap_celltype = "$pmux" *)
module smt_pmux (A, B, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [WIDTH*S_WIDTH-1:0] B;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [WIDTH-1:0] Y;

	(* force_downto *)
	wire [WIDTH-1:0] Y_B;

	genvar i, j;
	generate
		(* force_downto *)
		wire [WIDTH*(S_WIDTH+1)-1:0] C;

		assign C[WIDTH-1:0] = A;
		for (i = 0; i < S_WIDTH; i = i + 1)
			assign C[WIDTH*(i+2)-1:WIDTH*(i+1)] = S[i] ? B[WIDTH*(i+1)-1:WIDTH*i] : C[WIDTH*(i+1)-1:WIDTH*i];
		assign Y = C[WIDTH*(S_WIDTH+1)-1:WIDTH*S_WIDTH];
	endgenerate
endmodule
`,"techmap.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The internal logic cell technology mapper.
 *
 *  This Verilog library contains the mapping of internal cells (e.g. $not with
 *  variable bit width) to the internal logic cells (such as the single bit $_NOT_
 *  gate). Usually this logic network is then mapped to the actual technology
 *  using e.g. the "abc" pass.
 *
 *  Note that this library does not map $mem cells. They must be mapped to logic
 *  and $dff cells using the "memory_map" pass first. (Or map it to custom cells,
 *  which is of course highly recommended for larger memories.)
 *
 */

\`define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
\`define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))


// --------------------------------------------------------
// Use simplemap for trivial cell types
// --------------------------------------------------------

(* techmap_simplemap *)
(* techmap_celltype = "$not $and $or $xor $xnor" *)
module _90_simplemap_bool_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$reduce_and $reduce_or $reduce_xor $reduce_xnor $reduce_bool" *)
module _90_simplemap_reduce_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$logic_not $logic_and $logic_or" *)
module _90_simplemap_logic_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$eq $eqx $ne $nex" *)
module _90_simplemap_compare_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$buf $pos $slice $concat $mux $tribuf $bmux $bwmux $bweqx" *)
module _90_simplemap_various;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$sr $ff $dff $dffe $adff $adffe $aldff $aldffe $sdff $sdffe $sdffce $dffsr $dffsre $dlatch $adlatch $dlatchsr" *)
module _90_simplemap_registers;
endmodule


// --------------------------------------------------------
// Shift operators
// --------------------------------------------------------

(* techmap_celltype = "$shr $shl $sshl $sshr" *)
module _90_shift_ops_shr_shl_sshl_sshr (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	parameter _TECHMAP_CELLTYPE_ = "";
	localparam shift_left = _TECHMAP_CELLTYPE_ == "$shl" || _TECHMAP_CELLTYPE_ == "$sshl";
	localparam sign_extend = A_SIGNED && _TECHMAP_CELLTYPE_ == "$sshr";

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	localparam WIDTH = \`MAX(A_WIDTH, Y_WIDTH);
	localparam BB_WIDTH = \`MIN($clog2(shift_left ? Y_WIDTH : A_SIGNED ? WIDTH : A_WIDTH) + 1, B_WIDTH);

	wire [1023:0] _TECHMAP_DO_00_ = "proc;;";
	wire [1023:0] _TECHMAP_DO_01_ = "RECURSION; CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;";

	integer i;
	(* force_downto *)
	reg [WIDTH-1:0] buffer;
	reg overflow;

	always @* begin
		overflow = B_WIDTH > BB_WIDTH ? |B[B_WIDTH-1:BB_WIDTH] : 1'b0;
		buffer = overflow ? {WIDTH{sign_extend ? A[A_WIDTH-1] : 1'b0}} : {{WIDTH-A_WIDTH{A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};

		for (i = 0; i < BB_WIDTH; i = i+1)
			if (B[i]) begin
				if (shift_left)
					buffer = {buffer, (2**i)'b0};
				else if (2**i < WIDTH)
					buffer = {{2**i{sign_extend ? buffer[WIDTH-1] : 1'b0}}, buffer[WIDTH-1 : 2**i]};
				else
					buffer = {WIDTH{sign_extend ? buffer[WIDTH-1] : 1'b0}};
			end
	end

	assign Y = buffer;
endmodule

(* techmap_celltype = "$shift $shiftx" *)
module _90_shift_shiftx (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	parameter _TECHMAP_CELLTYPE_ = "";
	parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
	parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

	localparam extbit = _TECHMAP_CELLTYPE_ == "$shift" ? 1'b0 : 1'bx;
	wire a_padding = _TECHMAP_CELLTYPE_ == "$shiftx" ? extbit : (A_SIGNED ? A[A_WIDTH-1] : 1'b0);

	localparam BB_WIDTH = \`MIN($clog2(\`MAX(A_WIDTH, Y_WIDTH)) + (B_SIGNED ? 2 : 1), B_WIDTH);
	localparam WIDTH = \`MAX(A_WIDTH, Y_WIDTH) + (B_SIGNED ? 2**(BB_WIDTH-1) : 0);

	wire [1023:0] _TECHMAP_DO_00_ = "proc;;";
	wire [1023:0] _TECHMAP_DO_01_ = "CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;";

	integer i;
	(* force_downto *)
	reg [WIDTH-1:0] buffer;
	reg overflow;

	always @* begin
		overflow = 0;
		buffer = {WIDTH{extbit}};
		buffer[Y_WIDTH-1:0] = {Y_WIDTH{a_padding}};
		buffer[A_WIDTH-1:0] = A;

		if (B_WIDTH > BB_WIDTH) begin
			if (B_SIGNED) begin
				for (i = BB_WIDTH; i < B_WIDTH; i = i+1)
					if (B[i] != B[BB_WIDTH-1])
						overflow = 1;
			end else
				overflow = |B[B_WIDTH-1:BB_WIDTH];
			if (overflow)
				buffer = {WIDTH{extbit}};
		end

		if (B_SIGNED && B[BB_WIDTH-1])
			buffer = {buffer, {2**(BB_WIDTH-1){extbit}}};

		for (i = 0; i < (B_SIGNED ? BB_WIDTH-1 : BB_WIDTH); i = i+1)
			if (B[i]) begin
				if (2**i < WIDTH)
					buffer = {{2**i{extbit}}, buffer[WIDTH-1 : 2**i]};
				else
					buffer = {WIDTH{extbit}};
			end
	end
	assign Y = buffer;
endmodule


// --------------------------------------------------------
// Arithmetic operators
// --------------------------------------------------------

(* techmap_celltype = "$fa" *)
module _90_fa (A, B, C, X, Y);
	parameter WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A, B, C;
	(* force_downto *)
	output [WIDTH-1:0] X, Y;

	(* force_downto *)
	wire [WIDTH-1:0] t1, t2, t3;

	assign t1 = A ^ B, t2 = A & B, t3 = C & t1;
	assign Y = t1 ^ C, X = t2 | t3;
endmodule

(* techmap_celltype = "$lcu" *)
module _90_lcu_brent_kung (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);

		// [[CITE]] Brent Kung Adder
		// R. P. Brent and H. T. Kung, "A Regular Layout for Parallel Adders",
		// IEEE Transaction on Computers, Vol. C-31, No. 3, p. 260-264, March, 1982

		// Main tree
		for (i = 1; i <= $clog2(WIDTH); i = i+1) begin
			for (j = 2**i - 1; j < WIDTH; j = j + 2**i) begin
				g[j] = g[j] | p[j] & g[j - 2**(i-1)];
				p[j] = p[j] & p[j - 2**(i-1)];
			end
		end

		// Inverse tree
		for (i = $clog2(WIDTH); i > 0; i = i-1) begin
			for (j = 2**i + 2**(i-1) - 1; j < WIDTH; j = j + 2**i) begin
				g[j] = g[j] | p[j] & g[j - 2**(i-1)];
				p[j] = p[j] & p[j - 2**(i-1)];
			end
		end
	end

	assign CO = g;
endmodule

(* techmap_celltype = "$alu" *)
module _90_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	\\$lcu #(.WIDTH(Y_WIDTH)) lcu (.P(X), .G(AA & BB), .CI(CI), .CO(CO));

	assign X = AA ^ BB;
	assign Y = X ^ {CO, CI};
endmodule

(* techmap_maccmap *)
(* techmap_celltype = "$macc $macc_v2" *)
module _90_macc;
endmodule

(* techmap_wrap = "alumacc" *)
(* techmap_celltype = "$lt $le $ge $gt $add $sub $neg $mul" *)
module _90_alumacc;
endmodule


// --------------------------------------------------------
// Divide and Modulo
// --------------------------------------------------------

\`ifndef NODIV
module \\$__div_mod_u (A, B, Y, R);
	parameter WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A, B;
	(* force_downto *)
	output [WIDTH-1:0] Y, R;

	(* force_downto *)
	wire [WIDTH*WIDTH-1:0] chaindata;
	assign R = chaindata[WIDTH*WIDTH-1:WIDTH*(WIDTH-1)];

	genvar i;
	generate begin
		for (i = 0; i < WIDTH; i=i+1) begin:stage
			(* force_downto *)
			wire [WIDTH-1:0] stage_in;

			if (i == 0) begin:cp
				assign stage_in = A;
			end else begin:cp
				assign stage_in = chaindata[i*WIDTH-1:(i-1)*WIDTH];
			end

			assign Y[WIDTH-(i+1)] = stage_in >= {B, {WIDTH-(i+1){1'b0}}};
			assign chaindata[(i+1)*WIDTH-1:i*WIDTH] = Y[WIDTH-(i+1)] ? stage_in - {B, {WIDTH-(i+1){1'b0}}} : stage_in;
		end
	end endgenerate
endmodule

// truncating signed division/modulo
module \\$__div_mod_trunc (A, B, Y, R);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	localparam WIDTH =
			A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
			B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y, R;

	(* force_downto *)
	wire [WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u;
	assign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;
	assign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;

	\\$__div_mod_u #(
		.WIDTH(WIDTH)
	) div_mod_u (
		.A(A_buf_u),
		.B(B_buf_u),
		.Y(Y_u),
		.R(R_u)
	);

	assign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? -Y_u : Y_u;
	assign R = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;
endmodule

(* techmap_celltype = "$div" *)
module _90_div (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_trunc #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.Y(Y)
	);
endmodule

(* techmap_celltype = "$mod" *)
module _90_mod (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_trunc #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.R(Y)
	);
endmodule

// flooring signed division/modulo
module \\$__div_mod_floor (A, B, Y, R);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	localparam WIDTH =
			A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
			B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;

	input [A_WIDTH-1:0] A;
	input [B_WIDTH-1:0] B;
	output [Y_WIDTH-1:0] Y, R;

	wire [WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));

	wire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u, R_s;
	assign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;
	assign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;

	\\$__div_mod_u #(
		.WIDTH(WIDTH)
	) div_mod_u (
		.A(A_buf_u),
		.B(B_buf_u),
		.Y(Y_u),
		.R(R_u)
	);

	// For negative results, if there was a remainder, subtract one to turn
	// the round towards 0 into a round towards -inf
	assign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? (R_u == 0 ? -Y_u : -Y_u-1) : Y_u;

	// truncating modulo
	assign R_s = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;
	// Flooring modulo differs from truncating modulo only if it is nonzero and
	// A and B have different signs - then \`floor - trunc = B\`
	assign R = (R_s != 0) && A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? $signed(B_buf) + $signed(R_s) : R_s;
endmodule

(* techmap_celltype = "$divfloor" *)
module _90_divfloor (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_floor #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.Y(Y)
	);
endmodule

(* techmap_celltype = "$modfloor" *)
module _90_modfloor (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_floor #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.R(Y)
	);
endmodule
\`endif

// --------------------------------------------------------
// Power
// --------------------------------------------------------

(* techmap_celltype = "$pow" *)
module _90_pow (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	wire _TECHMAP_FAIL_ = 1;
endmodule


// --------------------------------------------------------
// Parallel Multiplexers
// --------------------------------------------------------

(* techmap_celltype = "$pmux" *)
module _90_pmux (A, B, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [WIDTH*S_WIDTH-1:0] B;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [WIDTH-1:0] Y;

	(* force_downto *)
	wire [WIDTH-1:0] Y_B;

	genvar i, j;
	generate
		(* force_downto *)
		wire [WIDTH*S_WIDTH-1:0] B_AND_S;
		for (i = 0; i < S_WIDTH; i = i + 1) begin:B_AND
			assign B_AND_S[WIDTH*(i+1)-1:WIDTH*i] = B[WIDTH*(i+1)-1:WIDTH*i] & {WIDTH{S[i]}};
		end:B_AND
		for (i = 0; i < WIDTH; i = i + 1) begin:B_OR
			(* force_downto *)
			wire [S_WIDTH-1:0] B_AND_BITS;
			for (j = 0; j < S_WIDTH; j = j + 1) begin:B_AND_BITS_COLLECT
				assign B_AND_BITS[j] = B_AND_S[WIDTH*j+i];
			end:B_AND_BITS_COLLECT
			assign Y_B[i] = |B_AND_BITS;
		end:B_OR
	endgenerate

	assign Y = |S ? Y_B : A;
endmodule

// --------------------------------------------------------
// Demultiplexers
// --------------------------------------------------------

(* techmap_celltype = "$demux" *)
module _90_demux (A, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [(WIDTH << S_WIDTH)-1:0] Y;

	generate
		if (S_WIDTH == 0) begin
			assign Y = A;
		end else if (S_WIDTH == 1) begin
			assign Y[0+:WIDTH] = S ? 0 : A;
			assign Y[WIDTH+:WIDTH] = S ? A : 0;
		end else begin
			localparam SPLIT = S_WIDTH / 2;
			wire [(1 << (S_WIDTH-SPLIT))-1:0] YH;
			wire [(1 << SPLIT)-1:0] YL;
			$demux #(.WIDTH(1), .S_WIDTH(SPLIT)) lo (.A(1'b1), .S(S[SPLIT-1:0]), .Y(YL));
			$demux #(.WIDTH(1), .S_WIDTH(S_WIDTH-SPLIT)) hi (.A(1'b1), .S(S[S_WIDTH-1:SPLIT]), .Y(YH));
			genvar i;
			for (i = 0; i < (1 << S_WIDTH); i = i + 1) begin
				localparam [S_WIDTH-1:0] IDX = i;
				assign Y[i*WIDTH+:WIDTH] = (YL[IDX[SPLIT-1:0]] & YH[IDX[S_WIDTH-1:SPLIT]]) ? A : 0;
			end
		end
	endgenerate
endmodule


// --------------------------------------------------------
// LUTs
// --------------------------------------------------------

\`ifndef NOLUT
(* techmap_simplemap *)
(* techmap_celltype = "$lut $sop" *)
module _90_lut;
endmodule
\`endif

`,xilinx:{"abc9_model.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================

// Box containing MUXF7.[AB] + MUXF8,
//   Necessary to make these an atomic unit so that
//   ABC cannot optimise just one of the MUXF7 away
//   and expect to save on its delay
(* abc9_box, lib_whitebox *)
module \\$__XILINX_MUXF78 (output O, input I0, I1, I2, I3, S0, S1);
  assign O = S1 ? (S0 ? I3 : I2)
                : (S0 ? I1 : I0);
  specify
    (I0 => O) = 294;
    (I1 => O) = 297;
    (I2 => O) = 311;
    (I3 => O) = 317;
    (S0 => O) = 390;
    (S1 => O) = 273;
  endspecify
endmodule
`,"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================
// LCU

(* techmap_celltype = "$lcu" *)
module _80_xilinx_lcu (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = WIDTH <= 2;

	genvar i;

generate if (\`LUT_SIZE == 4) begin

	(* force_downto *)
	wire [WIDTH-1:0] C = {CO, CI};
	(* force_downto *)
	wire [WIDTH-1:0] S = P & ~G;

	generate for (i = 0; i < WIDTH; i = i + 1) begin:slice
		MUXCY muxcy (
			.CI(C[i]),
			.DI(G[i]),
			.S(S[i]),
			.O(CO[i])
		);
	end endgenerate

end else begin

	localparam CARRY4_COUNT = (WIDTH + 3) / 4;
	localparam MAX_WIDTH    = CARRY4_COUNT * 4;
	localparam PAD_WIDTH    = MAX_WIDTH - WIDTH;

	(* force_downto *)
	wire [MAX_WIDTH-1:0] S =  {{PAD_WIDTH{1'b0}}, P & ~G};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] GG = {{PAD_WIDTH{1'b0}}, G};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] C;
	assign CO = C;

	generate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice
		if (i == 0) begin
			CARRY4 carry4
			(
			.CYINIT(CI),
			.CI    (1'd0),
			.DI    (GG[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.CO    (C [i*4 +: 4]),
			);
		end else begin
			CARRY4 carry4
			(
			.CYINIT(1'd0),
			.CI    (C [i*4 - 1]),
			.DI    (GG[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.CO    (C [i*4 +: 4]),
			);
		end
	end endgenerate
end endgenerate

endmodule


// ============================================================================
// ALU

(* techmap_celltype = "$alu" *)
module _80_xilinx_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;
	parameter _TECHMAP_CONSTVAL_CI_ = 0;
	parameter _TECHMAP_CONSTMSK_CI_ = 0;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	genvar i;

generate if (\`LUT_SIZE == 4) begin

	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH-1:0] S  = {AA ^ BB};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		MUXCY muxcy (
			.CI(C[i]),
			.DI(AA[i]),
			.S(S[i]),
			.O(CO[i])
		);
		XORCY xorcy (
			.CI(C[i]),
			.LI(S[i]),
			.O(Y[i])
		);
	end endgenerate

	assign X = S;

end else begin

	localparam CARRY4_COUNT = (Y_WIDTH + 3) / 4;
	localparam MAX_WIDTH    = CARRY4_COUNT * 4;
	localparam PAD_WIDTH    = MAX_WIDTH - Y_WIDTH;

	(* force_downto *)
	wire [MAX_WIDTH-1:0] S  = {{PAD_WIDTH{1'b0}}, AA ^ BB};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] DI = {{PAD_WIDTH{1'b0}}, AA};

	(* force_downto *)
	wire [MAX_WIDTH-1:0] O;
	(* force_downto *)
	wire [MAX_WIDTH-1:0] C;
	assign Y = O, CO = C;

	genvar i;
	generate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice
		if (i == 0) begin
			CARRY4 carry4
			(
			.CYINIT(CI),
			.CI    (1'd0),
			.DI    (DI[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.O     (O [i*4 +: 4]),
			.CO    (C [i*4 +: 4])
			);
		end else begin
		    CARRY4 carry4
		    (
			.CYINIT(1'd0),
			.CI    (C [i*4 - 1]),
			.DI    (DI[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.O     (O [i*4 +: 4]),
			.CO    (C [i*4 +: 4])
		    );
		end
	end endgenerate

	assign X = S;

end endgenerate
endmodule

`,"brams_defs.vh":`\`define PARAMS_INIT_9 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)),

\`define PARAMS_INITP_9 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)),

\`define PARAMS_INIT_18 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)), \\
	.INIT_20(slice_init('h20)), \\
	.INIT_21(slice_init('h21)), \\
	.INIT_22(slice_init('h22)), \\
	.INIT_23(slice_init('h23)), \\
	.INIT_24(slice_init('h24)), \\
	.INIT_25(slice_init('h25)), \\
	.INIT_26(slice_init('h26)), \\
	.INIT_27(slice_init('h27)), \\
	.INIT_28(slice_init('h28)), \\
	.INIT_29(slice_init('h29)), \\
	.INIT_2A(slice_init('h2a)), \\
	.INIT_2B(slice_init('h2b)), \\
	.INIT_2C(slice_init('h2c)), \\
	.INIT_2D(slice_init('h2d)), \\
	.INIT_2E(slice_init('h2e)), \\
	.INIT_2F(slice_init('h2f)), \\
	.INIT_30(slice_init('h30)), \\
	.INIT_31(slice_init('h31)), \\
	.INIT_32(slice_init('h32)), \\
	.INIT_33(slice_init('h33)), \\
	.INIT_34(slice_init('h34)), \\
	.INIT_35(slice_init('h35)), \\
	.INIT_36(slice_init('h36)), \\
	.INIT_37(slice_init('h37)), \\
	.INIT_38(slice_init('h38)), \\
	.INIT_39(slice_init('h39)), \\
	.INIT_3A(slice_init('h3a)), \\
	.INIT_3B(slice_init('h3b)), \\
	.INIT_3C(slice_init('h3c)), \\
	.INIT_3D(slice_init('h3d)), \\
	.INIT_3E(slice_init('h3e)), \\
	.INIT_3F(slice_init('h3f)),

\`define PARAMS_INIT_18_U \\
	.INIT_00(slice_init('h40)), \\
	.INIT_01(slice_init('h41)), \\
	.INIT_02(slice_init('h42)), \\
	.INIT_03(slice_init('h43)), \\
	.INIT_04(slice_init('h44)), \\
	.INIT_05(slice_init('h45)), \\
	.INIT_06(slice_init('h46)), \\
	.INIT_07(slice_init('h47)), \\
	.INIT_08(slice_init('h48)), \\
	.INIT_09(slice_init('h49)), \\
	.INIT_0A(slice_init('h4a)), \\
	.INIT_0B(slice_init('h4b)), \\
	.INIT_0C(slice_init('h4c)), \\
	.INIT_0D(slice_init('h4d)), \\
	.INIT_0E(slice_init('h4e)), \\
	.INIT_0F(slice_init('h4f)), \\
	.INIT_10(slice_init('h50)), \\
	.INIT_11(slice_init('h51)), \\
	.INIT_12(slice_init('h52)), \\
	.INIT_13(slice_init('h53)), \\
	.INIT_14(slice_init('h54)), \\
	.INIT_15(slice_init('h55)), \\
	.INIT_16(slice_init('h56)), \\
	.INIT_17(slice_init('h57)), \\
	.INIT_18(slice_init('h58)), \\
	.INIT_19(slice_init('h59)), \\
	.INIT_1A(slice_init('h5a)), \\
	.INIT_1B(slice_init('h5b)), \\
	.INIT_1C(slice_init('h5c)), \\
	.INIT_1D(slice_init('h5d)), \\
	.INIT_1E(slice_init('h5e)), \\
	.INIT_1F(slice_init('h5f)), \\
	.INIT_20(slice_init('h60)), \\
	.INIT_21(slice_init('h61)), \\
	.INIT_22(slice_init('h62)), \\
	.INIT_23(slice_init('h63)), \\
	.INIT_24(slice_init('h64)), \\
	.INIT_25(slice_init('h65)), \\
	.INIT_26(slice_init('h66)), \\
	.INIT_27(slice_init('h67)), \\
	.INIT_28(slice_init('h68)), \\
	.INIT_29(slice_init('h69)), \\
	.INIT_2A(slice_init('h6a)), \\
	.INIT_2B(slice_init('h6b)), \\
	.INIT_2C(slice_init('h6c)), \\
	.INIT_2D(slice_init('h6d)), \\
	.INIT_2E(slice_init('h6e)), \\
	.INIT_2F(slice_init('h6f)), \\
	.INIT_30(slice_init('h70)), \\
	.INIT_31(slice_init('h71)), \\
	.INIT_32(slice_init('h72)), \\
	.INIT_33(slice_init('h73)), \\
	.INIT_34(slice_init('h74)), \\
	.INIT_35(slice_init('h75)), \\
	.INIT_36(slice_init('h76)), \\
	.INIT_37(slice_init('h77)), \\
	.INIT_38(slice_init('h78)), \\
	.INIT_39(slice_init('h79)), \\
	.INIT_3A(slice_init('h7a)), \\
	.INIT_3B(slice_init('h7b)), \\
	.INIT_3C(slice_init('h7c)), \\
	.INIT_3D(slice_init('h7d)), \\
	.INIT_3E(slice_init('h7e)), \\
	.INIT_3F(slice_init('h7f)),

\`define PARAMS_INITP_18 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)), \\
	.INITP_04(slice_initp('h04)), \\
	.INITP_05(slice_initp('h05)), \\
	.INITP_06(slice_initp('h06)), \\
	.INITP_07(slice_initp('h07)),

\`define PARAMS_INIT_36 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)), \\
	.INIT_20(slice_init('h20)), \\
	.INIT_21(slice_init('h21)), \\
	.INIT_22(slice_init('h22)), \\
	.INIT_23(slice_init('h23)), \\
	.INIT_24(slice_init('h24)), \\
	.INIT_25(slice_init('h25)), \\
	.INIT_26(slice_init('h26)), \\
	.INIT_27(slice_init('h27)), \\
	.INIT_28(slice_init('h28)), \\
	.INIT_29(slice_init('h29)), \\
	.INIT_2A(slice_init('h2a)), \\
	.INIT_2B(slice_init('h2b)), \\
	.INIT_2C(slice_init('h2c)), \\
	.INIT_2D(slice_init('h2d)), \\
	.INIT_2E(slice_init('h2e)), \\
	.INIT_2F(slice_init('h2f)), \\
	.INIT_30(slice_init('h30)), \\
	.INIT_31(slice_init('h31)), \\
	.INIT_32(slice_init('h32)), \\
	.INIT_33(slice_init('h33)), \\
	.INIT_34(slice_init('h34)), \\
	.INIT_35(slice_init('h35)), \\
	.INIT_36(slice_init('h36)), \\
	.INIT_37(slice_init('h37)), \\
	.INIT_38(slice_init('h38)), \\
	.INIT_39(slice_init('h39)), \\
	.INIT_3A(slice_init('h3a)), \\
	.INIT_3B(slice_init('h3b)), \\
	.INIT_3C(slice_init('h3c)), \\
	.INIT_3D(slice_init('h3d)), \\
	.INIT_3E(slice_init('h3e)), \\
	.INIT_3F(slice_init('h3f)), \\
	.INIT_40(slice_init('h40)), \\
	.INIT_41(slice_init('h41)), \\
	.INIT_42(slice_init('h42)), \\
	.INIT_43(slice_init('h43)), \\
	.INIT_44(slice_init('h44)), \\
	.INIT_45(slice_init('h45)), \\
	.INIT_46(slice_init('h46)), \\
	.INIT_47(slice_init('h47)), \\
	.INIT_48(slice_init('h48)), \\
	.INIT_49(slice_init('h49)), \\
	.INIT_4A(slice_init('h4a)), \\
	.INIT_4B(slice_init('h4b)), \\
	.INIT_4C(slice_init('h4c)), \\
	.INIT_4D(slice_init('h4d)), \\
	.INIT_4E(slice_init('h4e)), \\
	.INIT_4F(slice_init('h4f)), \\
	.INIT_50(slice_init('h50)), \\
	.INIT_51(slice_init('h51)), \\
	.INIT_52(slice_init('h52)), \\
	.INIT_53(slice_init('h53)), \\
	.INIT_54(slice_init('h54)), \\
	.INIT_55(slice_init('h55)), \\
	.INIT_56(slice_init('h56)), \\
	.INIT_57(slice_init('h57)), \\
	.INIT_58(slice_init('h58)), \\
	.INIT_59(slice_init('h59)), \\
	.INIT_5A(slice_init('h5a)), \\
	.INIT_5B(slice_init('h5b)), \\
	.INIT_5C(slice_init('h5c)), \\
	.INIT_5D(slice_init('h5d)), \\
	.INIT_5E(slice_init('h5e)), \\
	.INIT_5F(slice_init('h5f)), \\
	.INIT_60(slice_init('h60)), \\
	.INIT_61(slice_init('h61)), \\
	.INIT_62(slice_init('h62)), \\
	.INIT_63(slice_init('h63)), \\
	.INIT_64(slice_init('h64)), \\
	.INIT_65(slice_init('h65)), \\
	.INIT_66(slice_init('h66)), \\
	.INIT_67(slice_init('h67)), \\
	.INIT_68(slice_init('h68)), \\
	.INIT_69(slice_init('h69)), \\
	.INIT_6A(slice_init('h6a)), \\
	.INIT_6B(slice_init('h6b)), \\
	.INIT_6C(slice_init('h6c)), \\
	.INIT_6D(slice_init('h6d)), \\
	.INIT_6E(slice_init('h6e)), \\
	.INIT_6F(slice_init('h6f)), \\
	.INIT_70(slice_init('h70)), \\
	.INIT_71(slice_init('h71)), \\
	.INIT_72(slice_init('h72)), \\
	.INIT_73(slice_init('h73)), \\
	.INIT_74(slice_init('h74)), \\
	.INIT_75(slice_init('h75)), \\
	.INIT_76(slice_init('h76)), \\
	.INIT_77(slice_init('h77)), \\
	.INIT_78(slice_init('h78)), \\
	.INIT_79(slice_init('h79)), \\
	.INIT_7A(slice_init('h7a)), \\
	.INIT_7B(slice_init('h7b)), \\
	.INIT_7C(slice_init('h7c)), \\
	.INIT_7D(slice_init('h7d)), \\
	.INIT_7E(slice_init('h7e)), \\
	.INIT_7F(slice_init('h7f)),

\`define PARAMS_INIT_36_U \\
	.INIT_00(slice_init('h80)), \\
	.INIT_01(slice_init('h81)), \\
	.INIT_02(slice_init('h82)), \\
	.INIT_03(slice_init('h83)), \\
	.INIT_04(slice_init('h84)), \\
	.INIT_05(slice_init('h85)), \\
	.INIT_06(slice_init('h86)), \\
	.INIT_07(slice_init('h87)), \\
	.INIT_08(slice_init('h88)), \\
	.INIT_09(slice_init('h89)), \\
	.INIT_0A(slice_init('h8a)), \\
	.INIT_0B(slice_init('h8b)), \\
	.INIT_0C(slice_init('h8c)), \\
	.INIT_0D(slice_init('h8d)), \\
	.INIT_0E(slice_init('h8e)), \\
	.INIT_0F(slice_init('h8f)), \\
	.INIT_10(slice_init('h90)), \\
	.INIT_11(slice_init('h91)), \\
	.INIT_12(slice_init('h92)), \\
	.INIT_13(slice_init('h93)), \\
	.INIT_14(slice_init('h94)), \\
	.INIT_15(slice_init('h95)), \\
	.INIT_16(slice_init('h96)), \\
	.INIT_17(slice_init('h97)), \\
	.INIT_18(slice_init('h98)), \\
	.INIT_19(slice_init('h99)), \\
	.INIT_1A(slice_init('h9a)), \\
	.INIT_1B(slice_init('h9b)), \\
	.INIT_1C(slice_init('h9c)), \\
	.INIT_1D(slice_init('h9d)), \\
	.INIT_1E(slice_init('h9e)), \\
	.INIT_1F(slice_init('h9f)), \\
	.INIT_20(slice_init('ha0)), \\
	.INIT_21(slice_init('ha1)), \\
	.INIT_22(slice_init('ha2)), \\
	.INIT_23(slice_init('ha3)), \\
	.INIT_24(slice_init('ha4)), \\
	.INIT_25(slice_init('ha5)), \\
	.INIT_26(slice_init('ha6)), \\
	.INIT_27(slice_init('ha7)), \\
	.INIT_28(slice_init('ha8)), \\
	.INIT_29(slice_init('ha9)), \\
	.INIT_2A(slice_init('haa)), \\
	.INIT_2B(slice_init('hab)), \\
	.INIT_2C(slice_init('hac)), \\
	.INIT_2D(slice_init('had)), \\
	.INIT_2E(slice_init('hae)), \\
	.INIT_2F(slice_init('haf)), \\
	.INIT_30(slice_init('hb0)), \\
	.INIT_31(slice_init('hb1)), \\
	.INIT_32(slice_init('hb2)), \\
	.INIT_33(slice_init('hb3)), \\
	.INIT_34(slice_init('hb4)), \\
	.INIT_35(slice_init('hb5)), \\
	.INIT_36(slice_init('hb6)), \\
	.INIT_37(slice_init('hb7)), \\
	.INIT_38(slice_init('hb8)), \\
	.INIT_39(slice_init('hb9)), \\
	.INIT_3A(slice_init('hba)), \\
	.INIT_3B(slice_init('hbb)), \\
	.INIT_3C(slice_init('hbc)), \\
	.INIT_3D(slice_init('hbd)), \\
	.INIT_3E(slice_init('hbe)), \\
	.INIT_3F(slice_init('hbf)), \\
	.INIT_40(slice_init('hc0)), \\
	.INIT_41(slice_init('hc1)), \\
	.INIT_42(slice_init('hc2)), \\
	.INIT_43(slice_init('hc3)), \\
	.INIT_44(slice_init('hc4)), \\
	.INIT_45(slice_init('hc5)), \\
	.INIT_46(slice_init('hc6)), \\
	.INIT_47(slice_init('hc7)), \\
	.INIT_48(slice_init('hc8)), \\
	.INIT_49(slice_init('hc9)), \\
	.INIT_4A(slice_init('hca)), \\
	.INIT_4B(slice_init('hcb)), \\
	.INIT_4C(slice_init('hcc)), \\
	.INIT_4D(slice_init('hcd)), \\
	.INIT_4E(slice_init('hce)), \\
	.INIT_4F(slice_init('hcf)), \\
	.INIT_50(slice_init('hd0)), \\
	.INIT_51(slice_init('hd1)), \\
	.INIT_52(slice_init('hd2)), \\
	.INIT_53(slice_init('hd3)), \\
	.INIT_54(slice_init('hd4)), \\
	.INIT_55(slice_init('hd5)), \\
	.INIT_56(slice_init('hd6)), \\
	.INIT_57(slice_init('hd7)), \\
	.INIT_58(slice_init('hd8)), \\
	.INIT_59(slice_init('hd9)), \\
	.INIT_5A(slice_init('hda)), \\
	.INIT_5B(slice_init('hdb)), \\
	.INIT_5C(slice_init('hdc)), \\
	.INIT_5D(slice_init('hdd)), \\
	.INIT_5E(slice_init('hde)), \\
	.INIT_5F(slice_init('hdf)), \\
	.INIT_60(slice_init('he0)), \\
	.INIT_61(slice_init('he1)), \\
	.INIT_62(slice_init('he2)), \\
	.INIT_63(slice_init('he3)), \\
	.INIT_64(slice_init('he4)), \\
	.INIT_65(slice_init('he5)), \\
	.INIT_66(slice_init('he6)), \\
	.INIT_67(slice_init('he7)), \\
	.INIT_68(slice_init('he8)), \\
	.INIT_69(slice_init('he9)), \\
	.INIT_6A(slice_init('hea)), \\
	.INIT_6B(slice_init('heb)), \\
	.INIT_6C(slice_init('hec)), \\
	.INIT_6D(slice_init('hed)), \\
	.INIT_6E(slice_init('hee)), \\
	.INIT_6F(slice_init('hef)), \\
	.INIT_70(slice_init('hf0)), \\
	.INIT_71(slice_init('hf1)), \\
	.INIT_72(slice_init('hf2)), \\
	.INIT_73(slice_init('hf3)), \\
	.INIT_74(slice_init('hf4)), \\
	.INIT_75(slice_init('hf5)), \\
	.INIT_76(slice_init('hf6)), \\
	.INIT_77(slice_init('hf7)), \\
	.INIT_78(slice_init('hf8)), \\
	.INIT_79(slice_init('hf9)), \\
	.INIT_7A(slice_init('hfa)), \\
	.INIT_7B(slice_init('hfb)), \\
	.INIT_7C(slice_init('hfc)), \\
	.INIT_7D(slice_init('hfd)), \\
	.INIT_7E(slice_init('hfe)), \\
	.INIT_7F(slice_init('hff)),

\`define PARAMS_INITP_36 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)), \\
	.INITP_04(slice_initp('h04)), \\
	.INITP_05(slice_initp('h05)), \\
	.INITP_06(slice_initp('h06)), \\
	.INITP_07(slice_initp('h07)), \\
	.INITP_08(slice_initp('h08)), \\
	.INITP_09(slice_initp('h09)), \\
	.INITP_0A(slice_initp('h0a)), \\
	.INITP_0B(slice_initp('h0b)), \\
	.INITP_0C(slice_initp('h0c)), \\
	.INITP_0D(slice_initp('h0d)), \\
	.INITP_0E(slice_initp('h0e)), \\
	.INITP_0F(slice_initp('h0f)),

\`define MAKE_DO(do, dop, rdata) \\
	wire [63:0] do; \\
	wire [7:0] dop; \\
	assign rdata = { \\
		dop[7], \\
		do[63:56], \\
		dop[6], \\
		do[55:48], \\
		dop[5], \\
		do[47:40], \\
		dop[4], \\
		do[39:32], \\
		dop[3], \\
		do[31:24], \\
		dop[2], \\
		do[23:16], \\
		dop[1], \\
		do[15:8], \\
		dop[0], \\
		do[7:0] \\
	};

\`define MAKE_DI(di, dip, wdata) \\
	wire [63:0] di; \\
	wire [7:0] dip; \\
	assign { \\
		dip[7], \\
		di[63:56], \\
		dip[6], \\
		di[55:48], \\
		dip[5], \\
		di[47:40], \\
		dip[4], \\
		di[39:32], \\
		dip[3], \\
		di[31:24], \\
		dip[2], \\
		di[23:16], \\
		dip[1], \\
		di[15:8], \\
		dip[0], \\
		di[7:0] \\
	} = wdata;

function [71:0] ival;
	input integer width;
	input [71:0] val;
	if (width == 72)
		ival = {
			val[71],
			val[62],
			val[53],
			val[44],
			val[35],
			val[26],
			val[17],
			val[8],
			val[70:63],
			val[61:54],
			val[52:45],
			val[43:36],
			val[34:27],
			val[25:18],
			val[16:9],
			val[7:0]
		};
	else if (width == 36)
		ival = {
			val[35],
			val[26],
			val[17],
			val[8],
			val[34:27],
			val[25:18],
			val[16:9],
			val[7:0]
		};
	else if (width == 18)
		ival = {
			val[17],
			val[8],
			val[16:9],
			val[7:0]
		};
	else
		ival = val;
endfunction

function [255:0] slice_init;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1)
		slice_init[i*8+:8] = INIT[(idx * 32 + i)*9+:8];
endfunction

function [255:0] slice_initp;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1)
		slice_initp[i] = INIT[(idx * 256 + i)*9+8];
endfunction
`,"brams_xc2v.txt":`# Block RAMs for Virtex 2, Spartan 3, Spartan 3E, Spartan 3A(N)
# The corresponding mapping file is brams_xc2v_map.v

ram block $__XILINX_BLOCKRAM_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	ifdef HAS_BE {
		option "USE_BE" 1 byte 9;
	}
	cost 129;
	init any;
	port srsw "A" "B" {
		option "USE_BE" 0 width tied;
		ifdef HAS_BE {
			option "USE_BE" 1 width tied 9 18 36;
		}
		clock posedge;
		clken;
		rdsrst any gated_clken;
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			rdwr new_only;
		}
		portoption "WRITE_MODE" "READ_FIRST" {
			rdwr old;
			wrtrans all old;
		}
		optional;
	}
}
`,"brams_xc2v_map.v":`module $__XILINX_BLOCKRAM_ (...);

parameter INIT = 0;
parameter OPTION_USE_BE = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [13:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_DP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.SRVAL_A(SRVAL_A), \\
	.SRVAL_B(SRVAL_B), \\
	.INIT_A(INIT_A), \\
	.INIT_B(INIT_B),

\`define PARAMS_DP_SWAP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE_A(PORT_B_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_A_OPTION_WRITE_MODE), \\
	.SRVAL_A(SRVAL_B), \\
	.SRVAL_B(SRVAL_A), \\
	.INIT_A(INIT_B), \\
	.INIT_B(INIT_A),

\`define PARAMS_SP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE(PORT_A_OPTION_WRITE_MODE), \\
	.SRVAL(SRVAL_A), \\
	.INIT(INIT_A),

\`define PORTS_DP(addr_slice_a, addr_slice_b) \\
	.CLKA(PORT_A_CLK), \\
	.ENA(PORT_A_CLK_EN), \\
	.WEA(PORT_A_WR_EN), \\
	.SSRA(PORT_A_RD_SRST), \\
	.ADDRA(PORT_A_ADDR addr_slice_a), \\
	.DOA(DO_A), \\
	.DIA(DI_A), \\
	.CLKB(PORT_B_CLK), \\
	.ENB(PORT_B_CLK_EN), \\
	.WEB(PORT_B_WR_EN), \\
	.SSRB(PORT_B_RD_SRST), \\
	.ADDRB(PORT_B_ADDR addr_slice_b), \\
	.DOB(DO_B), \\
	.DIB(DI_B),

\`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\
	.CLKB(PORT_A_CLK), \\
	.ENB(PORT_A_CLK_EN), \\
	.WEB(PORT_A_WR_EN), \\
	.SSRB(PORT_A_RD_SRST), \\
	.ADDRB(PORT_A_ADDR addr_slice_a), \\
	.DOB(DO_A), \\
	.DIB(DI_A), \\
	.CLKA(PORT_B_CLK), \\
	.ENA(PORT_B_CLK_EN), \\
	.WEA(PORT_B_WR_EN), \\
	.SSRA(PORT_B_RD_SRST), \\
	.ADDRA(PORT_B_ADDR addr_slice_b), \\
	.DOA(DO_B), \\
	.DIA(DI_B),

\`define PORTS_SP(addr_slice) \\
	.CLK(PORT_A_CLK), \\
	.EN(PORT_A_CLK_EN), \\
	.WE(PORT_A_WR_EN), \\
	.SSR(PORT_A_RD_SRST), \\
	.ADDR(PORT_A_ADDR addr_slice), \\
	.DO(DO_A), \\
	.DI(DI_A),

localparam [PORT_A_WIDTH-1:0] SRVAL_A = ival(PORT_A_WIDTH, PORT_A_RD_SRST_VALUE);
localparam [PORT_B_WIDTH-1:0] SRVAL_B = ival(PORT_B_WIDTH, PORT_B_RD_SRST_VALUE);
localparam [PORT_A_WIDTH-1:0] INIT_A = ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE);
localparam [PORT_B_WIDTH-1:0] INIT_B = ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE);

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

generate

if (OPTION_USE_BE) begin
	if (!PORT_B_USED) begin
		case (PORT_A_WIDTH)
		9: RAMB16_S9 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:3])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		18: RAMB16BWE_S18 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:4])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		36: RAMB16BWE_S36 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:5])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		endcase
	end else begin
		case (PORT_A_WIDTH)
		9:	case(PORT_B_WIDTH)
			9: RAMB16_S9_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:3])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16BWE_S9_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16BWE_S9_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		18:	case(PORT_B_WIDTH)
			9: RAMB16BWE_S9_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16BWE_S18_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16BWE_S18_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		36:	case(PORT_B_WIDTH)
			9: RAMB16BWE_S9_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16BWE_S18_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:4])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			36: RAMB16BWE_S36_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:5], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		endcase
	end
end else begin
	if (!PORT_B_USED) begin
		case (PORT_A_WIDTH)
		1: RAMB16_S1 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:0])
		);
		2: RAMB16_S2 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:1])
		);
		4: RAMB16_S4 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:2])
		);
		9: RAMB16_S9 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:3])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		18: RAMB16_S18 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:4])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		36: RAMB16_S36 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:5])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		endcase
	end else begin
		case (PORT_A_WIDTH)
		1:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S1 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:0])
			);
			2: RAMB16_S1_S2 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:1])
			);
			4: RAMB16_S1_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:2])
			);
			9: RAMB16_S1_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S1_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S1_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		2:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S2 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:1], [13:0])
			);
			2: RAMB16_S2_S2 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:1])
			);
			4: RAMB16_S2_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:2])
			);
			9: RAMB16_S2_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S2_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S2_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		4:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S4 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:2], [13:0])
			);
			2: RAMB16_S2_S4 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:2], [13:1])
			);
			4: RAMB16_S4_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:2])
			);
			9: RAMB16_S4_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S4_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S4_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		9:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:3])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S9_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S9_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		18:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16_S18_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S18_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		36:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16_S18_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:4])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			36: RAMB16_S36_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:5], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		endcase
	end
end

endgenerate


endmodule
`,"brams_xc3sda.txt":`# Block RAMs for Spartan 3A DSP and Spartan 6.
# The corresponding mapping file is brams_xc3sda_map.v

ram block $__XILINX_BLOCKRAM_TDP_ {
	byte 9;
	ifdef IS_SPARTAN6 {
		option "MODE" "HALF" {
			abits 13;
			widths 1 2 4 9 18 per_port;
			cost 65;
		}
	}
	option "MODE" "FULL" {
		abits 14;
		widths 1 2 4 9 18 36 per_port;
		cost 129;
	}
	init any;
	port srsw "A" "B" {
		# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
		ifdef IS_SPARTAN6 {
			option "HAS_RDFIRST" 1 {
				clock posedge "C";
			}
			option "HAS_RDFIRST" 0 {
				clock posedge;
			}
		} else {
			clock posedge;
		}
		clken;
		option "RSTTYPE" "SYNC" {
			portoption "RST_PRIORITY" "CE" {
				rdsrst any gated_clken;
			}
			ifdef IS_SPARTAN6 {
				portoption "RST_PRIORITY" "SR" {
					rdsrst any ungated;
				}
			}
		}
		ifdef IS_SPARTAN6 {
			option "RSTTYPE" "ASYNC" {
				portoption "RST_PRIORITY" "SR" {
					rdarst any;
				}
			}
		}
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			rdwr new;
		}
		ifdef IS_SPARTAN6 {
			option "HAS_RDFIRST" 1 {
				portoption "WRITE_MODE" "READ_FIRST" {
					rdwr old;
					wrtrans all old;
				}
			}
		} else {
			portoption "WRITE_MODE" "READ_FIRST" {
				rdwr old;
				wrtrans all old;
			}
		}
		optional;
	}
}

ifdef IS_SPARTAN6 {
	ram block $__XILINX_BLOCKRAM_SDP_ {
		byte 9;
		abits 13;
		widths 1 2 4 9 18 36 per_port;
		cost 65;
		init any;
		port sw "W" {
			width 36;
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			option "WRITE_MODE" "READ_FIRST" {
				clock posedge "C";
				wrtrans all old;
			}
			option "WRITE_MODE" "WRITE_FIRST" {
				clock posedge;
			}
			clken;
			optional;
		}
		port sr "R" {
			width 36;
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			option "WRITE_MODE" "READ_FIRST" {
				clock posedge "C";
			}
			option "WRITE_MODE" "WRITE_FIRST" {
				clock posedge;
			}
			clken;
			option "RSTTYPE" "SYNC" {
				portoption "RST_PRIORITY" "CE" {
					rdsrst any gated_clken;
				}
				portoption "RST_PRIORITY" "SR" {
					rdsrst any ungated;
				}
			}
			option "RSTTYPE" "ASYNC" {
				portoption "RST_PRIORITY" "SR" {
					rdarst any;
				}
			}
			rdinit any;
			optional;
		}
	}
}
`,"brams_xc3sda_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_RSTTYPE = "SYNC";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;
parameter PORT_A_RD_ARST_VALUE = 0;
parameter PORT_A_OPTION_RST_PRIORITY = "CE";

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;
parameter PORT_B_RD_ARST_VALUE = 0;
parameter PORT_B_OPTION_RST_PRIORITY = "CE";

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [13:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.DATA_WIDTH_A(PORT_A_USED ? PORT_A_WIDTH : 0), \\
	.DATA_WIDTH_B(PORT_B_USED ? PORT_B_WIDTH : 0), \\
	.EN_RSTRAM_A("TRUE"), \\
	.EN_RSTRAM_B("TRUE"), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.RST_PRIORITY_A(PORT_A_OPTION_RST_PRIORITY), \\
	.RST_PRIORITY_B(PORT_B_OPTION_RST_PRIORITY), \\
	.RSTTYPE(OPTION_RSTTYPE), \\
	.INIT_A(ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_WIDTH, OPTION_RSTTYPE == "SYNC" ? PORT_A_RD_SRST_VALUE : PORT_A_RD_ARST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_WIDTH, OPTION_RSTTYPE == "SYNC" ? PORT_B_RD_SRST_VALUE : PORT_B_RD_ARST_VALUE)),

wire RST_A = OPTION_RSTTYPE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire RST_B = OPTION_RSTTYPE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST;

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

generate

if (OPTION_MODE == "FULL") begin
	wire [3:0] WE_A = {4{PORT_A_WR_EN}};
	wire [3:0] WE_B = {4{PORT_B_WR_EN}};
	RAMB16BWER #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.RSTA(RST_A),
		.RSTB(RST_B),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire [1:0] WE_A = {2{PORT_A_WR_EN}};
	wire [1:0] WE_B = {2{PORT_B_WR_EN}};
	RAMB8BWER #(
		\`PARAMS_INIT_9
		\`PARAMS_INITP_9
		\`PARAMS_COMMON
		.RAM_MODE("TDP"),
	) _TECHMAP_REPLACE_ (
		.DOADO(DO_A),
		.DOPADOP(DOP_A),
		.DIADI(DI_A),
		.DIPADIP(DIP_A),
		.DOBDO(DO_B),
		.DOPBDOP(DOP_B),
		.DIBDI(DI_B),
		.DIPBDIP(DIP_B),
		.ADDRAWRADDR(PORT_A_ADDR),
		.ADDRBRDADDR(PORT_B_ADDR),
		.CLKAWRCLK(PORT_A_CLK),
		.CLKBRDCLK(PORT_B_CLK),
		.ENAWREN(PORT_A_CLK_EN),
		.ENBRDEN(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEBREGCE(1'b0),
		.RSTA(RST_A),
		.RSTBRST(RST_B),
		.WEAWEL(WE_A),
		.WEBWEU(WE_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RSTTYPE = "SYNC";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;
parameter PORT_R_RD_ARST_VALUE = 0;
parameter PORT_R_OPTION_RST_PRIORITY = "CE";

input CLK_C;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;

\`include "brams_defs.vh"

wire RST = OPTION_RSTTYPE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST;

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

localparam [35:0] RST_VALUE = OPTION_RSTTYPE == "SYNC" ? PORT_R_RD_SRST_VALUE : PORT_R_RD_ARST_VALUE;

RAMB8BWER #(
	\`PARAMS_INIT_9
	\`PARAMS_INITP_9
	.WRITE_MODE_A(OPTION_WRITE_MODE),
	.WRITE_MODE_B(OPTION_WRITE_MODE),
	.DATA_WIDTH_A(PORT_W_USED ? PORT_W_WIDTH : 0),
	.DATA_WIDTH_B(PORT_R_USED ? PORT_R_WIDTH : 0),
	.EN_RSTRAM_A("TRUE"),
	.EN_RSTRAM_B("TRUE"),
	.DOA_REG(0),
	.DOB_REG(0),
	.RST_PRIORITY_A("CE"),
	.RST_PRIORITY_B(PORT_R_OPTION_RST_PRIORITY),
	.RSTTYPE(OPTION_RSTTYPE),
	.INIT_A(ival(18, PORT_R_RD_INIT_VALUE[17:0])),
	.INIT_B(ival(18, PORT_R_RD_INIT_VALUE[35:18])),
	.SRVAL_A(ival(18, RST_VALUE[17:0])),
	.SRVAL_B(ival(18, RST_VALUE[35:18])),
	.RAM_MODE("SDP"),
) _TECHMAP_REPLACE_ (
	.DOADO(DO[15:0]),
	.DOPADOP(DOP[1:0]),
	.DIADI(DI[15:0]),
	.DIPADIP(DIP[1:0]),
	.DOBDO(DO[31:16]),
	.DOPBDOP(DOP[3:2]),
	.DIBDI(DI[31:16]),
	.DIPBDIP(DIP[3:2]),
	.ADDRAWRADDR(PORT_W_ADDR),
	.ADDRBRDADDR(PORT_R_ADDR),
	.CLKAWRCLK(PORT_W_CLK),
	.CLKBRDCLK(PORT_R_CLK),
	.ENAWREN(PORT_W_CLK_EN),
	.ENBRDEN(PORT_R_CLK_EN),
	.REGCEA(1'b0),
	.REGCEBREGCE(1'b0),
	.RSTA(1'b0),
	.RSTBRST(RST),
	.WEAWEL(PORT_W_WR_EN[1:0]),
	.WEBWEU(PORT_W_WR_EN[3:2]),
);

endmodule
`,"brams_xc4v.txt":`# Block RAMs for Virtex 4+.
# The corresponding mapping files are:
# - brams_xc3sda_map.v: Spartan 3A DSP, Spartan 6
# - brams_xc4v_map.v: Virtex 4
# - brams_xc5v_map.v: Virtex 5
# - brams_xc6v_map.v: Virtex 6, Series 7
# - brams_xcu_map.v: Ultrascale

ram block $__XILINX_BLOCKRAM_TDP_ {
	byte 9;
	ifdef HAS_SIZE_36 {
		option "MODE" "HALF" {
			abits 14;
			widths 1 2 4 9 18 per_port;
			cost 129;
		}
		option "MODE" "FULL" {
			abits 15;
			widths 1 2 4 9 18 36 per_port;
			cost 257;
		}
		ifdef HAS_CASCADE {
			option "MODE" "CASCADE" {
				abits 16;
				# hack to enforce same INIT layout as in the other modes
				widths 1 2 4 9 per_port;
				cost 513;
			}
		}
	} else {
		option "MODE" "FULL" {
			abits 14;
			widths 1 2 4 9 18 36 per_port;
			cost 129;
		}
		ifdef HAS_CASCADE {
			option "MODE" "CASCADE" {
				abits 15;
				widths 1 2 4 9 per_port;
				cost 257;
			}
		}
	}
	init any;
	port srsw "A" "B" {
		option "MODE" "HALF" {
			width mix;
		}
		option "MODE" "FULL" {
			width mix;
		}
		option "MODE" "CASCADE" {
			width mix 1;
		}
		ifdef HAS_ADDRCE {
			# TODO
			# addrce;
		}
		# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
		ifdef HAS_CONFLICT_BUG {
			option "HAS_RDFIRST" 1 {
				clock posedge "C";
			}
			option "HAS_RDFIRST" 0 {
				clock posedge;
			}
		} else {
			clock posedge;
		}
		clken;
		rdsrst any gated_clken;
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
			option "MODE" "CASCADE" {
				forbid;
			}
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			ifdef HAS_SIZE_36 {
				rdwr new;
			} else {
				rdwr new_only;
			}
		}
		ifdef HAS_CONFLICT_BUG {
			option "HAS_RDFIRST" 1 {
				portoption "WRITE_MODE" "READ_FIRST" {
					rdwr old;
					wrtrans all old;
				}
			}
		} else {
			portoption "WRITE_MODE" "READ_FIRST" {
				rdwr old;
				wrtrans all old;
			}
		}
		optional_rw;
	}
}

ifdef HAS_SIZE_36 {
	ram block $__XILINX_BLOCKRAM_SDP_ {
		byte 9;
		option "MODE" "HALF" {
			abits 14;
			widths 1 2 4 9 18 36 per_port;
			cost 129;
		}
		option "MODE" "FULL" {
			abits 15;
			widths 1 2 4 9 18 36 72 per_port;
			cost 257;
		}
		init any;
		port sw "W" {
			ifndef HAS_MIXWIDTH_SDP {
				option "MODE" "HALF" width 36;
				option "MODE" "FULL" width 72;
			}
			ifdef HAS_ADDRCE {
				# TODO
				# addrce;
			}
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			ifdef HAS_CONFLICT_BUG {
				option "WRITE_MODE" "READ_FIRST" {
					clock posedge "C";
				}
				option "WRITE_MODE" "WRITE_FIRST" {
					clock posedge;
				}
			} else {
				clock posedge;
			}
			clken;
			option "WRITE_MODE" "READ_FIRST" {
				wrtrans all old;
			}
			optional;
		}
		port sr "R" {
			ifndef HAS_MIXWIDTH_SDP {
				option "MODE" "HALF" width 36;
				option "MODE" "FULL" width 72;
			}
			ifdef HAS_ADDRCE {
				# TODO
				# addrce;
			}
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			ifdef HAS_CONFLICT_BUG {
				option "WRITE_MODE" "READ_FIRST" {
					clock posedge "C";
				}
				option "WRITE_MODE" "WRITE_FIRST" {
					clock posedge;
				}
			} else {
				clock posedge;
			}
			clken;
			rdsrst any gated_clken;
			rdinit any;
			optional;
		}
	}
}
`,"brams_xc4v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [14:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [14:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "FULL") begin
	RAMB16 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA({1'b1, PORT_A_ADDR[13:0]}),
		.ADDRB({1'b1, PORT_B_ADDR[13:0]}),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB16 #(
		\`PARAMS_INIT_18
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIA(DI_A),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEOUTA(CAS_A),
		.CASCADEOUTB(CAS_B),
	);
	RAMB16 #(
		\`PARAMS_INIT_18_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOA(DO_A),
		.DIA(DI_A),
		.DOB(DO_B),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEINA(CAS_A),
		.CASCADEINB(CAS_B),
	);
end

endgenerate

endmodule
`,"brams_xc5v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA(PORT_A_ADDR[13:0]),
		.ADDRB(PORT_B_ADDR[13:0]),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA({1'b1, PORT_A_ADDR[14:0]}),
		.ADDRB({1'b1, PORT_B_ADDR[14:0]}),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB36 #(
		\`PARAMS_INIT_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIA(DI_A),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEOUTLATA(CAS_A),
		.CASCADEOUTLATB(CAS_B),
	);
	RAMB36 #(
		\`PARAMS_INIT_36_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOA(DO_A),
		.DIA(DI_A),
		.DOB(DO_B),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEINLATA(CAS_A),
		.CASCADEINLATB(CAS_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.DO_REG(0), \\
	.INIT(ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)), \\
	.SRVAL(ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),

\`define PORTS_COMMON \\
	.DO(DO), \\
	.DOP(DOP), \\
	.DI(DI), \\
	.DIP(DIP), \\
	.WRCLK(PORT_W_CLK), \\
	.RDCLK(PORT_R_CLK), \\
	.WREN(PORT_W_CLK_EN), \\
	.RDEN(PORT_R_CLK_EN), \\
	.REGCE(1'b0), \\
	.SSR(PORT_R_RD_SRST), \\
	.WE(PORT_W_WR_EN),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18SDP #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.WRADDR(PORT_W_ADDR[13:5]),
		.RDADDR(PORT_R_ADDR[13:5]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36SDP #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.WRADDR(PORT_W_ADDR[14:6]),
		.RDADDR(PORT_R_ADDR[14:6]),
	);
end

endgenerate

endmodule
`,"brams_xc6v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 1;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)), \\
	.RAM_MODE("TDP"),

\`define PORTS_COMMON \\
	.DOADO(DO_A), \\
	.DOPADOP(DOP_A), \\
	.DIADI(DI_A), \\
	.DIPADIP(DIP_A), \\
	.DOBDO(DO_B), \\
	.DOPBDOP(DOP_B), \\
	.DIBDI(DI_B), \\
	.DIPBDIP(DIP_B), \\
	.CLKARDCLK(PORT_A_CLK), \\
	.CLKBWRCLK(PORT_B_CLK), \\
	.ENARDEN(PORT_A_CLK_EN), \\
	.ENBWREN(PORT_B_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.RSTRAMARSTRAM(PORT_A_RD_SRST), \\
	.RSTRAMB(PORT_B_RD_SRST), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(WE_A), \\
	.WEBWE(WE_B),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E1 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR(PORT_A_ADDR[13:0]),
		.ADDRBWRADDR(PORT_B_ADDR[13:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR({1'b1, PORT_A_ADDR[14:0]}),
		.ADDRBWRADDR({1'b1, PORT_B_ADDR[14:0]}),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIADI(DI_A),
		.DIBDI(DI_B),
		.CLKARDCLK(PORT_A_CLK),
		.CLKBWRCLK(PORT_B_CLK),
		.ENARDEN(PORT_A_CLK_EN),
		.ENBWREN(PORT_B_CLK_EN),
		.REGCEAREGCE(1'b0),
		.REGCEB(1'b0),
		.RSTRAMARSTRAM(PORT_A_RD_SRST),
		.RSTRAMB(PORT_B_RD_SRST),
		.RSTREGARSTREG(1'b0),
		.RSTREGB(1'b0),
		.WEA(WE_A),
		.WEBWE(WE_B),
		.ADDRARDADDR(PORT_A_ADDR),
		.ADDRBWRADDR(PORT_B_ADDR),
		.CASCADEOUTA(CAS_A),
		.CASCADEOUTB(CAS_B),
	);
	RAMB36E1 #(
		\`PARAMS_INIT_36_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOADO(DO_A),
		.DIADI(DI_A),
		.DOBDO(DO_B),
		.DIBDI(DI_B),
		.CLKARDCLK(PORT_A_CLK),
		.CLKBWRCLK(PORT_B_CLK),
		.ENARDEN(PORT_A_CLK_EN),
		.ENBWREN(PORT_B_CLK_EN),
		.REGCEAREGCE(1'b0),
		.REGCEB(1'b0),
		.RSTRAMARSTRAM(PORT_A_RD_SRST),
		.RSTRAMB(PORT_B_RD_SRST),
		.RSTREGARSTREG(1'b0),
		.RSTREGB(1'b0),
		.WEA(WE_A),
		.WEBWE(WE_B),
		.ADDRARDADDR(PORT_A_ADDR),
		.ADDRBWRADDR(PORT_B_ADDR),
		.CASCADEINA(CAS_A),
		.CASCADEINB(CAS_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input CLK_C;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\
	.READ_WIDTH_B(0), \\
	.WRITE_WIDTH_A(0), \\
	.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.RAM_MODE("SDP"),

\`define PORTS_COMMON \\
	.CLKBWRCLK(PORT_W_CLK), \\
	.CLKARDCLK(PORT_R_CLK), \\
	.ENBWREN(PORT_W_CLK_EN), \\
	.ENARDEN(PORT_R_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.RSTRAMARSTRAM(PORT_R_RD_SRST), \\
	.RSTRAMB(1'b0), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(0), \\
	.WEBWE(PORT_W_WR_EN),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E1 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR(PORT_R_ADDR[13:0]),
		.ADDRBWRADDR(PORT_W_ADDR[13:0]),
		.DOADO(DO[15:0]),
		.DOBDO(DO[31:16]),
		.DOPADOP(DOP[1:0]),
		.DOPBDOP(DOP[3:2]),
		.DIADI(DI[15:0]),
		.DIBDI(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),
		.DIPADIP(DIP[1:0]),
		.DIPBDIP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR({1'b1, PORT_R_ADDR}),
		.ADDRBWRADDR({1'b1, PORT_W_ADDR}),
		.DOADO(DO[31:0]),
		.DOBDO(DO[63:32]),
		.DOPADOP(DOP[3:0]),
		.DOPBDOP(DOP[7:4]),
		.DIADI(DI[31:0]),
		.DIBDI(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),
		.DIPADIP(DIP[3:0]),
		.DIPBDIP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),
	);
end

endgenerate

endmodule
`,"brams_xcu_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 1;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`define PORTS_COMMON \\
	.DOUTADOUT(DO_A), \\
	.DOUTPADOUTP(DOP_A), \\
	.DINADIN(DI_A), \\
	.DINPADINP(DIP_A), \\
	.DOUTBDOUT(DO_B), \\
	.DOUTPBDOUTP(DOP_B), \\
	.DINBDIN(DI_B), \\
	.DINPBDINP(DIP_B), \\
	.CLKARDCLK(PORT_A_CLK), \\
	.CLKBWRCLK(PORT_B_CLK), \\
	.ENARDEN(PORT_A_CLK_EN), \\
	.ENBWREN(PORT_B_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.ADDRENA(1'b1), \\
	.ADDRENB(1'b1), \\
	.RSTRAMARSTRAM(PORT_A_RD_SRST), \\
	.RSTRAMB(PORT_B_RD_SRST), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(WE_A), \\
	.WEBWE(WE_B), \\
	.ADDRARDADDR(PORT_A_ADDR), \\
	.ADDRBWRADDR(PORT_B_ADDR), \\
	.SLEEP(1'b0),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E2 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E2 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\
	.READ_WIDTH_B(0), \\
	.WRITE_WIDTH_A(0), \\
	.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0),

\`define PORTS_COMMON \\
	.CLKBWRCLK(PORT_W_CLK), \\
	.CLKARDCLK(PORT_R_CLK), \\
	.ENBWREN(PORT_W_CLK_EN), \\
	.ENARDEN(PORT_R_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.ADDRENA(1'b1), \\
	.ADDRENB(1'b1), \\
	.RSTRAMARSTRAM(PORT_R_RD_SRST), \\
	.RSTRAMB(1'b0), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(0), \\
	.WEBWE(PORT_W_WR_EN), \\
	.ADDRARDADDR(PORT_R_ADDR), \\
	.ADDRBWRADDR(PORT_W_ADDR), \\
	.SLEEP(1'b0),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E2 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.DOUTADOUT(DO[15:0]),
		.DOUTBDOUT(DO[31:16]),
		.DOUTPADOUTP(DOP[1:0]),
		.DOUTPBDOUTP(DOP[3:2]),
		.DINADIN(DI[15:0]),
		.DINBDIN(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),
		.DINPADINP(DIP[1:0]),
		.DINPBDINP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E2 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.DOUTADOUT(DO[31:0]),
		.DOUTBDOUT(DO[63:32]),
		.DOUTPADOUTP(DOP[3:0]),
		.DOUTPBDOUTP(DOP[7:4]),
		.DINADIN(DI[31:0]),
		.DINBDIN(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),
		.DINPADINP(DIP[3:0]),
		.DINPBDINP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),
	);
end

endgenerate

endmodule

`,"brams_xcv.txt":`# Block RAMs for the original Virtex.
# The corresponding mapping file is brams_xcv_map.v

ram block $__XILINX_BLOCKRAM_ {
	abits 12;
	widths 1 2 4 8 16 per_port;
	cost 32;
	init any;
	port srsw "A" "B" {
		clock posedge;
		clken;
		rdwr new;
		rdinit zero;
		rdsrst zero gated_clken;
		optional;
	}
}
`,"brams_xcv_map.v":`module $__XILINX_BLOCKRAM_ (...);

parameter INIT = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_B_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_B_USED = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [11:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [11:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`define PARAMS_INIT \\
	.INIT_00(INIT[0*256+:256]), \\
	.INIT_01(INIT[1*256+:256]), \\
	.INIT_02(INIT[2*256+:256]), \\
	.INIT_03(INIT[3*256+:256]), \\
	.INIT_04(INIT[4*256+:256]), \\
	.INIT_05(INIT[5*256+:256]), \\
	.INIT_06(INIT[6*256+:256]), \\
	.INIT_07(INIT[7*256+:256]), \\
	.INIT_08(INIT[8*256+:256]), \\
	.INIT_09(INIT[9*256+:256]), \\
	.INIT_0A(INIT[10*256+:256]), \\
	.INIT_0B(INIT[11*256+:256]), \\
	.INIT_0C(INIT[12*256+:256]), \\
	.INIT_0D(INIT[13*256+:256]), \\
	.INIT_0E(INIT[14*256+:256]), \\
	.INIT_0F(INIT[15*256+:256]),

\`define PORTS_DP(addr_slice_a, addr_slice_b) \\
	.CLKA(PORT_A_CLK), \\
	.ENA(PORT_A_CLK_EN), \\
	.WEA(PORT_A_WR_EN), \\
	.RSTA(PORT_A_RD_SRST), \\
	.ADDRA(PORT_A_ADDR addr_slice_a), \\
	.DOA(PORT_A_RD_DATA), \\
	.DIA(PORT_A_WR_DATA), \\
	.CLKB(PORT_B_CLK), \\
	.ENB(PORT_B_CLK_EN), \\
	.WEB(PORT_B_WR_EN), \\
	.RSTB(PORT_B_RD_SRST), \\
	.ADDRB(PORT_B_ADDR addr_slice_b), \\
	.DOB(PORT_B_RD_DATA), \\
	.DIB(PORT_B_WR_DATA),

\`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\
	.CLKB(PORT_A_CLK), \\
	.ENB(PORT_A_CLK_EN), \\
	.WEB(PORT_A_WR_EN), \\
	.RSTB(PORT_A_RD_SRST), \\
	.ADDRB(PORT_A_ADDR addr_slice_a), \\
	.DOB(PORT_A_RD_DATA), \\
	.DIB(PORT_A_WR_DATA), \\
	.CLKA(PORT_B_CLK), \\
	.ENA(PORT_B_CLK_EN), \\
	.WEA(PORT_B_WR_EN), \\
	.RSTA(PORT_B_RD_SRST), \\
	.ADDRA(PORT_B_ADDR addr_slice_b), \\
	.DOA(PORT_B_RD_DATA), \\
	.DIA(PORT_B_WR_DATA),

\`define PORTS_SP(addr_slice) \\
	.CLK(PORT_A_CLK), \\
	.EN(PORT_A_CLK_EN), \\
	.WE(PORT_A_WR_EN), \\
	.RST(PORT_A_RD_SRST), \\
	.ADDR(PORT_A_ADDR addr_slice), \\
	.DO(PORT_A_RD_DATA), \\
	.DI(PORT_A_WR_DATA),

generate

if (!PORT_B_USED) begin
	case (PORT_A_WIDTH)
	1: RAMB4_S1 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:0])
	);
	2: RAMB4_S2 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:1])
	);
	4: RAMB4_S4 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:2])
	);
	8: RAMB4_S8 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:3])
	);
	16: RAMB4_S16 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:4])
	);
	endcase
end else begin
	case (PORT_A_WIDTH)
	1:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S1 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:0])
		);
		2: RAMB4_S1_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:1])
		);
		4: RAMB4_S1_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:2])
		);
		8: RAMB4_S1_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:3])
		);
		16: RAMB4_S1_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:4])
		);
		endcase
	2:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:1], [11:0])
		);
		2: RAMB4_S2_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:1])
		);
		4: RAMB4_S2_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:2])
		);
		8: RAMB4_S2_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:3])
		);
		16: RAMB4_S2_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:4])
		);
		endcase
	4:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:2], [11:0])
		);
		2: RAMB4_S2_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:2], [11:1])
		);
		4: RAMB4_S4_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:2])
		);
		8: RAMB4_S4_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:3])
		);
		16: RAMB4_S4_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:4])
		);
		endcase
	8:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:0])
		);
		2: RAMB4_S2_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:1])
		);
		4: RAMB4_S4_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:2])
		);
		8: RAMB4_S8_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:3], [11:3])
		);
		16: RAMB4_S8_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:3], [11:4])
		);
		endcase
	16:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:0])
		);
		2: RAMB4_S2_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:1])
		);
		4: RAMB4_S4_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:2])
		);
		8: RAMB4_S8_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:3])
		);
		16: RAMB4_S16_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:4], [11:4])
		);
		endcase
	endcase
end

endgenerate

endmodule
`,"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module \\$__SHREG_ (input C, input D, input E, output Q);
  parameter DEPTH = 0;
  parameter [DEPTH-1:0] INIT = 0;
  parameter CLKPOL = 1;
  parameter ENPOL = 2;

  \\$__XILINX_SHREG_ #(.DEPTH(DEPTH), .INIT(INIT), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(DEPTH-1), .E(E), .Q(Q));
endmodule

module \\$__XILINX_SHREG_ (input C, input D, input [31:0] L, input E, output Q, output SO);
  parameter DEPTH = 0;
  parameter [DEPTH-1:0] INIT = 0;
  parameter CLKPOL = 1;
  parameter ENPOL = 2;

  // shregmap's INIT parameter shifts out LSB first;
  // however Xilinx expects MSB first
  function [DEPTH-1:0] brev;
    input [DEPTH-1:0] din;
    integer i;
    begin
      for (i = 0; i < DEPTH; i=i+1)
        brev[i] = din[DEPTH-1-i];
    end
  endfunction
  localparam [DEPTH-1:0] INIT_R = brev(INIT);

  parameter _TECHMAP_CONSTMSK_L_ = 0;

  wire CE;
  generate
    if (ENPOL == 0)
      assign CE = ~E;
    else if (ENPOL == 1)
      assign CE = E;
    else
      assign CE = 1'b1;
    if (DEPTH == 1) begin
      if (CLKPOL)
          FDRE #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));
      else
          FDRE_1 #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));
    end else
    if (DEPTH <= 16) begin
      SRL16E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A0(L[0]), .A1(L[1]), .A2(L[2]), .A3(L[3]), .CE(CE), .CLK(C), .D(D), .Q(Q));
    end else
    if (DEPTH > 17 && DEPTH <= 32) begin
      SRLC32E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(Q));
    end else
    if (DEPTH > 33 && DEPTH <= 64) begin
      wire T0, T1, T2;
      SRLC32E #(.INIT(INIT_R[32-1:0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(T0), .Q31(T1));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-32), .INIT(INIT[DEPTH-32-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_1 (.C(C), .D(T1), .L(L), .E(E), .Q(T2));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T2;
      else
        MUXF7 fpga_mux_0 (.O(Q), .I0(T0), .I1(T2), .S(L[5]));
    end else
    if (DEPTH > 65 && DEPTH <= 96) begin
      wire T0, T1, T2, T3, T4, T5, T6;
      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-64), .INIT(INIT[DEPTH-64-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_2 (.C(C), .D(T3), .L(L[4:0]), .E(E), .Q(T4));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T4;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(1'bx), .S0(L[5]), .S1(L[6]), .O(Q));
    end else
    if (DEPTH > 97 && DEPTH < 128) begin
      wire T0, T1, T2, T3, T4, T5, T6, T7, T8;
      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      SRLC32E #(.INIT(INIT_R[96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-96), .INIT(INIT[DEPTH-96-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_3 (.C(C), .D(T5), .L(L[4:0]), .E(E), .Q(T6));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T6;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));
    end
    else if (DEPTH == 128) begin
      wire T0, T1, T2, T3, T4, T5, T6;
      SRLC32E #(.INIT(INIT_R[ 32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[ 64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      SRLC32E #(.INIT(INIT_R[ 96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));
      SRLC32E #(.INIT(INIT_R[128-1:96]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_3 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T5), .Q(T6), .Q31(SO));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T6;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));
    end
    // For fixed length, if just 1 over a convenient value, decompose
    else if (DEPTH <= 129 && &_TECHMAP_CONSTMSK_L_) begin
      wire T;
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-1), .INIT(INIT[DEPTH-1:1]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(D), .L({32{1'b1}}), .E(E), .Q(T));
      \\$__XILINX_SHREG_ #(.DEPTH(1),       .INIT(INIT[0]),         .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(T), .L(L), .E(E), .Q(Q));
    end
    // For variable length, if just 1 over a convenient value, then bump up one more
    else if (DEPTH < 129 && ~&_TECHMAP_CONSTMSK_L_)
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH+1), .INIT({INIT,1'b0}), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(L), .E(E), .Q(Q));
    else begin
      localparam depth0 = 128;
      localparam num_srl128 = DEPTH / depth0;
      localparam depthN = DEPTH % depth0;
      wire [num_srl128 + (depthN > 0 ? 1 : 0) - 1:0] T;
      wire [num_srl128 + (depthN > 0 ? 1 : 0) :0] S;
      assign S[0] = D;
      genvar i;
      for (i = 0; i < num_srl128; i++)
        \\$__XILINX_SHREG_ #(.DEPTH(depth0), .INIT(INIT[DEPTH-1-i*depth0-:depth0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(S[i]),          .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[i]), .SO(S[i+1]));

      if (depthN > 0)
        \\$__XILINX_SHREG_ #(.DEPTH(depthN), .INIT(INIT[depthN-1:0]),               .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(S[num_srl128]), .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[num_srl128]));

      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T[num_srl128 + (depthN > 0 ? 1 : 0) - 1];
      else
        assign Q = T[L[DEPTH-1:$clog2(depth0)]];
    end
  endgenerate
endmodule

\`ifdef MIN_MUX_INPUTS
module \\$__XILINX_SHIFTX (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  parameter [A_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;
  parameter [A_WIDTH-1:0] _TECHMAP_CONSTVAL_A_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

  function integer A_WIDTH_trimmed;
    input integer start;
  begin
    A_WIDTH_trimmed = start;
    while (A_WIDTH_trimmed > 0 && _TECHMAP_CONSTMSK_A_[A_WIDTH_trimmed-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH_trimmed-1] === 1'bx)
      A_WIDTH_trimmed = A_WIDTH_trimmed - 1;
  end
  endfunction

  generate
    genvar i, j;
    // Bit-blast
    if (Y_WIDTH > 1) begin
      for (i = 0; i < Y_WIDTH; i++)
        \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH-Y_WIDTH+1), .B_WIDTH(B_WIDTH), .Y_WIDTH(1'd1)) bitblast (.A(A[A_WIDTH-Y_WIDTH+i:i]), .B(B), .Y(Y[i]));
    end
    // If the LSB of B is constant zero (and Y_WIDTH is 1) then
    //   we can optimise by removing every other entry from A
    //   and popping the constant zero from B
    else if (_TECHMAP_CONSTMSK_B_[0] && !_TECHMAP_CONSTVAL_B_[0]) begin
      wire [(A_WIDTH+1)/2-1:0] A_i;
      for (i = 0; i < (A_WIDTH+1)/2; i++)
        assign A_i[i] = A[i*2];
      \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH((A_WIDTH+1'd1)/2'd2), .B_WIDTH(B_WIDTH-1'd1), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A_i), .B(B[B_WIDTH-1:1]), .Y(Y));
    end
    // Trim off any leading 1'bx -es in A
    else if (_TECHMAP_CONSTMSK_A_[A_WIDTH-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH-1] === 1'bx) begin
      localparam A_WIDTH_new = A_WIDTH_trimmed(A_WIDTH-1);
      if (A_WIDTH_new == 0)
        assign Y = 1'bx;
      else
        \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH_new), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A[A_WIDTH_new-1:0]), .B(B), .Y(Y));
    end
    else if (A_WIDTH < \`MIN_MUX_INPUTS) begin
      wire _TECHMAP_FAIL_ = 1;
    end
    else if (A_WIDTH == 2) begin
      MUXF7 fpga_hard_mux (.I0(A[0]), .I1(A[1]), .S(B[0]), .O(Y));
    end
    else if (A_WIDTH <= 4) begin
      wire [4-1:0] Ax;
      if (A_WIDTH == 4)
        assign Ax = A;
      else
        // Rather than extend with 1'bx which gets flattened to 1'b0
        // causing the "don't care" status to get lost, extend with
        // the same driver of F7B.I0 so that we can optimise F7B away
        // later
        assign Ax = {A[1], A};
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(Ax[0]), .I1(Ax[2]), .I2(Ax[1]), .I3(Ax[3]), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    // Note that the following decompositions are 'backwards' in that
    // the LSBs are placed on the hard resources, and the soft resources
    // are used for MSBs.
    // This has the effect of more effectively utilising the hard mux;
    // take for example a 5:1 multiplexer, currently this would map as:
    //
    //     A[0] \\___  __                             A[0] \\__  __
    //     A[4] /   \\|  \\       whereas the more     A[1] /  \\|  \\
    //     A[1] _____|   |      obvious mapping      A[2] \\___|   |
    //     A[2] _____|   |--    of MSBs to hard      A[3] /   |   |__
    //     A[3]______|   |      resources would      A[4] ____|   |
    //               |__/       lead to:             1'bx ____|   |
    //                ||                                      |__/
    //                ||                                       ||
    //              B[1:0]                                   B[1:2]
    //
    // Expectation would be that the 'forward' mapping (right) is more
    // area efficient (consider a 9:1 multiplexer using 2x4:1 multiplexers
    // on its I0 and I1 inputs, and A[8] and 1'bx on its I2 and I3 inputs)
    // but that the 'backwards' mapping (left) is more delay efficient
    // since smaller LUTs are faster than wider ones.
    else if (A_WIDTH <= 8) begin
      wire [8-1:0] Ax = {{{8-A_WIDTH}{1'bx}}, A};
      wire T0 = B[2] ? Ax[4] : Ax[0];
      wire T1 = B[2] ? Ax[5] : Ax[1];
      wire T2 = B[2] ? Ax[6] : Ax[2];
      wire T3 = B[2] ? Ax[7] : Ax[3];
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    else if (A_WIDTH <= 16) begin
      wire [16-1:0] Ax = {{{16-A_WIDTH}{1'bx}}, A};
      wire T0 = B[2] ? B[3] ? Ax[12] : Ax[4]
                     : B[3] ? Ax[ 8] : Ax[0];
      wire T1 = B[2] ? B[3] ? Ax[13] : Ax[5]
                     : B[3] ? Ax[ 9] : Ax[1];
      wire T2 = B[2] ? B[3] ? Ax[14] : Ax[6]
                     : B[3] ? Ax[10] : Ax[2];
      wire T3 = B[2] ? B[3] ? Ax[15] : Ax[7]
                     : B[3] ? Ax[11] : Ax[3];
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    else begin
      localparam num_mux16 = (A_WIDTH+15) / 16;
      localparam clog2_num_mux16 = $clog2(num_mux16);
      wire [num_mux16-1:0] T;
      wire [num_mux16*16-1:0] Ax = {{(num_mux16*16-A_WIDTH){1'bx}}, A};
      for (i = 0; i < num_mux16; i++)
        \\$__XILINX_SHIFTX  #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(16),
          .B_WIDTH(4),
          .Y_WIDTH(Y_WIDTH)
        ) fpga_mux (
          .A(Ax[i*16+:16]),
          .B(B[3:0]),
          .Y(T[i])
        );
      \\$__XILINX_SHIFTX  #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(num_mux16),
          .B_WIDTH(clog2_num_mux16),
          .Y_WIDTH(Y_WIDTH)
      ) _TECHMAP_REPLACE_ (
          .A(T),
          .B(B[B_WIDTH-1-:clog2_num_mux16]),
          .Y(Y));
    end
  endgenerate
endmodule

(* techmap_celltype = "$__XILINX_SHIFTX" *)
module _90__XILINX_SHIFTX (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  \\$shiftx  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));
endmodule

module \\$_MUX_ (A, B, S, Y);
  input A, B, S;
  output Y;
  generate
    if (\`MIN_MUX_INPUTS == 2)
      \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(2), .B_WIDTH(1), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({B,A}), .B(S), .Y(Y));
    else
      wire _TECHMAP_FAIL_ = 1;
  endgenerate
endmodule

module \\$_MUX4_ (A, B, C, D, S, T, Y);
  input A, B, C, D, S, T;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(4), .B_WIDTH(2), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({D,C,B,A}), .B({T,S}), .Y(Y));
endmodule

module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);
  input A, B, C, D, E, F, G, H, S, T, U;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(8), .B_WIDTH(3), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({H,G,F,E,D,C,B,A}), .B({U,T,S}), .Y(Y));
endmodule

module \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);
  input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(16), .B_WIDTH(4), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A}), .B({V,U,T,S}), .Y(Y));
endmodule
\`endif

module \\$__XILINX_MUXF78 (O, I0, I1, I2, I3, S0, S1);
  output O;
  input I0, I1, I2, I3, S0, S1;
  wire T0, T1;
  parameter _TECHMAP_BITS_CONNMAP_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I0_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I1_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I2_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I3_ = 0;
  parameter _TECHMAP_CONSTMSK_S0_ = 0;
  parameter _TECHMAP_CONSTVAL_S0_ = 0;
  parameter _TECHMAP_CONSTMSK_S1_ = 0;
  parameter _TECHMAP_CONSTVAL_S1_ = 0;
  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)
    assign T0 = I1;
  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_)
    assign T0 = I0;
  else
    MUXF7 mux7a (.I0(I0), .I1(I1), .S(S0), .O(T0));
  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)
    assign T1 = I3;
  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_)
    assign T1 = I2;
  else
    MUXF7 mux7b (.I0(I2), .I1(I3), .S(S0), .O(T1));
  if (_TECHMAP_CONSTMSK_S1_ && _TECHMAP_CONSTVAL_S1_ === 1'b1)
    assign O = T1;
  else if (_TECHMAP_CONSTMSK_S1_ || (_TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_ && _TECHMAP_CONNMAP_I1_ === _TECHMAP_CONNMAP_I2_ && _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_))
    assign O = T0;
  else
    MUXF8 mux8 (.I0(T0), .I1(T1), .S(S1), .O(O));
endmodule
`,"cells_sim.v":new URL("cells_sim-7704155f.v?hash=7704155f",import.meta.url),"cells_xtra.v":new URL("cells_xtra-04bc1ce3.v?hash=04bc1ce3",import.meta.url),"ff_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

\`ifndef _NO_FFS

// Async reset, enable.

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDPE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Async set and reset, enable.

module  \\$_DFFSRE_NPPP_ (input D, C, E, S, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_C_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFSRE_PPPP_ (input D, C, E, S, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Sync reset, enable.

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDRE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDRE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDSE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDSE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Latches with reset.

module  \\$_DLATCH_NP0_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PP0_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_NP1_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PP1_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Latches with set and reset.

module  \\$_DLATCH_NPP_ (input E, S, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PPP_ (input E, S, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

\`endif

`,"lut_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================
// LUT mapping

\`ifndef _NO_LUTS

module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      if (LUT == 2'b01) begin
        INV _TECHMAP_REPLACE_ (.O(Y), .I(A[0]));
      end else begin
        LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
          .I0(A[0]));
      end
    end else
    if (WIDTH == 2) begin
      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]));
    end else
    if (WIDTH == 3) begin
      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]));
    end else
    if (WIDTH == 4) begin
      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]));
    end else
    if (WIDTH == 5 && WIDTH <= \`LUT_WIDTH) begin
      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]), .I4(A[4]));
    end else
    if (WIDTH == 6 && WIDTH <= \`LUT_WIDTH) begin
      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]), .I4(A[4]), .I5(A[5]));
    end else
    if (WIDTH == 5 && WIDTH > \`LUT_WIDTH) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));
      \\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));
      MUXF5 mux5(.I0(f0), .I1(f1), .S(A[4]), .O(Y));
    end else
    if (WIDTH == 6 && WIDTH > \`LUT_WIDTH) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));
      \\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));
      MUXF6 mux6(.I0(f0), .I1(f1), .S(A[5]), .O(Y));
    end else
    if (WIDTH == 7) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[ 63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));
      \\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));
      MUXF7 mux7(.I0(f0), .I1(f1), .S(A[6]), .O(Y));
    end else
    if (WIDTH == 8) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[127:  0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));
      \\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));
      MUXF8 mux8(.I0(f0), .I1(f1), .S(A[7]), .O(Y));
    end else
    if (WIDTH == 9) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[255:  0]), .WIDTH(8)) lut0 (.A(A[7:0]), .Y(f0));
      \\$lut #(.LUT(LUT[511:256]), .WIDTH(8)) lut1 (.A(A[7:0]), .Y(f1));
      MUXF9 mux9(.I0(f0), .I1(f1), .S(A[8]), .O(Y));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule

\`endif

`,"lutrams_xc5v.txt":`# LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7.
# The corresponding mapping file is lutrams_xc5v_map.v

# Single-port RAMs.

ram distributed $__XILINX_LUTRAM_SP_ {
	cost 8;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 8 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 4 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 2 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

# Dual-port RAMs.

ram distributed $__XILINX_LUTRAM_DP_ {
	cost 8;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 4 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 2 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Quad-port RAMs.

ram distributed $__XILINX_LUTRAM_QP_ {
	cost 7;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 2 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" {
	}
}

# Simple dual port RAMs.

ram distributed $__XILINX_LUTRAM_SDP_ {
	cost 8;
	widthscale 7;
	option "ABITS" 5 {
		abits 5;
		widths 6 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 3 global;
	}
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_xc5v_map.v":`// LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7, Ultrascale.
// The definitions are in lutrams_xc5v.txt (everything but Ultrascale)
// and lutrams_xcu.txt (Ultrascale).


module $__XILINX_LUTRAM_SP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 8;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case(OPTION_ABITS)
5: if (WIDTH == 8)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(1)),
		.INIT_B(init_slice2(2)),
		.INIT_A(init_slice2(3)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_RW_RD_DATA[7:6]),
		.DOB(PORT_RW_RD_DATA[5:4]),
		.DOC(PORT_RW_RD_DATA[3:2]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[7:6]),
		.DIB(PORT_RW_WR_DATA[5:4]),
		.DIC(PORT_RW_WR_DATA[3:2]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_RW_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_RW_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(1)),
		.INIT_F(init_slice2(2)),
		.INIT_E(init_slice2(3)),
		.INIT_D(init_slice2(4)),
		.INIT_C(init_slice2(5)),
		.INIT_B(init_slice2(6)),
		.INIT_A(init_slice2(7)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_RW_RD_DATA[15:14]),
		.DOB(PORT_RW_RD_DATA[13:12]),
		.DOC(PORT_RW_RD_DATA[11:10]),
		.DOD(PORT_RW_RD_DATA[9:8]),
		.DOE(PORT_RW_RD_DATA[7:6]),
		.DOF(PORT_RW_RD_DATA[5:4]),
		.DOG(PORT_RW_RD_DATA[3:2]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[15:14]),
		.DIB(PORT_RW_WR_DATA[13:12]),
		.DIC(PORT_RW_WR_DATA[11:10]),
		.DID(PORT_RW_WR_DATA[9:8]),
		.DIE(PORT_RW_WR_DATA[7:6]),
		.DIF(PORT_RW_WR_DATA[5:4]),
		.DIG(PORT_RW_WR_DATA[3:2]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_RW_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_RW_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_RW_ADDR),
		.ADDRF(PORT_RW_ADDR),
		.ADDRG(PORT_RW_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM64X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
7: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM128X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.A6(PORT_RW_ADDR[6]),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
8: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM256X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
9: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM512X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_DP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 4;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 4)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[3:2]),
		.DOB(PORT_RW_RD_DATA[3:2]),
		.DOC(PORT_R_RD_DATA[1:0]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[3:2]),
		.DIB(PORT_RW_WR_DATA[3:2]),
		.DIC(PORT_RW_WR_DATA[1:0]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(1)),
		.INIT_E(init_slice2(1)),
		.INIT_D(init_slice2(2)),
		.INIT_C(init_slice2(2)),
		.INIT_B(init_slice2(3)),
		.INIT_A(init_slice2(3)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[7:6]),
		.DOB(PORT_RW_RD_DATA[7:6]),
		.DOC(PORT_R_RD_DATA[5:4]),
		.DOD(PORT_RW_RD_DATA[5:4]),
		.DOE(PORT_R_RD_DATA[3:2]),
		.DOF(PORT_RW_RD_DATA[3:2]),
		.DOG(PORT_R_RD_DATA[1:0]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[7:6]),
		.DIB(PORT_RW_WR_DATA[7:6]),
		.DIC(PORT_RW_WR_DATA[5:4]),
		.DID(PORT_RW_WR_DATA[5:4]),
		.DIE(PORT_RW_WR_DATA[3:2]),
		.DIF(PORT_RW_WR_DATA[3:2]),
		.DIG(PORT_RW_WR_DATA[1:0]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_RW_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM64X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA0(PORT_R_ADDR[0]),
				.DPRA1(PORT_R_ADDR[1]),
				.DPRA2(PORT_R_ADDR[2]),
				.DPRA3(PORT_R_ADDR[3]),
				.DPRA4(PORT_R_ADDR[4]),
				.DPRA5(PORT_R_ADDR[5]),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
7: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM128X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA(PORT_R_ADDR),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
8: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM256X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA(PORT_R_ADDR),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_QP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 2;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R0_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R0_ADDR;
output [WIDTH-1:0] PORT_R1_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R1_ADDR;
output [WIDTH-1:0] PORT_R2_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R2_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 2)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(0)),
		.INIT_A(init_slice2(0)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[1:0]),
		.DOB(PORT_R1_RD_DATA[1:0]),
		.DOC(PORT_R0_RD_DATA[1:0]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[1:0]),
		.DIB(PORT_RW_WR_DATA[1:0]),
		.DIC(PORT_RW_WR_DATA[1:0]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(0)),
		.INIT_E(init_slice2(0)),
		.INIT_D(init_slice2(1)),
		.INIT_C(init_slice2(1)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[3:2]),
		.DOB(PORT_R1_RD_DATA[3:2]),
		.DOC(PORT_R0_RD_DATA[3:2]),
		.DOD(PORT_RW_RD_DATA[3:2]),
		.DOE(PORT_R2_RD_DATA[1:0]),
		.DOF(PORT_R1_RD_DATA[1:0]),
		.DOG(PORT_R0_RD_DATA[1:0]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[3:2]),
		.DIB(PORT_RW_WR_DATA[3:2]),
		.DIC(PORT_RW_WR_DATA[3:2]),
		.DID(PORT_RW_WR_DATA[3:2]),
		.DIE(PORT_RW_WR_DATA[1:0]),
		.DIF(PORT_RW_WR_DATA[1:0]),
		.DIG(PORT_RW_WR_DATA[1:0]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: if (WIDTH == 1)
	RAM64M
	#(
		.INIT_D(init_slice(0)),
		.INIT_C(init_slice(0)),
		.INIT_B(init_slice(0)),
		.INIT_A(init_slice(0)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[0]),
		.DOB(PORT_R1_RD_DATA[0]),
		.DOC(PORT_R0_RD_DATA[0]),
		.DOD(PORT_RW_RD_DATA[0]),
		.DIA(PORT_RW_WR_DATA[0]),
		.DIB(PORT_RW_WR_DATA[0]),
		.DIC(PORT_RW_WR_DATA[0]),
		.DID(PORT_RW_WR_DATA[0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM64M8
	#(
		.INIT_H(init_slice(0)),
		.INIT_G(init_slice(0)),
		.INIT_F(init_slice(0)),
		.INIT_E(init_slice(0)),
		.INIT_D(init_slice(1)),
		.INIT_C(init_slice(1)),
		.INIT_B(init_slice(1)),
		.INIT_A(init_slice(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[1]),
		.DOB(PORT_R1_RD_DATA[1]),
		.DOC(PORT_R0_RD_DATA[1]),
		.DOD(PORT_RW_RD_DATA[1]),
		.DOE(PORT_R2_RD_DATA[0]),
		.DOF(PORT_R1_RD_DATA[0]),
		.DOG(PORT_R0_RD_DATA[0]),
		.DOH(PORT_RW_RD_DATA[0]),
		.DIA(PORT_RW_WR_DATA[1]),
		.DIB(PORT_RW_WR_DATA[1]),
		.DIC(PORT_RW_WR_DATA[1]),
		.DID(PORT_RW_WR_DATA[1]),
		.DIE(PORT_RW_WR_DATA[0]),
		.DIF(PORT_RW_WR_DATA[0]),
		.DIG(PORT_RW_WR_DATA[0]),
		.DIH(PORT_RW_WR_DATA[0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_OP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 2;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R0_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R0_ADDR;
output [WIDTH-1:0] PORT_R1_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R1_ADDR;
output [WIDTH-1:0] PORT_R2_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R2_ADDR;
output [WIDTH-1:0] PORT_R3_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R3_ADDR;
output [WIDTH-1:0] PORT_R4_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R4_ADDR;
output [WIDTH-1:0] PORT_R5_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R5_ADDR;
output [WIDTH-1:0] PORT_R6_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R6_ADDR;

generate
case (OPTION_ABITS)
5:	RAM32M16
	#(
		.INIT_H(INIT),
		.INIT_G(INIT),
		.INIT_F(INIT),
		.INIT_E(INIT),
		.INIT_D(INIT),
		.INIT_C(INIT),
		.INIT_B(INIT),
		.INIT_A(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R6_RD_DATA),
		.DOB(PORT_R5_RD_DATA),
		.DOC(PORT_R4_RD_DATA),
		.DOD(PORT_R3_RD_DATA),
		.DOE(PORT_R2_RD_DATA),
		.DOF(PORT_R1_RD_DATA),
		.DOG(PORT_R0_RD_DATA),
		.DOH(PORT_RW_RD_DATA),
		.DIA(PORT_RW_WR_DATA),
		.DIB(PORT_RW_WR_DATA),
		.DIC(PORT_RW_WR_DATA),
		.DID(PORT_RW_WR_DATA),
		.DIE(PORT_RW_WR_DATA),
		.DIF(PORT_RW_WR_DATA),
		.DIG(PORT_RW_WR_DATA),
		.DIH(PORT_RW_WR_DATA),
		.ADDRA(PORT_R6_ADDR),
		.ADDRB(PORT_R5_ADDR),
		.ADDRC(PORT_R4_ADDR),
		.ADDRD(PORT_R3_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6:	RAM64M8
	#(
		.INIT_H(INIT),
		.INIT_G(INIT),
		.INIT_F(INIT),
		.INIT_E(INIT),
		.INIT_D(INIT),
		.INIT_C(INIT),
		.INIT_B(INIT),
		.INIT_A(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R6_RD_DATA),
		.DOB(PORT_R5_RD_DATA),
		.DOC(PORT_R4_RD_DATA),
		.DOD(PORT_R3_RD_DATA),
		.DOE(PORT_R2_RD_DATA),
		.DOF(PORT_R1_RD_DATA),
		.DOG(PORT_R0_RD_DATA),
		.DOH(PORT_RW_RD_DATA),
		.DIA(PORT_RW_WR_DATA),
		.DIB(PORT_RW_WR_DATA),
		.DIC(PORT_RW_WR_DATA),
		.DID(PORT_RW_WR_DATA),
		.DIE(PORT_RW_WR_DATA),
		.DIF(PORT_RW_WR_DATA),
		.DIG(PORT_RW_WR_DATA),
		.DIH(PORT_RW_WR_DATA),
		.ADDRA(PORT_R6_ADDR),
		.ADDRB(PORT_R5_ADDR),
		.ADDRC(PORT_R4_ADDR),
		.ADDRD(PORT_R3_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 6;
parameter BITS_USED = 0;

input [WIDTH-1:0] PORT_W_WR_DATA;
input [OPTION_ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input PORT_W_CLK;

output [WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 6)
	RAM32M
	#(
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(2)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[5:4]),
		.DOB(PORT_R_RD_DATA[3:2]),
		.DOC(PORT_R_RD_DATA[1:0]),
		.DIA(PORT_W_WR_DATA[5:4]),
		.DIB(PORT_W_WR_DATA[3:2]),
		.DIC(PORT_W_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
else
	RAM32M16
	#(
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(1)),
		.INIT_E(init_slice2(2)),
		.INIT_D(init_slice2(3)),
		.INIT_C(init_slice2(4)),
		.INIT_B(init_slice2(5)),
		.INIT_A(init_slice2(6)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[13:12]),
		.DOB(PORT_R_RD_DATA[11:10]),
		.DOC(PORT_R_RD_DATA[9:8]),
		.DOD(PORT_R_RD_DATA[7:6]),
		.DOE(PORT_R_RD_DATA[5:4]),
		.DOF(PORT_R_RD_DATA[3:2]),
		.DOG(PORT_R_RD_DATA[1:0]),
		.DIA(PORT_W_WR_DATA[13:12]),
		.DIB(PORT_W_WR_DATA[11:10]),
		.DIC(PORT_W_WR_DATA[9:8]),
		.DID(PORT_W_WR_DATA[7:6]),
		.DIE(PORT_W_WR_DATA[5:4]),
		.DIF(PORT_W_WR_DATA[3:2]),
		.DIG(PORT_W_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_R_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_R_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
6: if (WIDTH == 3)
	RAM64M
	#(
		.INIT_C(init_slice(0)),
		.INIT_B(init_slice(1)),
		.INIT_A(init_slice(2)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[2]),
		.DOB(PORT_R_RD_DATA[1]),
		.DOC(PORT_R_RD_DATA[0]),
		.DIA(PORT_W_WR_DATA[2]),
		.DIB(PORT_W_WR_DATA[1]),
		.DIC(PORT_W_WR_DATA[0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
else
	RAM64M8
	#(
		.INIT_G(init_slice(0)),
		.INIT_F(init_slice(1)),
		.INIT_E(init_slice(2)),
		.INIT_D(init_slice(3)),
		.INIT_C(init_slice(4)),
		.INIT_B(init_slice(5)),
		.INIT_A(init_slice(6)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[6]),
		.DOB(PORT_R_RD_DATA[5]),
		.DOC(PORT_R_RD_DATA[4]),
		.DOD(PORT_R_RD_DATA[3]),
		.DOE(PORT_R_RD_DATA[2]),
		.DOF(PORT_R_RD_DATA[1]),
		.DOG(PORT_R_RD_DATA[0]),
		.DIA(PORT_W_WR_DATA[6]),
		.DIB(PORT_W_WR_DATA[5]),
		.DIC(PORT_W_WR_DATA[4]),
		.DID(PORT_W_WR_DATA[3]),
		.DIE(PORT_W_WR_DATA[2]),
		.DIF(PORT_W_WR_DATA[1]),
		.DIG(PORT_W_WR_DATA[0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_R_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_R_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_64X8SW_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 9;
parameter PORT_RW_WR_WIDTH = 1;
parameter PORT_RW_RD_WIDTH = 8;

output [PORT_RW_RD_WIDTH-1:0] PORT_RW_RD_DATA;
input [PORT_RW_WR_WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

function [63:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 64; i = i + 1)
		init_slice[i] = INIT[i * 8 + idx];
endfunction

RAM64X8SW
#(
	.INIT_A(init_slice(7)),
	.INIT_B(init_slice(6)),
	.INIT_C(init_slice(5)),
	.INIT_D(init_slice(4)),
	.INIT_E(init_slice(3)),
	.INIT_F(init_slice(2)),
	.INIT_G(init_slice(1)),
	.INIT_H(init_slice(0)),
)
_TECHMAP_REPLACE_
(
	.A(PORT_RW_ADDR[8:3]),
	.WSEL(PORT_RW_ADDR[2:0]),
	.D(PORT_RW_WR_DATA),
	.O(PORT_RW_RD_DATA),
	.WE(PORT_RW_WR_EN),
	.WCLK(PORT_RW_CLK),
);

endmodule


module $__XILINX_LUTRAM_32X16DR8_ (...);

parameter OPTION_ABITS = 6;
parameter BITS_USED = 0;
parameter PORT_W_WIDTH = 14;
parameter PORT_R_WIDTH = 7;

input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [OPTION_ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input PORT_W_CLK;

output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

RAM32X16DR8 _TECHMAP_REPLACE_
(
	.DOA(PORT_R_RD_DATA[6]),
	.DOB(PORT_R_RD_DATA[5]),
	.DOC(PORT_R_RD_DATA[4]),
	.DOD(PORT_R_RD_DATA[3]),
	.DOE(PORT_R_RD_DATA[2]),
	.DOF(PORT_R_RD_DATA[1]),
	.DOG(PORT_R_RD_DATA[0]),
	.DIA({PORT_W_WR_DATA[13], PORT_W_WR_DATA[6]}),
	.DIB({PORT_W_WR_DATA[12], PORT_W_WR_DATA[5]}),
	.DIC({PORT_W_WR_DATA[11], PORT_W_WR_DATA[4]}),
	.DID({PORT_W_WR_DATA[10], PORT_W_WR_DATA[3]}),
	.DIE({PORT_W_WR_DATA[9], PORT_W_WR_DATA[2]}),
	.DIF({PORT_W_WR_DATA[8], PORT_W_WR_DATA[1]}),
	.DIG({PORT_W_WR_DATA[7], PORT_W_WR_DATA[0]}),
	.ADDRA(PORT_R_ADDR),
	.ADDRB(PORT_R_ADDR),
	.ADDRC(PORT_R_ADDR),
	.ADDRD(PORT_R_ADDR),
	.ADDRE(PORT_R_ADDR),
	.ADDRF(PORT_R_ADDR),
	.ADDRG(PORT_R_ADDR),
	.ADDRH(PORT_W_ADDR[5:1]),
	.WE(PORT_W_WR_EN),
	.WCLK(PORT_W_CLK),
);

endmodule
`,"lutrams_xcu.txt":`# LUT RAMs for Ultrascale.
# The corresponding mapping file is lutrams_xc5v_map.v

# Single-port RAMs.

ram distributed $__XILINX_LUTRAM_SP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 16 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 8 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 4 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 2 global;
	}
	option "ABITS" 16 {
		abits 16;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

# Dual-port RAMs.

ram distributed $__XILINX_LUTRAM_DP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 8 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 4 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 2 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Quad-port RAMs.

ram distributed $__XILINX_LUTRAM_QP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 4 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 2 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" {
	}
}

# Octal-port RAMs.

ram distributed $__XILINX_LUTRAM_OP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 2 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" "R3" "R4" "R5" "R6" {
	}
}

# Simple dual port RAMs.

ram distributed $__XILINX_LUTRAM_SDP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 14 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 7 global;
	}
	init any;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Wide-read RAM.

ram distributed $__XILINX_LUTRAM_64X8SW_ {
	cost 16;
	abits 9;
	widths 1 2 4 8 per_port;
	init any;
	prune_rom;
	port arsw "RW" {
		width rd 8 wr 1;
		clock posedge;
	}
}

# Wide-write RAM.

ram distributed $__XILINX_LUTRAM_32X16DR8_ {
	cost 16;
	widthscale;
	abits 6;
	widths 7 14 per_port;
	# Yes, no initialization capability.
	prune_rom;
	port sw "W" {
		width 14;
		clock posedge;
	}
	port ar "R" {
		width 7;
	}
}
`,"lutrams_xcv.txt":`# LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.
# The corresponding mapping file is lutrams_xcv_map.v

ram distributed $__XILINX_LUTRAM_SP_ {
	width 1;
	option "ABITS" 4 {
		abits 4;
		cost 3;
	}
	option "ABITS" 5 {
		abits 5;
		cost 5;
	}
	ifndef IS_VIRTEX {
		option "ABITS" 6 {
			abits 6;
			cost 9;
		}
	}
	ifdef IS_VIRTEX2 {
		# RAM128X1S
		option "ABITS" 7 {
			abits 7;
			cost 17;
		}
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

ram distributed $__XILINX_LUTRAM_DP_ {
	width 1;
	option "ABITS" 4 {
		abits 4;
		cost 5;
	}
	ifdef IS_VIRTEX2 {
		# RAM32X1D
		option "ABITS" 5 {
			abits 5;
			cost 9;
		}
		# RAM64X1D
		option "ABITS" 6 {
			abits 6;
			cost 17;
		}
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_xcv_map.v":`// LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.
// The corresponding definition file is lutrams_xcv.txt

module $__XILINX_LUTRAM_SP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 4;

output PORT_RW_RD_DATA;
input PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

generate
case(OPTION_ABITS)
4: RAM16X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
5: RAM32X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: RAM64X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
7: RAM128X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.A6(PORT_RW_ADDR[6]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS");
endcase
endgenerate

endmodule

module $__XILINX_LUTRAM_DP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 4;

output PORT_RW_RD_DATA;
input PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

generate
case (OPTION_ABITS)
4: RAM16X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPO(PORT_R_RD_DATA),
	);
5: RAM32X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPRA4(PORT_R_ADDR[4]),
		.DPO(PORT_R_RD_DATA),
	);
6: RAM64X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPRA4(PORT_R_ADDR[4]),
		.DPRA5(PORT_R_ADDR[5]),
		.DPO(PORT_R_RD_DATA),
	);
default:
	$error("invalid OPTION_ABITS");
endcase
endgenerate

endmodule
`,"mux_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// The purpose of these mapping rules is to allow preserve all (sufficiently
// wide) $shiftx cells during 'techmap' so that they can be mapped to hard
// resources, rather than being bit-blasted to gates during 'techmap'
// execution

module \\$shiftx (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

  generate
    if (B_SIGNED) begin
      if (_TECHMAP_CONSTMSK_B_[B_WIDTH-1] && (_TECHMAP_CONSTVAL_B_[B_WIDTH-1] == 1'b0 || _TECHMAP_CONSTVAL_B_[B_WIDTH-1] === 1'bx))
        // Optimisation to remove B_SIGNED if sign bit of B is constant-0
        \\$shiftx #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(0),
          .A_WIDTH(A_WIDTH),
          .B_WIDTH(B_WIDTH-1'd1),
          .Y_WIDTH(Y_WIDTH)
        ) _TECHMAP_REPLACE_ (
          .A(A), .B(B[B_WIDTH-2:0]), .Y(Y)
        );
      else
        wire _TECHMAP_FAIL_ = 1;
    end
    else begin
      if (((A_WIDTH + Y_WIDTH - 1) / Y_WIDTH) < \`MIN_MUX_INPUTS)
        wire _TECHMAP_FAIL_ = 1;
      else
        \\$__XILINX_SHIFTX #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(A_WIDTH),
          .B_WIDTH(B_WIDTH),
          .Y_WIDTH(Y_WIDTH)
        ) _TECHMAP_REPLACE_ (
          .A(A), .B(B), .Y(Y)
        );
    end
  endgenerate
endmodule
`,"urams.txt":`ram huge $__XILINX_URAM_ {
	abits 12;
	width 72;
	cost 1024;
	option "BYTEWIDTH" 8 byte 8;
	option "BYTEWIDTH" 9 byte 9;
	init zero;
	port srsw "A" {
		clock anyedge "C";
		clken;
		rdwr no_change;
		rdinit zero;
		portoption "RST_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		portoption "RST_MODE" "ASYNC" {
			rdarst zero;
		}
		wrtrans all new;
		wrbe_separate;
	}
	port srsw "B" {
		clock anyedge "C";
		clken;
		rdwr no_change;
		rdinit zero;
		portoption "RST_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		portoption "RST_MODE" "ASYNC" {
			rdarst zero;
		}
		wrtrans all old;
		wrprio "A";
		wrbe_separate;
	}
}

ram huge $__XILINX_URAM_SP_ {
	abits 11;
	width 144;
	cost 1024;
	option "BYTEWIDTH" 8 byte 8;
	option "BYTEWIDTH" 9 byte 9;
	init zero;
	port srsw "A" {
		clock anyedge "C";
		clken;
		rdwr no_change;
		rdinit zero;
		portoption "RST_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		portoption "RST_MODE" "ASYNC" {
			rdarst zero;
		}
		wrbe_separate;
	}
}
`,"urams_map.v":`module $__XILINX_URAM_ (...);
	parameter OPTION_BYTEWIDTH = 8;
	localparam WR_BE_WIDTH = 72 / OPTION_BYTEWIDTH;

	parameter CLK_C_POL = 1;
	parameter PORT_A_CLK_POL = 1;
	parameter PORT_A_OPTION_RST_MODE = "SYNC";
	parameter PORT_B_CLK_POL = 1;
	parameter PORT_B_OPTION_RST_MODE = "SYNC";

	input CLK_C;

	input PORT_A_CLK;
	input PORT_A_CLK_EN;
	input PORT_A_RD_SRST;
	input PORT_A_RD_ARST;
	input PORT_A_WR_EN;
	input [WR_BE_WIDTH-1:0] PORT_A_WR_BE;
	input [11:0] PORT_A_ADDR;
	input [71:0] PORT_A_WR_DATA;
	output [71:0] PORT_A_RD_DATA;

	input PORT_B_CLK;
	input PORT_B_CLK_EN;
	input PORT_B_RD_SRST;
	input PORT_B_RD_ARST;
	input PORT_B_WR_EN;
	input [WR_BE_WIDTH-1:0] PORT_B_WR_BE;
	input [11:0] PORT_B_ADDR;
	input [71:0] PORT_B_WR_DATA;
	output [71:0] PORT_B_RD_DATA;

	wire [71:0] DIN_A, DIN_B, DOUT_A, DOUT_B;

	generate
		if (OPTION_BYTEWIDTH == 8) begin
			assign DIN_A = PORT_A_WR_DATA;
			assign DIN_B = PORT_B_WR_DATA;
			assign PORT_A_RD_DATA = DOUT_A;
			assign PORT_B_RD_DATA = DOUT_B;
		end else begin
			assign DIN_A = {
				PORT_A_WR_DATA[71],
				PORT_A_WR_DATA[62],
				PORT_A_WR_DATA[53],
				PORT_A_WR_DATA[44],
				PORT_A_WR_DATA[35],
				PORT_A_WR_DATA[26],
				PORT_A_WR_DATA[17],
				PORT_A_WR_DATA[8],
				PORT_A_WR_DATA[70:63],
				PORT_A_WR_DATA[61:54],
				PORT_A_WR_DATA[52:45],
				PORT_A_WR_DATA[43:36],
				PORT_A_WR_DATA[34:27],
				PORT_A_WR_DATA[25:18],
				PORT_A_WR_DATA[16:9],
				PORT_A_WR_DATA[7:0]
			};
			assign DIN_B = {
				PORT_B_WR_DATA[71],
				PORT_B_WR_DATA[62],
				PORT_B_WR_DATA[53],
				PORT_B_WR_DATA[44],
				PORT_B_WR_DATA[35],
				PORT_B_WR_DATA[26],
				PORT_B_WR_DATA[17],
				PORT_B_WR_DATA[8],
				PORT_B_WR_DATA[70:63],
				PORT_B_WR_DATA[61:54],
				PORT_B_WR_DATA[52:45],
				PORT_B_WR_DATA[43:36],
				PORT_B_WR_DATA[34:27],
				PORT_B_WR_DATA[25:18],
				PORT_B_WR_DATA[16:9],
				PORT_B_WR_DATA[7:0]
			};
			assign PORT_A_RD_DATA = {
				DOUT_A[71],
				DOUT_A[63:56],
				DOUT_A[70],
				DOUT_A[55:48],
				DOUT_A[69],
				DOUT_A[47:40],
				DOUT_A[68],
				DOUT_A[39:32],
				DOUT_A[67],
				DOUT_A[31:24],
				DOUT_A[66],
				DOUT_A[23:16],
				DOUT_A[65],
				DOUT_A[15:8],
				DOUT_A[64],
				DOUT_A[7:0]
			};
			assign PORT_B_RD_DATA = {
				DOUT_B[71],
				DOUT_B[63:56],
				DOUT_B[70],
				DOUT_B[55:48],
				DOUT_B[69],
				DOUT_B[47:40],
				DOUT_B[68],
				DOUT_B[39:32],
				DOUT_B[67],
				DOUT_B[31:24],
				DOUT_B[66],
				DOUT_B[23:16],
				DOUT_B[65],
				DOUT_B[15:8],
				DOUT_B[64],
				DOUT_B[7:0]
			};
		end
	endgenerate

	URAM288 #(
		.BWE_MODE_A(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.BWE_MODE_B(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.EN_AUTO_SLEEP_MODE("FALSE"),
		.IREG_PRE_A("FALSE"),
		.IREG_PRE_B("FALSE"),
		.IS_CLK_INVERTED(!CLK_C_POL),
		.OREG_A("FALSE"),
		.OREG_B("FALSE"),
		.RST_MODE_A(PORT_A_OPTION_RST_MODE),
		.RST_MODE_B(PORT_B_OPTION_RST_MODE),
	) _TECHMAP_REPLACE_ (
		.ADDR_A({11'b0, PORT_A_ADDR}),
		.BWE_A(PORT_A_WR_BE),
		.EN_A(PORT_A_CLK_EN),
		.RDB_WR_A(PORT_A_WR_EN),
		.INJECT_DBITERR_A(1'b0),
		.INJECT_SBITERR_A(1'b0),
		.RST_A(PORT_A_OPTION_RST_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
		.DIN_A(DIN_A),
		.DOUT_A(DOUT_A),

		.ADDR_B({11'b0, PORT_B_ADDR}),
		.BWE_B(PORT_B_WR_BE),
		.EN_B(PORT_B_CLK_EN),
		.RDB_WR_B(PORT_B_WR_EN),
		.INJECT_DBITERR_B(1'b0),
		.INJECT_SBITERR_B(1'b0),
		.RST_B(PORT_B_OPTION_RST_MODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
		.DIN_B(DIN_B),
		.DOUT_B(DOUT_B),

		.CLK(CLK_C),
		.SLEEP(1'b0)
	);
endmodule

module $__XILINX_URAM_SP_ (...);
	parameter OPTION_BYTEWIDTH = 8;
	localparam WR_BE_WIDTH = 144 / OPTION_BYTEWIDTH;

	parameter CLK_C_POL = 1;
	parameter PORT_A_CLK_POL = 1;
	parameter PORT_A_OPTION_RST_MODE = "SYNC";

	input CLK_C;

	input PORT_A_CLK;
	input PORT_A_CLK_EN;
	input PORT_A_RD_SRST;
	input PORT_A_RD_ARST;
	input PORT_A_WR_EN;
	input [WR_BE_WIDTH-1:0] PORT_A_WR_BE;
	input [10:0] PORT_A_ADDR;
	input [143:0] PORT_A_WR_DATA;
	output [143:0] PORT_A_RD_DATA;

	wire [71:0] DIN_A, DIN_B, DOUT_A, DOUT_B;

	generate
		if (OPTION_BYTEWIDTH == 8) begin
			assign DIN_A = PORT_A_WR_DATA[71:0];
			assign DIN_B = PORT_A_WR_DATA[143:72];
			assign PORT_A_RD_DATA = {DOUT_B, DOUT_A};
		end else begin
			assign DIN_A = {
				PORT_A_WR_DATA[71],
				PORT_A_WR_DATA[62],
				PORT_A_WR_DATA[53],
				PORT_A_WR_DATA[44],
				PORT_A_WR_DATA[35],
				PORT_A_WR_DATA[26],
				PORT_A_WR_DATA[17],
				PORT_A_WR_DATA[8],
				PORT_A_WR_DATA[70:63],
				PORT_A_WR_DATA[61:54],
				PORT_A_WR_DATA[52:45],
				PORT_A_WR_DATA[43:36],
				PORT_A_WR_DATA[34:27],
				PORT_A_WR_DATA[25:18],
				PORT_A_WR_DATA[16:9],
				PORT_A_WR_DATA[7:0]
			};
			assign DIN_B = {
				PORT_A_WR_DATA[72+71],
				PORT_A_WR_DATA[72+62],
				PORT_A_WR_DATA[72+53],
				PORT_A_WR_DATA[72+44],
				PORT_A_WR_DATA[72+35],
				PORT_A_WR_DATA[72+26],
				PORT_A_WR_DATA[72+17],
				PORT_A_WR_DATA[72+8],
				PORT_A_WR_DATA[72+70:72+63],
				PORT_A_WR_DATA[72+61:72+54],
				PORT_A_WR_DATA[72+52:72+45],
				PORT_A_WR_DATA[72+43:72+36],
				PORT_A_WR_DATA[72+34:72+27],
				PORT_A_WR_DATA[72+25:72+18],
				PORT_A_WR_DATA[72+16:72+ 9],
				PORT_A_WR_DATA[72+ 7:72+ 0]
			};
			assign PORT_A_RD_DATA = {
				DOUT_B[71],
				DOUT_B[63:56],
				DOUT_B[70],
				DOUT_B[55:48],
				DOUT_B[69],
				DOUT_B[47:40],
				DOUT_B[68],
				DOUT_B[39:32],
				DOUT_B[67],
				DOUT_B[31:24],
				DOUT_B[66],
				DOUT_B[23:16],
				DOUT_B[65],
				DOUT_B[15:8],
				DOUT_B[64],
				DOUT_B[7:0],
				DOUT_A[71],
				DOUT_A[63:56],
				DOUT_A[70],
				DOUT_A[55:48],
				DOUT_A[69],
				DOUT_A[47:40],
				DOUT_A[68],
				DOUT_A[39:32],
				DOUT_A[67],
				DOUT_A[31:24],
				DOUT_A[66],
				DOUT_A[23:16],
				DOUT_A[65],
				DOUT_A[15:8],
				DOUT_A[64],
				DOUT_A[7:0]
			};
		end
	endgenerate

	URAM288 #(
		.BWE_MODE_A(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.BWE_MODE_B(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.EN_AUTO_SLEEP_MODE("FALSE"),
		.IREG_PRE_A("FALSE"),
		.IREG_PRE_B("FALSE"),
		.IS_CLK_INVERTED(!CLK_C_POL),
		.OREG_A("FALSE"),
		.OREG_B("FALSE"),
		.RST_MODE_A(PORT_A_OPTION_RST_MODE),
		.RST_MODE_B(PORT_A_OPTION_RST_MODE),
	) _TECHMAP_REPLACE_ (
		.ADDR_A({11'b0, PORT_A_ADDR, 1'b0}),
		.BWE_A(PORT_A_WR_BE[WR_BE_WIDTH/2-1:0]),
		.EN_A(PORT_A_CLK_EN),
		.RDB_WR_A(PORT_A_WR_EN),
		.INJECT_DBITERR_A(1'b0),
		.INJECT_SBITERR_A(1'b0),
		.RST_A(PORT_A_OPTION_RST_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
		.DIN_A(DIN_A),
		.DOUT_A(DOUT_A),

		.ADDR_B({11'b0, PORT_A_ADDR, 1'b1}),
		.BWE_B(PORT_A_WR_BE[WR_BE_WIDTH-1:WR_BE_WIDTH/2]),
		.EN_B(PORT_A_CLK_EN),
		.RDB_WR_B(PORT_A_WR_EN),
		.INJECT_DBITERR_B(1'b0),
		.INJECT_SBITERR_B(1'b0),
		.RST_B(PORT_A_OPTION_RST_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
		.DIN_B(DIN_B),
		.DOUT_B(DOUT_B),

		.CLK(CLK_C),
		.SLEEP(1'b0)
	);
endmodule
`,"xc3s_mult_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	MULT18X18 _TECHMAP_REPLACE_ (
		.A(A),
		.B(B),
		.P(Y)
	);
endmodule

`,"xc3sda_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48A #(
		// Disable all registers
		.A0REG(0),
		.A1REG(0),
		.B0REG(0),
		.B1REG(0),
		.CARRYINREG(0),
		.CARRYINSEL("OPMODE5"),
		.CREG(0),
		.DREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0)
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.D(18'b0),
		.P(P_48),

		.OPMODE(8'b0000001)
	);
	assign Y = P_48;
endmodule

`,"xc4v_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48 #(
		// Disable all registers
		.AREG(0),
		.BREG(0),
		.B_INPUT("DIRECT"),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.SUBTRACTREG(0),
		.LEGACY_MODE("MULT18X18")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.P(P_48),

		.SUBTRACT(1'b0),
		.OPMODE(7'b000101),
		.CARRYINSEL(2'b00),

		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule
`,"xc5v_dsp_map.v":`module \\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E #(
		// Disable all registers
		.ACASCREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.MULTCARRYINREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULT"),
		.USE_SIMD("ONE48")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{5{A[24]}}, A}),
		.B(B),
		.C(48'b0),
		.P(P_48),

		.ALUMODE(4'b0000),
		.OPMODE(7'b000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule

`,"xc6s_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48A1 #(
		// Disable all registers
		.A0REG(0),
		.A1REG(0),
		.B0REG(0),
		.B1REG(0),
		.CARRYINREG(0),
		.CARRYINSEL("OPMODE5"),
		.CREG(0),
		.DREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0)
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.D(18'b0),
		.P(P_48),

		.OPMODE(8'b0000001)
	);
	assign Y = P_48;
endmodule


`,"xc7_dsp_map.v":`module \\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E1 #(
		// Disable all registers
		.ACASCREG(0),
		.ADREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.DREG(0),
		.INMODEREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULTIPLY"),
		.USE_SIMD("ONE48"),
		.USE_DPORT("FALSE")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{5{A[24]}}, A}),
		.B(B),
		.C(48'b0),
		.D(25'b0),
		.CARRYIN(1'b0),
		.P(P_48),

		.INMODE(5'b00000),
		.ALUMODE(4'b0000),
		.OPMODE(7'b000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule
`,"xcu_dsp_map.v":`module \\$__MUL27X18 (input [26:0] A, input [17:0] B, output [44:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E2 #(
		// Disable all registers
		.ACASCREG(0),
		.ADREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.DREG(0),
		.INMODEREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULTIPLY"),
		.USE_SIMD("ONE48"),
		.AMULTSEL("A"),
		.BMULTSEL("B")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{3{A[26]}}, A}),
		.B(B),
		.C(48'b0),
		.D(27'b0),
		.P(P_48),

		.INMODE(5'b00000),
		.ALUMODE(4'b0000),
		.OPMODE(9'b00000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule

`}}}});var T_={};de(T_,{filesystem:()=>ar,modules:()=>ir});var ir,ar,A_=qe(()=>{ir={"icebram.core.wasm":new URL("icebram.core-ba6ef3a8.wasm?hash=ba6ef3a8",import.meta.url),"icebram.core2.wasm":new URL("icebram.core2-d5a2637d.wasm?hash=d5a2637d",import.meta.url),"icebram.core3.wasm":new URL("icebram.core3-742fd861.wasm?hash=742fd861",import.meta.url),"icebram.core4.wasm":new URL("icebram.core4-8d34ccc8.wasm?hash=8d34ccc8",import.meta.url),"icemulti.core.wasm":new URL("icemulti.core-f4be5531.wasm?hash=f4be5531",import.meta.url),"icemulti.core2.wasm":new URL("icemulti.core2-f8c2828b.wasm?hash=f8c2828b",import.meta.url),"icemulti.core3.wasm":new URL("icemulti.core3-cd16c078.wasm?hash=cd16c078",import.meta.url),"icemulti.core4.wasm":new URL("icemulti.core4-767a9873.wasm?hash=767a9873",import.meta.url),"icepack.core.wasm":new URL("icepack.core-702927a8.wasm?hash=702927a8",import.meta.url),"icepack.core2.wasm":new URL("icepack.core2-f8c2828b.wasm?hash=f8c2828b",import.meta.url),"icepack.core3.wasm":new URL("icepack.core3-cd16c078.wasm?hash=cd16c078",import.meta.url),"icepack.core4.wasm":new URL("icepack.core4-767a9873.wasm?hash=767a9873",import.meta.url),"icepll.core.wasm":new URL("icepll.core-1cc498bb.wasm?hash=1cc498bb",import.meta.url),"icepll.core2.wasm":new URL("icepll.core2-6d594f09.wasm?hash=6d594f09",import.meta.url),"icepll.core3.wasm":new URL("icepll.core3-65f1921e.wasm?hash=65f1921e",import.meta.url),"icepll.core4.wasm":new URL("icepll.core4-f5c32dbc.wasm?hash=f5c32dbc",import.meta.url),"nextpnr-ice40.core.wasm":new URL("nextpnr-ice40.core-b9074c2d.wasm?hash=b9074c2d",import.meta.url),"nextpnr-ice40.core2.wasm":new URL("nextpnr-ice40.core2-1d7c1e2f.wasm?hash=1d7c1e2f",import.meta.url),"nextpnr-ice40.core3.wasm":new URL("nextpnr-ice40.core3-3861a678.wasm?hash=3861a678",import.meta.url),"nextpnr-ice40.core4.wasm":new URL("nextpnr-ice40.core4-b83a37e9.wasm?hash=b83a37e9",import.meta.url)},ar={share:{ice40:{"chipdb-1k.bin":new URL("chipdb-1k-a5f6358b.bin?hash=a5f6358b",import.meta.url),"chipdb-384.bin":new URL("chipdb-384-49b8e64a.bin?hash=49b8e64a",import.meta.url),"chipdb-5k.bin":new URL("chipdb-5k-bc4914aa.bin?hash=bc4914aa",import.meta.url),"chipdb-8k.bin":new URL("chipdb-8k-af2b6ffa.bin?hash=af2b6ffa",import.meta.url),"chipdb-u4k.bin":new URL("chipdb-u4k-a87d5b0a.bin?hash=a87d5b0a",import.meta.url)}}}});var Je;typeof process=="object"&&process.release?.name==="node"?Je=async function(n,l){if(n.protocol==="file:"){let{readFile:b}=await import("fs/promises"),M="application/octet-stream";return n.pathname.endsWith(".wasm")&&(M="application/wasm"),new Response(await b(n),{headers:{"Content-Type":M}})}else return globalThis.fetch(n,l)}:Je=globalThis.fetch;var Me={};de(Me,{Exit:()=>Ee,commands:()=>_r,runYosys:()=>u_,version:()=>rr});var he;typeof process=="object"&&process.release?.name==="node"?he=async function(n,l){if(n.protocol==="file:"){let{readFile:b}=await import("fs/promises"),M="application/octet-stream";return n.pathname.endsWith(".wasm")&&(M="application/wasm"),new Response(await b(n),{headers:{"Content-Type":M}})}else return globalThis.fetch(n,l)}:he=globalThis.fetch;var s_=he,Ee=class extends Error{constructor(n=0){super(`Exited with status ${n}`),this.code=n}};function U_(){return BigInt(Math.floor(performance.now()*1e6))}function x_(){let n=Date.now(),l=BigInt(Math.floor(n/1e3)),b=n%1e3*1e6;return{seconds:l,nanoseconds:b}}var K_=class{constructor(n){if(BigInt(n)===0n)throw new Error("xoroshiro128** must be seeded with a non-zero state");this.s=[BigInt(n)&0xffffffffffffffffn,BigInt(n)>>64n&0xffffffffffffffffn]}next(){function n(z){return z&0xffffffffffffffffn}function l(z,m0){return z<<m0|z>>64n-m0}let[b,M]=this.s,G=n(l(b*5n,7n)*9n);return M^=b,b=n(l(b,24n)^M^M<<16n),M=n(l(M,37n)),this.s=[b,M],G}getBytes(n){return Uint8Array.from({length:n},()=>Number(BigInt.asUintN(8,this.next()>>32n)))}},Y_=class extends Error{},We=class{read(n){throw{tag:"closed"}}blockingRead(n){return this.read(n)}},ve=class{checkWrite(){throw{tag:"closed"}}write(n){this.checkWrite()}flush(){}blockingFlush(){this.flush()}blockingWriteAndFlush(n){this.write(n),this.blockingFlush()}},G_=class extends We{constructor(n=null){super(),this.callback=n}read(n){if(this.callback===null)throw{tag:"closed"};let l=this.callback(Number(n));if(l===null)throw{tag:"closed"};return l}},e_=class extends ve{constructor(n=null){super(),this.callback=n}checkWrite(){return 4096}write(n){this.callback!==null&&this.callback(n)}flush(){this.callback!==null&&this.callback(null)}},__=class{},r_=class{},Zn=class{constructor(n=""){if(n instanceof Uint8Array)this.data=n;else if(typeof n=="string")this.data=new TextEncoder().encode(n);else throw new Error(`Cannot construct a file from ${typeof n}`)}get size(){return this.data.length}},z_=class extends We{constructor(n,l){super(),this.file=n,this.offset=l}read(n){let l=this.file.data.subarray(Number(this.offset),Number(this.offset+n));return this.offset+=n,l}},X_=class extends ve{constructor(n,l){super(),this.file=n,this.offset=l}write(n){let l=new Uint8Array(this.file.data.length+n.length);l.set(this.file.data),l.subarray(Number(this.offset)).set(n),this.file.data=l,this.offset+=BigInt(n.length)}},Qt=class o_{constructor(l={}){this.files=l}get size(){return Object.keys(this.files).length}traverse(l,b={create:!1,remove:!1}){let M=this,G=-1;do{if(M instanceof Zn)throw"not-directory";let z=M.files;G=l.indexOf("/");let m0=G===-1?l:l.substring(0,G);if(G===-1&&b.remove)delete z[m0];else if(!(m0===""||m0===".")){if(m0!=="..")if(Object.hasOwn(z,m0))M=z[m0];else if(b.create==="directory"||b.create==="file"&&G!==-1)M=z[m0]=new o_({});else if(b.create==="file")M=z[m0]=new Zn(new Uint8Array);else throw"no-entry"}l=l.substring(G+1)}while(G!==-1);return M}},i_=class De{constructor(l){this.entry=l}getType(){if(this.entry instanceof Qt)return"directory";if(this.entry instanceof Zn)return"regular-file"}getFlags(){return{}}metadataHash(){return{upper:0,lower:0}}metadataHashAt(l,b){if(!(this.entry instanceof Qt))throw"invalid";let M=this.entry.traverse(b);return new De(M).metadataHash()}stat(){let l;return this.entry instanceof Qt&&(l="directory"),this.entry instanceof Zn&&(l="regular-file"),{type:l,linkCount:1,size:this.entry.size,dataAccessTimestamp:null,dataModificationTimestamp:null,statusChangeTimestamp:null}}statAt(l,b){if(!(this.entry instanceof Qt))throw"invalid";let M=this.entry.traverse(b);return new De(M).stat()}openAt(l,b,M,G){if(!(this.entry instanceof Qt))throw"invalid";let z=this.entry.traverse(b,{create:M.create?"file":!1});if(M.directory){if(!(z instanceof Qt))throw"not-directory"}else{if(z instanceof Qt)throw"is-directory";M.truncate&&(z.data=new Uint8Array)}return new De(z)}read(l,b){if(this.entry instanceof Qt)throw"is-directory";return[l,b]=[Number(l),Number(b)],[this.entry.data.subarray(b,b+l),b+l>=this.entry.data.byteLength]}readViaStream(l){return new z_(this.entry,l)}write(l,b){throw this.entry instanceof Qt?"is-directory":(console.error("Descriptor.write not implemented"),"unsupported")}writeViaStream(l){return new X_(this.entry,l)}readDirectory(){return new p_(this.entry)}createDirectoryAt(l){this.entry.traverse(l,{create:"directory"})}unlinkFileAt(l){if(this.entry.traverse(l)instanceof Qt)return"is-directory";this.entry.traverse(l,{remove:!0})}removeDirectoryAt(l){if(!(this.entry.traverse(l)instanceof Qt))return"not-directory";this.entry.traverse(l,{remove:!0})}},p_=class{constructor(n){this.entries=Object.entries(n.files),this.index=0}readDirectoryEntry(){if(this.index===this.entries.length)return null;let[n,l]=this.entries[this.index++],b;return l instanceof Qt&&(b="directory"),l instanceof Zn&&(b="regular-file"),{name:n,type:b}}};function ge(n){let l={};for(let[b,M]of Object.entries(n))typeof M=="string"||M instanceof Uint8Array?l[b]=new Zn(n[b]):l[b]=ge(n[b]);return new Qt(l)}function I_(n,{decodeASCII:l=!0}={}){function b(G){for(let z of G)if(z<32&&z!==9&&z!==10&&z!==13||z>=127)return!1;return!0}let M={};for(let[G,z]of Object.entries(n.files))z instanceof Zn&&(M[G]=l&&b(z.data)?new TextDecoder().decode(z.data):z.data),z instanceof Qt&&(M[G]=I_(z,{decodeASCII:l}));return M}var Z_=class{vars={};args=[];root=new Qt({});constructor(){this.prng=new K_(1n),this.standardInputStream=new G_,this.standardOutputStream=new e_,this.standardErrorStream=new e_,this.terminalInput=new __,this.terminalOutput=new r_;let n=this;this.exports={monotonicClock:{now:U_},wallClock:{now:x_},random:{getRandomBytes(l){return n.prng.getBytes(Number(l))}},io:{Error:Y_,InputStream:We,OutputStream:ve},cli:{exit(l){throw new Ee(l.tag==="ok"?0:1)},getEnvironment(){return n.vars},getArguments(){return n.args},getStdin(){return n.standardInputStream},getStdout(){return n.standardOutputStream},getStderr(){return n.standardErrorStream},getTerminalStdin(){return n.terminalInput},getTerminalStdout(){return n.terminalOutput},getTerminalStderr(){return n.terminalOutput},TerminalInput:__,TerminalOutput:r_},fs:{Descriptor:i_,DirectoryEntryStream:p_,filesystemErrorCode(){},getDirectories(){return n.root===null?[]:[[new i_(n.root),"/"]]}}}}get stdin(){return this.standardInputStream.callback}set stdin(n){this.standardInputStream.callback=n}get stdout(){return this.standardOutputStream.callback}set stdout(n){this.standardOutputStream.callback=n}get stderr(){return this.standardErrorStream.callback}set stderr(n){this.standardErrorStream.callback=n}};function Q_(n){let l=new Uint8Array;return b=>{if(b===null)return;let M=new Uint8Array(l.length+b.length);M.set(l),M.set(b,l.length),l=M;let G=-1;for(;;){let z=l.indexOf(10,G+1);if(z===-1)break;n(new TextDecoder().decode(l.subarray(G+1,z))),G=z}l=l.subarray(G+1)}}async function Be(n,l){let b=[];for(let[M,G]of Object.entries(n))typeof G=="string"||G instanceof Uint8Array?b.push(Promise.resolve([M,G])):G instanceof URL?b.push(l(G).then(z=>[M,z])):b.push(Be(G,l).then(z=>[M,z]));for(let[M,G]of await Promise.all(b))n[M]=G;return n}function V_(n){return s_(n).then(WebAssembly.compileStreaming)}function $_(n){return s_(n).then(l=>l.arrayBuffer()).then(l=>new Uint8Array(l))}function j_({modules:n,filesystem:l}){return Promise.all([Be(n,V_),Be(l,$_)]).then(([b,M])=>({modules:b,filesystem:M}))}var q_=class{constructor(n,l,b){this.resources=n,this.resourceData=null,this.instantiate=l,this.argv0=b}run(n=null,l={},b={}){if(this.resourceData===null){if(b.synchronously)throw new Error("Cannot run application synchronously unless resources are prefetched first; use `await run()` to do so");return this.resources().then(j_).then(x0=>(this.resourceData=x0,this.run(n,l,b)))}if(n===null)return;let M=new Z_;M.args=[this.argv0].concat(n),M.root=ge(l);for(let[x0,K0]of Object.entries(this.resourceData.filesystem))M.root.files[x0]=ge(K0);let G=Q_(b.printLine??console.log);M.stdin=b.stdin===void 0?null:b.stdin,M.stdout=b.stdout===void 0?G:b.stdout,M.stderr=b.stderr===void 0?G:b.stderr;let z=x0=>{let K0=null;try{x0.run.run()}catch(y0){if(!(y0 instanceof Ee))throw y0;y0 instanceof Ee&&y0.code!==0&&(K0=y0)}for(let y0 of Object.keys(this.resourceData.filesystem))delete M.root.files[y0];if(l=I_(M.root,{decodeASCII:b.decodeASCII??!0}),K0!==null)throw K0.files=l,K0;return l},m0=x0=>this.resourceData.modules[x0],J0={runtime:M.exports};if(b.synchronously){let x0=(K0,y0)=>new WebAssembly.Instance(K0,y0);return z(this.instantiate(m0,J0,x0))}else return this.instantiate(m0,J0).then(z)}},J_=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},i0=[],Pe=new DataView(new ArrayBuffer),k=n=>Pe.buffer===n.buffer?Pe:Pe=new DataView(n.buffer);function Nt(n){if(n&&tr.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var Yn=[],tr=Object.prototype.hasOwnProperty,k0=1<<30;function gt(n,l){let b=n[0]&~k0;return b===0?(n.push(0),n.push(l|k0),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|k0,b)}function Gn(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&k0)!==0,z=M&~k0;if(M===0||(b&k0)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|k0,n[0]=l|k0,{rep:z,scope:b,own:G}}var Vt=Symbol.for("cabiDispose"),o0=Symbol("handle"),M0=Symbol.for("cabiRep"),$t=Symbol.dispose||Symbol.for("dispose"),yt=n=>BigInt.asUintN(64,BigInt(n));function zn(n){return n>>>0}var ie=new TextDecoder,nr=new TextEncoder,Xn=0;function ce(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return Xn=0,1;let M=nr.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),Xn=M.length,G}function er(n,l,b=WebAssembly.instantiate){let M=n("yosys.core.wasm"),G=n("yosys.core2.wasm"),z=n("yosys.core3.wasm"),m0=n("yosys.core4.wasm"),{cli:J0,fs:x0,io:K0,monotonicClock:y0,random:Lt,wallClock:jt}=l.runtime,{TerminalInput:Pt,TerminalOutput:vt,exit:Nn,getArguments:Ln,getEnvironment:bn,getStderr:Sn,getStdin:fn,getStdout:Et,getTerminalStderr:Z0,getTerminalStdin:Pn,getTerminalStdout:tt}=J0,{Descriptor:a0,DirectoryEntryStream:z0,filesystemErrorCode:w0,getDirectories:It}=x0,{Error:v0,InputStream:Y0,OutputStream:ot}=K0,{now:qt}=y0,{getRandomBytes:bt}=Lt,{now:r0}=jt,X=function*(){let $,Q0;function ut(){let R=qt();return yt(R)}let et=[k0,0],P0=new Map,F=0;Yn[2]=et;function S(){let R=Sn();if(!(R instanceof ot))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var a=R[o0];if(!a){let d=R[M0]||++F;P0.set(d,R),a=gt(et,d)}return a}let H0=[k0,0],pt=new Map,lt=0;Yn[1]=H0;function d0(){let R=fn();if(!(R instanceof Y0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var a=R[o0];if(!a){let d=R[M0]||++lt;pt.set(d,R),a=gt(H0,d)}return a}function x(){let R=Et();if(!(R instanceof ot))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var a=R[o0];if(!a){let d=R[M0]||++F;P0.set(d,R),a=gt(et,d)}return a}function b0(R){let a;switch(R){case 0:{a={tag:"ok",val:void 0};break}case 1:{a={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}Nn(a)}let v,W,Rt;function mt(R){var d=bn(),c=d.length,m=Rt(0,0,4,c*16);for(let B=0;B<d.length;B++){let J=d[B],H=m+B*16;var[o,p]=J,s=ce(o,Rt,W),w=Xn;k(W).setInt32(H+4,w,!0),k(W).setInt32(H+0,s,!0);var O=ce(p,Rt,W),N=Xn;k(W).setInt32(H+12,N,!0),k(W).setInt32(H+8,O,!0)}k(W).setInt32(R+4,c,!0),k(W).setInt32(R+0,m,!0)}function Ct(R){var d=Ln(),c=d.length,m=Rt(0,0,4,c*8);for(let s=0;s<d.length;s++){let w=d[s],O=m+s*8;var o=ce(w,Rt,W),p=Xn;k(W).setInt32(O+4,p,!0),k(W).setInt32(O+0,o,!0)}k(W).setInt32(R+4,c,!0),k(W).setInt32(R+0,m,!0)}function U0(R){let a=r0();var{seconds:d,nanoseconds:c}=a;k(W).setBigInt64(R+0,yt(d),!0),k(W).setInt32(R+8,zn(c),!0)}let A0=[k0,0],l0=new Map,st=0;Yn[5]=A0;function Ot(R,a,d){var c=R,m=A0[(c<<1)+1]&~k0,o=l0.get(m);o||(o=Object.create(a0.prototype),Object.defineProperty(o,o0,{writable:!0,value:c}),Object.defineProperty(o,M0,{writable:!0,value:m})),i0.push(o);let p;try{p={tag:"ok",val:o.readViaStream(BigInt.asUintN(64,a))}}catch(N){p={tag:"err",val:Nt(N)}}for(let N of i0)N[o0]=null;i0=[];var s=p;switch(s.tag){case"ok":{let N=s.val;if(k(W).setInt8(d+0,0,!0),!(N instanceof Y0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var w=N[o0];if(!w){let B=N[M0]||++lt;pt.set(B,N),w=gt(H0,B)}k(W).setInt32(d+4,w,!0);break}case"err":{let N=s.val;k(W).setInt8(d+0,1,!0);var O=N;let B;switch(O){case"access":{B=0;break}case"would-block":{B=1;break}case"already":{B=2;break}case"bad-descriptor":{B=3;break}case"busy":{B=4;break}case"deadlock":{B=5;break}case"quota":{B=6;break}case"exist":{B=7;break}case"file-too-large":{B=8;break}case"illegal-byte-sequence":{B=9;break}case"in-progress":{B=10;break}case"interrupted":{B=11;break}case"invalid":{B=12;break}case"io":{B=13;break}case"is-directory":{B=14;break}case"loop":{B=15;break}case"too-many-links":{B=16;break}case"message-size":{B=17;break}case"name-too-long":{B=18;break}case"no-device":{B=19;break}case"no-entry":{B=20;break}case"no-lock":{B=21;break}case"insufficient-memory":{B=22;break}case"insufficient-space":{B=23;break}case"not-directory":{B=24;break}case"not-empty":{B=25;break}case"not-recoverable":{B=26;break}case"unsupported":{B=27;break}case"no-tty":{B=28;break}case"no-such-device":{B=29;break}case"overflow":{B=30;break}case"not-permitted":{B=31;break}case"pipe":{B=32;break}case"read-only":{B=33;break}case"invalid-seek":{B=34;break}case"text-file-busy":{B=35;break}case"cross-device":{B=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${O}" is not one of the cases of error-code`)}k(W).setInt8(d+4,B,!0);break}default:throw new TypeError("invalid variant specified for result")}}function hn(R,a,d){var c=R,m=A0[(c<<1)+1]&~k0,o=l0.get(m);o||(o=Object.create(a0.prototype),Object.defineProperty(o,o0,{writable:!0,value:c}),Object.defineProperty(o,M0,{writable:!0,value:m})),i0.push(o);let p;try{p={tag:"ok",val:o.writeViaStream(BigInt.asUintN(64,a))}}catch(N){p={tag:"err",val:Nt(N)}}for(let N of i0)N[o0]=null;i0=[];var s=p;switch(s.tag){case"ok":{let N=s.val;if(k(W).setInt8(d+0,0,!0),!(N instanceof ot))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var w=N[o0];if(!w){let B=N[M0]||++F;P0.set(B,N),w=gt(et,B)}k(W).setInt32(d+4,w,!0);break}case"err":{let N=s.val;k(W).setInt8(d+0,1,!0);var O=N;let B;switch(O){case"access":{B=0;break}case"would-block":{B=1;break}case"already":{B=2;break}case"bad-descriptor":{B=3;break}case"busy":{B=4;break}case"deadlock":{B=5;break}case"quota":{B=6;break}case"exist":{B=7;break}case"file-too-large":{B=8;break}case"illegal-byte-sequence":{B=9;break}case"in-progress":{B=10;break}case"interrupted":{B=11;break}case"invalid":{B=12;break}case"io":{B=13;break}case"is-directory":{B=14;break}case"loop":{B=15;break}case"too-many-links":{B=16;break}case"message-size":{B=17;break}case"name-too-long":{B=18;break}case"no-device":{B=19;break}case"no-entry":{B=20;break}case"no-lock":{B=21;break}case"insufficient-memory":{B=22;break}case"insufficient-space":{B=23;break}case"not-directory":{B=24;break}case"not-empty":{B=25;break}case"not-recoverable":{B=26;break}case"unsupported":{B=27;break}case"no-tty":{B=28;break}case"no-such-device":{B=29;break}case"overflow":{B=30;break}case"not-permitted":{B=31;break}case"pipe":{B=32;break}case"read-only":{B=33;break}case"invalid-seek":{B=34;break}case"text-file-busy":{B=35;break}case"cross-device":{B=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${O}" is not one of the cases of error-code`)}k(W).setInt8(d+4,B,!0);break}default:throw new TypeError("invalid variant specified for result")}}function gn(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.appendViaStream()}}catch(O){o={tag:"err",val:Nt(O)}}for(let O of i0)O[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let O=p.val;if(k(W).setInt8(a+0,0,!0),!(O instanceof ot))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var s=O[o0];if(!s){let N=O[M0]||++F;P0.set(N,O),s=gt(et,N)}k(W).setInt32(a+4,s,!0);break}case"err":{let O=p.val;k(W).setInt8(a+0,1,!0);var w=O;let N;switch(w){case"access":{N=0;break}case"would-block":{N=1;break}case"already":{N=2;break}case"bad-descriptor":{N=3;break}case"busy":{N=4;break}case"deadlock":{N=5;break}case"quota":{N=6;break}case"exist":{N=7;break}case"file-too-large":{N=8;break}case"illegal-byte-sequence":{N=9;break}case"in-progress":{N=10;break}case"interrupted":{N=11;break}case"invalid":{N=12;break}case"io":{N=13;break}case"is-directory":{N=14;break}case"loop":{N=15;break}case"too-many-links":{N=16;break}case"message-size":{N=17;break}case"name-too-long":{N=18;break}case"no-device":{N=19;break}case"no-entry":{N=20;break}case"no-lock":{N=21;break}case"insufficient-memory":{N=22;break}case"insufficient-space":{N=23;break}case"not-directory":{N=24;break}case"not-empty":{N=25;break}case"not-recoverable":{N=26;break}case"unsupported":{N=27;break}case"no-tty":{N=28;break}case"no-such-device":{N=29;break}case"overflow":{N=30;break}case"not-permitted":{N=31;break}case"pipe":{N=32;break}case"read-only":{N=33;break}case"invalid-seek":{N=34;break}case"text-file-busy":{N=35;break}case"cross-device":{N=36;break}default:throw O instanceof Error&&console.error(O),new TypeError(`"${w}" is not one of the cases of error-code`)}k(W).setInt8(a+4,N,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Bn(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.getFlags()}}catch(w){o={tag:"err",val:Nt(w)}}for(let w of i0)w[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let w=p.val;k(W).setInt8(a+0,0,!0);let O=0;if(typeof w=="object"&&w!==null)O=!!w.read<<0|!!w.write<<1|!!w.fileIntegritySync<<2|!!w.dataIntegritySync<<3|!!w.requestedWriteSync<<4|!!w.mutateDirectory<<5;else if(w!=null)throw new TypeError("only an object, undefined or null can be converted to flags");k(W).setInt8(a+1,O,!0);break}case"err":{let w=p.val;k(W).setInt8(a+0,1,!0);var s=w;let O;switch(s){case"access":{O=0;break}case"would-block":{O=1;break}case"already":{O=2;break}case"bad-descriptor":{O=3;break}case"busy":{O=4;break}case"deadlock":{O=5;break}case"quota":{O=6;break}case"exist":{O=7;break}case"file-too-large":{O=8;break}case"illegal-byte-sequence":{O=9;break}case"in-progress":{O=10;break}case"interrupted":{O=11;break}case"invalid":{O=12;break}case"io":{O=13;break}case"is-directory":{O=14;break}case"loop":{O=15;break}case"too-many-links":{O=16;break}case"message-size":{O=17;break}case"name-too-long":{O=18;break}case"no-device":{O=19;break}case"no-entry":{O=20;break}case"no-lock":{O=21;break}case"insufficient-memory":{O=22;break}case"insufficient-space":{O=23;break}case"not-directory":{O=24;break}case"not-empty":{O=25;break}case"not-recoverable":{O=26;break}case"unsupported":{O=27;break}case"no-tty":{O=28;break}case"no-such-device":{O=29;break}case"overflow":{O=30;break}case"not-permitted":{O=31;break}case"pipe":{O=32;break}case"read-only":{O=33;break}case"invalid-seek":{O=34;break}case"text-file-busy":{O=35;break}case"cross-device":{O=36;break}default:throw w instanceof Error&&console.error(w),new TypeError(`"${s}" is not one of the cases of error-code`)}k(W).setInt8(a+1,O,!0);break}default:throw new TypeError("invalid variant specified for result")}}function St(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.getType()}}catch(O){o={tag:"err",val:Nt(O)}}for(let O of i0)O[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let O=p.val;k(W).setInt8(a+0,0,!0);var s=O;let N;switch(s){case"unknown":{N=0;break}case"block-device":{N=1;break}case"character-device":{N=2;break}case"directory":{N=3;break}case"fifo":{N=4;break}case"symbolic-link":{N=5;break}case"regular-file":{N=6;break}case"socket":{N=7;break}default:throw O instanceof Error&&console.error(O),new TypeError(`"${s}" is not one of the cases of descriptor-type`)}k(W).setInt8(a+1,N,!0);break}case"err":{let O=p.val;k(W).setInt8(a+0,1,!0);var w=O;let N;switch(w){case"access":{N=0;break}case"would-block":{N=1;break}case"already":{N=2;break}case"bad-descriptor":{N=3;break}case"busy":{N=4;break}case"deadlock":{N=5;break}case"quota":{N=6;break}case"exist":{N=7;break}case"file-too-large":{N=8;break}case"illegal-byte-sequence":{N=9;break}case"in-progress":{N=10;break}case"interrupted":{N=11;break}case"invalid":{N=12;break}case"io":{N=13;break}case"is-directory":{N=14;break}case"loop":{N=15;break}case"too-many-links":{N=16;break}case"message-size":{N=17;break}case"name-too-long":{N=18;break}case"no-device":{N=19;break}case"no-entry":{N=20;break}case"no-lock":{N=21;break}case"insufficient-memory":{N=22;break}case"insufficient-space":{N=23;break}case"not-directory":{N=24;break}case"not-empty":{N=25;break}case"not-recoverable":{N=26;break}case"unsupported":{N=27;break}case"no-tty":{N=28;break}case"no-such-device":{N=29;break}case"overflow":{N=30;break}case"not-permitted":{N=31;break}case"pipe":{N=32;break}case"read-only":{N=33;break}case"invalid-seek":{N=34;break}case"text-file-busy":{N=35;break}case"cross-device":{N=36;break}default:throw O instanceof Error&&console.error(O),new TypeError(`"${w}" is not one of the cases of error-code`)}k(W).setInt8(a+1,N,!0);break}default:throw new TypeError("invalid variant specified for result")}}let ct=[k0,0],ft=new Map,Jt=0;Yn[6]=ct;function tn(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.readDirectory()}}catch(O){o={tag:"err",val:Nt(O)}}for(let O of i0)O[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let O=p.val;if(k(W).setInt8(a+0,0,!0),!(O instanceof z0))throw new TypeError('Resource error: Not a valid "DirectoryEntryStream" resource.');var s=O[o0];if(!s){let N=O[M0]||++Jt;ft.set(N,O),s=gt(ct,N)}k(W).setInt32(a+4,s,!0);break}case"err":{let O=p.val;k(W).setInt8(a+0,1,!0);var w=O;let N;switch(w){case"access":{N=0;break}case"would-block":{N=1;break}case"already":{N=2;break}case"bad-descriptor":{N=3;break}case"busy":{N=4;break}case"deadlock":{N=5;break}case"quota":{N=6;break}case"exist":{N=7;break}case"file-too-large":{N=8;break}case"illegal-byte-sequence":{N=9;break}case"in-progress":{N=10;break}case"interrupted":{N=11;break}case"invalid":{N=12;break}case"io":{N=13;break}case"is-directory":{N=14;break}case"loop":{N=15;break}case"too-many-links":{N=16;break}case"message-size":{N=17;break}case"name-too-long":{N=18;break}case"no-device":{N=19;break}case"no-entry":{N=20;break}case"no-lock":{N=21;break}case"insufficient-memory":{N=22;break}case"insufficient-space":{N=23;break}case"not-directory":{N=24;break}case"not-empty":{N=25;break}case"not-recoverable":{N=26;break}case"unsupported":{N=27;break}case"no-tty":{N=28;break}case"no-such-device":{N=29;break}case"overflow":{N=30;break}case"not-permitted":{N=31;break}case"pipe":{N=32;break}case"read-only":{N=33;break}case"invalid-seek":{N=34;break}case"text-file-busy":{N=35;break}case"cross-device":{N=36;break}default:throw O instanceof Error&&console.error(O),new TypeError(`"${w}" is not one of the cases of error-code`)}k(W).setInt8(a+4,N,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Yt(R,a,d,c){var m=R,o=A0[(m<<1)+1]&~k0,p=l0.get(o);p||(p=Object.create(a0.prototype),Object.defineProperty(p,o0,{writable:!0,value:m}),Object.defineProperty(p,M0,{writable:!0,value:o})),i0.push(p);var s=a,w=d,O=ie.decode(new Uint8Array(W.buffer,s,w));let N;try{N={tag:"ok",val:p.createDirectoryAt(O)}}catch(H){N={tag:"err",val:Nt(H)}}for(let H of i0)H[o0]=null;i0=[];var B=N;switch(B.tag){case"ok":{let H=B.val;k(W).setInt8(c+0,0,!0);break}case"err":{let H=B.val;k(W).setInt8(c+0,1,!0);var J=H;let g;switch(J){case"access":{g=0;break}case"would-block":{g=1;break}case"already":{g=2;break}case"bad-descriptor":{g=3;break}case"busy":{g=4;break}case"deadlock":{g=5;break}case"quota":{g=6;break}case"exist":{g=7;break}case"file-too-large":{g=8;break}case"illegal-byte-sequence":{g=9;break}case"in-progress":{g=10;break}case"interrupted":{g=11;break}case"invalid":{g=12;break}case"io":{g=13;break}case"is-directory":{g=14;break}case"loop":{g=15;break}case"too-many-links":{g=16;break}case"message-size":{g=17;break}case"name-too-long":{g=18;break}case"no-device":{g=19;break}case"no-entry":{g=20;break}case"no-lock":{g=21;break}case"insufficient-memory":{g=22;break}case"insufficient-space":{g=23;break}case"not-directory":{g=24;break}case"not-empty":{g=25;break}case"not-recoverable":{g=26;break}case"unsupported":{g=27;break}case"no-tty":{g=28;break}case"no-such-device":{g=29;break}case"overflow":{g=30;break}case"not-permitted":{g=31;break}case"pipe":{g=32;break}case"read-only":{g=33;break}case"invalid-seek":{g=34;break}case"text-file-busy":{g=35;break}case"cross-device":{g=36;break}default:throw H instanceof Error&&console.error(H),new TypeError(`"${J}" is not one of the cases of error-code`)}k(W).setInt8(c+1,g,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Gt(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.stat()}}catch(Zt){o={tag:"err",val:Nt(Zt)}}for(let Zt of i0)Zt[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let Zt=p.val;k(W).setInt8(a+0,0,!0);var{type:s,linkCount:w,size:O,dataAccessTimestamp:N,dataModificationTimestamp:B,statusChangeTimestamp:J}=Zt,H=s;let T0;switch(H){case"unknown":{T0=0;break}case"block-device":{T0=1;break}case"character-device":{T0=2;break}case"directory":{T0=3;break}case"fifo":{T0=4;break}case"symbolic-link":{T0=5;break}case"regular-file":{T0=6;break}case"socket":{T0=7;break}default:throw s instanceof Error&&console.error(s),new TypeError(`"${H}" is not one of the cases of descriptor-type`)}k(W).setInt8(a+8,T0,!0),k(W).setBigInt64(a+16,yt(w),!0),k(W).setBigInt64(a+24,yt(O),!0);var g=N;if(g==null)k(W).setInt8(a+32,0,!0);else{let wn=g;k(W).setInt8(a+32,1,!0);var{seconds:e0,nanoseconds:u0}=wn;k(W).setBigInt64(a+40,yt(e0),!0),k(W).setInt32(a+48,zn(u0),!0)}var _0=B;if(_0==null)k(W).setInt8(a+56,0,!0);else{let wn=_0;k(W).setInt8(a+56,1,!0);var{seconds:R0,nanoseconds:vn}=wn;k(W).setBigInt64(a+64,yt(R0),!0),k(W).setInt32(a+72,zn(vn),!0)}var X0=J;if(X0==null)k(W).setInt8(a+80,0,!0);else{let wn=X0;k(W).setInt8(a+80,1,!0);var{seconds:j,nanoseconds:Mn}=wn;k(W).setBigInt64(a+88,yt(j),!0),k(W).setInt32(a+96,zn(Mn),!0)}break}case"err":{let Zt=p.val;k(W).setInt8(a+0,1,!0);var Fn=Zt;let T0;switch(Fn){case"access":{T0=0;break}case"would-block":{T0=1;break}case"already":{T0=2;break}case"bad-descriptor":{T0=3;break}case"busy":{T0=4;break}case"deadlock":{T0=5;break}case"quota":{T0=6;break}case"exist":{T0=7;break}case"file-too-large":{T0=8;break}case"illegal-byte-sequence":{T0=9;break}case"in-progress":{T0=10;break}case"interrupted":{T0=11;break}case"invalid":{T0=12;break}case"io":{T0=13;break}case"is-directory":{T0=14;break}case"loop":{T0=15;break}case"too-many-links":{T0=16;break}case"message-size":{T0=17;break}case"name-too-long":{T0=18;break}case"no-device":{T0=19;break}case"no-entry":{T0=20;break}case"no-lock":{T0=21;break}case"insufficient-memory":{T0=22;break}case"insufficient-space":{T0=23;break}case"not-directory":{T0=24;break}case"not-empty":{T0=25;break}case"not-recoverable":{T0=26;break}case"unsupported":{T0=27;break}case"no-tty":{T0=28;break}case"no-such-device":{T0=29;break}case"overflow":{T0=30;break}case"not-permitted":{T0=31;break}case"pipe":{T0=32;break}case"read-only":{T0=33;break}case"invalid-seek":{T0=34;break}case"text-file-busy":{T0=35;break}case"cross-device":{T0=36;break}default:throw Zt instanceof Error&&console.error(Zt),new TypeError(`"${Fn}" is not one of the cases of error-code`)}k(W).setInt8(a+8,T0,!0);break}default:throw new TypeError("invalid variant specified for result")}}function dt(R,a,d,c,m){var o=R,p=A0[(o<<1)+1]&~k0,s=l0.get(p);if(s||(s=Object.create(a0.prototype),Object.defineProperty(s,o0,{writable:!0,value:o}),Object.defineProperty(s,M0,{writable:!0,value:p})),i0.push(s),(a&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var w={symlinkFollow:!!(a&1)},O=d,N=c,B=ie.decode(new Uint8Array(W.buffer,O,N));let J;try{J={tag:"ok",val:s.statAt(w,B)}}catch(kn){J={tag:"err",val:Nt(kn)}}for(let kn of i0)kn[o0]=null;i0=[];var H=J;switch(H.tag){case"ok":{let kn=H.val;k(W).setInt8(m+0,0,!0);var{type:g,linkCount:e0,size:u0,dataAccessTimestamp:_0,dataModificationTimestamp:R0,statusChangeTimestamp:vn}=kn,X0=g;let E0;switch(X0){case"unknown":{E0=0;break}case"block-device":{E0=1;break}case"character-device":{E0=2;break}case"directory":{E0=3;break}case"fifo":{E0=4;break}case"symbolic-link":{E0=5;break}case"regular-file":{E0=6;break}case"socket":{E0=7;break}default:throw g instanceof Error&&console.error(g),new TypeError(`"${X0}" is not one of the cases of descriptor-type`)}k(W).setInt8(m+8,E0,!0),k(W).setBigInt64(m+16,yt(e0),!0),k(W).setBigInt64(m+24,yt(u0),!0);var j=_0;if(j==null)k(W).setInt8(m+32,0,!0);else{let Re=j;k(W).setInt8(m+32,1,!0);var{seconds:Mn,nanoseconds:Fn}=Re;k(W).setBigInt64(m+40,yt(Mn),!0),k(W).setInt32(m+48,zn(Fn),!0)}var Zt=R0;if(Zt==null)k(W).setInt8(m+56,0,!0);else{let Re=Zt;k(W).setInt8(m+56,1,!0);var{seconds:T0,nanoseconds:wn}=Re;k(W).setBigInt64(m+64,yt(T0),!0),k(W).setInt32(m+72,zn(wn),!0)}var an=vn;if(an==null)k(W).setInt8(m+80,0,!0);else{let Re=an;k(W).setInt8(m+80,1,!0);var{seconds:c0,nanoseconds:Kn}=Re;k(W).setBigInt64(m+88,yt(c0),!0),k(W).setInt32(m+96,zn(Kn),!0)}break}case"err":{let kn=H.val;k(W).setInt8(m+0,1,!0);var je=kn;let E0;switch(je){case"access":{E0=0;break}case"would-block":{E0=1;break}case"already":{E0=2;break}case"bad-descriptor":{E0=3;break}case"busy":{E0=4;break}case"deadlock":{E0=5;break}case"quota":{E0=6;break}case"exist":{E0=7;break}case"file-too-large":{E0=8;break}case"illegal-byte-sequence":{E0=9;break}case"in-progress":{E0=10;break}case"interrupted":{E0=11;break}case"invalid":{E0=12;break}case"io":{E0=13;break}case"is-directory":{E0=14;break}case"loop":{E0=15;break}case"too-many-links":{E0=16;break}case"message-size":{E0=17;break}case"name-too-long":{E0=18;break}case"no-device":{E0=19;break}case"no-entry":{E0=20;break}case"no-lock":{E0=21;break}case"insufficient-memory":{E0=22;break}case"insufficient-space":{E0=23;break}case"not-directory":{E0=24;break}case"not-empty":{E0=25;break}case"not-recoverable":{E0=26;break}case"unsupported":{E0=27;break}case"no-tty":{E0=28;break}case"no-such-device":{E0=29;break}case"overflow":{E0=30;break}case"not-permitted":{E0=31;break}case"pipe":{E0=32;break}case"read-only":{E0=33;break}case"invalid-seek":{E0=34;break}case"text-file-busy":{E0=35;break}case"cross-device":{E0=36;break}default:throw kn instanceof Error&&console.error(kn),new TypeError(`"${je}" is not one of the cases of error-code`)}k(W).setInt8(m+8,E0,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Dt(R,a,d,c,m,o,p){var s=R,w=A0[(s<<1)+1]&~k0,O=l0.get(w);if(O||(O=Object.create(a0.prototype),Object.defineProperty(O,o0,{writable:!0,value:s}),Object.defineProperty(O,M0,{writable:!0,value:w})),i0.push(O),(a&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var N={symlinkFollow:!!(a&1)},B=d,J=c,H=ie.decode(new Uint8Array(W.buffer,B,J));if((m&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var g={create:!!(m&1),directory:!!(m&2),exclusive:!!(m&4),truncate:!!(m&8)};if((o&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var e0={read:!!(o&1),write:!!(o&2),fileIntegritySync:!!(o&4),dataIntegritySync:!!(o&8),requestedWriteSync:!!(o&16),mutateDirectory:!!(o&32)};let u0;try{u0={tag:"ok",val:O.openAt(N,H,g,e0)}}catch(X0){u0={tag:"err",val:Nt(X0)}}for(let X0 of i0)X0[o0]=null;i0=[];var _0=u0;switch(_0.tag){case"ok":{let X0=_0.val;if(k(W).setInt8(p+0,0,!0),!(X0 instanceof a0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var R0=X0[o0];if(!R0){let j=X0[M0]||++st;l0.set(j,X0),R0=gt(A0,j)}k(W).setInt32(p+4,R0,!0);break}case"err":{let X0=_0.val;k(W).setInt8(p+0,1,!0);var vn=X0;let j;switch(vn){case"access":{j=0;break}case"would-block":{j=1;break}case"already":{j=2;break}case"bad-descriptor":{j=3;break}case"busy":{j=4;break}case"deadlock":{j=5;break}case"quota":{j=6;break}case"exist":{j=7;break}case"file-too-large":{j=8;break}case"illegal-byte-sequence":{j=9;break}case"in-progress":{j=10;break}case"interrupted":{j=11;break}case"invalid":{j=12;break}case"io":{j=13;break}case"is-directory":{j=14;break}case"loop":{j=15;break}case"too-many-links":{j=16;break}case"message-size":{j=17;break}case"name-too-long":{j=18;break}case"no-device":{j=19;break}case"no-entry":{j=20;break}case"no-lock":{j=21;break}case"insufficient-memory":{j=22;break}case"insufficient-space":{j=23;break}case"not-directory":{j=24;break}case"not-empty":{j=25;break}case"not-recoverable":{j=26;break}case"unsupported":{j=27;break}case"no-tty":{j=28;break}case"no-such-device":{j=29;break}case"overflow":{j=30;break}case"not-permitted":{j=31;break}case"pipe":{j=32;break}case"read-only":{j=33;break}case"invalid-seek":{j=34;break}case"text-file-busy":{j=35;break}case"cross-device":{j=36;break}default:throw X0 instanceof Error&&console.error(X0),new TypeError(`"${vn}" is not one of the cases of error-code`)}k(W).setInt8(p+4,j,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Tt(R,a,d,c){var m=R,o=A0[(m<<1)+1]&~k0,p=l0.get(o);p||(p=Object.create(a0.prototype),Object.defineProperty(p,o0,{writable:!0,value:m}),Object.defineProperty(p,M0,{writable:!0,value:o})),i0.push(p);var s=a,w=d,O=ie.decode(new Uint8Array(W.buffer,s,w));let N;try{N={tag:"ok",val:p.removeDirectoryAt(O)}}catch(H){N={tag:"err",val:Nt(H)}}for(let H of i0)H[o0]=null;i0=[];var B=N;switch(B.tag){case"ok":{let H=B.val;k(W).setInt8(c+0,0,!0);break}case"err":{let H=B.val;k(W).setInt8(c+0,1,!0);var J=H;let g;switch(J){case"access":{g=0;break}case"would-block":{g=1;break}case"already":{g=2;break}case"bad-descriptor":{g=3;break}case"busy":{g=4;break}case"deadlock":{g=5;break}case"quota":{g=6;break}case"exist":{g=7;break}case"file-too-large":{g=8;break}case"illegal-byte-sequence":{g=9;break}case"in-progress":{g=10;break}case"interrupted":{g=11;break}case"invalid":{g=12;break}case"io":{g=13;break}case"is-directory":{g=14;break}case"loop":{g=15;break}case"too-many-links":{g=16;break}case"message-size":{g=17;break}case"name-too-long":{g=18;break}case"no-device":{g=19;break}case"no-entry":{g=20;break}case"no-lock":{g=21;break}case"insufficient-memory":{g=22;break}case"insufficient-space":{g=23;break}case"not-directory":{g=24;break}case"not-empty":{g=25;break}case"not-recoverable":{g=26;break}case"unsupported":{g=27;break}case"no-tty":{g=28;break}case"no-such-device":{g=29;break}case"overflow":{g=30;break}case"not-permitted":{g=31;break}case"pipe":{g=32;break}case"read-only":{g=33;break}case"invalid-seek":{g=34;break}case"text-file-busy":{g=35;break}case"cross-device":{g=36;break}default:throw H instanceof Error&&console.error(H),new TypeError(`"${J}" is not one of the cases of error-code`)}k(W).setInt8(c+1,g,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Mt(R,a,d,c){var m=R,o=A0[(m<<1)+1]&~k0,p=l0.get(o);p||(p=Object.create(a0.prototype),Object.defineProperty(p,o0,{writable:!0,value:m}),Object.defineProperty(p,M0,{writable:!0,value:o})),i0.push(p);var s=a,w=d,O=ie.decode(new Uint8Array(W.buffer,s,w));let N;try{N={tag:"ok",val:p.unlinkFileAt(O)}}catch(H){N={tag:"err",val:Nt(H)}}for(let H of i0)H[o0]=null;i0=[];var B=N;switch(B.tag){case"ok":{let H=B.val;k(W).setInt8(c+0,0,!0);break}case"err":{let H=B.val;k(W).setInt8(c+0,1,!0);var J=H;let g;switch(J){case"access":{g=0;break}case"would-block":{g=1;break}case"already":{g=2;break}case"bad-descriptor":{g=3;break}case"busy":{g=4;break}case"deadlock":{g=5;break}case"quota":{g=6;break}case"exist":{g=7;break}case"file-too-large":{g=8;break}case"illegal-byte-sequence":{g=9;break}case"in-progress":{g=10;break}case"interrupted":{g=11;break}case"invalid":{g=12;break}case"io":{g=13;break}case"is-directory":{g=14;break}case"loop":{g=15;break}case"too-many-links":{g=16;break}case"message-size":{g=17;break}case"name-too-long":{g=18;break}case"no-device":{g=19;break}case"no-entry":{g=20;break}case"no-lock":{g=21;break}case"insufficient-memory":{g=22;break}case"insufficient-space":{g=23;break}case"not-directory":{g=24;break}case"not-empty":{g=25;break}case"not-recoverable":{g=26;break}case"unsupported":{g=27;break}case"no-tty":{g=28;break}case"no-such-device":{g=29;break}case"overflow":{g=30;break}case"not-permitted":{g=31;break}case"pipe":{g=32;break}case"read-only":{g=33;break}case"invalid-seek":{g=34;break}case"text-file-busy":{g=35;break}case"cross-device":{g=36;break}default:throw H instanceof Error&&console.error(H),new TypeError(`"${J}" is not one of the cases of error-code`)}k(W).setInt8(c+1,g,!0);break}default:throw new TypeError("invalid variant specified for result")}}function zt(R,a){var d=R,c=A0[(d<<1)+1]&~k0,m=l0.get(c);m||(m=Object.create(a0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.metadataHash()}}catch(N){o={tag:"err",val:Nt(N)}}for(let N of i0)N[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let N=p.val;k(W).setInt8(a+0,0,!0);var{lower:s,upper:w}=N;k(W).setBigInt64(a+8,yt(s),!0),k(W).setBigInt64(a+16,yt(w),!0);break}case"err":{let N=p.val;k(W).setInt8(a+0,1,!0);var O=N;let B;switch(O){case"access":{B=0;break}case"would-block":{B=1;break}case"already":{B=2;break}case"bad-descriptor":{B=3;break}case"busy":{B=4;break}case"deadlock":{B=5;break}case"quota":{B=6;break}case"exist":{B=7;break}case"file-too-large":{B=8;break}case"illegal-byte-sequence":{B=9;break}case"in-progress":{B=10;break}case"interrupted":{B=11;break}case"invalid":{B=12;break}case"io":{B=13;break}case"is-directory":{B=14;break}case"loop":{B=15;break}case"too-many-links":{B=16;break}case"message-size":{B=17;break}case"name-too-long":{B=18;break}case"no-device":{B=19;break}case"no-entry":{B=20;break}case"no-lock":{B=21;break}case"insufficient-memory":{B=22;break}case"insufficient-space":{B=23;break}case"not-directory":{B=24;break}case"not-empty":{B=25;break}case"not-recoverable":{B=26;break}case"unsupported":{B=27;break}case"no-tty":{B=28;break}case"no-such-device":{B=29;break}case"overflow":{B=30;break}case"not-permitted":{B=31;break}case"pipe":{B=32;break}case"read-only":{B=33;break}case"invalid-seek":{B=34;break}case"text-file-busy":{B=35;break}case"cross-device":{B=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${O}" is not one of the cases of error-code`)}k(W).setInt8(a+8,B,!0);break}default:throw new TypeError("invalid variant specified for result")}}function nn(R,a,d,c,m){var o=R,p=A0[(o<<1)+1]&~k0,s=l0.get(p);if(s||(s=Object.create(a0.prototype),Object.defineProperty(s,o0,{writable:!0,value:o}),Object.defineProperty(s,M0,{writable:!0,value:p})),i0.push(s),(a&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var w={symlinkFollow:!!(a&1)},O=d,N=c,B=ie.decode(new Uint8Array(W.buffer,O,N));let J;try{J={tag:"ok",val:s.metadataHashAt(w,B)}}catch(_0){J={tag:"err",val:Nt(_0)}}for(let _0 of i0)_0[o0]=null;i0=[];var H=J;switch(H.tag){case"ok":{let _0=H.val;k(W).setInt8(m+0,0,!0);var{lower:g,upper:e0}=_0;k(W).setBigInt64(m+8,yt(g),!0),k(W).setBigInt64(m+16,yt(e0),!0);break}case"err":{let _0=H.val;k(W).setInt8(m+0,1,!0);var u0=_0;let R0;switch(u0){case"access":{R0=0;break}case"would-block":{R0=1;break}case"already":{R0=2;break}case"bad-descriptor":{R0=3;break}case"busy":{R0=4;break}case"deadlock":{R0=5;break}case"quota":{R0=6;break}case"exist":{R0=7;break}case"file-too-large":{R0=8;break}case"illegal-byte-sequence":{R0=9;break}case"in-progress":{R0=10;break}case"interrupted":{R0=11;break}case"invalid":{R0=12;break}case"io":{R0=13;break}case"is-directory":{R0=14;break}case"loop":{R0=15;break}case"too-many-links":{R0=16;break}case"message-size":{R0=17;break}case"name-too-long":{R0=18;break}case"no-device":{R0=19;break}case"no-entry":{R0=20;break}case"no-lock":{R0=21;break}case"insufficient-memory":{R0=22;break}case"insufficient-space":{R0=23;break}case"not-directory":{R0=24;break}case"not-empty":{R0=25;break}case"not-recoverable":{R0=26;break}case"unsupported":{R0=27;break}case"no-tty":{R0=28;break}case"no-such-device":{R0=29;break}case"overflow":{R0=30;break}case"not-permitted":{R0=31;break}case"pipe":{R0=32;break}case"read-only":{R0=33;break}case"invalid-seek":{R0=34;break}case"text-file-busy":{R0=35;break}case"cross-device":{R0=36;break}default:throw _0 instanceof Error&&console.error(_0),new TypeError(`"${u0}" is not one of the cases of error-code`)}k(W).setInt8(m+8,R0,!0);break}default:throw new TypeError("invalid variant specified for result")}}function un(R,a){var d=R,c=ct[(d<<1)+1]&~k0,m=ft.get(c);m||(m=Object.create(z0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.readDirectoryEntry()}}catch(g){o={tag:"err",val:Nt(g)}}for(let g of i0)g[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let g=p.val;k(W).setInt8(a+0,0,!0);var s=g;if(s==null)k(W).setInt8(a+4,0,!0);else{let e0=s;k(W).setInt8(a+4,1,!0);var{type:w,name:O}=e0,N=w;let u0;switch(N){case"unknown":{u0=0;break}case"block-device":{u0=1;break}case"character-device":{u0=2;break}case"directory":{u0=3;break}case"fifo":{u0=4;break}case"symbolic-link":{u0=5;break}case"regular-file":{u0=6;break}case"socket":{u0=7;break}default:throw w instanceof Error&&console.error(w),new TypeError(`"${N}" is not one of the cases of descriptor-type`)}k(W).setInt8(a+8,u0,!0);var B=ce(O,Rt,W),J=Xn;k(W).setInt32(a+16,J,!0),k(W).setInt32(a+12,B,!0)}break}case"err":{let g=p.val;k(W).setInt8(a+0,1,!0);var H=g;let e0;switch(H){case"access":{e0=0;break}case"would-block":{e0=1;break}case"already":{e0=2;break}case"bad-descriptor":{e0=3;break}case"busy":{e0=4;break}case"deadlock":{e0=5;break}case"quota":{e0=6;break}case"exist":{e0=7;break}case"file-too-large":{e0=8;break}case"illegal-byte-sequence":{e0=9;break}case"in-progress":{e0=10;break}case"interrupted":{e0=11;break}case"invalid":{e0=12;break}case"io":{e0=13;break}case"is-directory":{e0=14;break}case"loop":{e0=15;break}case"too-many-links":{e0=16;break}case"message-size":{e0=17;break}case"name-too-long":{e0=18;break}case"no-device":{e0=19;break}case"no-entry":{e0=20;break}case"no-lock":{e0=21;break}case"insufficient-memory":{e0=22;break}case"insufficient-space":{e0=23;break}case"not-directory":{e0=24;break}case"not-empty":{e0=25;break}case"not-recoverable":{e0=26;break}case"unsupported":{e0=27;break}case"no-tty":{e0=28;break}case"no-such-device":{e0=29;break}case"overflow":{e0=30;break}case"not-permitted":{e0=31;break}case"pipe":{e0=32;break}case"read-only":{e0=33;break}case"invalid-seek":{e0=34;break}case"text-file-busy":{e0=35;break}case"cross-device":{e0=36;break}default:throw g instanceof Error&&console.error(g),new TypeError(`"${H}" is not one of the cases of error-code`)}k(W).setInt8(a+4,e0,!0);break}default:throw new TypeError("invalid variant specified for result")}}let ht=[k0,0],At=new Map,Ht=0;Yn[0]=ht;function Hn(R,a){var d=R,c=ht[(d<<1)+1]&~k0,m=At.get(c);m||(m=Object.create(v0.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o=w0(m);for(let w of i0)w[o0]=null;i0=[];var p=o;if(p==null)k(W).setInt8(a+0,0,!0);else{let w=p;k(W).setInt8(a+0,1,!0);var s=w;let O;switch(s){case"access":{O=0;break}case"would-block":{O=1;break}case"already":{O=2;break}case"bad-descriptor":{O=3;break}case"busy":{O=4;break}case"deadlock":{O=5;break}case"quota":{O=6;break}case"exist":{O=7;break}case"file-too-large":{O=8;break}case"illegal-byte-sequence":{O=9;break}case"in-progress":{O=10;break}case"interrupted":{O=11;break}case"invalid":{O=12;break}case"io":{O=13;break}case"is-directory":{O=14;break}case"loop":{O=15;break}case"too-many-links":{O=16;break}case"message-size":{O=17;break}case"name-too-long":{O=18;break}case"no-device":{O=19;break}case"no-entry":{O=20;break}case"no-lock":{O=21;break}case"insufficient-memory":{O=22;break}case"insufficient-space":{O=23;break}case"not-directory":{O=24;break}case"not-empty":{O=25;break}case"not-recoverable":{O=26;break}case"unsupported":{O=27;break}case"no-tty":{O=28;break}case"no-such-device":{O=29;break}case"overflow":{O=30;break}case"not-permitted":{O=31;break}case"pipe":{O=32;break}case"read-only":{O=33;break}case"invalid-seek":{O=34;break}case"text-file-busy":{O=35;break}case"cross-device":{O=36;break}default:throw w instanceof Error&&console.error(w),new TypeError(`"${s}" is not one of the cases of error-code`)}k(W).setInt8(a+1,O,!0)}}function Wn(R,a,d){var c=R,m=H0[(c<<1)+1]&~k0,o=pt.get(m);o||(o=Object.create(Y0.prototype),Object.defineProperty(o,o0,{writable:!0,value:c}),Object.defineProperty(o,M0,{writable:!0,value:m})),i0.push(o);let p;try{p={tag:"ok",val:o.read(BigInt.asUintN(64,a))}}catch(g){p={tag:"err",val:Nt(g)}}for(let g of i0)g[o0]=null;i0=[];var s=p;switch(s.tag){case"ok":{let g=s.val;k(W).setInt8(d+0,0,!0);var w=g,O=w.byteLength,N=Rt(0,0,1,O*1),B=new Uint8Array(w.buffer||w,w.byteOffset,O*1);new Uint8Array(W.buffer,N,O*1).set(B),k(W).setInt32(d+8,O,!0),k(W).setInt32(d+4,N,!0);break}case"err":{let g=s.val;k(W).setInt8(d+0,1,!0);var J=g;switch(J.tag){case"last-operation-failed":{let e0=J.val;if(k(W).setInt8(d+4,0,!0),!(e0 instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var H=e0[o0];if(!H){let u0=e0[M0]||++Ht;At.set(u0,e0),H=gt(ht,u0)}k(W).setInt32(d+8,H,!0);break}case"closed":{k(W).setInt8(d+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(J.tag)}\` (received \`${J}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function en(R,a,d){var c=R,m=H0[(c<<1)+1]&~k0,o=pt.get(m);o||(o=Object.create(Y0.prototype),Object.defineProperty(o,o0,{writable:!0,value:c}),Object.defineProperty(o,M0,{writable:!0,value:m})),i0.push(o);let p;try{p={tag:"ok",val:o.blockingRead(BigInt.asUintN(64,a))}}catch(g){p={tag:"err",val:Nt(g)}}for(let g of i0)g[o0]=null;i0=[];var s=p;switch(s.tag){case"ok":{let g=s.val;k(W).setInt8(d+0,0,!0);var w=g,O=w.byteLength,N=Rt(0,0,1,O*1),B=new Uint8Array(w.buffer||w,w.byteOffset,O*1);new Uint8Array(W.buffer,N,O*1).set(B),k(W).setInt32(d+8,O,!0),k(W).setInt32(d+4,N,!0);break}case"err":{let g=s.val;k(W).setInt8(d+0,1,!0);var J=g;switch(J.tag){case"last-operation-failed":{let e0=J.val;if(k(W).setInt8(d+4,0,!0),!(e0 instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var H=e0[o0];if(!H){let u0=e0[M0]||++Ht;At.set(u0,e0),H=gt(ht,u0)}k(W).setInt32(d+8,H,!0);break}case"closed":{k(W).setInt8(d+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(J.tag)}\` (received \`${J}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function _n(R,a){var d=R,c=et[(d<<1)+1]&~k0,m=P0.get(c);m||(m=Object.create(ot.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.checkWrite()}}catch(O){o={tag:"err",val:Nt(O)}}for(let O of i0)O[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let O=p.val;k(W).setInt8(a+0,0,!0),k(W).setBigInt64(a+8,yt(O),!0);break}case"err":{let O=p.val;k(W).setInt8(a+0,1,!0);var s=O;switch(s.tag){case"last-operation-failed":{let N=s.val;if(k(W).setInt8(a+8,0,!0),!(N instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var w=N[o0];if(!w){let B=N[M0]||++Ht;At.set(B,N),w=gt(ht,B)}k(W).setInt32(a+12,w,!0);break}case"closed":{k(W).setInt8(a+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(s.tag)}\` (received \`${s}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Tn(R,a,d,c){var m=R,o=et[(m<<1)+1]&~k0,p=P0.get(o);p||(p=Object.create(ot.prototype),Object.defineProperty(p,o0,{writable:!0,value:m}),Object.defineProperty(p,M0,{writable:!0,value:o})),i0.push(p);var s=a,w=d,O=new Uint8Array(W.buffer.slice(s,s+w*1));let N;try{N={tag:"ok",val:p.write(O)}}catch(g){N={tag:"err",val:Nt(g)}}for(let g of i0)g[o0]=null;i0=[];var B=N;switch(B.tag){case"ok":{let g=B.val;k(W).setInt8(c+0,0,!0);break}case"err":{let g=B.val;k(W).setInt8(c+0,1,!0);var J=g;switch(J.tag){case"last-operation-failed":{let e0=J.val;if(k(W).setInt8(c+4,0,!0),!(e0 instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var H=e0[o0];if(!H){let u0=e0[M0]||++Ht;At.set(u0,e0),H=gt(ht,u0)}k(W).setInt32(c+8,H,!0);break}case"closed":{k(W).setInt8(c+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(J.tag)}\` (received \`${J}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function yn(R,a,d,c){var m=R,o=et[(m<<1)+1]&~k0,p=P0.get(o);p||(p=Object.create(ot.prototype),Object.defineProperty(p,o0,{writable:!0,value:m}),Object.defineProperty(p,M0,{writable:!0,value:o})),i0.push(p);var s=a,w=d,O=new Uint8Array(W.buffer.slice(s,s+w*1));let N;try{N={tag:"ok",val:p.blockingWriteAndFlush(O)}}catch(g){N={tag:"err",val:Nt(g)}}for(let g of i0)g[o0]=null;i0=[];var B=N;switch(B.tag){case"ok":{let g=B.val;k(W).setInt8(c+0,0,!0);break}case"err":{let g=B.val;k(W).setInt8(c+0,1,!0);var J=g;switch(J.tag){case"last-operation-failed":{let e0=J.val;if(k(W).setInt8(c+4,0,!0),!(e0 instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var H=e0[o0];if(!H){let u0=e0[M0]||++Ht;At.set(u0,e0),H=gt(ht,u0)}k(W).setInt32(c+8,H,!0);break}case"closed":{k(W).setInt8(c+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(J.tag)}\` (received \`${J}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function rn(R,a){var d=R,c=et[(d<<1)+1]&~k0,m=P0.get(c);m||(m=Object.create(ot.prototype),Object.defineProperty(m,o0,{writable:!0,value:d}),Object.defineProperty(m,M0,{writable:!0,value:c})),i0.push(m);let o;try{o={tag:"ok",val:m.blockingFlush()}}catch(O){o={tag:"err",val:Nt(O)}}for(let O of i0)O[o0]=null;i0=[];var p=o;switch(p.tag){case"ok":{let O=p.val;k(W).setInt8(a+0,0,!0);break}case"err":{let O=p.val;k(W).setInt8(a+0,1,!0);var s=O;switch(s.tag){case"last-operation-failed":{let N=s.val;if(k(W).setInt8(a+4,0,!0),!(N instanceof v0))throw new TypeError('Resource error: Not a valid "Error" resource.');var w=N[o0];if(!w){let B=N[M0]||++Ht;At.set(B,N),w=gt(ht,B)}k(W).setInt32(a+8,w,!0);break}case"closed":{k(W).setInt8(a+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(s.tag)}\` (received \`${s}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Xt(R,a){var c=bt(BigInt.asUintN(64,R)),m=c.byteLength,o=Rt(0,0,1,m*1),p=new Uint8Array(c.buffer||c,c.byteOffset,m*1);new Uint8Array(W.buffer,o,m*1).set(p),k(W).setInt32(a+4,m,!0),k(W).setInt32(a+0,o,!0)}function n0(R){var d=It(),c=d.length,m=Rt(0,0,4,c*12);for(let N=0;N<d.length;N++){let B=d[N],J=m+N*12;var[o,p]=B;if(!(o instanceof a0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var s=o[o0];if(!s){let H=o[M0]||++st;l0.set(H,o),s=gt(A0,H)}k(W).setInt32(J+0,s,!0);var w=ce(p,Rt,W),O=Xn;k(W).setInt32(J+8,O,!0),k(W).setInt32(J+4,w,!0)}k(W).setInt32(R+4,c,!0),k(W).setInt32(R+0,m,!0)}let Y=[k0,0],E=new Map,T=0;Yn[3]=Y;function A(R){var d=Pn();if(d==null)k(W).setInt8(R+0,0,!0);else{let m=d;if(k(W).setInt8(R+0,1,!0),!(m instanceof Pt))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var c=m[o0];if(!c){let o=m[M0]||++T;E.set(o,m),c=gt(Y,o)}k(W).setInt32(R+4,c,!0)}}let h=[k0,0],C=new Map,f=0;Yn[4]=h;function D(R){var d=tt();if(d==null)k(W).setInt8(R+0,0,!0);else{let m=d;if(k(W).setInt8(R+0,1,!0),!(m instanceof vt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var c=m[o0];if(!c){let o=m[M0]||++f;C.set(o,m),c=gt(h,o)}k(W).setInt32(R+4,c,!0)}}function _(R){var d=Z0();if(d==null)k(W).setInt8(R+0,0,!0);else{let m=d;if(k(W).setInt8(R+0,1,!0),!(m instanceof vt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var c=m[o0];if(!c){let o=m[M0]||++f;C.set(o,m),c=gt(h,o)}k(W).setInt32(R+4,c,!0)}}let r;function t(R){let a=Gn(ct,R);if(a.own){let d=ft.get(a.rep);d?(d[$t]&&d[$t](),ft.delete(a.rep)):z0[Vt]&&z0[Vt](a.rep)}}function e(R){let a=Gn(et,R);if(a.own){let d=P0.get(a.rep);d?(d[$t]&&d[$t](),P0.delete(a.rep)):ot[Vt]&&ot[Vt](a.rep)}}function I(R){let a=Gn(ht,R);if(a.own){let d=At.get(a.rep);d?(d[$t]&&d[$t](),At.delete(a.rep)):v0[Vt]&&v0[Vt](a.rep)}}function y(R){let a=Gn(H0,R);if(a.own){let d=pt.get(a.rep);d?(d[$t]&&d[$t](),pt.delete(a.rep)):Y0[Vt]&&Y0[Vt](a.rep)}}function U(R){let a=Gn(A0,R);if(a.own){let d=l0.get(a.rep);d?(d[$t]&&d[$t](),l0.delete(a.rep)):a0[Vt]&&a0[Vt](a.rep)}}function L(R){let a=Gn(Y,R);if(a.own){let d=E.get(a.rep);d?(d[$t]&&d[$t](),E.delete(a.rep)):Pt[Vt]&&Pt[Vt](a.rep)}}function i(R){let a=Gn(h,R);if(a.own){let d=C.get(a.rep);d?(d[$t]&&d[$t](),C.delete(a.rep)):vt[Vt]&&vt[Vt](a.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:$}=yield b(yield z),{exports:Q0}=yield b(yield M,{wasi_snapshot_preview1:{args_get:$[30],args_sizes_get:$[31],clock_time_get:$[34],environ_get:$[32],environ_sizes_get:$[33],fd_close:$[35],fd_fdstat_get:$[36],fd_fdstat_set_flags:$[37],fd_filestat_get:$[38],fd_prestat_dir_name:$[40],fd_prestat_get:$[39],fd_read:$[41],fd_readdir:$[42],fd_renumber:$[43],fd_seek:$[44],fd_write:$[45],path_create_directory:$[46],path_filestat_get:$[47],path_open:$[48],path_remove_directory:$[49],path_unlink_file:$[50],proc_exit:$[51],random_get:$[52]}}),{exports:v}=yield b(yield G,{__main_module__:{_start:Q0._start},env:{memory:Q0.memory},"wasi:cli/environment@0.2.0":{"get-arguments":$[1],"get-environment":$[0]},"wasi:cli/exit@0.2.0":{exit:b0},"wasi:cli/stderr@0.2.0":{"get-stderr":S},"wasi:cli/stdin@0.2.0":{"get-stdin":d0},"wasi:cli/stdout@0.2.0":{"get-stdout":x},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":L},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":i},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":$[29]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":$[27]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":$[28]},"wasi:clocks/monotonic-clock@0.2.0":{now:ut},"wasi:clocks/wall-clock@0.2.0":{now:$[2]},"wasi:filesystem/preopens@0.2.0":{"get-directories":$[26]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":$[5],"[method]descriptor.create-directory-at":$[9],"[method]descriptor.get-flags":$[6],"[method]descriptor.get-type":$[7],"[method]descriptor.metadata-hash":$[15],"[method]descriptor.metadata-hash-at":$[16],"[method]descriptor.open-at":$[12],"[method]descriptor.read-directory":$[8],"[method]descriptor.read-via-stream":$[3],"[method]descriptor.remove-directory-at":$[13],"[method]descriptor.stat":$[10],"[method]descriptor.stat-at":$[11],"[method]descriptor.unlink-file-at":$[14],"[method]descriptor.write-via-stream":$[4],"[method]directory-entry-stream.read-directory-entry":$[17],"[resource-drop]descriptor":U,"[resource-drop]directory-entry-stream":t,"filesystem-error-code":$[18]},"wasi:io/error@0.2.0":{"[resource-drop]error":I},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":$[20],"[method]input-stream.read":$[19],"[method]output-stream.blocking-flush":$[24],"[method]output-stream.blocking-write-and-flush":$[23],"[method]output-stream.check-write":$[21],"[method]output-stream.write":$[22],"[resource-drop]input-stream":y,"[resource-drop]output-stream":e},"wasi:random/random@0.2.0":{"get-random-bytes":$[25]}}),W=Q0.memory,Rt=v.cabi_import_realloc,{exports:r}=yield b(yield m0,{"":{$imports:$.$imports,0:mt,1:Ct,10:Gt,11:dt,12:Dt,13:Tt,14:Mt,15:zt,16:nn,17:un,18:Hn,19:Wn,2:U0,20:en,21:_n,22:Tn,23:yn,24:rn,25:Xt,26:n0,27:A,28:D,29:_,3:Ot,30:v.args_get,31:v.args_sizes_get,32:v.environ_get,33:v.environ_sizes_get,34:v.clock_time_get,35:v.fd_close,36:v.fd_fdstat_get,37:v.fd_fdstat_set_flags,38:v.fd_filestat_get,39:v.fd_prestat_get,4:hn,40:v.fd_prestat_dir_name,41:v.fd_read,42:v.fd_readdir,43:v.fd_renumber,44:v.fd_seek,45:v.fd_write,46:v.path_create_directory,47:v.path_filestat_get,48:v.path_open,49:v.path_remove_directory,5:gn,50:v.path_unlink_file,51:v.proc_exit,52:v.random_get,6:Bn,7:St,8:tn,9:Yt}});function u(){let R=v["wasi:cli/run@0.2.0#run"](),a;switch(R){case 0:{a={tag:"ok",val:void 0};break}case 1:{a={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(a.tag==="err")throw new J_(a.val);return a.val}let P={run:u};return{run:P,"wasi:cli/run@0.2.0":P}}(),S0,D0,f0;function s0(t0){try{let $;do({value:t0,done:$}=X.next(t0));while(!(t0 instanceof Promise)&&!$);if($)if(D0)D0(t0);else return t0;S0||(S0=new Promise((Q0,ut)=>(D0=Q0,f0=ut))),t0.then(Q0=>$?D0():s0(Q0),f0)}catch($){if(f0)f0($);else throw $}}let nt=s0(null);return S0||nt}var a_=new q_(()=>Promise.resolve().then(()=>(n_(),t_)),er,"yowasp-yosys"),u_=a_.run.bind(a_),_r={yosys:u_},rr="0.55.944";var $e={};de($e,{Exit:()=>Se,commands:()=>Kr,runIcebram:()=>B_,runIcemulti:()=>W_,runIcepack:()=>v_,runIcepll:()=>g_,runIceunpack:()=>M_,runNextpnrIce40:()=>H_,version:()=>Yr});var Ge;typeof process=="object"&&process.release?.name==="node"?Ge=async function(n,l){if(n.protocol==="file:"){let{readFile:b}=await import("fs/promises"),M="application/octet-stream";return n.pathname.endsWith(".wasm")&&(M="application/wasm"),new Response(await b(n),{headers:{"Content-Type":M}})}else return globalThis.fetch(n,l)}:Ge=globalThis.fetch;var b_=Ge,Se=class extends Error{constructor(n=0){super(`Exited with status ${n}`),this.code=n}};function sr(){return BigInt(Math.floor(performance.now()*1e6))}function or(){let n=Date.now(),l=BigInt(Math.floor(n/1e3)),b=n%1e3*1e6;return{seconds:l,nanoseconds:b}}var pr=class{constructor(n){if(BigInt(n)===0n)throw new Error("xoroshiro128** must be seeded with a non-zero state");this.s=[BigInt(n)&0xffffffffffffffffn,BigInt(n)>>64n&0xffffffffffffffffn]}next(){function n(z){return z&0xffffffffffffffffn}function l(z,m0){return z<<m0|z>>64n-m0}let[b,M]=this.s,G=n(l(b*5n,7n)*9n);return M^=b,b=n(l(b,24n)^M^M<<16n),M=n(l(M,37n)),this.s=[b,M],G}getBytes(n){return Uint8Array.from({length:n},()=>Number(BigInt.asUintN(8,this.next()>>32n)))}},Ir=class extends Error{},Qe=class{read(n){throw{tag:"closed"}}blockingRead(n){return this.read(n)}},Ve=class{checkWrite(){throw{tag:"closed"}}write(n){this.checkWrite()}flush(){}blockingFlush(){this.flush()}blockingWriteAndFlush(n){this.write(n),this.blockingFlush()}},ur=class extends Qe{constructor(n=null){super(),this.callback=n}read(n){if(this.callback===null)throw{tag:"closed"};let l=this.callback(Number(n));if(l===null)throw{tag:"closed"};return l}},l_=class extends Ve{constructor(n=null){super(),this.callback=n}checkWrite(){return 4096}write(n){this.callback!==null&&this.callback(n)}flush(){this.callback!==null&&this.callback(null)}},R_=class{},c_=class{},S_=function(){let n=0;return()=>n++}(),xn=class{constructor(n=""){if(this.id=S_(),n instanceof Uint8Array)this.data=n;else if(typeof n=="string")this.data=new TextEncoder().encode(n);else throw new Error(`Cannot construct a file from ${typeof n}`)}get size(){return this.data.length}},Wt=class ze{constructor(l={}){this.id=S_(),this.files=l}get size(){return Object.keys(this.files).length}traverse(l,{create:b=null,remove:M=!1}={}){let G=this,z=-1;do{if(G instanceof xn)throw"not-directory";let m0=G.files;z=l.indexOf("/");let J0=z===-1?l:l.substring(0,z);if(z===-1&&M)delete m0[J0];else if(!(J0===""||J0===".")){if(J0!=="..")if(Object.hasOwn(m0,J0))G=m0[J0];else if(b==="directory"||b!==null&&z!==-1)G=m0[J0]=new ze({});else if(b==="file")G=m0[J0]=new xn(new Uint8Array);else if(b instanceof xn||b instanceof ze)G=m0[J0]=b;else throw"no-entry"}l=l.substring(z+1)}while(z!==-1);return G}},Tr=class extends Qe{constructor(n,l){super(),this.file=n,this.offset=l}read(n){let l=this.file.data.subarray(Number(this.offset),Number(this.offset+n));return this.offset+=n,l}},Ar=class extends Ve{constructor(n,l){super(),this.file=n,this.offset=l}write(n){let l=Number(this.offset),b=new Uint8Array(Math.max(this.file.data.length,l+n.length));b.set(this.file.data),b.subarray(l).set(n),this.file.data=b,this.offset+=BigInt(n.length)}},d_=class be{constructor(l){this.entry=l}getType(){if(this.entry instanceof Wt)return"directory";if(this.entry instanceof xn)return"regular-file"}getFlags(){return{}}metadataHash(){return{upper:0,lower:this.entry.id}}metadataHashAt(l,b){if(!(this.entry instanceof Wt))throw"invalid";let M=this.entry.traverse(b);return new be(M).metadataHash()}stat(){let l;return this.entry instanceof Wt&&(l="directory"),this.entry instanceof xn&&(l="regular-file"),{type:l,linkCount:1,size:this.entry.size,dataAccessTimestamp:null,dataModificationTimestamp:null,statusChangeTimestamp:null}}statAt(l,b){if(!(this.entry instanceof Wt))throw"invalid";let M=this.entry.traverse(b);return new be(M).stat()}openAt(l,b,M,G){if(!(this.entry instanceof Wt))throw"invalid";let z=this.entry.traverse(b,M.create?{create:"file"}:{});if(M.directory){if(!(z instanceof Wt))throw"not-directory"}else{if(z instanceof Wt)throw"is-directory";M.truncate&&(z.data=new Uint8Array)}return new be(z)}read(l,b){if(this.entry instanceof Wt)throw"is-directory";return[l,b]=[Number(l),Number(b)],[this.entry.data.subarray(b,b+l),b+l>=this.entry.data.byteLength]}readViaStream(l){return new Tr(this.entry,l)}write(l,b){throw this.entry instanceof Wt?"is-directory":(console.error("Descriptor.write not implemented"),"unsupported")}writeViaStream(l){return new Ar(this.entry,l)}setSize(l){if(this.entry instanceof Wt)throw"is-directory";if(l=Number(l),l>this.entry.data.length){let b=new Uint8Array(l);b.set(this.entry.data),this.entry.data=b}else l<this.entry.data.length&&(this.entry.data=this.entry.data.subarray(0,l))}readDirectory(){return new f_(this.entry)}createDirectoryAt(l){this.entry.traverse(l,{create:"directory"})}unlinkFileAt(l){if(this.entry.traverse(l)instanceof Wt)throw"is-directory";this.entry.traverse(l,{remove:!0})}removeDirectoryAt(l){if(!(this.entry.traverse(l)instanceof Wt))throw"not-directory";this.entry.traverse(l,{remove:!0})}readlinkAt(l){let b=this.entry.traverse(l);throw"invalid"}renameAt(l,b,M){if(!(this.entry instanceof Wt)||!(b.entry instanceof Wt))throw"not-directory";let G=this.entry.traverse(l);this.entry.traverse(M,{create:G}),this.entry.traverse(l,{remove:!0})}},f_=class{constructor(n){this.entries=Object.entries(n.files),this.index=0}readDirectoryEntry(){if(this.index===this.entries.length)return null;let[n,l]=this.entries[this.index++],b;return l instanceof Wt&&(b="directory"),l instanceof xn&&(b="regular-file"),{name:n,type:b}}};function Xe(n){let l={};for(let[b,M]of Object.entries(n))typeof M=="string"||M instanceof Uint8Array?l[b]=new xn(n[b]):l[b]=Xe(n[b]);return new Wt(l)}function P_(n,{decodeASCII:l=!0}={}){function b(G){for(let z of G)if(z<32&&z!==9&&z!==10&&z!==13||z>=127)return!1;return!0}let M={};for(let[G,z]of Object.entries(n.files))z instanceof xn&&(M[G]=l&&b(z.data)?new TextDecoder().decode(z.data):z.data),z instanceof Wt&&(M[G]=P_(z,{decodeASCII:l}));return M}var lr=class{vars={};args=[];root=new Wt({});constructor(){this.prng=new pr(1n),this.standardInputStream=new ur,this.standardOutputStream=new l_,this.standardErrorStream=new l_,this.terminalInput=new R_,this.terminalOutput=new c_;let n=this;this.exports={monotonicClock:{now:sr},wallClock:{now:or},random:{getRandomBytes(l){return n.prng.getBytes(Number(l))}},io:{Error:Ir,InputStream:Qe,OutputStream:Ve},cli:{exit(l){throw new Se(l.tag==="ok"?0:1)},getEnvironment(){return n.vars},getArguments(){return n.args},getStdin(){return n.standardInputStream},getStdout(){return n.standardOutputStream},getStderr(){return n.standardErrorStream},getTerminalStdin(){return n.terminalInput},getTerminalStdout(){return n.terminalOutput},getTerminalStderr(){return n.terminalOutput},TerminalInput:R_,TerminalOutput:c_},fs:{Descriptor:d_,DirectoryEntryStream:f_,filesystemErrorCode(){},getDirectories(){return n.root===null?[]:[[new d_(n.root),"/"]]}}}}get stdin(){return this.standardInputStream.callback}set stdin(n){this.standardInputStream.callback=n}get stdout(){return this.standardOutputStream.callback}set stdout(n){this.standardOutputStream.callback=n}get stderr(){return this.standardErrorStream.callback}set stderr(n){this.standardErrorStream.callback=n}};function Rr(n){let l=new Uint8Array;return b=>{if(b===null)return;let M=new Uint8Array(l.length+b.length);M.set(l),M.set(b,l.length),l=M;let G=-1;for(;;){let z=l.indexOf(10,G+1);if(z===-1)break;n(new TextDecoder().decode(l.subarray(G+1,z))),G=z}l=l.subarray(G+1)}}async function Ze(n,l){let b=[];for(let[M,G]of Object.entries(n))typeof G=="string"||G instanceof Uint8Array?b.push(Promise.resolve([M,G])):G instanceof URL?b.push(l(G).then(z=>[M,z])):b.push(Ze(G,l).then(z=>[M,z]));for(let[M,G]of await Promise.all(b))n[M]=G;return n}function cr(n){return b_(n).then(WebAssembly.compileStreaming)}function dr(n){return b_(n).then(l=>l.arrayBuffer()).then(l=>new Uint8Array(l))}function Dr({modules:n,filesystem:l}){return Promise.all([Ze(n,cr),Ze(l,dr)]).then(([b,M])=>({modules:b,filesystem:M}))}var Ae=class{constructor(n,l,b){this.resources=n,this.resourceData=null,this.instantiate=l,this.argv0=b}run(n=null,l={},b={}){if(this.resourceData===null){if(b.synchronously)throw new Error("Cannot run application synchronously unless resources are prefetched first; use `await run()` to do so");return this.resources().then(Dr).then(x0=>(this.resourceData=x0,this.run(n,l,b)))}if(n===null)return;let M=new lr;M.args=[this.argv0].concat(n),M.root=Xe(l);for(let[x0,K0]of Object.entries(this.resourceData.filesystem))M.root.files[x0]=Xe(K0);let G=Rr(b.printLine??console.log);M.stdin=b.stdin===void 0?null:b.stdin,M.stdout=b.stdout===void 0?G:b.stdout,M.stderr=b.stderr===void 0?G:b.stderr;let z=x0=>{let K0=null;try{x0.run.run()}catch(y0){if(!(y0 instanceof Se))throw y0;y0 instanceof Se&&y0.code!==0&&(K0=y0)}for(let y0 of Object.keys(this.resourceData.filesystem))delete M.root.files[y0];if(l=P_(M.root,{decodeASCII:b.decodeASCII??!0}),K0!==null)throw K0.files=l,K0;return l},m0=x0=>this.resourceData.modules[x0],J0={runtime:M.exports};if(b.synchronously){let x0=(K0,y0)=>new WebAssembly.Instance(K0,y0);return z(this.instantiate(m0,J0,x0))}else return this.instantiate(m0,J0).then(z)}},Er=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},h0=[],He=new DataView(new ArrayBuffer),q=n=>He.buffer===n.buffer?He:He=new DataView(n.buffer);function sn(n){if(n&&mr.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var Qn=[],mr=Object.prototype.hasOwnProperty,_t=1<<30;function wt(n,l){let b=n[0]&~_t;return b===0?(n.push(0),n.push(l|_t),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|_t,b)}function Vn(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&_t)!==0,z=M&~_t;if(M===0||(b&_t)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|_t,n[0]=l|_t,{rep:z,scope:b,own:G}}var An=Symbol.for("cabiDispose"),C0=Symbol("handle"),V0=Symbol.for("cabiRep"),ln=Symbol.dispose||Symbol.for("dispose"),ae=n=>BigInt.asUintN(64,BigInt(n));function ye(n){return n>>>0}var Cr=new TextDecoder,Or=new TextEncoder,fe=0;function D_(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return fe=0,1;let M=Or.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),fe=M.length,G}function Nr(n,l,b=WebAssembly.instantiate){let M=n("icepll.core.wasm"),G=n("icepll.core2.wasm"),z=n("icepll.core3.wasm"),m0=n("icepll.core4.wasm"),{cli:J0,fs:x0,io:K0}=l.runtime,{TerminalInput:y0,TerminalOutput:Lt,exit:jt,getArguments:Pt,getStderr:vt,getStdin:Nn,getStdout:Ln,getTerminalStderr:bn,getTerminalStdin:Sn,getTerminalStdout:fn}=J0,{Descriptor:Et,filesystemErrorCode:Z0,getDirectories:Pn}=x0,{Error:tt,InputStream:a0,OutputStream:z0}=K0,w0=function*(){let r0,X,S0=[_t,0],D0=new Map,f0=0;Qn[2]=S0;function s0(){let n0=vt();if(!(n0 instanceof z0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var Y=n0[C0];if(!Y){let E=n0[V0]||++f0;D0.set(E,n0),Y=wt(S0,E)}return Y}let nt=[_t,0],t0=new Map,$=0;Qn[1]=nt;function Q0(){let n0=Nn();if(!(n0 instanceof a0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var Y=n0[C0];if(!Y){let E=n0[V0]||++$;t0.set(E,n0),Y=wt(nt,E)}return Y}function ut(){let n0=Ln();if(!(n0 instanceof z0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var Y=n0[C0];if(!Y){let E=n0[V0]||++f0;D0.set(E,n0),Y=wt(S0,E)}return Y}function et(n0){let Y;switch(n0){case 0:{Y={tag:"ok",val:void 0};break}case 1:{Y={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}jt(Y)}let P0,F,S;function H0(n0){var E=Pt(),T=E.length,A=S(0,0,4,T*8);for(let f=0;f<E.length;f++){let D=E[f],_=A+f*8;var h=D_(D,S,F),C=fe;q(F).setInt32(_+4,C,!0),q(F).setInt32(_+0,h,!0)}q(F).setInt32(n0+4,T,!0),q(F).setInt32(n0+0,A,!0)}let pt=[_t,0],lt=new Map,d0=0;Qn[5]=pt;function x(n0,Y,E){var T=n0,A=pt[(T<<1)+1]&~_t,h=lt.get(A);h||(h=Object.create(Et.prototype),Object.defineProperty(h,C0,{writable:!0,value:T}),Object.defineProperty(h,V0,{writable:!0,value:A})),h0.push(h);let C;try{C={tag:"ok",val:h.readViaStream(BigInt.asUintN(64,Y))}}catch(r){C={tag:"err",val:sn(r)}}for(let r of h0)r[C0]=null;h0=[];var f=C;switch(f.tag){case"ok":{let r=f.val;if(q(F).setInt8(E+0,0,!0),!(r instanceof a0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var D=r[C0];if(!D){let t=r[V0]||++$;t0.set(t,r),D=wt(nt,t)}q(F).setInt32(E+4,D,!0);break}case"err":{let r=f.val;q(F).setInt8(E+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}q(F).setInt8(E+4,t,!0);break}default:throw new TypeError("invalid variant specified for result")}}function b0(n0,Y,E){var T=n0,A=pt[(T<<1)+1]&~_t,h=lt.get(A);h||(h=Object.create(Et.prototype),Object.defineProperty(h,C0,{writable:!0,value:T}),Object.defineProperty(h,V0,{writable:!0,value:A})),h0.push(h);let C;try{C={tag:"ok",val:h.writeViaStream(BigInt.asUintN(64,Y))}}catch(r){C={tag:"err",val:sn(r)}}for(let r of h0)r[C0]=null;h0=[];var f=C;switch(f.tag){case"ok":{let r=f.val;if(q(F).setInt8(E+0,0,!0),!(r instanceof z0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var D=r[C0];if(!D){let t=r[V0]||++f0;D0.set(t,r),D=wt(S0,t)}q(F).setInt32(E+4,D,!0);break}case"err":{let r=f.val;q(F).setInt8(E+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}q(F).setInt8(E+4,t,!0);break}default:throw new TypeError("invalid variant specified for result")}}function v(n0,Y){var E=n0,T=pt[(E<<1)+1]&~_t,A=lt.get(T);A||(A=Object.create(Et.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.appendViaStream()}}catch(_){h={tag:"err",val:sn(_)}}for(let _ of h0)_[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let _=C.val;if(q(F).setInt8(Y+0,0,!0),!(_ instanceof z0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var f=_[C0];if(!f){let r=_[V0]||++f0;D0.set(r,_),f=wt(S0,r)}q(F).setInt32(Y+4,f,!0);break}case"err":{let _=C.val;q(F).setInt8(Y+0,1,!0);var D=_;let r;switch(D){case"access":{r=0;break}case"would-block":{r=1;break}case"already":{r=2;break}case"bad-descriptor":{r=3;break}case"busy":{r=4;break}case"deadlock":{r=5;break}case"quota":{r=6;break}case"exist":{r=7;break}case"file-too-large":{r=8;break}case"illegal-byte-sequence":{r=9;break}case"in-progress":{r=10;break}case"interrupted":{r=11;break}case"invalid":{r=12;break}case"io":{r=13;break}case"is-directory":{r=14;break}case"loop":{r=15;break}case"too-many-links":{r=16;break}case"message-size":{r=17;break}case"name-too-long":{r=18;break}case"no-device":{r=19;break}case"no-entry":{r=20;break}case"no-lock":{r=21;break}case"insufficient-memory":{r=22;break}case"insufficient-space":{r=23;break}case"not-directory":{r=24;break}case"not-empty":{r=25;break}case"not-recoverable":{r=26;break}case"unsupported":{r=27;break}case"no-tty":{r=28;break}case"no-such-device":{r=29;break}case"overflow":{r=30;break}case"not-permitted":{r=31;break}case"pipe":{r=32;break}case"read-only":{r=33;break}case"invalid-seek":{r=34;break}case"text-file-busy":{r=35;break}case"cross-device":{r=36;break}default:throw _ instanceof Error&&console.error(_),new TypeError(`"${D}" is not one of the cases of error-code`)}q(F).setInt8(Y+4,r,!0);break}default:throw new TypeError("invalid variant specified for result")}}function W(n0,Y){var E=n0,T=pt[(E<<1)+1]&~_t,A=lt.get(T);A||(A=Object.create(Et.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.getFlags()}}catch(D){h={tag:"err",val:sn(D)}}for(let D of h0)D[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let D=C.val;q(F).setInt8(Y+0,0,!0);let _=0;if(typeof D=="object"&&D!==null)_=!!D.read<<0|!!D.write<<1|!!D.fileIntegritySync<<2|!!D.dataIntegritySync<<3|!!D.requestedWriteSync<<4|!!D.mutateDirectory<<5;else if(D!=null)throw new TypeError("only an object, undefined or null can be converted to flags");q(F).setInt8(Y+1,_,!0);break}case"err":{let D=C.val;q(F).setInt8(Y+0,1,!0);var f=D;let _;switch(f){case"access":{_=0;break}case"would-block":{_=1;break}case"already":{_=2;break}case"bad-descriptor":{_=3;break}case"busy":{_=4;break}case"deadlock":{_=5;break}case"quota":{_=6;break}case"exist":{_=7;break}case"file-too-large":{_=8;break}case"illegal-byte-sequence":{_=9;break}case"in-progress":{_=10;break}case"interrupted":{_=11;break}case"invalid":{_=12;break}case"io":{_=13;break}case"is-directory":{_=14;break}case"loop":{_=15;break}case"too-many-links":{_=16;break}case"message-size":{_=17;break}case"name-too-long":{_=18;break}case"no-device":{_=19;break}case"no-entry":{_=20;break}case"no-lock":{_=21;break}case"insufficient-memory":{_=22;break}case"insufficient-space":{_=23;break}case"not-directory":{_=24;break}case"not-empty":{_=25;break}case"not-recoverable":{_=26;break}case"unsupported":{_=27;break}case"no-tty":{_=28;break}case"no-such-device":{_=29;break}case"overflow":{_=30;break}case"not-permitted":{_=31;break}case"pipe":{_=32;break}case"read-only":{_=33;break}case"invalid-seek":{_=34;break}case"text-file-busy":{_=35;break}case"cross-device":{_=36;break}default:throw D instanceof Error&&console.error(D),new TypeError(`"${f}" is not one of the cases of error-code`)}q(F).setInt8(Y+1,_,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Rt(n0,Y){var E=n0,T=pt[(E<<1)+1]&~_t,A=lt.get(T);A||(A=Object.create(Et.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.getType()}}catch(_){h={tag:"err",val:sn(_)}}for(let _ of h0)_[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let _=C.val;q(F).setInt8(Y+0,0,!0);var f=_;let r;switch(f){case"unknown":{r=0;break}case"block-device":{r=1;break}case"character-device":{r=2;break}case"directory":{r=3;break}case"fifo":{r=4;break}case"symbolic-link":{r=5;break}case"regular-file":{r=6;break}case"socket":{r=7;break}default:throw _ instanceof Error&&console.error(_),new TypeError(`"${f}" is not one of the cases of descriptor-type`)}q(F).setInt8(Y+1,r,!0);break}case"err":{let _=C.val;q(F).setInt8(Y+0,1,!0);var D=_;let r;switch(D){case"access":{r=0;break}case"would-block":{r=1;break}case"already":{r=2;break}case"bad-descriptor":{r=3;break}case"busy":{r=4;break}case"deadlock":{r=5;break}case"quota":{r=6;break}case"exist":{r=7;break}case"file-too-large":{r=8;break}case"illegal-byte-sequence":{r=9;break}case"in-progress":{r=10;break}case"interrupted":{r=11;break}case"invalid":{r=12;break}case"io":{r=13;break}case"is-directory":{r=14;break}case"loop":{r=15;break}case"too-many-links":{r=16;break}case"message-size":{r=17;break}case"name-too-long":{r=18;break}case"no-device":{r=19;break}case"no-entry":{r=20;break}case"no-lock":{r=21;break}case"insufficient-memory":{r=22;break}case"insufficient-space":{r=23;break}case"not-directory":{r=24;break}case"not-empty":{r=25;break}case"not-recoverable":{r=26;break}case"unsupported":{r=27;break}case"no-tty":{r=28;break}case"no-such-device":{r=29;break}case"overflow":{r=30;break}case"not-permitted":{r=31;break}case"pipe":{r=32;break}case"read-only":{r=33;break}case"invalid-seek":{r=34;break}case"text-file-busy":{r=35;break}case"cross-device":{r=36;break}default:throw _ instanceof Error&&console.error(_),new TypeError(`"${D}" is not one of the cases of error-code`)}q(F).setInt8(Y+1,r,!0);break}default:throw new TypeError("invalid variant specified for result")}}function mt(n0,Y){var E=n0,T=pt[(E<<1)+1]&~_t,A=lt.get(T);A||(A=Object.create(Et.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.stat()}}catch(m){h={tag:"err",val:sn(m)}}for(let m of h0)m[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let m=C.val;q(F).setInt8(Y+0,0,!0);var{type:f,linkCount:D,size:_,dataAccessTimestamp:r,dataModificationTimestamp:t,statusChangeTimestamp:e}=m,I=f;let o;switch(I){case"unknown":{o=0;break}case"block-device":{o=1;break}case"character-device":{o=2;break}case"directory":{o=3;break}case"fifo":{o=4;break}case"symbolic-link":{o=5;break}case"regular-file":{o=6;break}case"socket":{o=7;break}default:throw f instanceof Error&&console.error(f),new TypeError(`"${I}" is not one of the cases of descriptor-type`)}q(F).setInt8(Y+8,o,!0),q(F).setBigInt64(Y+16,ae(D),!0),q(F).setBigInt64(Y+24,ae(_),!0);var y=r;if(y==null)q(F).setInt8(Y+32,0,!0);else{let p=y;q(F).setInt8(Y+32,1,!0);var{seconds:U,nanoseconds:L}=p;q(F).setBigInt64(Y+40,ae(U),!0),q(F).setInt32(Y+48,ye(L),!0)}var i=t;if(i==null)q(F).setInt8(Y+56,0,!0);else{let p=i;q(F).setInt8(Y+56,1,!0);var{seconds:u,nanoseconds:P}=p;q(F).setBigInt64(Y+64,ae(u),!0),q(F).setInt32(Y+72,ye(P),!0)}var R=e;if(R==null)q(F).setInt8(Y+80,0,!0);else{let p=R;q(F).setInt8(Y+80,1,!0);var{seconds:a,nanoseconds:d}=p;q(F).setBigInt64(Y+88,ae(a),!0),q(F).setInt32(Y+96,ye(d),!0)}break}case"err":{let m=C.val;q(F).setInt8(Y+0,1,!0);var c=m;let o;switch(c){case"access":{o=0;break}case"would-block":{o=1;break}case"already":{o=2;break}case"bad-descriptor":{o=3;break}case"busy":{o=4;break}case"deadlock":{o=5;break}case"quota":{o=6;break}case"exist":{o=7;break}case"file-too-large":{o=8;break}case"illegal-byte-sequence":{o=9;break}case"in-progress":{o=10;break}case"interrupted":{o=11;break}case"invalid":{o=12;break}case"io":{o=13;break}case"is-directory":{o=14;break}case"loop":{o=15;break}case"too-many-links":{o=16;break}case"message-size":{o=17;break}case"name-too-long":{o=18;break}case"no-device":{o=19;break}case"no-entry":{o=20;break}case"no-lock":{o=21;break}case"insufficient-memory":{o=22;break}case"insufficient-space":{o=23;break}case"not-directory":{o=24;break}case"not-empty":{o=25;break}case"not-recoverable":{o=26;break}case"unsupported":{o=27;break}case"no-tty":{o=28;break}case"no-such-device":{o=29;break}case"overflow":{o=30;break}case"not-permitted":{o=31;break}case"pipe":{o=32;break}case"read-only":{o=33;break}case"invalid-seek":{o=34;break}case"text-file-busy":{o=35;break}case"cross-device":{o=36;break}default:throw m instanceof Error&&console.error(m),new TypeError(`"${c}" is not one of the cases of error-code`)}q(F).setInt8(Y+8,o,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ct(n0,Y,E,T,A,h,C){var f=n0,D=pt[(f<<1)+1]&~_t,_=lt.get(D);if(_||(_=Object.create(Et.prototype),Object.defineProperty(_,C0,{writable:!0,value:f}),Object.defineProperty(_,V0,{writable:!0,value:D})),h0.push(_),(Y&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var r={symlinkFollow:!!(Y&1)},t=E,e=T,I=Cr.decode(new Uint8Array(F.buffer,t,e));if((A&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var y={create:!!(A&1),directory:!!(A&2),exclusive:!!(A&4),truncate:!!(A&8)};if((h&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var U={read:!!(h&1),write:!!(h&2),fileIntegritySync:!!(h&4),dataIntegritySync:!!(h&8),requestedWriteSync:!!(h&16),mutateDirectory:!!(h&32)};let L;try{L={tag:"ok",val:_.openAt(r,I,y,U)}}catch(R){L={tag:"err",val:sn(R)}}for(let R of h0)R[C0]=null;h0=[];var i=L;switch(i.tag){case"ok":{let R=i.val;if(q(F).setInt8(C+0,0,!0),!(R instanceof Et))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var u=R[C0];if(!u){let a=R[V0]||++d0;lt.set(a,R),u=wt(pt,a)}q(F).setInt32(C+4,u,!0);break}case"err":{let R=i.val;q(F).setInt8(C+0,1,!0);var P=R;let a;switch(P){case"access":{a=0;break}case"would-block":{a=1;break}case"already":{a=2;break}case"bad-descriptor":{a=3;break}case"busy":{a=4;break}case"deadlock":{a=5;break}case"quota":{a=6;break}case"exist":{a=7;break}case"file-too-large":{a=8;break}case"illegal-byte-sequence":{a=9;break}case"in-progress":{a=10;break}case"interrupted":{a=11;break}case"invalid":{a=12;break}case"io":{a=13;break}case"is-directory":{a=14;break}case"loop":{a=15;break}case"too-many-links":{a=16;break}case"message-size":{a=17;break}case"name-too-long":{a=18;break}case"no-device":{a=19;break}case"no-entry":{a=20;break}case"no-lock":{a=21;break}case"insufficient-memory":{a=22;break}case"insufficient-space":{a=23;break}case"not-directory":{a=24;break}case"not-empty":{a=25;break}case"not-recoverable":{a=26;break}case"unsupported":{a=27;break}case"no-tty":{a=28;break}case"no-such-device":{a=29;break}case"overflow":{a=30;break}case"not-permitted":{a=31;break}case"pipe":{a=32;break}case"read-only":{a=33;break}case"invalid-seek":{a=34;break}case"text-file-busy":{a=35;break}case"cross-device":{a=36;break}default:throw R instanceof Error&&console.error(R),new TypeError(`"${P}" is not one of the cases of error-code`)}q(F).setInt8(C+4,a,!0);break}default:throw new TypeError("invalid variant specified for result")}}let U0=[_t,0],A0=new Map,l0=0;Qn[0]=U0;function st(n0,Y){var E=n0,T=U0[(E<<1)+1]&~_t,A=A0.get(T);A||(A=Object.create(tt.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h=Z0(A);for(let D of h0)D[C0]=null;h0=[];var C=h;if(C==null)q(F).setInt8(Y+0,0,!0);else{let D=C;q(F).setInt8(Y+0,1,!0);var f=D;let _;switch(f){case"access":{_=0;break}case"would-block":{_=1;break}case"already":{_=2;break}case"bad-descriptor":{_=3;break}case"busy":{_=4;break}case"deadlock":{_=5;break}case"quota":{_=6;break}case"exist":{_=7;break}case"file-too-large":{_=8;break}case"illegal-byte-sequence":{_=9;break}case"in-progress":{_=10;break}case"interrupted":{_=11;break}case"invalid":{_=12;break}case"io":{_=13;break}case"is-directory":{_=14;break}case"loop":{_=15;break}case"too-many-links":{_=16;break}case"message-size":{_=17;break}case"name-too-long":{_=18;break}case"no-device":{_=19;break}case"no-entry":{_=20;break}case"no-lock":{_=21;break}case"insufficient-memory":{_=22;break}case"insufficient-space":{_=23;break}case"not-directory":{_=24;break}case"not-empty":{_=25;break}case"not-recoverable":{_=26;break}case"unsupported":{_=27;break}case"no-tty":{_=28;break}case"no-such-device":{_=29;break}case"overflow":{_=30;break}case"not-permitted":{_=31;break}case"pipe":{_=32;break}case"read-only":{_=33;break}case"invalid-seek":{_=34;break}case"text-file-busy":{_=35;break}case"cross-device":{_=36;break}default:throw D instanceof Error&&console.error(D),new TypeError(`"${f}" is not one of the cases of error-code`)}q(F).setInt8(Y+1,_,!0)}}function Ot(n0,Y,E){var T=n0,A=nt[(T<<1)+1]&~_t,h=t0.get(A);h||(h=Object.create(a0.prototype),Object.defineProperty(h,C0,{writable:!0,value:T}),Object.defineProperty(h,V0,{writable:!0,value:A})),h0.push(h);let C;try{C={tag:"ok",val:h.read(BigInt.asUintN(64,Y))}}catch(y){C={tag:"err",val:sn(y)}}for(let y of h0)y[C0]=null;h0=[];var f=C;switch(f.tag){case"ok":{let y=f.val;q(F).setInt8(E+0,0,!0);var D=y,_=D.byteLength,r=S(0,0,1,_*1),t=new Uint8Array(D.buffer||D,D.byteOffset,_*1);new Uint8Array(F.buffer,r,_*1).set(t),q(F).setInt32(E+8,_,!0),q(F).setInt32(E+4,r,!0);break}case"err":{let y=f.val;q(F).setInt8(E+0,1,!0);var e=y;switch(e.tag){case"last-operation-failed":{let U=e.val;if(q(F).setInt8(E+4,0,!0),!(U instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var I=U[C0];if(!I){let L=U[V0]||++l0;A0.set(L,U),I=wt(U0,L)}q(F).setInt32(E+8,I,!0);break}case"closed":{q(F).setInt8(E+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(e.tag)}\` (received \`${e}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function hn(n0,Y,E){var T=n0,A=nt[(T<<1)+1]&~_t,h=t0.get(A);h||(h=Object.create(a0.prototype),Object.defineProperty(h,C0,{writable:!0,value:T}),Object.defineProperty(h,V0,{writable:!0,value:A})),h0.push(h);let C;try{C={tag:"ok",val:h.blockingRead(BigInt.asUintN(64,Y))}}catch(y){C={tag:"err",val:sn(y)}}for(let y of h0)y[C0]=null;h0=[];var f=C;switch(f.tag){case"ok":{let y=f.val;q(F).setInt8(E+0,0,!0);var D=y,_=D.byteLength,r=S(0,0,1,_*1),t=new Uint8Array(D.buffer||D,D.byteOffset,_*1);new Uint8Array(F.buffer,r,_*1).set(t),q(F).setInt32(E+8,_,!0),q(F).setInt32(E+4,r,!0);break}case"err":{let y=f.val;q(F).setInt8(E+0,1,!0);var e=y;switch(e.tag){case"last-operation-failed":{let U=e.val;if(q(F).setInt8(E+4,0,!0),!(U instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var I=U[C0];if(!I){let L=U[V0]||++l0;A0.set(L,U),I=wt(U0,L)}q(F).setInt32(E+8,I,!0);break}case"closed":{q(F).setInt8(E+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(e.tag)}\` (received \`${e}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function gn(n0,Y){var E=n0,T=S0[(E<<1)+1]&~_t,A=D0.get(T);A||(A=Object.create(z0.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.checkWrite()}}catch(_){h={tag:"err",val:sn(_)}}for(let _ of h0)_[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let _=C.val;q(F).setInt8(Y+0,0,!0),q(F).setBigInt64(Y+8,ae(_),!0);break}case"err":{let _=C.val;q(F).setInt8(Y+0,1,!0);var f=_;switch(f.tag){case"last-operation-failed":{let r=f.val;if(q(F).setInt8(Y+8,0,!0),!(r instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var D=r[C0];if(!D){let t=r[V0]||++l0;A0.set(t,r),D=wt(U0,t)}q(F).setInt32(Y+12,D,!0);break}case"closed":{q(F).setInt8(Y+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(f.tag)}\` (received \`${f}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Bn(n0,Y,E,T){var A=n0,h=S0[(A<<1)+1]&~_t,C=D0.get(h);C||(C=Object.create(z0.prototype),Object.defineProperty(C,C0,{writable:!0,value:A}),Object.defineProperty(C,V0,{writable:!0,value:h})),h0.push(C);var f=Y,D=E,_=new Uint8Array(F.buffer.slice(f,f+D*1));let r;try{r={tag:"ok",val:C.write(_)}}catch(y){r={tag:"err",val:sn(y)}}for(let y of h0)y[C0]=null;h0=[];var t=r;switch(t.tag){case"ok":{let y=t.val;q(F).setInt8(T+0,0,!0);break}case"err":{let y=t.val;q(F).setInt8(T+0,1,!0);var e=y;switch(e.tag){case"last-operation-failed":{let U=e.val;if(q(F).setInt8(T+4,0,!0),!(U instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var I=U[C0];if(!I){let L=U[V0]||++l0;A0.set(L,U),I=wt(U0,L)}q(F).setInt32(T+8,I,!0);break}case"closed":{q(F).setInt8(T+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(e.tag)}\` (received \`${e}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function St(n0,Y,E,T){var A=n0,h=S0[(A<<1)+1]&~_t,C=D0.get(h);C||(C=Object.create(z0.prototype),Object.defineProperty(C,C0,{writable:!0,value:A}),Object.defineProperty(C,V0,{writable:!0,value:h})),h0.push(C);var f=Y,D=E,_=new Uint8Array(F.buffer.slice(f,f+D*1));let r;try{r={tag:"ok",val:C.blockingWriteAndFlush(_)}}catch(y){r={tag:"err",val:sn(y)}}for(let y of h0)y[C0]=null;h0=[];var t=r;switch(t.tag){case"ok":{let y=t.val;q(F).setInt8(T+0,0,!0);break}case"err":{let y=t.val;q(F).setInt8(T+0,1,!0);var e=y;switch(e.tag){case"last-operation-failed":{let U=e.val;if(q(F).setInt8(T+4,0,!0),!(U instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var I=U[C0];if(!I){let L=U[V0]||++l0;A0.set(L,U),I=wt(U0,L)}q(F).setInt32(T+8,I,!0);break}case"closed":{q(F).setInt8(T+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(e.tag)}\` (received \`${e}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ct(n0,Y){var E=n0,T=S0[(E<<1)+1]&~_t,A=D0.get(T);A||(A=Object.create(z0.prototype),Object.defineProperty(A,C0,{writable:!0,value:E}),Object.defineProperty(A,V0,{writable:!0,value:T})),h0.push(A);let h;try{h={tag:"ok",val:A.blockingFlush()}}catch(_){h={tag:"err",val:sn(_)}}for(let _ of h0)_[C0]=null;h0=[];var C=h;switch(C.tag){case"ok":{let _=C.val;q(F).setInt8(Y+0,0,!0);break}case"err":{let _=C.val;q(F).setInt8(Y+0,1,!0);var f=_;switch(f.tag){case"last-operation-failed":{let r=f.val;if(q(F).setInt8(Y+4,0,!0),!(r instanceof tt))throw new TypeError('Resource error: Not a valid "Error" resource.');var D=r[C0];if(!D){let t=r[V0]||++l0;A0.set(t,r),D=wt(U0,t)}q(F).setInt32(Y+8,D,!0);break}case"closed":{q(F).setInt8(Y+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(f.tag)}\` (received \`${f}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ft(n0){var E=Pn(),T=E.length,A=S(0,0,4,T*12);for(let r=0;r<E.length;r++){let t=E[r],e=A+r*12;var[h,C]=t;if(!(h instanceof Et))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var f=h[C0];if(!f){let I=h[V0]||++d0;lt.set(I,h),f=wt(pt,I)}q(F).setInt32(e+0,f,!0);var D=D_(C,S,F),_=fe;q(F).setInt32(e+8,_,!0),q(F).setInt32(e+4,D,!0)}q(F).setInt32(n0+4,T,!0),q(F).setInt32(n0+0,A,!0)}let Jt=[_t,0],tn=new Map,Yt=0;Qn[3]=Jt;function Gt(n0){var E=Sn();if(E==null)q(F).setInt8(n0+0,0,!0);else{let A=E;if(q(F).setInt8(n0+0,1,!0),!(A instanceof y0))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var T=A[C0];if(!T){let h=A[V0]||++Yt;tn.set(h,A),T=wt(Jt,h)}q(F).setInt32(n0+4,T,!0)}}let dt=[_t,0],Dt=new Map,Tt=0;Qn[4]=dt;function Mt(n0){var E=fn();if(E==null)q(F).setInt8(n0+0,0,!0);else{let A=E;if(q(F).setInt8(n0+0,1,!0),!(A instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var T=A[C0];if(!T){let h=A[V0]||++Tt;Dt.set(h,A),T=wt(dt,h)}q(F).setInt32(n0+4,T,!0)}}function zt(n0){var E=bn();if(E==null)q(F).setInt8(n0+0,0,!0);else{let A=E;if(q(F).setInt8(n0+0,1,!0),!(A instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var T=A[C0];if(!T){let h=A[V0]||++Tt;Dt.set(h,A),T=wt(dt,h)}q(F).setInt32(n0+4,T,!0)}}let nn,un=[_t,0],ht=new Map,At=0;Qn[6]=un;function Ht(n0){if(Vn(un,n0).own)throw new TypeError("unreachable resource trampoline")}function Hn(n0){let Y=Vn(S0,n0);if(Y.own){let E=D0.get(Y.rep);E?(E[ln]&&E[ln](),D0.delete(Y.rep)):z0[An]&&z0[An](Y.rep)}}function Wn(n0){let Y=Vn(U0,n0);if(Y.own){let E=A0.get(Y.rep);E?(E[ln]&&E[ln](),A0.delete(Y.rep)):tt[An]&&tt[An](Y.rep)}}function en(n0){let Y=Vn(nt,n0);if(Y.own){let E=t0.get(Y.rep);E?(E[ln]&&E[ln](),t0.delete(Y.rep)):a0[An]&&a0[An](Y.rep)}}function _n(n0){let Y=Vn(pt,n0);if(Y.own){let E=lt.get(Y.rep);E?(E[ln]&&E[ln](),lt.delete(Y.rep)):Et[An]&&Et[An](Y.rep)}}function Tn(n0){let Y=Vn(Jt,n0);if(Y.own){let E=tn.get(Y.rep);E?(E[ln]&&E[ln](),tn.delete(Y.rep)):y0[An]&&y0[An](Y.rep)}}function yn(n0){let Y=Vn(dt,n0);if(Y.own){let E=Dt.get(Y.rep);E?(E[ln]&&E[ln](),Dt.delete(Y.rep)):Lt[An]&&Lt[An](Y.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:r0}=yield b(yield z),{exports:X}=yield b(yield M,{wasi_snapshot_preview1:{args_get:r0[19],args_sizes_get:r0[20],fd_close:r0[21],fd_fdstat_get:r0[22],fd_fdstat_set_flags:r0[23],fd_prestat_dir_name:r0[25],fd_prestat_get:r0[24],fd_read:r0[26],fd_seek:r0[27],fd_write:r0[28],path_open:r0[29],proc_exit:r0[30]}}),{exports:P0}=yield b(yield G,{__main_module__:{_start:X._start},env:{memory:X.memory},"wasi:cli/environment@0.2.0":{"get-arguments":r0[0]},"wasi:cli/exit@0.2.0":{exit:et},"wasi:cli/stderr@0.2.0":{"get-stderr":s0},"wasi:cli/stdin@0.2.0":{"get-stdin":Q0},"wasi:cli/stdout@0.2.0":{"get-stdout":ut},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":Tn},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":yn},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":r0[18]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":r0[16]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":r0[17]},"wasi:filesystem/preopens@0.2.0":{"get-directories":r0[15]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":r0[3],"[method]descriptor.get-flags":r0[4],"[method]descriptor.get-type":r0[5],"[method]descriptor.open-at":r0[7],"[method]descriptor.read-via-stream":r0[1],"[method]descriptor.stat":r0[6],"[method]descriptor.write-via-stream":r0[2],"[resource-drop]descriptor":_n,"[resource-drop]directory-entry-stream":Ht,"filesystem-error-code":r0[8]},"wasi:io/error@0.2.0":{"[resource-drop]error":Wn},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":r0[10],"[method]input-stream.read":r0[9],"[method]output-stream.blocking-flush":r0[14],"[method]output-stream.blocking-write-and-flush":r0[13],"[method]output-stream.check-write":r0[11],"[method]output-stream.write":r0[12],"[resource-drop]input-stream":en,"[resource-drop]output-stream":Hn}}),F=X.memory,S=P0.cabi_import_realloc,{exports:nn}=yield b(yield m0,{"":{$imports:r0.$imports,0:H0,1:x,10:hn,11:gn,12:Bn,13:St,14:ct,15:ft,16:Gt,17:Mt,18:zt,19:P0.args_get,2:b0,20:P0.args_sizes_get,21:P0.fd_close,22:P0.fd_fdstat_get,23:P0.fd_fdstat_set_flags,24:P0.fd_prestat_get,25:P0.fd_prestat_dir_name,26:P0.fd_read,27:P0.fd_seek,28:P0.fd_write,29:P0.path_open,3:v,30:P0.proc_exit,4:W,5:Rt,6:mt,7:Ct,8:st,9:Ot}});function rn(){let n0=P0["wasi:cli/run@0.2.0#run"](),Y;switch(n0){case 0:{Y={tag:"ok",val:void 0};break}case 1:{Y={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(Y.tag==="err")throw new Er(Y.val);return Y.val}let Xt={run:rn};return{run:Xt,"wasi:cli/run@0.2.0":Xt}}(),It,v0,Y0;function ot(bt){try{let r0;do({value:bt,done:r0}=w0.next(bt));while(!(bt instanceof Promise)&&!r0);if(r0)if(v0)v0(bt);else return bt;It||(It=new Promise((X,S0)=>(v0=X,Y0=S0))),bt.then(X=>r0?v0():ot(X),Y0)}catch(r0){if(Y0)Y0(r0);else throw r0}}let qt=ot(null);return It||qt}var Lr=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},g0=[],we=new DataView(new ArrayBuffer),Z=n=>we.buffer===n.buffer?we:we=new DataView(n.buffer);function on(n){if(n&&br.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var $n=[],br=Object.prototype.hasOwnProperty,rt=1<<30;function kt(n,l){let b=n[0]&~rt;return b===0?(n.push(0),n.push(l|rt),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|rt,b)}function jn(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&rt)!==0,z=M&~rt;if(M===0||(b&rt)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|rt,n[0]=l|rt,{rep:z,scope:b,own:G}}var Rn=Symbol.for("cabiDispose"),O0=Symbol("handle"),$0=Symbol.for("cabiRep"),cn=Symbol.dispose||Symbol.for("dispose"),Un=n=>BigInt.asUintN(64,BigInt(n));function me(n){return n>>>0}var Sr=new TextDecoder,fr=new TextEncoder,pe=0;function Ce(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return pe=0,1;let M=fr.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),pe=M.length,G}function Pr(n,l,b=WebAssembly.instantiate){let M=n("icebram.core.wasm"),G=n("icebram.core2.wasm"),z=n("icebram.core3.wasm"),m0=n("icebram.core4.wasm"),{cli:J0,fs:x0,io:K0,monotonicClock:y0,wallClock:Lt}=l.runtime,{TerminalInput:jt,TerminalOutput:Pt,exit:vt,getArguments:Nn,getEnvironment:Ln,getStderr:bn,getStdin:Sn,getStdout:fn,getTerminalStderr:Et,getTerminalStdin:Z0,getTerminalStdout:Pn}=J0,{Descriptor:tt,filesystemErrorCode:a0,getDirectories:z0}=x0,{Error:w0,InputStream:It,OutputStream:v0}=K0,{now:Y0}=y0,{now:ot}=Lt,qt=function*(){let s0,nt;function t0(){let D=Y0();return Un(D)}let $=[rt,0],Q0=new Map,ut=0;$n[2]=$;function et(){let D=bn();if(!(D instanceof v0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var _=D[O0];if(!_){let r=D[$0]||++ut;Q0.set(r,D),_=kt($,r)}return _}let P0=[rt,0],F=new Map,S=0;$n[1]=P0;function H0(){let D=Sn();if(!(D instanceof It))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var _=D[O0];if(!_){let r=D[$0]||++S;F.set(r,D),_=kt(P0,r)}return _}function pt(){let D=fn();if(!(D instanceof v0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var _=D[O0];if(!_){let r=D[$0]||++ut;Q0.set(r,D),_=kt($,r)}return _}function lt(D){let _;switch(D){case 0:{_={tag:"ok",val:void 0};break}case 1:{_={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}vt(_)}let d0,x,b0;function v(D){var r=Ln(),t=r.length,e=b0(0,0,4,t*16);for(let P=0;P<r.length;P++){let R=r[P],a=e+P*16;var[I,y]=R,U=Ce(I,b0,x),L=pe;Z(x).setInt32(a+4,L,!0),Z(x).setInt32(a+0,U,!0);var i=Ce(y,b0,x),u=pe;Z(x).setInt32(a+12,u,!0),Z(x).setInt32(a+8,i,!0)}Z(x).setInt32(D+4,t,!0),Z(x).setInt32(D+0,e,!0)}function W(D){var r=Nn(),t=r.length,e=b0(0,0,4,t*8);for(let U=0;U<r.length;U++){let L=r[U],i=e+U*8;var I=Ce(L,b0,x),y=pe;Z(x).setInt32(i+4,y,!0),Z(x).setInt32(i+0,I,!0)}Z(x).setInt32(D+4,t,!0),Z(x).setInt32(D+0,e,!0)}function Rt(D){let _=ot();var{seconds:r,nanoseconds:t}=_;Z(x).setBigInt64(D+0,Un(r),!0),Z(x).setInt32(D+8,me(t),!0)}let mt=[rt,0],Ct=new Map,U0=0;$n[5]=mt;function A0(D,_,r){var t=D,e=mt[(t<<1)+1]&~rt,I=Ct.get(e);I||(I=Object.create(tt.prototype),Object.defineProperty(I,O0,{writable:!0,value:t}),Object.defineProperty(I,$0,{writable:!0,value:e})),g0.push(I);let y;try{y={tag:"ok",val:I.readViaStream(BigInt.asUintN(64,_))}}catch(u){y={tag:"err",val:on(u)}}for(let u of g0)u[O0]=null;g0=[];var U=y;switch(U.tag){case"ok":{let u=U.val;if(Z(x).setInt8(r+0,0,!0),!(u instanceof It))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var L=u[O0];if(!L){let P=u[$0]||++S;F.set(P,u),L=kt(P0,P)}Z(x).setInt32(r+4,L,!0);break}case"err":{let u=U.val;Z(x).setInt8(r+0,1,!0);var i=u;let P;switch(i){case"access":{P=0;break}case"would-block":{P=1;break}case"already":{P=2;break}case"bad-descriptor":{P=3;break}case"busy":{P=4;break}case"deadlock":{P=5;break}case"quota":{P=6;break}case"exist":{P=7;break}case"file-too-large":{P=8;break}case"illegal-byte-sequence":{P=9;break}case"in-progress":{P=10;break}case"interrupted":{P=11;break}case"invalid":{P=12;break}case"io":{P=13;break}case"is-directory":{P=14;break}case"loop":{P=15;break}case"too-many-links":{P=16;break}case"message-size":{P=17;break}case"name-too-long":{P=18;break}case"no-device":{P=19;break}case"no-entry":{P=20;break}case"no-lock":{P=21;break}case"insufficient-memory":{P=22;break}case"insufficient-space":{P=23;break}case"not-directory":{P=24;break}case"not-empty":{P=25;break}case"not-recoverable":{P=26;break}case"unsupported":{P=27;break}case"no-tty":{P=28;break}case"no-such-device":{P=29;break}case"overflow":{P=30;break}case"not-permitted":{P=31;break}case"pipe":{P=32;break}case"read-only":{P=33;break}case"invalid-seek":{P=34;break}case"text-file-busy":{P=35;break}case"cross-device":{P=36;break}default:throw u instanceof Error&&console.error(u),new TypeError(`"${i}" is not one of the cases of error-code`)}Z(x).setInt8(r+4,P,!0);break}default:throw new TypeError("invalid variant specified for result")}}function l0(D,_,r){var t=D,e=mt[(t<<1)+1]&~rt,I=Ct.get(e);I||(I=Object.create(tt.prototype),Object.defineProperty(I,O0,{writable:!0,value:t}),Object.defineProperty(I,$0,{writable:!0,value:e})),g0.push(I);let y;try{y={tag:"ok",val:I.writeViaStream(BigInt.asUintN(64,_))}}catch(u){y={tag:"err",val:on(u)}}for(let u of g0)u[O0]=null;g0=[];var U=y;switch(U.tag){case"ok":{let u=U.val;if(Z(x).setInt8(r+0,0,!0),!(u instanceof v0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var L=u[O0];if(!L){let P=u[$0]||++ut;Q0.set(P,u),L=kt($,P)}Z(x).setInt32(r+4,L,!0);break}case"err":{let u=U.val;Z(x).setInt8(r+0,1,!0);var i=u;let P;switch(i){case"access":{P=0;break}case"would-block":{P=1;break}case"already":{P=2;break}case"bad-descriptor":{P=3;break}case"busy":{P=4;break}case"deadlock":{P=5;break}case"quota":{P=6;break}case"exist":{P=7;break}case"file-too-large":{P=8;break}case"illegal-byte-sequence":{P=9;break}case"in-progress":{P=10;break}case"interrupted":{P=11;break}case"invalid":{P=12;break}case"io":{P=13;break}case"is-directory":{P=14;break}case"loop":{P=15;break}case"too-many-links":{P=16;break}case"message-size":{P=17;break}case"name-too-long":{P=18;break}case"no-device":{P=19;break}case"no-entry":{P=20;break}case"no-lock":{P=21;break}case"insufficient-memory":{P=22;break}case"insufficient-space":{P=23;break}case"not-directory":{P=24;break}case"not-empty":{P=25;break}case"not-recoverable":{P=26;break}case"unsupported":{P=27;break}case"no-tty":{P=28;break}case"no-such-device":{P=29;break}case"overflow":{P=30;break}case"not-permitted":{P=31;break}case"pipe":{P=32;break}case"read-only":{P=33;break}case"invalid-seek":{P=34;break}case"text-file-busy":{P=35;break}case"cross-device":{P=36;break}default:throw u instanceof Error&&console.error(u),new TypeError(`"${i}" is not one of the cases of error-code`)}Z(x).setInt8(r+4,P,!0);break}default:throw new TypeError("invalid variant specified for result")}}function st(D,_){var r=D,t=mt[(r<<1)+1]&~rt,e=Ct.get(t);e||(e=Object.create(tt.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.appendViaStream()}}catch(i){I={tag:"err",val:on(i)}}for(let i of g0)i[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let i=y.val;if(Z(x).setInt8(_+0,0,!0),!(i instanceof v0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var U=i[O0];if(!U){let u=i[$0]||++ut;Q0.set(u,i),U=kt($,u)}Z(x).setInt32(_+4,U,!0);break}case"err":{let i=y.val;Z(x).setInt8(_+0,1,!0);var L=i;let u;switch(L){case"access":{u=0;break}case"would-block":{u=1;break}case"already":{u=2;break}case"bad-descriptor":{u=3;break}case"busy":{u=4;break}case"deadlock":{u=5;break}case"quota":{u=6;break}case"exist":{u=7;break}case"file-too-large":{u=8;break}case"illegal-byte-sequence":{u=9;break}case"in-progress":{u=10;break}case"interrupted":{u=11;break}case"invalid":{u=12;break}case"io":{u=13;break}case"is-directory":{u=14;break}case"loop":{u=15;break}case"too-many-links":{u=16;break}case"message-size":{u=17;break}case"name-too-long":{u=18;break}case"no-device":{u=19;break}case"no-entry":{u=20;break}case"no-lock":{u=21;break}case"insufficient-memory":{u=22;break}case"insufficient-space":{u=23;break}case"not-directory":{u=24;break}case"not-empty":{u=25;break}case"not-recoverable":{u=26;break}case"unsupported":{u=27;break}case"no-tty":{u=28;break}case"no-such-device":{u=29;break}case"overflow":{u=30;break}case"not-permitted":{u=31;break}case"pipe":{u=32;break}case"read-only":{u=33;break}case"invalid-seek":{u=34;break}case"text-file-busy":{u=35;break}case"cross-device":{u=36;break}default:throw i instanceof Error&&console.error(i),new TypeError(`"${L}" is not one of the cases of error-code`)}Z(x).setInt8(_+4,u,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ot(D,_){var r=D,t=mt[(r<<1)+1]&~rt,e=Ct.get(t);e||(e=Object.create(tt.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.getFlags()}}catch(L){I={tag:"err",val:on(L)}}for(let L of g0)L[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let L=y.val;Z(x).setInt8(_+0,0,!0);let i=0;if(typeof L=="object"&&L!==null)i=!!L.read<<0|!!L.write<<1|!!L.fileIntegritySync<<2|!!L.dataIntegritySync<<3|!!L.requestedWriteSync<<4|!!L.mutateDirectory<<5;else if(L!=null)throw new TypeError("only an object, undefined or null can be converted to flags");Z(x).setInt8(_+1,i,!0);break}case"err":{let L=y.val;Z(x).setInt8(_+0,1,!0);var U=L;let i;switch(U){case"access":{i=0;break}case"would-block":{i=1;break}case"already":{i=2;break}case"bad-descriptor":{i=3;break}case"busy":{i=4;break}case"deadlock":{i=5;break}case"quota":{i=6;break}case"exist":{i=7;break}case"file-too-large":{i=8;break}case"illegal-byte-sequence":{i=9;break}case"in-progress":{i=10;break}case"interrupted":{i=11;break}case"invalid":{i=12;break}case"io":{i=13;break}case"is-directory":{i=14;break}case"loop":{i=15;break}case"too-many-links":{i=16;break}case"message-size":{i=17;break}case"name-too-long":{i=18;break}case"no-device":{i=19;break}case"no-entry":{i=20;break}case"no-lock":{i=21;break}case"insufficient-memory":{i=22;break}case"insufficient-space":{i=23;break}case"not-directory":{i=24;break}case"not-empty":{i=25;break}case"not-recoverable":{i=26;break}case"unsupported":{i=27;break}case"no-tty":{i=28;break}case"no-such-device":{i=29;break}case"overflow":{i=30;break}case"not-permitted":{i=31;break}case"pipe":{i=32;break}case"read-only":{i=33;break}case"invalid-seek":{i=34;break}case"text-file-busy":{i=35;break}case"cross-device":{i=36;break}default:throw L instanceof Error&&console.error(L),new TypeError(`"${U}" is not one of the cases of error-code`)}Z(x).setInt8(_+1,i,!0);break}default:throw new TypeError("invalid variant specified for result")}}function hn(D,_){var r=D,t=mt[(r<<1)+1]&~rt,e=Ct.get(t);e||(e=Object.create(tt.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.getType()}}catch(i){I={tag:"err",val:on(i)}}for(let i of g0)i[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let i=y.val;Z(x).setInt8(_+0,0,!0);var U=i;let u;switch(U){case"unknown":{u=0;break}case"block-device":{u=1;break}case"character-device":{u=2;break}case"directory":{u=3;break}case"fifo":{u=4;break}case"symbolic-link":{u=5;break}case"regular-file":{u=6;break}case"socket":{u=7;break}default:throw i instanceof Error&&console.error(i),new TypeError(`"${U}" is not one of the cases of descriptor-type`)}Z(x).setInt8(_+1,u,!0);break}case"err":{let i=y.val;Z(x).setInt8(_+0,1,!0);var L=i;let u;switch(L){case"access":{u=0;break}case"would-block":{u=1;break}case"already":{u=2;break}case"bad-descriptor":{u=3;break}case"busy":{u=4;break}case"deadlock":{u=5;break}case"quota":{u=6;break}case"exist":{u=7;break}case"file-too-large":{u=8;break}case"illegal-byte-sequence":{u=9;break}case"in-progress":{u=10;break}case"interrupted":{u=11;break}case"invalid":{u=12;break}case"io":{u=13;break}case"is-directory":{u=14;break}case"loop":{u=15;break}case"too-many-links":{u=16;break}case"message-size":{u=17;break}case"name-too-long":{u=18;break}case"no-device":{u=19;break}case"no-entry":{u=20;break}case"no-lock":{u=21;break}case"insufficient-memory":{u=22;break}case"insufficient-space":{u=23;break}case"not-directory":{u=24;break}case"not-empty":{u=25;break}case"not-recoverable":{u=26;break}case"unsupported":{u=27;break}case"no-tty":{u=28;break}case"no-such-device":{u=29;break}case"overflow":{u=30;break}case"not-permitted":{u=31;break}case"pipe":{u=32;break}case"read-only":{u=33;break}case"invalid-seek":{u=34;break}case"text-file-busy":{u=35;break}case"cross-device":{u=36;break}default:throw i instanceof Error&&console.error(i),new TypeError(`"${L}" is not one of the cases of error-code`)}Z(x).setInt8(_+1,u,!0);break}default:throw new TypeError("invalid variant specified for result")}}function gn(D,_){var r=D,t=mt[(r<<1)+1]&~rt,e=Ct.get(t);e||(e=Object.create(tt.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.stat()}}catch(J){I={tag:"err",val:on(J)}}for(let J of g0)J[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let J=y.val;Z(x).setInt8(_+0,0,!0);var{type:U,linkCount:L,size:i,dataAccessTimestamp:u,dataModificationTimestamp:P,statusChangeTimestamp:R}=J,a=U;let H;switch(a){case"unknown":{H=0;break}case"block-device":{H=1;break}case"character-device":{H=2;break}case"directory":{H=3;break}case"fifo":{H=4;break}case"symbolic-link":{H=5;break}case"regular-file":{H=6;break}case"socket":{H=7;break}default:throw U instanceof Error&&console.error(U),new TypeError(`"${a}" is not one of the cases of descriptor-type`)}Z(x).setInt8(_+8,H,!0),Z(x).setBigInt64(_+16,Un(L),!0),Z(x).setBigInt64(_+24,Un(i),!0);var d=u;if(d==null)Z(x).setInt8(_+32,0,!0);else{let g=d;Z(x).setInt8(_+32,1,!0);var{seconds:c,nanoseconds:m}=g;Z(x).setBigInt64(_+40,Un(c),!0),Z(x).setInt32(_+48,me(m),!0)}var o=P;if(o==null)Z(x).setInt8(_+56,0,!0);else{let g=o;Z(x).setInt8(_+56,1,!0);var{seconds:p,nanoseconds:s}=g;Z(x).setBigInt64(_+64,Un(p),!0),Z(x).setInt32(_+72,me(s),!0)}var w=R;if(w==null)Z(x).setInt8(_+80,0,!0);else{let g=w;Z(x).setInt8(_+80,1,!0);var{seconds:O,nanoseconds:N}=g;Z(x).setBigInt64(_+88,Un(O),!0),Z(x).setInt32(_+96,me(N),!0)}break}case"err":{let J=y.val;Z(x).setInt8(_+0,1,!0);var B=J;let H;switch(B){case"access":{H=0;break}case"would-block":{H=1;break}case"already":{H=2;break}case"bad-descriptor":{H=3;break}case"busy":{H=4;break}case"deadlock":{H=5;break}case"quota":{H=6;break}case"exist":{H=7;break}case"file-too-large":{H=8;break}case"illegal-byte-sequence":{H=9;break}case"in-progress":{H=10;break}case"interrupted":{H=11;break}case"invalid":{H=12;break}case"io":{H=13;break}case"is-directory":{H=14;break}case"loop":{H=15;break}case"too-many-links":{H=16;break}case"message-size":{H=17;break}case"name-too-long":{H=18;break}case"no-device":{H=19;break}case"no-entry":{H=20;break}case"no-lock":{H=21;break}case"insufficient-memory":{H=22;break}case"insufficient-space":{H=23;break}case"not-directory":{H=24;break}case"not-empty":{H=25;break}case"not-recoverable":{H=26;break}case"unsupported":{H=27;break}case"no-tty":{H=28;break}case"no-such-device":{H=29;break}case"overflow":{H=30;break}case"not-permitted":{H=31;break}case"pipe":{H=32;break}case"read-only":{H=33;break}case"invalid-seek":{H=34;break}case"text-file-busy":{H=35;break}case"cross-device":{H=36;break}default:throw J instanceof Error&&console.error(J),new TypeError(`"${B}" is not one of the cases of error-code`)}Z(x).setInt8(_+8,H,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Bn(D,_,r,t,e,I,y){var U=D,L=mt[(U<<1)+1]&~rt,i=Ct.get(L);if(i||(i=Object.create(tt.prototype),Object.defineProperty(i,O0,{writable:!0,value:U}),Object.defineProperty(i,$0,{writable:!0,value:L})),g0.push(i),(_&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var u={symlinkFollow:!!(_&1)},P=r,R=t,a=Sr.decode(new Uint8Array(x.buffer,P,R));if((e&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var d={create:!!(e&1),directory:!!(e&2),exclusive:!!(e&4),truncate:!!(e&8)};if((I&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var c={read:!!(I&1),write:!!(I&2),fileIntegritySync:!!(I&4),dataIntegritySync:!!(I&8),requestedWriteSync:!!(I&16),mutateDirectory:!!(I&32)};let m;try{m={tag:"ok",val:i.openAt(u,a,d,c)}}catch(w){m={tag:"err",val:on(w)}}for(let w of g0)w[O0]=null;g0=[];var o=m;switch(o.tag){case"ok":{let w=o.val;if(Z(x).setInt8(y+0,0,!0),!(w instanceof tt))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var p=w[O0];if(!p){let O=w[$0]||++U0;Ct.set(O,w),p=kt(mt,O)}Z(x).setInt32(y+4,p,!0);break}case"err":{let w=o.val;Z(x).setInt8(y+0,1,!0);var s=w;let O;switch(s){case"access":{O=0;break}case"would-block":{O=1;break}case"already":{O=2;break}case"bad-descriptor":{O=3;break}case"busy":{O=4;break}case"deadlock":{O=5;break}case"quota":{O=6;break}case"exist":{O=7;break}case"file-too-large":{O=8;break}case"illegal-byte-sequence":{O=9;break}case"in-progress":{O=10;break}case"interrupted":{O=11;break}case"invalid":{O=12;break}case"io":{O=13;break}case"is-directory":{O=14;break}case"loop":{O=15;break}case"too-many-links":{O=16;break}case"message-size":{O=17;break}case"name-too-long":{O=18;break}case"no-device":{O=19;break}case"no-entry":{O=20;break}case"no-lock":{O=21;break}case"insufficient-memory":{O=22;break}case"insufficient-space":{O=23;break}case"not-directory":{O=24;break}case"not-empty":{O=25;break}case"not-recoverable":{O=26;break}case"unsupported":{O=27;break}case"no-tty":{O=28;break}case"no-such-device":{O=29;break}case"overflow":{O=30;break}case"not-permitted":{O=31;break}case"pipe":{O=32;break}case"read-only":{O=33;break}case"invalid-seek":{O=34;break}case"text-file-busy":{O=35;break}case"cross-device":{O=36;break}default:throw w instanceof Error&&console.error(w),new TypeError(`"${s}" is not one of the cases of error-code`)}Z(x).setInt8(y+4,O,!0);break}default:throw new TypeError("invalid variant specified for result")}}let St=[rt,0],ct=new Map,ft=0;$n[0]=St;function Jt(D,_){var r=D,t=St[(r<<1)+1]&~rt,e=ct.get(t);e||(e=Object.create(w0.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I=a0(e);for(let L of g0)L[O0]=null;g0=[];var y=I;if(y==null)Z(x).setInt8(_+0,0,!0);else{let L=y;Z(x).setInt8(_+0,1,!0);var U=L;let i;switch(U){case"access":{i=0;break}case"would-block":{i=1;break}case"already":{i=2;break}case"bad-descriptor":{i=3;break}case"busy":{i=4;break}case"deadlock":{i=5;break}case"quota":{i=6;break}case"exist":{i=7;break}case"file-too-large":{i=8;break}case"illegal-byte-sequence":{i=9;break}case"in-progress":{i=10;break}case"interrupted":{i=11;break}case"invalid":{i=12;break}case"io":{i=13;break}case"is-directory":{i=14;break}case"loop":{i=15;break}case"too-many-links":{i=16;break}case"message-size":{i=17;break}case"name-too-long":{i=18;break}case"no-device":{i=19;break}case"no-entry":{i=20;break}case"no-lock":{i=21;break}case"insufficient-memory":{i=22;break}case"insufficient-space":{i=23;break}case"not-directory":{i=24;break}case"not-empty":{i=25;break}case"not-recoverable":{i=26;break}case"unsupported":{i=27;break}case"no-tty":{i=28;break}case"no-such-device":{i=29;break}case"overflow":{i=30;break}case"not-permitted":{i=31;break}case"pipe":{i=32;break}case"read-only":{i=33;break}case"invalid-seek":{i=34;break}case"text-file-busy":{i=35;break}case"cross-device":{i=36;break}default:throw L instanceof Error&&console.error(L),new TypeError(`"${U}" is not one of the cases of error-code`)}Z(x).setInt8(_+1,i,!0)}}function tn(D,_,r){var t=D,e=P0[(t<<1)+1]&~rt,I=F.get(e);I||(I=Object.create(It.prototype),Object.defineProperty(I,O0,{writable:!0,value:t}),Object.defineProperty(I,$0,{writable:!0,value:e})),g0.push(I);let y;try{y={tag:"ok",val:I.read(BigInt.asUintN(64,_))}}catch(d){y={tag:"err",val:on(d)}}for(let d of g0)d[O0]=null;g0=[];var U=y;switch(U.tag){case"ok":{let d=U.val;Z(x).setInt8(r+0,0,!0);var L=d,i=L.byteLength,u=b0(0,0,1,i*1),P=new Uint8Array(L.buffer||L,L.byteOffset,i*1);new Uint8Array(x.buffer,u,i*1).set(P),Z(x).setInt32(r+8,i,!0),Z(x).setInt32(r+4,u,!0);break}case"err":{let d=U.val;Z(x).setInt8(r+0,1,!0);var R=d;switch(R.tag){case"last-operation-failed":{let c=R.val;if(Z(x).setInt8(r+4,0,!0),!(c instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var a=c[O0];if(!a){let m=c[$0]||++ft;ct.set(m,c),a=kt(St,m)}Z(x).setInt32(r+8,a,!0);break}case"closed":{Z(x).setInt8(r+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(R.tag)}\` (received \`${R}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Yt(D,_,r){var t=D,e=P0[(t<<1)+1]&~rt,I=F.get(e);I||(I=Object.create(It.prototype),Object.defineProperty(I,O0,{writable:!0,value:t}),Object.defineProperty(I,$0,{writable:!0,value:e})),g0.push(I);let y;try{y={tag:"ok",val:I.blockingRead(BigInt.asUintN(64,_))}}catch(d){y={tag:"err",val:on(d)}}for(let d of g0)d[O0]=null;g0=[];var U=y;switch(U.tag){case"ok":{let d=U.val;Z(x).setInt8(r+0,0,!0);var L=d,i=L.byteLength,u=b0(0,0,1,i*1),P=new Uint8Array(L.buffer||L,L.byteOffset,i*1);new Uint8Array(x.buffer,u,i*1).set(P),Z(x).setInt32(r+8,i,!0),Z(x).setInt32(r+4,u,!0);break}case"err":{let d=U.val;Z(x).setInt8(r+0,1,!0);var R=d;switch(R.tag){case"last-operation-failed":{let c=R.val;if(Z(x).setInt8(r+4,0,!0),!(c instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var a=c[O0];if(!a){let m=c[$0]||++ft;ct.set(m,c),a=kt(St,m)}Z(x).setInt32(r+8,a,!0);break}case"closed":{Z(x).setInt8(r+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(R.tag)}\` (received \`${R}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Gt(D,_){var r=D,t=$[(r<<1)+1]&~rt,e=Q0.get(t);e||(e=Object.create(v0.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.checkWrite()}}catch(i){I={tag:"err",val:on(i)}}for(let i of g0)i[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let i=y.val;Z(x).setInt8(_+0,0,!0),Z(x).setBigInt64(_+8,Un(i),!0);break}case"err":{let i=y.val;Z(x).setInt8(_+0,1,!0);var U=i;switch(U.tag){case"last-operation-failed":{let u=U.val;if(Z(x).setInt8(_+8,0,!0),!(u instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var L=u[O0];if(!L){let P=u[$0]||++ft;ct.set(P,u),L=kt(St,P)}Z(x).setInt32(_+12,L,!0);break}case"closed":{Z(x).setInt8(_+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(U.tag)}\` (received \`${U}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function dt(D,_,r,t){var e=D,I=$[(e<<1)+1]&~rt,y=Q0.get(I);y||(y=Object.create(v0.prototype),Object.defineProperty(y,O0,{writable:!0,value:e}),Object.defineProperty(y,$0,{writable:!0,value:I})),g0.push(y);var U=_,L=r,i=new Uint8Array(x.buffer.slice(U,U+L*1));let u;try{u={tag:"ok",val:y.write(i)}}catch(d){u={tag:"err",val:on(d)}}for(let d of g0)d[O0]=null;g0=[];var P=u;switch(P.tag){case"ok":{let d=P.val;Z(x).setInt8(t+0,0,!0);break}case"err":{let d=P.val;Z(x).setInt8(t+0,1,!0);var R=d;switch(R.tag){case"last-operation-failed":{let c=R.val;if(Z(x).setInt8(t+4,0,!0),!(c instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var a=c[O0];if(!a){let m=c[$0]||++ft;ct.set(m,c),a=kt(St,m)}Z(x).setInt32(t+8,a,!0);break}case"closed":{Z(x).setInt8(t+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(R.tag)}\` (received \`${R}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Dt(D,_,r,t){var e=D,I=$[(e<<1)+1]&~rt,y=Q0.get(I);y||(y=Object.create(v0.prototype),Object.defineProperty(y,O0,{writable:!0,value:e}),Object.defineProperty(y,$0,{writable:!0,value:I})),g0.push(y);var U=_,L=r,i=new Uint8Array(x.buffer.slice(U,U+L*1));let u;try{u={tag:"ok",val:y.blockingWriteAndFlush(i)}}catch(d){u={tag:"err",val:on(d)}}for(let d of g0)d[O0]=null;g0=[];var P=u;switch(P.tag){case"ok":{let d=P.val;Z(x).setInt8(t+0,0,!0);break}case"err":{let d=P.val;Z(x).setInt8(t+0,1,!0);var R=d;switch(R.tag){case"last-operation-failed":{let c=R.val;if(Z(x).setInt8(t+4,0,!0),!(c instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var a=c[O0];if(!a){let m=c[$0]||++ft;ct.set(m,c),a=kt(St,m)}Z(x).setInt32(t+8,a,!0);break}case"closed":{Z(x).setInt8(t+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(R.tag)}\` (received \`${R}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Tt(D,_){var r=D,t=$[(r<<1)+1]&~rt,e=Q0.get(t);e||(e=Object.create(v0.prototype),Object.defineProperty(e,O0,{writable:!0,value:r}),Object.defineProperty(e,$0,{writable:!0,value:t})),g0.push(e);let I;try{I={tag:"ok",val:e.blockingFlush()}}catch(i){I={tag:"err",val:on(i)}}for(let i of g0)i[O0]=null;g0=[];var y=I;switch(y.tag){case"ok":{let i=y.val;Z(x).setInt8(_+0,0,!0);break}case"err":{let i=y.val;Z(x).setInt8(_+0,1,!0);var U=i;switch(U.tag){case"last-operation-failed":{let u=U.val;if(Z(x).setInt8(_+4,0,!0),!(u instanceof w0))throw new TypeError('Resource error: Not a valid "Error" resource.');var L=u[O0];if(!L){let P=u[$0]||++ft;ct.set(P,u),L=kt(St,P)}Z(x).setInt32(_+8,L,!0);break}case"closed":{Z(x).setInt8(_+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(U.tag)}\` (received \`${U}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Mt(D){var r=z0(),t=r.length,e=b0(0,0,4,t*12);for(let u=0;u<r.length;u++){let P=r[u],R=e+u*12;var[I,y]=P;if(!(I instanceof tt))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var U=I[O0];if(!U){let a=I[$0]||++U0;Ct.set(a,I),U=kt(mt,a)}Z(x).setInt32(R+0,U,!0);var L=Ce(y,b0,x),i=pe;Z(x).setInt32(R+8,i,!0),Z(x).setInt32(R+4,L,!0)}Z(x).setInt32(D+4,t,!0),Z(x).setInt32(D+0,e,!0)}let zt=[rt,0],nn=new Map,un=0;$n[3]=zt;function ht(D){var r=Z0();if(r==null)Z(x).setInt8(D+0,0,!0);else{let e=r;if(Z(x).setInt8(D+0,1,!0),!(e instanceof jt))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var t=e[O0];if(!t){let I=e[$0]||++un;nn.set(I,e),t=kt(zt,I)}Z(x).setInt32(D+4,t,!0)}}let At=[rt,0],Ht=new Map,Hn=0;$n[4]=At;function Wn(D){var r=Pn();if(r==null)Z(x).setInt8(D+0,0,!0);else{let e=r;if(Z(x).setInt8(D+0,1,!0),!(e instanceof Pt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var t=e[O0];if(!t){let I=e[$0]||++Hn;Ht.set(I,e),t=kt(At,I)}Z(x).setInt32(D+4,t,!0)}}function en(D){var r=Et();if(r==null)Z(x).setInt8(D+0,0,!0);else{let e=r;if(Z(x).setInt8(D+0,1,!0),!(e instanceof Pt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var t=e[O0];if(!t){let I=e[$0]||++Hn;Ht.set(I,e),t=kt(At,I)}Z(x).setInt32(D+4,t,!0)}}let _n,Tn=[rt,0],yn=new Map,rn=0;$n[6]=Tn;function Xt(D){if(jn(Tn,D).own)throw new TypeError("unreachable resource trampoline")}function n0(D){let _=jn($,D);if(_.own){let r=Q0.get(_.rep);r?(r[cn]&&r[cn](),Q0.delete(_.rep)):v0[Rn]&&v0[Rn](_.rep)}}function Y(D){let _=jn(St,D);if(_.own){let r=ct.get(_.rep);r?(r[cn]&&r[cn](),ct.delete(_.rep)):w0[Rn]&&w0[Rn](_.rep)}}function E(D){let _=jn(P0,D);if(_.own){let r=F.get(_.rep);r?(r[cn]&&r[cn](),F.delete(_.rep)):It[Rn]&&It[Rn](_.rep)}}function T(D){let _=jn(mt,D);if(_.own){let r=Ct.get(_.rep);r?(r[cn]&&r[cn](),Ct.delete(_.rep)):tt[Rn]&&tt[Rn](_.rep)}}function A(D){let _=jn(zt,D);if(_.own){let r=nn.get(_.rep);r?(r[cn]&&r[cn](),nn.delete(_.rep)):jt[Rn]&&jt[Rn](_.rep)}}function h(D){let _=jn(At,D);if(_.own){let r=Ht.get(_.rep);r?(r[cn]&&r[cn](),Ht.delete(_.rep)):Pt[Rn]&&Pt[Rn](_.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:s0}=yield b(yield z),{exports:nt}=yield b(yield M,{wasi_snapshot_preview1:{args_get:s0[21],args_sizes_get:s0[22],clock_time_get:s0[25],environ_get:s0[23],environ_sizes_get:s0[24],fd_close:s0[26],fd_fdstat_get:s0[27],fd_fdstat_set_flags:s0[28],fd_prestat_dir_name:s0[30],fd_prestat_get:s0[29],fd_read:s0[31],fd_seek:s0[32],fd_write:s0[33],path_open:s0[34],proc_exit:s0[35]}}),{exports:d0}=yield b(yield G,{__main_module__:{_start:nt._start},env:{memory:nt.memory},"wasi:cli/environment@0.2.0":{"get-arguments":s0[1],"get-environment":s0[0]},"wasi:cli/exit@0.2.0":{exit:lt},"wasi:cli/stderr@0.2.0":{"get-stderr":et},"wasi:cli/stdin@0.2.0":{"get-stdin":H0},"wasi:cli/stdout@0.2.0":{"get-stdout":pt},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":A},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":h},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":s0[20]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":s0[18]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":s0[19]},"wasi:clocks/monotonic-clock@0.2.0":{now:t0},"wasi:clocks/wall-clock@0.2.0":{now:s0[2]},"wasi:filesystem/preopens@0.2.0":{"get-directories":s0[17]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":s0[5],"[method]descriptor.get-flags":s0[6],"[method]descriptor.get-type":s0[7],"[method]descriptor.open-at":s0[9],"[method]descriptor.read-via-stream":s0[3],"[method]descriptor.stat":s0[8],"[method]descriptor.write-via-stream":s0[4],"[resource-drop]descriptor":T,"[resource-drop]directory-entry-stream":Xt,"filesystem-error-code":s0[10]},"wasi:io/error@0.2.0":{"[resource-drop]error":Y},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":s0[12],"[method]input-stream.read":s0[11],"[method]output-stream.blocking-flush":s0[16],"[method]output-stream.blocking-write-and-flush":s0[15],"[method]output-stream.check-write":s0[13],"[method]output-stream.write":s0[14],"[resource-drop]input-stream":E,"[resource-drop]output-stream":n0}}),x=nt.memory,b0=d0.cabi_import_realloc,{exports:_n}=yield b(yield m0,{"":{$imports:s0.$imports,0:v,1:W,10:Jt,11:tn,12:Yt,13:Gt,14:dt,15:Dt,16:Tt,17:Mt,18:ht,19:Wn,2:Rt,20:en,21:d0.args_get,22:d0.args_sizes_get,23:d0.environ_get,24:d0.environ_sizes_get,25:d0.clock_time_get,26:d0.fd_close,27:d0.fd_fdstat_get,28:d0.fd_fdstat_set_flags,29:d0.fd_prestat_get,3:A0,30:d0.fd_prestat_dir_name,31:d0.fd_read,32:d0.fd_seek,33:d0.fd_write,34:d0.path_open,35:d0.proc_exit,4:l0,5:st,6:Ot,7:hn,8:gn,9:Bn}});function C(){let D=d0["wasi:cli/run@0.2.0#run"](),_;switch(D){case 0:{_={tag:"ok",val:void 0};break}case 1:{_={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(_.tag==="err")throw new Lr(_.val);return _.val}let f={run:C};return{run:f,"wasi:cli/run@0.2.0":f}}(),bt,r0,X;function S0(f0){try{let s0;do({value:f0,done:s0}=qt.next(f0));while(!(f0 instanceof Promise)&&!s0);if(s0)if(r0)r0(f0);else return f0;bt||(bt=new Promise((nt,t0)=>(r0=nt,X=t0))),f0.then(nt=>s0?r0():S0(nt),X)}catch(s0){if(X)X(s0);else throw s0}}let D0=S0(null);return bt||D0}var hr=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},B0=[],ke=new DataView(new ArrayBuffer),Q=n=>ke.buffer===n.buffer?ke:ke=new DataView(n.buffer);function pn(n){if(n&&gr.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var qn=[],gr=Object.prototype.hasOwnProperty,it=1<<30;function Ft(n,l){let b=n[0]&~it;return b===0?(n.push(0),n.push(l|it),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|it,b)}function Jn(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&it)!==0,z=M&~it;if(M===0||(b&it)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|it,n[0]=l|it,{rep:z,scope:b,own:G}}var dn=Symbol.for("cabiDispose"),N0=Symbol("handle"),j0=Symbol.for("cabiRep"),Dn=Symbol.dispose||Symbol.for("dispose"),se=n=>BigInt.asUintN(64,BigInt(n));function Fe(n){return n>>>0}var Br=new TextDecoder,Wr=new TextEncoder,Ie=0;function Oe(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return Ie=0,1;let M=Wr.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),Ie=M.length,G}function vr(n,l,b=WebAssembly.instantiate){let M=n("icemulti.core.wasm"),G=n("icemulti.core2.wasm"),z=n("icemulti.core3.wasm"),m0=n("icemulti.core4.wasm"),{cli:J0,fs:x0,io:K0}=l.runtime,{TerminalInput:y0,TerminalOutput:Lt,exit:jt,getArguments:Pt,getEnvironment:vt,getStderr:Nn,getStdin:Ln,getStdout:bn,getTerminalStderr:Sn,getTerminalStdin:fn,getTerminalStdout:Et}=J0,{Descriptor:Z0,filesystemErrorCode:Pn,getDirectories:tt}=x0,{Error:a0,InputStream:z0,OutputStream:w0}=K0,It=function*(){let X,S0,D0=[it,0],f0=new Map,s0=0;qn[2]=D0;function nt(){let E=Nn();if(!(E instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var T=E[N0];if(!T){let A=E[j0]||++s0;f0.set(A,E),T=Ft(D0,A)}return T}let t0=[it,0],$=new Map,Q0=0;qn[1]=t0;function ut(){let E=Ln();if(!(E instanceof z0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var T=E[N0];if(!T){let A=E[j0]||++Q0;$.set(A,E),T=Ft(t0,A)}return T}function et(){let E=bn();if(!(E instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var T=E[N0];if(!T){let A=E[j0]||++s0;f0.set(A,E),T=Ft(D0,A)}return T}function P0(E){let T;switch(E){case 0:{T={tag:"ok",val:void 0};break}case 1:{T={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}jt(T)}let F,S,H0;function pt(E){var A=vt(),h=A.length,C=H0(0,0,4,h*16);for(let I=0;I<A.length;I++){let y=A[I],U=C+I*16;var[f,D]=y,_=Oe(f,H0,S),r=Ie;Q(S).setInt32(U+4,r,!0),Q(S).setInt32(U+0,_,!0);var t=Oe(D,H0,S),e=Ie;Q(S).setInt32(U+12,e,!0),Q(S).setInt32(U+8,t,!0)}Q(S).setInt32(E+4,h,!0),Q(S).setInt32(E+0,C,!0)}function lt(E){var A=Pt(),h=A.length,C=H0(0,0,4,h*8);for(let _=0;_<A.length;_++){let r=A[_],t=C+_*8;var f=Oe(r,H0,S),D=Ie;Q(S).setInt32(t+4,D,!0),Q(S).setInt32(t+0,f,!0)}Q(S).setInt32(E+4,h,!0),Q(S).setInt32(E+0,C,!0)}let d0=[it,0],x=new Map,b0=0;qn[5]=d0;function v(E,T,A){var h=E,C=d0[(h<<1)+1]&~it,f=x.get(C);f||(f=Object.create(Z0.prototype),Object.defineProperty(f,N0,{writable:!0,value:h}),Object.defineProperty(f,j0,{writable:!0,value:C})),B0.push(f);let D;try{D={tag:"ok",val:f.readViaStream(BigInt.asUintN(64,T))}}catch(e){D={tag:"err",val:pn(e)}}for(let e of B0)e[N0]=null;B0=[];var _=D;switch(_.tag){case"ok":{let e=_.val;if(Q(S).setInt8(A+0,0,!0),!(e instanceof z0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var r=e[N0];if(!r){let I=e[j0]||++Q0;$.set(I,e),r=Ft(t0,I)}Q(S).setInt32(A+4,r,!0);break}case"err":{let e=_.val;Q(S).setInt8(A+0,1,!0);var t=e;let I;switch(t){case"access":{I=0;break}case"would-block":{I=1;break}case"already":{I=2;break}case"bad-descriptor":{I=3;break}case"busy":{I=4;break}case"deadlock":{I=5;break}case"quota":{I=6;break}case"exist":{I=7;break}case"file-too-large":{I=8;break}case"illegal-byte-sequence":{I=9;break}case"in-progress":{I=10;break}case"interrupted":{I=11;break}case"invalid":{I=12;break}case"io":{I=13;break}case"is-directory":{I=14;break}case"loop":{I=15;break}case"too-many-links":{I=16;break}case"message-size":{I=17;break}case"name-too-long":{I=18;break}case"no-device":{I=19;break}case"no-entry":{I=20;break}case"no-lock":{I=21;break}case"insufficient-memory":{I=22;break}case"insufficient-space":{I=23;break}case"not-directory":{I=24;break}case"not-empty":{I=25;break}case"not-recoverable":{I=26;break}case"unsupported":{I=27;break}case"no-tty":{I=28;break}case"no-such-device":{I=29;break}case"overflow":{I=30;break}case"not-permitted":{I=31;break}case"pipe":{I=32;break}case"read-only":{I=33;break}case"invalid-seek":{I=34;break}case"text-file-busy":{I=35;break}case"cross-device":{I=36;break}default:throw e instanceof Error&&console.error(e),new TypeError(`"${t}" is not one of the cases of error-code`)}Q(S).setInt8(A+4,I,!0);break}default:throw new TypeError("invalid variant specified for result")}}function W(E,T,A){var h=E,C=d0[(h<<1)+1]&~it,f=x.get(C);f||(f=Object.create(Z0.prototype),Object.defineProperty(f,N0,{writable:!0,value:h}),Object.defineProperty(f,j0,{writable:!0,value:C})),B0.push(f);let D;try{D={tag:"ok",val:f.writeViaStream(BigInt.asUintN(64,T))}}catch(e){D={tag:"err",val:pn(e)}}for(let e of B0)e[N0]=null;B0=[];var _=D;switch(_.tag){case"ok":{let e=_.val;if(Q(S).setInt8(A+0,0,!0),!(e instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var r=e[N0];if(!r){let I=e[j0]||++s0;f0.set(I,e),r=Ft(D0,I)}Q(S).setInt32(A+4,r,!0);break}case"err":{let e=_.val;Q(S).setInt8(A+0,1,!0);var t=e;let I;switch(t){case"access":{I=0;break}case"would-block":{I=1;break}case"already":{I=2;break}case"bad-descriptor":{I=3;break}case"busy":{I=4;break}case"deadlock":{I=5;break}case"quota":{I=6;break}case"exist":{I=7;break}case"file-too-large":{I=8;break}case"illegal-byte-sequence":{I=9;break}case"in-progress":{I=10;break}case"interrupted":{I=11;break}case"invalid":{I=12;break}case"io":{I=13;break}case"is-directory":{I=14;break}case"loop":{I=15;break}case"too-many-links":{I=16;break}case"message-size":{I=17;break}case"name-too-long":{I=18;break}case"no-device":{I=19;break}case"no-entry":{I=20;break}case"no-lock":{I=21;break}case"insufficient-memory":{I=22;break}case"insufficient-space":{I=23;break}case"not-directory":{I=24;break}case"not-empty":{I=25;break}case"not-recoverable":{I=26;break}case"unsupported":{I=27;break}case"no-tty":{I=28;break}case"no-such-device":{I=29;break}case"overflow":{I=30;break}case"not-permitted":{I=31;break}case"pipe":{I=32;break}case"read-only":{I=33;break}case"invalid-seek":{I=34;break}case"text-file-busy":{I=35;break}case"cross-device":{I=36;break}default:throw e instanceof Error&&console.error(e),new TypeError(`"${t}" is not one of the cases of error-code`)}Q(S).setInt8(A+4,I,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Rt(E,T){var A=E,h=d0[(A<<1)+1]&~it,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.appendViaStream()}}catch(t){f={tag:"err",val:pn(t)}}for(let t of B0)t[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;if(Q(S).setInt8(T+0,0,!0),!(t instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var _=t[N0];if(!_){let e=t[j0]||++s0;f0.set(e,t),_=Ft(D0,e)}Q(S).setInt32(T+4,_,!0);break}case"err":{let t=D.val;Q(S).setInt8(T+0,1,!0);var r=t;let e;switch(r){case"access":{e=0;break}case"would-block":{e=1;break}case"already":{e=2;break}case"bad-descriptor":{e=3;break}case"busy":{e=4;break}case"deadlock":{e=5;break}case"quota":{e=6;break}case"exist":{e=7;break}case"file-too-large":{e=8;break}case"illegal-byte-sequence":{e=9;break}case"in-progress":{e=10;break}case"interrupted":{e=11;break}case"invalid":{e=12;break}case"io":{e=13;break}case"is-directory":{e=14;break}case"loop":{e=15;break}case"too-many-links":{e=16;break}case"message-size":{e=17;break}case"name-too-long":{e=18;break}case"no-device":{e=19;break}case"no-entry":{e=20;break}case"no-lock":{e=21;break}case"insufficient-memory":{e=22;break}case"insufficient-space":{e=23;break}case"not-directory":{e=24;break}case"not-empty":{e=25;break}case"not-recoverable":{e=26;break}case"unsupported":{e=27;break}case"no-tty":{e=28;break}case"no-such-device":{e=29;break}case"overflow":{e=30;break}case"not-permitted":{e=31;break}case"pipe":{e=32;break}case"read-only":{e=33;break}case"invalid-seek":{e=34;break}case"text-file-busy":{e=35;break}case"cross-device":{e=36;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${r}" is not one of the cases of error-code`)}Q(S).setInt8(T+4,e,!0);break}default:throw new TypeError("invalid variant specified for result")}}function mt(E,T){var A=E,h=d0[(A<<1)+1]&~it,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.getFlags()}}catch(r){f={tag:"err",val:pn(r)}}for(let r of B0)r[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let r=D.val;Q(S).setInt8(T+0,0,!0);let t=0;if(typeof r=="object"&&r!==null)t=!!r.read<<0|!!r.write<<1|!!r.fileIntegritySync<<2|!!r.dataIntegritySync<<3|!!r.requestedWriteSync<<4|!!r.mutateDirectory<<5;else if(r!=null)throw new TypeError("only an object, undefined or null can be converted to flags");Q(S).setInt8(T+1,t,!0);break}case"err":{let r=D.val;Q(S).setInt8(T+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}Q(S).setInt8(T+1,t,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ct(E,T){var A=E,h=d0[(A<<1)+1]&~it,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.getType()}}catch(t){f={tag:"err",val:pn(t)}}for(let t of B0)t[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;Q(S).setInt8(T+0,0,!0);var _=t;let e;switch(_){case"unknown":{e=0;break}case"block-device":{e=1;break}case"character-device":{e=2;break}case"directory":{e=3;break}case"fifo":{e=4;break}case"symbolic-link":{e=5;break}case"regular-file":{e=6;break}case"socket":{e=7;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${_}" is not one of the cases of descriptor-type`)}Q(S).setInt8(T+1,e,!0);break}case"err":{let t=D.val;Q(S).setInt8(T+0,1,!0);var r=t;let e;switch(r){case"access":{e=0;break}case"would-block":{e=1;break}case"already":{e=2;break}case"bad-descriptor":{e=3;break}case"busy":{e=4;break}case"deadlock":{e=5;break}case"quota":{e=6;break}case"exist":{e=7;break}case"file-too-large":{e=8;break}case"illegal-byte-sequence":{e=9;break}case"in-progress":{e=10;break}case"interrupted":{e=11;break}case"invalid":{e=12;break}case"io":{e=13;break}case"is-directory":{e=14;break}case"loop":{e=15;break}case"too-many-links":{e=16;break}case"message-size":{e=17;break}case"name-too-long":{e=18;break}case"no-device":{e=19;break}case"no-entry":{e=20;break}case"no-lock":{e=21;break}case"insufficient-memory":{e=22;break}case"insufficient-space":{e=23;break}case"not-directory":{e=24;break}case"not-empty":{e=25;break}case"not-recoverable":{e=26;break}case"unsupported":{e=27;break}case"no-tty":{e=28;break}case"no-such-device":{e=29;break}case"overflow":{e=30;break}case"not-permitted":{e=31;break}case"pipe":{e=32;break}case"read-only":{e=33;break}case"invalid-seek":{e=34;break}case"text-file-busy":{e=35;break}case"cross-device":{e=36;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${r}" is not one of the cases of error-code`)}Q(S).setInt8(T+1,e,!0);break}default:throw new TypeError("invalid variant specified for result")}}function U0(E,T){var A=E,h=d0[(A<<1)+1]&~it,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.stat()}}catch(p){f={tag:"err",val:pn(p)}}for(let p of B0)p[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let p=D.val;Q(S).setInt8(T+0,0,!0);var{type:_,linkCount:r,size:t,dataAccessTimestamp:e,dataModificationTimestamp:I,statusChangeTimestamp:y}=p,U=_;let s;switch(U){case"unknown":{s=0;break}case"block-device":{s=1;break}case"character-device":{s=2;break}case"directory":{s=3;break}case"fifo":{s=4;break}case"symbolic-link":{s=5;break}case"regular-file":{s=6;break}case"socket":{s=7;break}default:throw _ instanceof Error&&console.error(_),new TypeError(`"${U}" is not one of the cases of descriptor-type`)}Q(S).setInt8(T+8,s,!0),Q(S).setBigInt64(T+16,se(r),!0),Q(S).setBigInt64(T+24,se(t),!0);var L=e;if(L==null)Q(S).setInt8(T+32,0,!0);else{let w=L;Q(S).setInt8(T+32,1,!0);var{seconds:i,nanoseconds:u}=w;Q(S).setBigInt64(T+40,se(i),!0),Q(S).setInt32(T+48,Fe(u),!0)}var P=I;if(P==null)Q(S).setInt8(T+56,0,!0);else{let w=P;Q(S).setInt8(T+56,1,!0);var{seconds:R,nanoseconds:a}=w;Q(S).setBigInt64(T+64,se(R),!0),Q(S).setInt32(T+72,Fe(a),!0)}var d=y;if(d==null)Q(S).setInt8(T+80,0,!0);else{let w=d;Q(S).setInt8(T+80,1,!0);var{seconds:c,nanoseconds:m}=w;Q(S).setBigInt64(T+88,se(c),!0),Q(S).setInt32(T+96,Fe(m),!0)}break}case"err":{let p=D.val;Q(S).setInt8(T+0,1,!0);var o=p;let s;switch(o){case"access":{s=0;break}case"would-block":{s=1;break}case"already":{s=2;break}case"bad-descriptor":{s=3;break}case"busy":{s=4;break}case"deadlock":{s=5;break}case"quota":{s=6;break}case"exist":{s=7;break}case"file-too-large":{s=8;break}case"illegal-byte-sequence":{s=9;break}case"in-progress":{s=10;break}case"interrupted":{s=11;break}case"invalid":{s=12;break}case"io":{s=13;break}case"is-directory":{s=14;break}case"loop":{s=15;break}case"too-many-links":{s=16;break}case"message-size":{s=17;break}case"name-too-long":{s=18;break}case"no-device":{s=19;break}case"no-entry":{s=20;break}case"no-lock":{s=21;break}case"insufficient-memory":{s=22;break}case"insufficient-space":{s=23;break}case"not-directory":{s=24;break}case"not-empty":{s=25;break}case"not-recoverable":{s=26;break}case"unsupported":{s=27;break}case"no-tty":{s=28;break}case"no-such-device":{s=29;break}case"overflow":{s=30;break}case"not-permitted":{s=31;break}case"pipe":{s=32;break}case"read-only":{s=33;break}case"invalid-seek":{s=34;break}case"text-file-busy":{s=35;break}case"cross-device":{s=36;break}default:throw p instanceof Error&&console.error(p),new TypeError(`"${o}" is not one of the cases of error-code`)}Q(S).setInt8(T+8,s,!0);break}default:throw new TypeError("invalid variant specified for result")}}function A0(E,T,A,h,C,f,D){var _=E,r=d0[(_<<1)+1]&~it,t=x.get(r);if(t||(t=Object.create(Z0.prototype),Object.defineProperty(t,N0,{writable:!0,value:_}),Object.defineProperty(t,j0,{writable:!0,value:r})),B0.push(t),(T&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var e={symlinkFollow:!!(T&1)},I=A,y=h,U=Br.decode(new Uint8Array(S.buffer,I,y));if((C&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var L={create:!!(C&1),directory:!!(C&2),exclusive:!!(C&4),truncate:!!(C&8)};if((f&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var i={read:!!(f&1),write:!!(f&2),fileIntegritySync:!!(f&4),dataIntegritySync:!!(f&8),requestedWriteSync:!!(f&16),mutateDirectory:!!(f&32)};let u;try{u={tag:"ok",val:t.openAt(e,U,L,i)}}catch(d){u={tag:"err",val:pn(d)}}for(let d of B0)d[N0]=null;B0=[];var P=u;switch(P.tag){case"ok":{let d=P.val;if(Q(S).setInt8(D+0,0,!0),!(d instanceof Z0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var R=d[N0];if(!R){let c=d[j0]||++b0;x.set(c,d),R=Ft(d0,c)}Q(S).setInt32(D+4,R,!0);break}case"err":{let d=P.val;Q(S).setInt8(D+0,1,!0);var a=d;let c;switch(a){case"access":{c=0;break}case"would-block":{c=1;break}case"already":{c=2;break}case"bad-descriptor":{c=3;break}case"busy":{c=4;break}case"deadlock":{c=5;break}case"quota":{c=6;break}case"exist":{c=7;break}case"file-too-large":{c=8;break}case"illegal-byte-sequence":{c=9;break}case"in-progress":{c=10;break}case"interrupted":{c=11;break}case"invalid":{c=12;break}case"io":{c=13;break}case"is-directory":{c=14;break}case"loop":{c=15;break}case"too-many-links":{c=16;break}case"message-size":{c=17;break}case"name-too-long":{c=18;break}case"no-device":{c=19;break}case"no-entry":{c=20;break}case"no-lock":{c=21;break}case"insufficient-memory":{c=22;break}case"insufficient-space":{c=23;break}case"not-directory":{c=24;break}case"not-empty":{c=25;break}case"not-recoverable":{c=26;break}case"unsupported":{c=27;break}case"no-tty":{c=28;break}case"no-such-device":{c=29;break}case"overflow":{c=30;break}case"not-permitted":{c=31;break}case"pipe":{c=32;break}case"read-only":{c=33;break}case"invalid-seek":{c=34;break}case"text-file-busy":{c=35;break}case"cross-device":{c=36;break}default:throw d instanceof Error&&console.error(d),new TypeError(`"${a}" is not one of the cases of error-code`)}Q(S).setInt8(D+4,c,!0);break}default:throw new TypeError("invalid variant specified for result")}}let l0=[it,0],st=new Map,Ot=0;qn[0]=l0;function hn(E,T){var A=E,h=l0[(A<<1)+1]&~it,C=st.get(h);C||(C=Object.create(a0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f=Pn(C);for(let r of B0)r[N0]=null;B0=[];var D=f;if(D==null)Q(S).setInt8(T+0,0,!0);else{let r=D;Q(S).setInt8(T+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}Q(S).setInt8(T+1,t,!0)}}function gn(E,T,A){var h=E,C=t0[(h<<1)+1]&~it,f=$.get(C);f||(f=Object.create(z0.prototype),Object.defineProperty(f,N0,{writable:!0,value:h}),Object.defineProperty(f,j0,{writable:!0,value:C})),B0.push(f);let D;try{D={tag:"ok",val:f.read(BigInt.asUintN(64,T))}}catch(L){D={tag:"err",val:pn(L)}}for(let L of B0)L[N0]=null;B0=[];var _=D;switch(_.tag){case"ok":{let L=_.val;Q(S).setInt8(A+0,0,!0);var r=L,t=r.byteLength,e=H0(0,0,1,t*1),I=new Uint8Array(r.buffer||r,r.byteOffset,t*1);new Uint8Array(S.buffer,e,t*1).set(I),Q(S).setInt32(A+8,t,!0),Q(S).setInt32(A+4,e,!0);break}case"err":{let L=_.val;Q(S).setInt8(A+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(Q(S).setInt8(A+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[N0];if(!U){let u=i[j0]||++Ot;st.set(u,i),U=Ft(l0,u)}Q(S).setInt32(A+8,U,!0);break}case"closed":{Q(S).setInt8(A+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Bn(E,T,A){var h=E,C=t0[(h<<1)+1]&~it,f=$.get(C);f||(f=Object.create(z0.prototype),Object.defineProperty(f,N0,{writable:!0,value:h}),Object.defineProperty(f,j0,{writable:!0,value:C})),B0.push(f);let D;try{D={tag:"ok",val:f.blockingRead(BigInt.asUintN(64,T))}}catch(L){D={tag:"err",val:pn(L)}}for(let L of B0)L[N0]=null;B0=[];var _=D;switch(_.tag){case"ok":{let L=_.val;Q(S).setInt8(A+0,0,!0);var r=L,t=r.byteLength,e=H0(0,0,1,t*1),I=new Uint8Array(r.buffer||r,r.byteOffset,t*1);new Uint8Array(S.buffer,e,t*1).set(I),Q(S).setInt32(A+8,t,!0),Q(S).setInt32(A+4,e,!0);break}case"err":{let L=_.val;Q(S).setInt8(A+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(Q(S).setInt8(A+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[N0];if(!U){let u=i[j0]||++Ot;st.set(u,i),U=Ft(l0,u)}Q(S).setInt32(A+8,U,!0);break}case"closed":{Q(S).setInt8(A+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function St(E,T){var A=E,h=D0[(A<<1)+1]&~it,C=f0.get(h);C||(C=Object.create(w0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.checkWrite()}}catch(t){f={tag:"err",val:pn(t)}}for(let t of B0)t[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;Q(S).setInt8(T+0,0,!0),Q(S).setBigInt64(T+8,se(t),!0);break}case"err":{let t=D.val;Q(S).setInt8(T+0,1,!0);var _=t;switch(_.tag){case"last-operation-failed":{let e=_.val;if(Q(S).setInt8(T+8,0,!0),!(e instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var r=e[N0];if(!r){let I=e[j0]||++Ot;st.set(I,e),r=Ft(l0,I)}Q(S).setInt32(T+12,r,!0);break}case"closed":{Q(S).setInt8(T+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(_.tag)}\` (received \`${_}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ct(E,T,A,h){var C=E,f=D0[(C<<1)+1]&~it,D=f0.get(f);D||(D=Object.create(w0.prototype),Object.defineProperty(D,N0,{writable:!0,value:C}),Object.defineProperty(D,j0,{writable:!0,value:f})),B0.push(D);var _=T,r=A,t=new Uint8Array(S.buffer.slice(_,_+r*1));let e;try{e={tag:"ok",val:D.write(t)}}catch(L){e={tag:"err",val:pn(L)}}for(let L of B0)L[N0]=null;B0=[];var I=e;switch(I.tag){case"ok":{let L=I.val;Q(S).setInt8(h+0,0,!0);break}case"err":{let L=I.val;Q(S).setInt8(h+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(Q(S).setInt8(h+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[N0];if(!U){let u=i[j0]||++Ot;st.set(u,i),U=Ft(l0,u)}Q(S).setInt32(h+8,U,!0);break}case"closed":{Q(S).setInt8(h+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ft(E,T,A,h){var C=E,f=D0[(C<<1)+1]&~it,D=f0.get(f);D||(D=Object.create(w0.prototype),Object.defineProperty(D,N0,{writable:!0,value:C}),Object.defineProperty(D,j0,{writable:!0,value:f})),B0.push(D);var _=T,r=A,t=new Uint8Array(S.buffer.slice(_,_+r*1));let e;try{e={tag:"ok",val:D.blockingWriteAndFlush(t)}}catch(L){e={tag:"err",val:pn(L)}}for(let L of B0)L[N0]=null;B0=[];var I=e;switch(I.tag){case"ok":{let L=I.val;Q(S).setInt8(h+0,0,!0);break}case"err":{let L=I.val;Q(S).setInt8(h+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(Q(S).setInt8(h+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[N0];if(!U){let u=i[j0]||++Ot;st.set(u,i),U=Ft(l0,u)}Q(S).setInt32(h+8,U,!0);break}case"closed":{Q(S).setInt8(h+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Jt(E,T){var A=E,h=D0[(A<<1)+1]&~it,C=f0.get(h);C||(C=Object.create(w0.prototype),Object.defineProperty(C,N0,{writable:!0,value:A}),Object.defineProperty(C,j0,{writable:!0,value:h})),B0.push(C);let f;try{f={tag:"ok",val:C.blockingFlush()}}catch(t){f={tag:"err",val:pn(t)}}for(let t of B0)t[N0]=null;B0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;Q(S).setInt8(T+0,0,!0);break}case"err":{let t=D.val;Q(S).setInt8(T+0,1,!0);var _=t;switch(_.tag){case"last-operation-failed":{let e=_.val;if(Q(S).setInt8(T+4,0,!0),!(e instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var r=e[N0];if(!r){let I=e[j0]||++Ot;st.set(I,e),r=Ft(l0,I)}Q(S).setInt32(T+8,r,!0);break}case"closed":{Q(S).setInt8(T+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(_.tag)}\` (received \`${_}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function tn(E){var A=tt(),h=A.length,C=H0(0,0,4,h*12);for(let e=0;e<A.length;e++){let I=A[e],y=C+e*12;var[f,D]=I;if(!(f instanceof Z0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var _=f[N0];if(!_){let U=f[j0]||++b0;x.set(U,f),_=Ft(d0,U)}Q(S).setInt32(y+0,_,!0);var r=Oe(D,H0,S),t=Ie;Q(S).setInt32(y+8,t,!0),Q(S).setInt32(y+4,r,!0)}Q(S).setInt32(E+4,h,!0),Q(S).setInt32(E+0,C,!0)}let Yt=[it,0],Gt=new Map,dt=0;qn[3]=Yt;function Dt(E){var A=fn();if(A==null)Q(S).setInt8(E+0,0,!0);else{let C=A;if(Q(S).setInt8(E+0,1,!0),!(C instanceof y0))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var h=C[N0];if(!h){let f=C[j0]||++dt;Gt.set(f,C),h=Ft(Yt,f)}Q(S).setInt32(E+4,h,!0)}}let Tt=[it,0],Mt=new Map,zt=0;qn[4]=Tt;function nn(E){var A=Et();if(A==null)Q(S).setInt8(E+0,0,!0);else{let C=A;if(Q(S).setInt8(E+0,1,!0),!(C instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var h=C[N0];if(!h){let f=C[j0]||++zt;Mt.set(f,C),h=Ft(Tt,f)}Q(S).setInt32(E+4,h,!0)}}function un(E){var A=Sn();if(A==null)Q(S).setInt8(E+0,0,!0);else{let C=A;if(Q(S).setInt8(E+0,1,!0),!(C instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var h=C[N0];if(!h){let f=C[j0]||++zt;Mt.set(f,C),h=Ft(Tt,f)}Q(S).setInt32(E+4,h,!0)}}let ht,At=[it,0],Ht=new Map,Hn=0;qn[6]=At;function Wn(E){if(Jn(At,E).own)throw new TypeError("unreachable resource trampoline")}function en(E){let T=Jn(D0,E);if(T.own){let A=f0.get(T.rep);A?(A[Dn]&&A[Dn](),f0.delete(T.rep)):w0[dn]&&w0[dn](T.rep)}}function _n(E){let T=Jn(l0,E);if(T.own){let A=st.get(T.rep);A?(A[Dn]&&A[Dn](),st.delete(T.rep)):a0[dn]&&a0[dn](T.rep)}}function Tn(E){let T=Jn(t0,E);if(T.own){let A=$.get(T.rep);A?(A[Dn]&&A[Dn](),$.delete(T.rep)):z0[dn]&&z0[dn](T.rep)}}function yn(E){let T=Jn(d0,E);if(T.own){let A=x.get(T.rep);A?(A[Dn]&&A[Dn](),x.delete(T.rep)):Z0[dn]&&Z0[dn](T.rep)}}function rn(E){let T=Jn(Yt,E);if(T.own){let A=Gt.get(T.rep);A?(A[Dn]&&A[Dn](),Gt.delete(T.rep)):y0[dn]&&y0[dn](T.rep)}}function Xt(E){let T=Jn(Tt,E);if(T.own){let A=Mt.get(T.rep);A?(A[Dn]&&A[Dn](),Mt.delete(T.rep)):Lt[dn]&&Lt[dn](T.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:X}=yield b(yield z),{exports:S0}=yield b(yield M,{wasi_snapshot_preview1:{args_get:X[20],args_sizes_get:X[21],environ_get:X[22],environ_sizes_get:X[23],fd_close:X[24],fd_fdstat_get:X[25],fd_fdstat_set_flags:X[26],fd_prestat_dir_name:X[28],fd_prestat_get:X[27],fd_read:X[29],fd_seek:X[30],fd_write:X[31],path_open:X[32],proc_exit:X[33]}}),{exports:F}=yield b(yield G,{__main_module__:{_start:S0._start},env:{memory:S0.memory},"wasi:cli/environment@0.2.0":{"get-arguments":X[1],"get-environment":X[0]},"wasi:cli/exit@0.2.0":{exit:P0},"wasi:cli/stderr@0.2.0":{"get-stderr":nt},"wasi:cli/stdin@0.2.0":{"get-stdin":ut},"wasi:cli/stdout@0.2.0":{"get-stdout":et},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":rn},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":Xt},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":X[19]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":X[17]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":X[18]},"wasi:filesystem/preopens@0.2.0":{"get-directories":X[16]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":X[4],"[method]descriptor.get-flags":X[5],"[method]descriptor.get-type":X[6],"[method]descriptor.open-at":X[8],"[method]descriptor.read-via-stream":X[2],"[method]descriptor.stat":X[7],"[method]descriptor.write-via-stream":X[3],"[resource-drop]descriptor":yn,"[resource-drop]directory-entry-stream":Wn,"filesystem-error-code":X[9]},"wasi:io/error@0.2.0":{"[resource-drop]error":_n},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":X[11],"[method]input-stream.read":X[10],"[method]output-stream.blocking-flush":X[15],"[method]output-stream.blocking-write-and-flush":X[14],"[method]output-stream.check-write":X[12],"[method]output-stream.write":X[13],"[resource-drop]input-stream":Tn,"[resource-drop]output-stream":en}}),S=S0.memory,H0=F.cabi_import_realloc,{exports:ht}=yield b(yield m0,{"":{$imports:X.$imports,0:pt,1:lt,10:gn,11:Bn,12:St,13:ct,14:ft,15:Jt,16:tn,17:Dt,18:nn,19:un,2:v,20:F.args_get,21:F.args_sizes_get,22:F.environ_get,23:F.environ_sizes_get,24:F.fd_close,25:F.fd_fdstat_get,26:F.fd_fdstat_set_flags,27:F.fd_prestat_get,28:F.fd_prestat_dir_name,29:F.fd_read,3:W,30:F.fd_seek,31:F.fd_write,32:F.path_open,33:F.proc_exit,4:Rt,5:mt,6:Ct,7:U0,8:A0,9:hn}});function n0(){let E=F["wasi:cli/run@0.2.0#run"](),T;switch(E){case 0:{T={tag:"ok",val:void 0};break}case 1:{T={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(T.tag==="err")throw new hr(T.val);return T.val}let Y={run:n0};return{run:Y,"wasi:cli/run@0.2.0":Y}}(),v0,Y0,ot;function qt(r0){try{let X;do({value:r0,done:X}=It.next(r0));while(!(r0 instanceof Promise)&&!X);if(X)if(Y0)Y0(r0);else return r0;v0||(v0=new Promise((S0,D0)=>(Y0=S0,ot=D0))),r0.then(S0=>X?Y0():qt(S0),ot)}catch(X){if(ot)ot(X);else throw X}}let bt=qt(null);return v0||bt}var Mr=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},W0=[],Ue=new DataView(new ArrayBuffer),V=n=>Ue.buffer===n.buffer?Ue:Ue=new DataView(n.buffer);function In(n){if(n&&Hr.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var te=[],Hr=Object.prototype.hasOwnProperty,at=1<<30;function Ut(n,l){let b=n[0]&~at;return b===0?(n.push(0),n.push(l|at),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|at,b)}function ne(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&at)!==0,z=M&~at;if(M===0||(b&at)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|at,n[0]=l|at,{rep:z,scope:b,own:G}}var En=Symbol.for("cabiDispose"),L0=Symbol("handle"),q0=Symbol.for("cabiRep"),mn=Symbol.dispose||Symbol.for("dispose"),oe=n=>BigInt.asUintN(64,BigInt(n));function xe(n){return n>>>0}var yr=new TextDecoder,wr=new TextEncoder,ue=0;function Ne(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return ue=0,1;let M=wr.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),ue=M.length,G}function h_(n,l,b=WebAssembly.instantiate){let M=n("icepack.core.wasm"),G=n("icepack.core2.wasm"),z=n("icepack.core3.wasm"),m0=n("icepack.core4.wasm"),{cli:J0,fs:x0,io:K0}=l.runtime,{TerminalInput:y0,TerminalOutput:Lt,exit:jt,getArguments:Pt,getEnvironment:vt,getStderr:Nn,getStdin:Ln,getStdout:bn,getTerminalStderr:Sn,getTerminalStdin:fn,getTerminalStdout:Et}=J0,{Descriptor:Z0,filesystemErrorCode:Pn,getDirectories:tt}=x0,{Error:a0,InputStream:z0,OutputStream:w0}=K0,It=function*(){let X,S0,D0=[at,0],f0=new Map,s0=0;te[2]=D0;function nt(){let E=Nn();if(!(E instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var T=E[L0];if(!T){let A=E[q0]||++s0;f0.set(A,E),T=Ut(D0,A)}return T}let t0=[at,0],$=new Map,Q0=0;te[1]=t0;function ut(){let E=Ln();if(!(E instanceof z0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var T=E[L0];if(!T){let A=E[q0]||++Q0;$.set(A,E),T=Ut(t0,A)}return T}function et(){let E=bn();if(!(E instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var T=E[L0];if(!T){let A=E[q0]||++s0;f0.set(A,E),T=Ut(D0,A)}return T}function P0(E){let T;switch(E){case 0:{T={tag:"ok",val:void 0};break}case 1:{T={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}jt(T)}let F,S,H0;function pt(E){var A=vt(),h=A.length,C=H0(0,0,4,h*16);for(let I=0;I<A.length;I++){let y=A[I],U=C+I*16;var[f,D]=y,_=Ne(f,H0,S),r=ue;V(S).setInt32(U+4,r,!0),V(S).setInt32(U+0,_,!0);var t=Ne(D,H0,S),e=ue;V(S).setInt32(U+12,e,!0),V(S).setInt32(U+8,t,!0)}V(S).setInt32(E+4,h,!0),V(S).setInt32(E+0,C,!0)}function lt(E){var A=Pt(),h=A.length,C=H0(0,0,4,h*8);for(let _=0;_<A.length;_++){let r=A[_],t=C+_*8;var f=Ne(r,H0,S),D=ue;V(S).setInt32(t+4,D,!0),V(S).setInt32(t+0,f,!0)}V(S).setInt32(E+4,h,!0),V(S).setInt32(E+0,C,!0)}let d0=[at,0],x=new Map,b0=0;te[5]=d0;function v(E,T,A){var h=E,C=d0[(h<<1)+1]&~at,f=x.get(C);f||(f=Object.create(Z0.prototype),Object.defineProperty(f,L0,{writable:!0,value:h}),Object.defineProperty(f,q0,{writable:!0,value:C})),W0.push(f);let D;try{D={tag:"ok",val:f.readViaStream(BigInt.asUintN(64,T))}}catch(e){D={tag:"err",val:In(e)}}for(let e of W0)e[L0]=null;W0=[];var _=D;switch(_.tag){case"ok":{let e=_.val;if(V(S).setInt8(A+0,0,!0),!(e instanceof z0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var r=e[L0];if(!r){let I=e[q0]||++Q0;$.set(I,e),r=Ut(t0,I)}V(S).setInt32(A+4,r,!0);break}case"err":{let e=_.val;V(S).setInt8(A+0,1,!0);var t=e;let I;switch(t){case"access":{I=0;break}case"would-block":{I=1;break}case"already":{I=2;break}case"bad-descriptor":{I=3;break}case"busy":{I=4;break}case"deadlock":{I=5;break}case"quota":{I=6;break}case"exist":{I=7;break}case"file-too-large":{I=8;break}case"illegal-byte-sequence":{I=9;break}case"in-progress":{I=10;break}case"interrupted":{I=11;break}case"invalid":{I=12;break}case"io":{I=13;break}case"is-directory":{I=14;break}case"loop":{I=15;break}case"too-many-links":{I=16;break}case"message-size":{I=17;break}case"name-too-long":{I=18;break}case"no-device":{I=19;break}case"no-entry":{I=20;break}case"no-lock":{I=21;break}case"insufficient-memory":{I=22;break}case"insufficient-space":{I=23;break}case"not-directory":{I=24;break}case"not-empty":{I=25;break}case"not-recoverable":{I=26;break}case"unsupported":{I=27;break}case"no-tty":{I=28;break}case"no-such-device":{I=29;break}case"overflow":{I=30;break}case"not-permitted":{I=31;break}case"pipe":{I=32;break}case"read-only":{I=33;break}case"invalid-seek":{I=34;break}case"text-file-busy":{I=35;break}case"cross-device":{I=36;break}default:throw e instanceof Error&&console.error(e),new TypeError(`"${t}" is not one of the cases of error-code`)}V(S).setInt8(A+4,I,!0);break}default:throw new TypeError("invalid variant specified for result")}}function W(E,T,A){var h=E,C=d0[(h<<1)+1]&~at,f=x.get(C);f||(f=Object.create(Z0.prototype),Object.defineProperty(f,L0,{writable:!0,value:h}),Object.defineProperty(f,q0,{writable:!0,value:C})),W0.push(f);let D;try{D={tag:"ok",val:f.writeViaStream(BigInt.asUintN(64,T))}}catch(e){D={tag:"err",val:In(e)}}for(let e of W0)e[L0]=null;W0=[];var _=D;switch(_.tag){case"ok":{let e=_.val;if(V(S).setInt8(A+0,0,!0),!(e instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var r=e[L0];if(!r){let I=e[q0]||++s0;f0.set(I,e),r=Ut(D0,I)}V(S).setInt32(A+4,r,!0);break}case"err":{let e=_.val;V(S).setInt8(A+0,1,!0);var t=e;let I;switch(t){case"access":{I=0;break}case"would-block":{I=1;break}case"already":{I=2;break}case"bad-descriptor":{I=3;break}case"busy":{I=4;break}case"deadlock":{I=5;break}case"quota":{I=6;break}case"exist":{I=7;break}case"file-too-large":{I=8;break}case"illegal-byte-sequence":{I=9;break}case"in-progress":{I=10;break}case"interrupted":{I=11;break}case"invalid":{I=12;break}case"io":{I=13;break}case"is-directory":{I=14;break}case"loop":{I=15;break}case"too-many-links":{I=16;break}case"message-size":{I=17;break}case"name-too-long":{I=18;break}case"no-device":{I=19;break}case"no-entry":{I=20;break}case"no-lock":{I=21;break}case"insufficient-memory":{I=22;break}case"insufficient-space":{I=23;break}case"not-directory":{I=24;break}case"not-empty":{I=25;break}case"not-recoverable":{I=26;break}case"unsupported":{I=27;break}case"no-tty":{I=28;break}case"no-such-device":{I=29;break}case"overflow":{I=30;break}case"not-permitted":{I=31;break}case"pipe":{I=32;break}case"read-only":{I=33;break}case"invalid-seek":{I=34;break}case"text-file-busy":{I=35;break}case"cross-device":{I=36;break}default:throw e instanceof Error&&console.error(e),new TypeError(`"${t}" is not one of the cases of error-code`)}V(S).setInt8(A+4,I,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Rt(E,T){var A=E,h=d0[(A<<1)+1]&~at,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.appendViaStream()}}catch(t){f={tag:"err",val:In(t)}}for(let t of W0)t[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;if(V(S).setInt8(T+0,0,!0),!(t instanceof w0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var _=t[L0];if(!_){let e=t[q0]||++s0;f0.set(e,t),_=Ut(D0,e)}V(S).setInt32(T+4,_,!0);break}case"err":{let t=D.val;V(S).setInt8(T+0,1,!0);var r=t;let e;switch(r){case"access":{e=0;break}case"would-block":{e=1;break}case"already":{e=2;break}case"bad-descriptor":{e=3;break}case"busy":{e=4;break}case"deadlock":{e=5;break}case"quota":{e=6;break}case"exist":{e=7;break}case"file-too-large":{e=8;break}case"illegal-byte-sequence":{e=9;break}case"in-progress":{e=10;break}case"interrupted":{e=11;break}case"invalid":{e=12;break}case"io":{e=13;break}case"is-directory":{e=14;break}case"loop":{e=15;break}case"too-many-links":{e=16;break}case"message-size":{e=17;break}case"name-too-long":{e=18;break}case"no-device":{e=19;break}case"no-entry":{e=20;break}case"no-lock":{e=21;break}case"insufficient-memory":{e=22;break}case"insufficient-space":{e=23;break}case"not-directory":{e=24;break}case"not-empty":{e=25;break}case"not-recoverable":{e=26;break}case"unsupported":{e=27;break}case"no-tty":{e=28;break}case"no-such-device":{e=29;break}case"overflow":{e=30;break}case"not-permitted":{e=31;break}case"pipe":{e=32;break}case"read-only":{e=33;break}case"invalid-seek":{e=34;break}case"text-file-busy":{e=35;break}case"cross-device":{e=36;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${r}" is not one of the cases of error-code`)}V(S).setInt8(T+4,e,!0);break}default:throw new TypeError("invalid variant specified for result")}}function mt(E,T){var A=E,h=d0[(A<<1)+1]&~at,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.getFlags()}}catch(r){f={tag:"err",val:In(r)}}for(let r of W0)r[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let r=D.val;V(S).setInt8(T+0,0,!0);let t=0;if(typeof r=="object"&&r!==null)t=!!r.read<<0|!!r.write<<1|!!r.fileIntegritySync<<2|!!r.dataIntegritySync<<3|!!r.requestedWriteSync<<4|!!r.mutateDirectory<<5;else if(r!=null)throw new TypeError("only an object, undefined or null can be converted to flags");V(S).setInt8(T+1,t,!0);break}case"err":{let r=D.val;V(S).setInt8(T+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}V(S).setInt8(T+1,t,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ct(E,T){var A=E,h=d0[(A<<1)+1]&~at,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.getType()}}catch(t){f={tag:"err",val:In(t)}}for(let t of W0)t[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;V(S).setInt8(T+0,0,!0);var _=t;let e;switch(_){case"unknown":{e=0;break}case"block-device":{e=1;break}case"character-device":{e=2;break}case"directory":{e=3;break}case"fifo":{e=4;break}case"symbolic-link":{e=5;break}case"regular-file":{e=6;break}case"socket":{e=7;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${_}" is not one of the cases of descriptor-type`)}V(S).setInt8(T+1,e,!0);break}case"err":{let t=D.val;V(S).setInt8(T+0,1,!0);var r=t;let e;switch(r){case"access":{e=0;break}case"would-block":{e=1;break}case"already":{e=2;break}case"bad-descriptor":{e=3;break}case"busy":{e=4;break}case"deadlock":{e=5;break}case"quota":{e=6;break}case"exist":{e=7;break}case"file-too-large":{e=8;break}case"illegal-byte-sequence":{e=9;break}case"in-progress":{e=10;break}case"interrupted":{e=11;break}case"invalid":{e=12;break}case"io":{e=13;break}case"is-directory":{e=14;break}case"loop":{e=15;break}case"too-many-links":{e=16;break}case"message-size":{e=17;break}case"name-too-long":{e=18;break}case"no-device":{e=19;break}case"no-entry":{e=20;break}case"no-lock":{e=21;break}case"insufficient-memory":{e=22;break}case"insufficient-space":{e=23;break}case"not-directory":{e=24;break}case"not-empty":{e=25;break}case"not-recoverable":{e=26;break}case"unsupported":{e=27;break}case"no-tty":{e=28;break}case"no-such-device":{e=29;break}case"overflow":{e=30;break}case"not-permitted":{e=31;break}case"pipe":{e=32;break}case"read-only":{e=33;break}case"invalid-seek":{e=34;break}case"text-file-busy":{e=35;break}case"cross-device":{e=36;break}default:throw t instanceof Error&&console.error(t),new TypeError(`"${r}" is not one of the cases of error-code`)}V(S).setInt8(T+1,e,!0);break}default:throw new TypeError("invalid variant specified for result")}}function U0(E,T){var A=E,h=d0[(A<<1)+1]&~at,C=x.get(h);C||(C=Object.create(Z0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.stat()}}catch(p){f={tag:"err",val:In(p)}}for(let p of W0)p[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let p=D.val;V(S).setInt8(T+0,0,!0);var{type:_,linkCount:r,size:t,dataAccessTimestamp:e,dataModificationTimestamp:I,statusChangeTimestamp:y}=p,U=_;let s;switch(U){case"unknown":{s=0;break}case"block-device":{s=1;break}case"character-device":{s=2;break}case"directory":{s=3;break}case"fifo":{s=4;break}case"symbolic-link":{s=5;break}case"regular-file":{s=6;break}case"socket":{s=7;break}default:throw _ instanceof Error&&console.error(_),new TypeError(`"${U}" is not one of the cases of descriptor-type`)}V(S).setInt8(T+8,s,!0),V(S).setBigInt64(T+16,oe(r),!0),V(S).setBigInt64(T+24,oe(t),!0);var L=e;if(L==null)V(S).setInt8(T+32,0,!0);else{let w=L;V(S).setInt8(T+32,1,!0);var{seconds:i,nanoseconds:u}=w;V(S).setBigInt64(T+40,oe(i),!0),V(S).setInt32(T+48,xe(u),!0)}var P=I;if(P==null)V(S).setInt8(T+56,0,!0);else{let w=P;V(S).setInt8(T+56,1,!0);var{seconds:R,nanoseconds:a}=w;V(S).setBigInt64(T+64,oe(R),!0),V(S).setInt32(T+72,xe(a),!0)}var d=y;if(d==null)V(S).setInt8(T+80,0,!0);else{let w=d;V(S).setInt8(T+80,1,!0);var{seconds:c,nanoseconds:m}=w;V(S).setBigInt64(T+88,oe(c),!0),V(S).setInt32(T+96,xe(m),!0)}break}case"err":{let p=D.val;V(S).setInt8(T+0,1,!0);var o=p;let s;switch(o){case"access":{s=0;break}case"would-block":{s=1;break}case"already":{s=2;break}case"bad-descriptor":{s=3;break}case"busy":{s=4;break}case"deadlock":{s=5;break}case"quota":{s=6;break}case"exist":{s=7;break}case"file-too-large":{s=8;break}case"illegal-byte-sequence":{s=9;break}case"in-progress":{s=10;break}case"interrupted":{s=11;break}case"invalid":{s=12;break}case"io":{s=13;break}case"is-directory":{s=14;break}case"loop":{s=15;break}case"too-many-links":{s=16;break}case"message-size":{s=17;break}case"name-too-long":{s=18;break}case"no-device":{s=19;break}case"no-entry":{s=20;break}case"no-lock":{s=21;break}case"insufficient-memory":{s=22;break}case"insufficient-space":{s=23;break}case"not-directory":{s=24;break}case"not-empty":{s=25;break}case"not-recoverable":{s=26;break}case"unsupported":{s=27;break}case"no-tty":{s=28;break}case"no-such-device":{s=29;break}case"overflow":{s=30;break}case"not-permitted":{s=31;break}case"pipe":{s=32;break}case"read-only":{s=33;break}case"invalid-seek":{s=34;break}case"text-file-busy":{s=35;break}case"cross-device":{s=36;break}default:throw p instanceof Error&&console.error(p),new TypeError(`"${o}" is not one of the cases of error-code`)}V(S).setInt8(T+8,s,!0);break}default:throw new TypeError("invalid variant specified for result")}}function A0(E,T,A,h,C,f,D){var _=E,r=d0[(_<<1)+1]&~at,t=x.get(r);if(t||(t=Object.create(Z0.prototype),Object.defineProperty(t,L0,{writable:!0,value:_}),Object.defineProperty(t,q0,{writable:!0,value:r})),W0.push(t),(T&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var e={symlinkFollow:!!(T&1)},I=A,y=h,U=yr.decode(new Uint8Array(S.buffer,I,y));if((C&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var L={create:!!(C&1),directory:!!(C&2),exclusive:!!(C&4),truncate:!!(C&8)};if((f&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var i={read:!!(f&1),write:!!(f&2),fileIntegritySync:!!(f&4),dataIntegritySync:!!(f&8),requestedWriteSync:!!(f&16),mutateDirectory:!!(f&32)};let u;try{u={tag:"ok",val:t.openAt(e,U,L,i)}}catch(d){u={tag:"err",val:In(d)}}for(let d of W0)d[L0]=null;W0=[];var P=u;switch(P.tag){case"ok":{let d=P.val;if(V(S).setInt8(D+0,0,!0),!(d instanceof Z0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var R=d[L0];if(!R){let c=d[q0]||++b0;x.set(c,d),R=Ut(d0,c)}V(S).setInt32(D+4,R,!0);break}case"err":{let d=P.val;V(S).setInt8(D+0,1,!0);var a=d;let c;switch(a){case"access":{c=0;break}case"would-block":{c=1;break}case"already":{c=2;break}case"bad-descriptor":{c=3;break}case"busy":{c=4;break}case"deadlock":{c=5;break}case"quota":{c=6;break}case"exist":{c=7;break}case"file-too-large":{c=8;break}case"illegal-byte-sequence":{c=9;break}case"in-progress":{c=10;break}case"interrupted":{c=11;break}case"invalid":{c=12;break}case"io":{c=13;break}case"is-directory":{c=14;break}case"loop":{c=15;break}case"too-many-links":{c=16;break}case"message-size":{c=17;break}case"name-too-long":{c=18;break}case"no-device":{c=19;break}case"no-entry":{c=20;break}case"no-lock":{c=21;break}case"insufficient-memory":{c=22;break}case"insufficient-space":{c=23;break}case"not-directory":{c=24;break}case"not-empty":{c=25;break}case"not-recoverable":{c=26;break}case"unsupported":{c=27;break}case"no-tty":{c=28;break}case"no-such-device":{c=29;break}case"overflow":{c=30;break}case"not-permitted":{c=31;break}case"pipe":{c=32;break}case"read-only":{c=33;break}case"invalid-seek":{c=34;break}case"text-file-busy":{c=35;break}case"cross-device":{c=36;break}default:throw d instanceof Error&&console.error(d),new TypeError(`"${a}" is not one of the cases of error-code`)}V(S).setInt8(D+4,c,!0);break}default:throw new TypeError("invalid variant specified for result")}}let l0=[at,0],st=new Map,Ot=0;te[0]=l0;function hn(E,T){var A=E,h=l0[(A<<1)+1]&~at,C=st.get(h);C||(C=Object.create(a0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f=Pn(C);for(let r of W0)r[L0]=null;W0=[];var D=f;if(D==null)V(S).setInt8(T+0,0,!0);else{let r=D;V(S).setInt8(T+0,1,!0);var _=r;let t;switch(_){case"access":{t=0;break}case"would-block":{t=1;break}case"already":{t=2;break}case"bad-descriptor":{t=3;break}case"busy":{t=4;break}case"deadlock":{t=5;break}case"quota":{t=6;break}case"exist":{t=7;break}case"file-too-large":{t=8;break}case"illegal-byte-sequence":{t=9;break}case"in-progress":{t=10;break}case"interrupted":{t=11;break}case"invalid":{t=12;break}case"io":{t=13;break}case"is-directory":{t=14;break}case"loop":{t=15;break}case"too-many-links":{t=16;break}case"message-size":{t=17;break}case"name-too-long":{t=18;break}case"no-device":{t=19;break}case"no-entry":{t=20;break}case"no-lock":{t=21;break}case"insufficient-memory":{t=22;break}case"insufficient-space":{t=23;break}case"not-directory":{t=24;break}case"not-empty":{t=25;break}case"not-recoverable":{t=26;break}case"unsupported":{t=27;break}case"no-tty":{t=28;break}case"no-such-device":{t=29;break}case"overflow":{t=30;break}case"not-permitted":{t=31;break}case"pipe":{t=32;break}case"read-only":{t=33;break}case"invalid-seek":{t=34;break}case"text-file-busy":{t=35;break}case"cross-device":{t=36;break}default:throw r instanceof Error&&console.error(r),new TypeError(`"${_}" is not one of the cases of error-code`)}V(S).setInt8(T+1,t,!0)}}function gn(E,T,A){var h=E,C=t0[(h<<1)+1]&~at,f=$.get(C);f||(f=Object.create(z0.prototype),Object.defineProperty(f,L0,{writable:!0,value:h}),Object.defineProperty(f,q0,{writable:!0,value:C})),W0.push(f);let D;try{D={tag:"ok",val:f.read(BigInt.asUintN(64,T))}}catch(L){D={tag:"err",val:In(L)}}for(let L of W0)L[L0]=null;W0=[];var _=D;switch(_.tag){case"ok":{let L=_.val;V(S).setInt8(A+0,0,!0);var r=L,t=r.byteLength,e=H0(0,0,1,t*1),I=new Uint8Array(r.buffer||r,r.byteOffset,t*1);new Uint8Array(S.buffer,e,t*1).set(I),V(S).setInt32(A+8,t,!0),V(S).setInt32(A+4,e,!0);break}case"err":{let L=_.val;V(S).setInt8(A+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(V(S).setInt8(A+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[L0];if(!U){let u=i[q0]||++Ot;st.set(u,i),U=Ut(l0,u)}V(S).setInt32(A+8,U,!0);break}case"closed":{V(S).setInt8(A+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Bn(E,T,A){var h=E,C=t0[(h<<1)+1]&~at,f=$.get(C);f||(f=Object.create(z0.prototype),Object.defineProperty(f,L0,{writable:!0,value:h}),Object.defineProperty(f,q0,{writable:!0,value:C})),W0.push(f);let D;try{D={tag:"ok",val:f.blockingRead(BigInt.asUintN(64,T))}}catch(L){D={tag:"err",val:In(L)}}for(let L of W0)L[L0]=null;W0=[];var _=D;switch(_.tag){case"ok":{let L=_.val;V(S).setInt8(A+0,0,!0);var r=L,t=r.byteLength,e=H0(0,0,1,t*1),I=new Uint8Array(r.buffer||r,r.byteOffset,t*1);new Uint8Array(S.buffer,e,t*1).set(I),V(S).setInt32(A+8,t,!0),V(S).setInt32(A+4,e,!0);break}case"err":{let L=_.val;V(S).setInt8(A+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(V(S).setInt8(A+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[L0];if(!U){let u=i[q0]||++Ot;st.set(u,i),U=Ut(l0,u)}V(S).setInt32(A+8,U,!0);break}case"closed":{V(S).setInt8(A+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function St(E,T){var A=E,h=D0[(A<<1)+1]&~at,C=f0.get(h);C||(C=Object.create(w0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.checkWrite()}}catch(t){f={tag:"err",val:In(t)}}for(let t of W0)t[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;V(S).setInt8(T+0,0,!0),V(S).setBigInt64(T+8,oe(t),!0);break}case"err":{let t=D.val;V(S).setInt8(T+0,1,!0);var _=t;switch(_.tag){case"last-operation-failed":{let e=_.val;if(V(S).setInt8(T+8,0,!0),!(e instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var r=e[L0];if(!r){let I=e[q0]||++Ot;st.set(I,e),r=Ut(l0,I)}V(S).setInt32(T+12,r,!0);break}case"closed":{V(S).setInt8(T+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(_.tag)}\` (received \`${_}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ct(E,T,A,h){var C=E,f=D0[(C<<1)+1]&~at,D=f0.get(f);D||(D=Object.create(w0.prototype),Object.defineProperty(D,L0,{writable:!0,value:C}),Object.defineProperty(D,q0,{writable:!0,value:f})),W0.push(D);var _=T,r=A,t=new Uint8Array(S.buffer.slice(_,_+r*1));let e;try{e={tag:"ok",val:D.write(t)}}catch(L){e={tag:"err",val:In(L)}}for(let L of W0)L[L0]=null;W0=[];var I=e;switch(I.tag){case"ok":{let L=I.val;V(S).setInt8(h+0,0,!0);break}case"err":{let L=I.val;V(S).setInt8(h+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(V(S).setInt8(h+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[L0];if(!U){let u=i[q0]||++Ot;st.set(u,i),U=Ut(l0,u)}V(S).setInt32(h+8,U,!0);break}case"closed":{V(S).setInt8(h+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ft(E,T,A,h){var C=E,f=D0[(C<<1)+1]&~at,D=f0.get(f);D||(D=Object.create(w0.prototype),Object.defineProperty(D,L0,{writable:!0,value:C}),Object.defineProperty(D,q0,{writable:!0,value:f})),W0.push(D);var _=T,r=A,t=new Uint8Array(S.buffer.slice(_,_+r*1));let e;try{e={tag:"ok",val:D.blockingWriteAndFlush(t)}}catch(L){e={tag:"err",val:In(L)}}for(let L of W0)L[L0]=null;W0=[];var I=e;switch(I.tag){case"ok":{let L=I.val;V(S).setInt8(h+0,0,!0);break}case"err":{let L=I.val;V(S).setInt8(h+0,1,!0);var y=L;switch(y.tag){case"last-operation-failed":{let i=y.val;if(V(S).setInt8(h+4,0,!0),!(i instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var U=i[L0];if(!U){let u=i[q0]||++Ot;st.set(u,i),U=Ut(l0,u)}V(S).setInt32(h+8,U,!0);break}case"closed":{V(S).setInt8(h+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(y.tag)}\` (received \`${y}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Jt(E,T){var A=E,h=D0[(A<<1)+1]&~at,C=f0.get(h);C||(C=Object.create(w0.prototype),Object.defineProperty(C,L0,{writable:!0,value:A}),Object.defineProperty(C,q0,{writable:!0,value:h})),W0.push(C);let f;try{f={tag:"ok",val:C.blockingFlush()}}catch(t){f={tag:"err",val:In(t)}}for(let t of W0)t[L0]=null;W0=[];var D=f;switch(D.tag){case"ok":{let t=D.val;V(S).setInt8(T+0,0,!0);break}case"err":{let t=D.val;V(S).setInt8(T+0,1,!0);var _=t;switch(_.tag){case"last-operation-failed":{let e=_.val;if(V(S).setInt8(T+4,0,!0),!(e instanceof a0))throw new TypeError('Resource error: Not a valid "Error" resource.');var r=e[L0];if(!r){let I=e[q0]||++Ot;st.set(I,e),r=Ut(l0,I)}V(S).setInt32(T+8,r,!0);break}case"closed":{V(S).setInt8(T+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(_.tag)}\` (received \`${_}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function tn(E){var A=tt(),h=A.length,C=H0(0,0,4,h*12);for(let e=0;e<A.length;e++){let I=A[e],y=C+e*12;var[f,D]=I;if(!(f instanceof Z0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var _=f[L0];if(!_){let U=f[q0]||++b0;x.set(U,f),_=Ut(d0,U)}V(S).setInt32(y+0,_,!0);var r=Ne(D,H0,S),t=ue;V(S).setInt32(y+8,t,!0),V(S).setInt32(y+4,r,!0)}V(S).setInt32(E+4,h,!0),V(S).setInt32(E+0,C,!0)}let Yt=[at,0],Gt=new Map,dt=0;te[3]=Yt;function Dt(E){var A=fn();if(A==null)V(S).setInt8(E+0,0,!0);else{let C=A;if(V(S).setInt8(E+0,1,!0),!(C instanceof y0))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var h=C[L0];if(!h){let f=C[q0]||++dt;Gt.set(f,C),h=Ut(Yt,f)}V(S).setInt32(E+4,h,!0)}}let Tt=[at,0],Mt=new Map,zt=0;te[4]=Tt;function nn(E){var A=Et();if(A==null)V(S).setInt8(E+0,0,!0);else{let C=A;if(V(S).setInt8(E+0,1,!0),!(C instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var h=C[L0];if(!h){let f=C[q0]||++zt;Mt.set(f,C),h=Ut(Tt,f)}V(S).setInt32(E+4,h,!0)}}function un(E){var A=Sn();if(A==null)V(S).setInt8(E+0,0,!0);else{let C=A;if(V(S).setInt8(E+0,1,!0),!(C instanceof Lt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var h=C[L0];if(!h){let f=C[q0]||++zt;Mt.set(f,C),h=Ut(Tt,f)}V(S).setInt32(E+4,h,!0)}}let ht,At=[at,0],Ht=new Map,Hn=0;te[6]=At;function Wn(E){if(ne(At,E).own)throw new TypeError("unreachable resource trampoline")}function en(E){let T=ne(D0,E);if(T.own){let A=f0.get(T.rep);A?(A[mn]&&A[mn](),f0.delete(T.rep)):w0[En]&&w0[En](T.rep)}}function _n(E){let T=ne(l0,E);if(T.own){let A=st.get(T.rep);A?(A[mn]&&A[mn](),st.delete(T.rep)):a0[En]&&a0[En](T.rep)}}function Tn(E){let T=ne(t0,E);if(T.own){let A=$.get(T.rep);A?(A[mn]&&A[mn](),$.delete(T.rep)):z0[En]&&z0[En](T.rep)}}function yn(E){let T=ne(d0,E);if(T.own){let A=x.get(T.rep);A?(A[mn]&&A[mn](),x.delete(T.rep)):Z0[En]&&Z0[En](T.rep)}}function rn(E){let T=ne(Yt,E);if(T.own){let A=Gt.get(T.rep);A?(A[mn]&&A[mn](),Gt.delete(T.rep)):y0[En]&&y0[En](T.rep)}}function Xt(E){let T=ne(Tt,E);if(T.own){let A=Mt.get(T.rep);A?(A[mn]&&A[mn](),Mt.delete(T.rep)):Lt[En]&&Lt[En](T.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:X}=yield b(yield z),{exports:S0}=yield b(yield M,{wasi_snapshot_preview1:{args_get:X[20],args_sizes_get:X[21],environ_get:X[22],environ_sizes_get:X[23],fd_close:X[24],fd_fdstat_get:X[25],fd_fdstat_set_flags:X[26],fd_prestat_dir_name:X[28],fd_prestat_get:X[27],fd_read:X[29],fd_seek:X[30],fd_write:X[31],path_open:X[32],proc_exit:X[33]}}),{exports:F}=yield b(yield G,{__main_module__:{_start:S0._start},env:{memory:S0.memory},"wasi:cli/environment@0.2.0":{"get-arguments":X[1],"get-environment":X[0]},"wasi:cli/exit@0.2.0":{exit:P0},"wasi:cli/stderr@0.2.0":{"get-stderr":nt},"wasi:cli/stdin@0.2.0":{"get-stdin":ut},"wasi:cli/stdout@0.2.0":{"get-stdout":et},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":rn},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":Xt},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":X[19]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":X[17]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":X[18]},"wasi:filesystem/preopens@0.2.0":{"get-directories":X[16]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":X[4],"[method]descriptor.get-flags":X[5],"[method]descriptor.get-type":X[6],"[method]descriptor.open-at":X[8],"[method]descriptor.read-via-stream":X[2],"[method]descriptor.stat":X[7],"[method]descriptor.write-via-stream":X[3],"[resource-drop]descriptor":yn,"[resource-drop]directory-entry-stream":Wn,"filesystem-error-code":X[9]},"wasi:io/error@0.2.0":{"[resource-drop]error":_n},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":X[11],"[method]input-stream.read":X[10],"[method]output-stream.blocking-flush":X[15],"[method]output-stream.blocking-write-and-flush":X[14],"[method]output-stream.check-write":X[12],"[method]output-stream.write":X[13],"[resource-drop]input-stream":Tn,"[resource-drop]output-stream":en}}),S=S0.memory,H0=F.cabi_import_realloc,{exports:ht}=yield b(yield m0,{"":{$imports:X.$imports,0:pt,1:lt,10:gn,11:Bn,12:St,13:ct,14:ft,15:Jt,16:tn,17:Dt,18:nn,19:un,2:v,20:F.args_get,21:F.args_sizes_get,22:F.environ_get,23:F.environ_sizes_get,24:F.fd_close,25:F.fd_fdstat_get,26:F.fd_fdstat_set_flags,27:F.fd_prestat_get,28:F.fd_prestat_dir_name,29:F.fd_read,3:W,30:F.fd_seek,31:F.fd_write,32:F.path_open,33:F.proc_exit,4:Rt,5:mt,6:Ct,7:U0,8:A0,9:hn}});function n0(){let E=F["wasi:cli/run@0.2.0#run"](),T;switch(E){case 0:{T={tag:"ok",val:void 0};break}case 1:{T={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(T.tag==="err")throw new Mr(T.val);return T.val}let Y={run:n0};return{run:Y,"wasi:cli/run@0.2.0":Y}}(),v0,Y0,ot;function qt(r0){try{let X;do({value:r0,done:X}=It.next(r0));while(!(r0 instanceof Promise)&&!X);if(X)if(Y0)Y0(r0);else return r0;v0||(v0=new Promise((S0,D0)=>(Y0=S0,ot=D0))),r0.then(S0=>X?Y0():qt(S0),ot)}catch(X){if(ot)ot(X);else throw X}}let bt=qt(null);return v0||bt}var kr=class extends Error{constructor(n){let l=typeof n!="string";super(l?`${String(n)} (see error.payload)`:n),Object.defineProperty(this,"payload",{value:n,enumerable:l})}},p0=[],Ke=new DataView(new ArrayBuffer),K=n=>Ke.buffer===n.buffer?Ke:Ke=new DataView(n.buffer);function Bt(n){if(n&&Fr.call(n,"payload"))return n.payload;if(n instanceof Error)throw n;return n}var ee=[],Fr=Object.prototype.hasOwnProperty,G0=1<<30;function xt(n,l){let b=n[0]&~G0;return b===0?(n.push(0),n.push(l|G0),(n.length>>1)-1):(n[0]=n[b<<1],n[b<<1]=0,n[(b<<1)+1]=l|G0,b)}function _e(n,l){let b=n[l<<1],M=n[(l<<1)+1],G=(M&G0)!==0,z=M&~G0;if(M===0||(b&G0)!==0)throw new TypeError("Invalid handle");return n[l<<1]=n[0]|G0,n[0]=l|G0,{rep:z,scope:b,own:G}}var Cn=Symbol.for("cabiDispose"),I0=Symbol("handle"),F0=Symbol.for("cabiRep"),On=Symbol.dispose||Symbol.for("dispose"),Kt=n=>BigInt.asUintN(64,BigInt(n));function re(n){return n>>>0}var Ye=new TextDecoder,Ur=new TextEncoder,Te=0;function Le(n,l,b){if(typeof n!="string")throw new TypeError("expected a string");if(n.length===0)return Te=0,1;let M=Ur.encode(n),G=l(0,0,1,M.length);return new Uint8Array(b.buffer).set(M,G),Te=M.length,G}function xr(n,l,b=WebAssembly.instantiate){let M=n("nextpnr-ice40.core.wasm"),G=n("nextpnr-ice40.core2.wasm"),z=n("nextpnr-ice40.core3.wasm"),m0=n("nextpnr-ice40.core4.wasm"),{cli:J0,fs:x0,io:K0,monotonicClock:y0,random:Lt,wallClock:jt}=l.runtime,{TerminalInput:Pt,TerminalOutput:vt,exit:Nn,getArguments:Ln,getEnvironment:bn,getStderr:Sn,getStdin:fn,getStdout:Et,getTerminalStderr:Z0,getTerminalStdin:Pn,getTerminalStdout:tt}=J0,{Descriptor:a0,filesystemErrorCode:z0,getDirectories:w0}=x0,{Error:It,InputStream:v0,OutputStream:Y0}=K0,{now:ot}=y0,{getRandomBytes:qt}=Lt,{now:bt}=jt,r0=function*(){let t0,$;function Q0(){let L=ot();return Kt(L)}let ut=[G0,0],et=new Map,P0=0;ee[2]=ut;function F(){let L=Sn();if(!(L instanceof Y0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var i=L[I0];if(!i){let u=L[F0]||++P0;et.set(u,L),i=xt(ut,u)}return i}let S=[G0,0],H0=new Map,pt=0;ee[1]=S;function lt(){let L=fn();if(!(L instanceof v0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var i=L[I0];if(!i){let u=L[F0]||++pt;H0.set(u,L),i=xt(S,u)}return i}function d0(){let L=Et();if(!(L instanceof Y0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var i=L[I0];if(!i){let u=L[F0]||++P0;et.set(u,L),i=xt(ut,u)}return i}function x(L){let i;switch(L){case 0:{i={tag:"ok",val:void 0};break}case 1:{i={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}Nn(i)}let b0,v,W;function Rt(L){var u=bn(),P=u.length,R=W(0,0,4,P*16);for(let s=0;s<u.length;s++){let w=u[s],O=R+s*16;var[a,d]=w,c=Le(a,W,v),m=Te;K(v).setInt32(O+4,m,!0),K(v).setInt32(O+0,c,!0);var o=Le(d,W,v),p=Te;K(v).setInt32(O+12,p,!0),K(v).setInt32(O+8,o,!0)}K(v).setInt32(L+4,P,!0),K(v).setInt32(L+0,R,!0)}function mt(L){var u=Ln(),P=u.length,R=W(0,0,4,P*8);for(let c=0;c<u.length;c++){let m=u[c],o=R+c*8;var a=Le(m,W,v),d=Te;K(v).setInt32(o+4,d,!0),K(v).setInt32(o+0,a,!0)}K(v).setInt32(L+4,P,!0),K(v).setInt32(L+0,R,!0)}function Ct(L){let i=bt();var{seconds:u,nanoseconds:P}=i;K(v).setBigInt64(L+0,Kt(u),!0),K(v).setInt32(L+8,re(P),!0)}let U0=[G0,0],A0=new Map,l0=0;ee[5]=U0;function st(L,i,u){var P=L,R=U0[(P<<1)+1]&~G0,a=A0.get(R);a||(a=Object.create(a0.prototype),Object.defineProperty(a,I0,{writable:!0,value:P}),Object.defineProperty(a,F0,{writable:!0,value:R})),p0.push(a);let d;try{d={tag:"ok",val:a.readViaStream(BigInt.asUintN(64,i))}}catch(p){d={tag:"err",val:Bt(p)}}for(let p of p0)p[I0]=null;p0=[];var c=d;switch(c.tag){case"ok":{let p=c.val;if(K(v).setInt8(u+0,0,!0),!(p instanceof v0))throw new TypeError('Resource error: Not a valid "InputStream" resource.');var m=p[I0];if(!m){let s=p[F0]||++pt;H0.set(s,p),m=xt(S,s)}K(v).setInt32(u+4,m,!0);break}case"err":{let p=c.val;K(v).setInt8(u+0,1,!0);var o=p;let s;switch(o){case"access":{s=0;break}case"would-block":{s=1;break}case"already":{s=2;break}case"bad-descriptor":{s=3;break}case"busy":{s=4;break}case"deadlock":{s=5;break}case"quota":{s=6;break}case"exist":{s=7;break}case"file-too-large":{s=8;break}case"illegal-byte-sequence":{s=9;break}case"in-progress":{s=10;break}case"interrupted":{s=11;break}case"invalid":{s=12;break}case"io":{s=13;break}case"is-directory":{s=14;break}case"loop":{s=15;break}case"too-many-links":{s=16;break}case"message-size":{s=17;break}case"name-too-long":{s=18;break}case"no-device":{s=19;break}case"no-entry":{s=20;break}case"no-lock":{s=21;break}case"insufficient-memory":{s=22;break}case"insufficient-space":{s=23;break}case"not-directory":{s=24;break}case"not-empty":{s=25;break}case"not-recoverable":{s=26;break}case"unsupported":{s=27;break}case"no-tty":{s=28;break}case"no-such-device":{s=29;break}case"overflow":{s=30;break}case"not-permitted":{s=31;break}case"pipe":{s=32;break}case"read-only":{s=33;break}case"invalid-seek":{s=34;break}case"text-file-busy":{s=35;break}case"cross-device":{s=36;break}default:throw p instanceof Error&&console.error(p),new TypeError(`"${o}" is not one of the cases of error-code`)}K(v).setInt8(u+4,s,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ot(L,i,u){var P=L,R=U0[(P<<1)+1]&~G0,a=A0.get(R);a||(a=Object.create(a0.prototype),Object.defineProperty(a,I0,{writable:!0,value:P}),Object.defineProperty(a,F0,{writable:!0,value:R})),p0.push(a);let d;try{d={tag:"ok",val:a.writeViaStream(BigInt.asUintN(64,i))}}catch(p){d={tag:"err",val:Bt(p)}}for(let p of p0)p[I0]=null;p0=[];var c=d;switch(c.tag){case"ok":{let p=c.val;if(K(v).setInt8(u+0,0,!0),!(p instanceof Y0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var m=p[I0];if(!m){let s=p[F0]||++P0;et.set(s,p),m=xt(ut,s)}K(v).setInt32(u+4,m,!0);break}case"err":{let p=c.val;K(v).setInt8(u+0,1,!0);var o=p;let s;switch(o){case"access":{s=0;break}case"would-block":{s=1;break}case"already":{s=2;break}case"bad-descriptor":{s=3;break}case"busy":{s=4;break}case"deadlock":{s=5;break}case"quota":{s=6;break}case"exist":{s=7;break}case"file-too-large":{s=8;break}case"illegal-byte-sequence":{s=9;break}case"in-progress":{s=10;break}case"interrupted":{s=11;break}case"invalid":{s=12;break}case"io":{s=13;break}case"is-directory":{s=14;break}case"loop":{s=15;break}case"too-many-links":{s=16;break}case"message-size":{s=17;break}case"name-too-long":{s=18;break}case"no-device":{s=19;break}case"no-entry":{s=20;break}case"no-lock":{s=21;break}case"insufficient-memory":{s=22;break}case"insufficient-space":{s=23;break}case"not-directory":{s=24;break}case"not-empty":{s=25;break}case"not-recoverable":{s=26;break}case"unsupported":{s=27;break}case"no-tty":{s=28;break}case"no-such-device":{s=29;break}case"overflow":{s=30;break}case"not-permitted":{s=31;break}case"pipe":{s=32;break}case"read-only":{s=33;break}case"invalid-seek":{s=34;break}case"text-file-busy":{s=35;break}case"cross-device":{s=36;break}default:throw p instanceof Error&&console.error(p),new TypeError(`"${o}" is not one of the cases of error-code`)}K(v).setInt8(u+4,s,!0);break}default:throw new TypeError("invalid variant specified for result")}}function hn(L,i){var u=L,P=U0[(u<<1)+1]&~G0,R=A0.get(P);R||(R=Object.create(a0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.appendViaStream()}}catch(o){a={tag:"err",val:Bt(o)}}for(let o of p0)o[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let o=d.val;if(K(v).setInt8(i+0,0,!0),!(o instanceof Y0))throw new TypeError('Resource error: Not a valid "OutputStream" resource.');var c=o[I0];if(!c){let p=o[F0]||++P0;et.set(p,o),c=xt(ut,p)}K(v).setInt32(i+4,c,!0);break}case"err":{let o=d.val;K(v).setInt8(i+0,1,!0);var m=o;let p;switch(m){case"access":{p=0;break}case"would-block":{p=1;break}case"already":{p=2;break}case"bad-descriptor":{p=3;break}case"busy":{p=4;break}case"deadlock":{p=5;break}case"quota":{p=6;break}case"exist":{p=7;break}case"file-too-large":{p=8;break}case"illegal-byte-sequence":{p=9;break}case"in-progress":{p=10;break}case"interrupted":{p=11;break}case"invalid":{p=12;break}case"io":{p=13;break}case"is-directory":{p=14;break}case"loop":{p=15;break}case"too-many-links":{p=16;break}case"message-size":{p=17;break}case"name-too-long":{p=18;break}case"no-device":{p=19;break}case"no-entry":{p=20;break}case"no-lock":{p=21;break}case"insufficient-memory":{p=22;break}case"insufficient-space":{p=23;break}case"not-directory":{p=24;break}case"not-empty":{p=25;break}case"not-recoverable":{p=26;break}case"unsupported":{p=27;break}case"no-tty":{p=28;break}case"no-such-device":{p=29;break}case"overflow":{p=30;break}case"not-permitted":{p=31;break}case"pipe":{p=32;break}case"read-only":{p=33;break}case"invalid-seek":{p=34;break}case"text-file-busy":{p=35;break}case"cross-device":{p=36;break}default:throw o instanceof Error&&console.error(o),new TypeError(`"${m}" is not one of the cases of error-code`)}K(v).setInt8(i+4,p,!0);break}default:throw new TypeError("invalid variant specified for result")}}function gn(L,i){var u=L,P=U0[(u<<1)+1]&~G0,R=A0.get(P);R||(R=Object.create(a0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.getFlags()}}catch(m){a={tag:"err",val:Bt(m)}}for(let m of p0)m[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let m=d.val;K(v).setInt8(i+0,0,!0);let o=0;if(typeof m=="object"&&m!==null)o=!!m.read<<0|!!m.write<<1|!!m.fileIntegritySync<<2|!!m.dataIntegritySync<<3|!!m.requestedWriteSync<<4|!!m.mutateDirectory<<5;else if(m!=null)throw new TypeError("only an object, undefined or null can be converted to flags");K(v).setInt8(i+1,o,!0);break}case"err":{let m=d.val;K(v).setInt8(i+0,1,!0);var c=m;let o;switch(c){case"access":{o=0;break}case"would-block":{o=1;break}case"already":{o=2;break}case"bad-descriptor":{o=3;break}case"busy":{o=4;break}case"deadlock":{o=5;break}case"quota":{o=6;break}case"exist":{o=7;break}case"file-too-large":{o=8;break}case"illegal-byte-sequence":{o=9;break}case"in-progress":{o=10;break}case"interrupted":{o=11;break}case"invalid":{o=12;break}case"io":{o=13;break}case"is-directory":{o=14;break}case"loop":{o=15;break}case"too-many-links":{o=16;break}case"message-size":{o=17;break}case"name-too-long":{o=18;break}case"no-device":{o=19;break}case"no-entry":{o=20;break}case"no-lock":{o=21;break}case"insufficient-memory":{o=22;break}case"insufficient-space":{o=23;break}case"not-directory":{o=24;break}case"not-empty":{o=25;break}case"not-recoverable":{o=26;break}case"unsupported":{o=27;break}case"no-tty":{o=28;break}case"no-such-device":{o=29;break}case"overflow":{o=30;break}case"not-permitted":{o=31;break}case"pipe":{o=32;break}case"read-only":{o=33;break}case"invalid-seek":{o=34;break}case"text-file-busy":{o=35;break}case"cross-device":{o=36;break}default:throw m instanceof Error&&console.error(m),new TypeError(`"${c}" is not one of the cases of error-code`)}K(v).setInt8(i+1,o,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Bn(L,i){var u=L,P=U0[(u<<1)+1]&~G0,R=A0.get(P);R||(R=Object.create(a0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.getType()}}catch(o){a={tag:"err",val:Bt(o)}}for(let o of p0)o[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let o=d.val;K(v).setInt8(i+0,0,!0);var c=o;let p;switch(c){case"unknown":{p=0;break}case"block-device":{p=1;break}case"character-device":{p=2;break}case"directory":{p=3;break}case"fifo":{p=4;break}case"symbolic-link":{p=5;break}case"regular-file":{p=6;break}case"socket":{p=7;break}default:throw o instanceof Error&&console.error(o),new TypeError(`"${c}" is not one of the cases of descriptor-type`)}K(v).setInt8(i+1,p,!0);break}case"err":{let o=d.val;K(v).setInt8(i+0,1,!0);var m=o;let p;switch(m){case"access":{p=0;break}case"would-block":{p=1;break}case"already":{p=2;break}case"bad-descriptor":{p=3;break}case"busy":{p=4;break}case"deadlock":{p=5;break}case"quota":{p=6;break}case"exist":{p=7;break}case"file-too-large":{p=8;break}case"illegal-byte-sequence":{p=9;break}case"in-progress":{p=10;break}case"interrupted":{p=11;break}case"invalid":{p=12;break}case"io":{p=13;break}case"is-directory":{p=14;break}case"loop":{p=15;break}case"too-many-links":{p=16;break}case"message-size":{p=17;break}case"name-too-long":{p=18;break}case"no-device":{p=19;break}case"no-entry":{p=20;break}case"no-lock":{p=21;break}case"insufficient-memory":{p=22;break}case"insufficient-space":{p=23;break}case"not-directory":{p=24;break}case"not-empty":{p=25;break}case"not-recoverable":{p=26;break}case"unsupported":{p=27;break}case"no-tty":{p=28;break}case"no-such-device":{p=29;break}case"overflow":{p=30;break}case"not-permitted":{p=31;break}case"pipe":{p=32;break}case"read-only":{p=33;break}case"invalid-seek":{p=34;break}case"text-file-busy":{p=35;break}case"cross-device":{p=36;break}default:throw o instanceof Error&&console.error(o),new TypeError(`"${m}" is not one of the cases of error-code`)}K(v).setInt8(i+1,p,!0);break}default:throw new TypeError("invalid variant specified for result")}}function St(L,i,u){var P=L,R=U0[(P<<1)+1]&~G0,a=A0.get(R);a||(a=Object.create(a0.prototype),Object.defineProperty(a,I0,{writable:!0,value:P}),Object.defineProperty(a,F0,{writable:!0,value:R})),p0.push(a);let d;try{d={tag:"ok",val:a.setSize(BigInt.asUintN(64,i))}}catch(o){d={tag:"err",val:Bt(o)}}for(let o of p0)o[I0]=null;p0=[];var c=d;switch(c.tag){case"ok":{let o=c.val;K(v).setInt8(u+0,0,!0);break}case"err":{let o=c.val;K(v).setInt8(u+0,1,!0);var m=o;let p;switch(m){case"access":{p=0;break}case"would-block":{p=1;break}case"already":{p=2;break}case"bad-descriptor":{p=3;break}case"busy":{p=4;break}case"deadlock":{p=5;break}case"quota":{p=6;break}case"exist":{p=7;break}case"file-too-large":{p=8;break}case"illegal-byte-sequence":{p=9;break}case"in-progress":{p=10;break}case"interrupted":{p=11;break}case"invalid":{p=12;break}case"io":{p=13;break}case"is-directory":{p=14;break}case"loop":{p=15;break}case"too-many-links":{p=16;break}case"message-size":{p=17;break}case"name-too-long":{p=18;break}case"no-device":{p=19;break}case"no-entry":{p=20;break}case"no-lock":{p=21;break}case"insufficient-memory":{p=22;break}case"insufficient-space":{p=23;break}case"not-directory":{p=24;break}case"not-empty":{p=25;break}case"not-recoverable":{p=26;break}case"unsupported":{p=27;break}case"no-tty":{p=28;break}case"no-such-device":{p=29;break}case"overflow":{p=30;break}case"not-permitted":{p=31;break}case"pipe":{p=32;break}case"read-only":{p=33;break}case"invalid-seek":{p=34;break}case"text-file-busy":{p=35;break}case"cross-device":{p=36;break}default:throw o instanceof Error&&console.error(o),new TypeError(`"${m}" is not one of the cases of error-code`)}K(v).setInt8(u+1,p,!0);break}default:throw new TypeError("invalid variant specified for result")}}function ct(L,i,u,P){var R=L,a=U0[(R<<1)+1]&~G0,d=A0.get(a);d||(d=Object.create(a0.prototype),Object.defineProperty(d,I0,{writable:!0,value:R}),Object.defineProperty(d,F0,{writable:!0,value:a})),p0.push(d);let c;try{c={tag:"ok",val:d.read(BigInt.asUintN(64,i),BigInt.asUintN(64,u))}}catch(J){c={tag:"err",val:Bt(J)}}for(let J of p0)J[I0]=null;p0=[];var m=c;switch(m.tag){case"ok":{let J=m.val;K(v).setInt8(P+0,0,!0);var[o,p]=J,s=o,w=s.byteLength,O=W(0,0,1,w*1),N=new Uint8Array(s.buffer||s,s.byteOffset,w*1);new Uint8Array(v.buffer,O,w*1).set(N),K(v).setInt32(P+8,w,!0),K(v).setInt32(P+4,O,!0),K(v).setInt8(P+12,p?1:0,!0);break}case"err":{let J=m.val;K(v).setInt8(P+0,1,!0);var B=J;let H;switch(B){case"access":{H=0;break}case"would-block":{H=1;break}case"already":{H=2;break}case"bad-descriptor":{H=3;break}case"busy":{H=4;break}case"deadlock":{H=5;break}case"quota":{H=6;break}case"exist":{H=7;break}case"file-too-large":{H=8;break}case"illegal-byte-sequence":{H=9;break}case"in-progress":{H=10;break}case"interrupted":{H=11;break}case"invalid":{H=12;break}case"io":{H=13;break}case"is-directory":{H=14;break}case"loop":{H=15;break}case"too-many-links":{H=16;break}case"message-size":{H=17;break}case"name-too-long":{H=18;break}case"no-device":{H=19;break}case"no-entry":{H=20;break}case"no-lock":{H=21;break}case"insufficient-memory":{H=22;break}case"insufficient-space":{H=23;break}case"not-directory":{H=24;break}case"not-empty":{H=25;break}case"not-recoverable":{H=26;break}case"unsupported":{H=27;break}case"no-tty":{H=28;break}case"no-such-device":{H=29;break}case"overflow":{H=30;break}case"not-permitted":{H=31;break}case"pipe":{H=32;break}case"read-only":{H=33;break}case"invalid-seek":{H=34;break}case"text-file-busy":{H=35;break}case"cross-device":{H=36;break}default:throw J instanceof Error&&console.error(J),new TypeError(`"${B}" is not one of the cases of error-code`)}K(v).setInt8(P+4,H,!0);break}default:throw new TypeError("invalid variant specified for result")}}function ft(L,i){var u=L,P=U0[(u<<1)+1]&~G0,R=A0.get(P);R||(R=Object.create(a0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.stat()}}catch(X0){a={tag:"err",val:Bt(X0)}}for(let X0 of p0)X0[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let X0=d.val;K(v).setInt8(i+0,0,!0);var{type:c,linkCount:m,size:o,dataAccessTimestamp:p,dataModificationTimestamp:s,statusChangeTimestamp:w}=X0,O=c;let j;switch(O){case"unknown":{j=0;break}case"block-device":{j=1;break}case"character-device":{j=2;break}case"directory":{j=3;break}case"fifo":{j=4;break}case"symbolic-link":{j=5;break}case"regular-file":{j=6;break}case"socket":{j=7;break}default:throw c instanceof Error&&console.error(c),new TypeError(`"${O}" is not one of the cases of descriptor-type`)}K(v).setInt8(i+8,j,!0),K(v).setBigInt64(i+16,Kt(m),!0),K(v).setBigInt64(i+24,Kt(o),!0);var N=p;if(N==null)K(v).setInt8(i+32,0,!0);else{let Mn=N;K(v).setInt8(i+32,1,!0);var{seconds:B,nanoseconds:J}=Mn;K(v).setBigInt64(i+40,Kt(B),!0),K(v).setInt32(i+48,re(J),!0)}var H=s;if(H==null)K(v).setInt8(i+56,0,!0);else{let Mn=H;K(v).setInt8(i+56,1,!0);var{seconds:g,nanoseconds:e0}=Mn;K(v).setBigInt64(i+64,Kt(g),!0),K(v).setInt32(i+72,re(e0),!0)}var u0=w;if(u0==null)K(v).setInt8(i+80,0,!0);else{let Mn=u0;K(v).setInt8(i+80,1,!0);var{seconds:_0,nanoseconds:R0}=Mn;K(v).setBigInt64(i+88,Kt(_0),!0),K(v).setInt32(i+96,re(R0),!0)}break}case"err":{let X0=d.val;K(v).setInt8(i+0,1,!0);var vn=X0;let j;switch(vn){case"access":{j=0;break}case"would-block":{j=1;break}case"already":{j=2;break}case"bad-descriptor":{j=3;break}case"busy":{j=4;break}case"deadlock":{j=5;break}case"quota":{j=6;break}case"exist":{j=7;break}case"file-too-large":{j=8;break}case"illegal-byte-sequence":{j=9;break}case"in-progress":{j=10;break}case"interrupted":{j=11;break}case"invalid":{j=12;break}case"io":{j=13;break}case"is-directory":{j=14;break}case"loop":{j=15;break}case"too-many-links":{j=16;break}case"message-size":{j=17;break}case"name-too-long":{j=18;break}case"no-device":{j=19;break}case"no-entry":{j=20;break}case"no-lock":{j=21;break}case"insufficient-memory":{j=22;break}case"insufficient-space":{j=23;break}case"not-directory":{j=24;break}case"not-empty":{j=25;break}case"not-recoverable":{j=26;break}case"unsupported":{j=27;break}case"no-tty":{j=28;break}case"no-such-device":{j=29;break}case"overflow":{j=30;break}case"not-permitted":{j=31;break}case"pipe":{j=32;break}case"read-only":{j=33;break}case"invalid-seek":{j=34;break}case"text-file-busy":{j=35;break}case"cross-device":{j=36;break}default:throw X0 instanceof Error&&console.error(X0),new TypeError(`"${vn}" is not one of the cases of error-code`)}K(v).setInt8(i+8,j,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Jt(L,i,u,P,R){var a=L,d=U0[(a<<1)+1]&~G0,c=A0.get(d);if(c||(c=Object.create(a0.prototype),Object.defineProperty(c,I0,{writable:!0,value:a}),Object.defineProperty(c,F0,{writable:!0,value:d})),p0.push(c),(i&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var m={symlinkFollow:!!(i&1)},o=u,p=P,s=Ye.decode(new Uint8Array(v.buffer,o,p));let w;try{w={tag:"ok",val:c.statAt(m,s)}}catch(an){w={tag:"err",val:Bt(an)}}for(let an of p0)an[I0]=null;p0=[];var O=w;switch(O.tag){case"ok":{let an=O.val;K(v).setInt8(R+0,0,!0);var{type:N,linkCount:B,size:J,dataAccessTimestamp:H,dataModificationTimestamp:g,statusChangeTimestamp:e0}=an,u0=N;let c0;switch(u0){case"unknown":{c0=0;break}case"block-device":{c0=1;break}case"character-device":{c0=2;break}case"directory":{c0=3;break}case"fifo":{c0=4;break}case"symbolic-link":{c0=5;break}case"regular-file":{c0=6;break}case"socket":{c0=7;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${u0}" is not one of the cases of descriptor-type`)}K(v).setInt8(R+8,c0,!0),K(v).setBigInt64(R+16,Kt(B),!0),K(v).setBigInt64(R+24,Kt(J),!0);var _0=H;if(_0==null)K(v).setInt8(R+32,0,!0);else{let Kn=_0;K(v).setInt8(R+32,1,!0);var{seconds:R0,nanoseconds:vn}=Kn;K(v).setBigInt64(R+40,Kt(R0),!0),K(v).setInt32(R+48,re(vn),!0)}var X0=g;if(X0==null)K(v).setInt8(R+56,0,!0);else{let Kn=X0;K(v).setInt8(R+56,1,!0);var{seconds:j,nanoseconds:Mn}=Kn;K(v).setBigInt64(R+64,Kt(j),!0),K(v).setInt32(R+72,re(Mn),!0)}var Fn=e0;if(Fn==null)K(v).setInt8(R+80,0,!0);else{let Kn=Fn;K(v).setInt8(R+80,1,!0);var{seconds:Zt,nanoseconds:T0}=Kn;K(v).setBigInt64(R+88,Kt(Zt),!0),K(v).setInt32(R+96,re(T0),!0)}break}case"err":{let an=O.val;K(v).setInt8(R+0,1,!0);var wn=an;let c0;switch(wn){case"access":{c0=0;break}case"would-block":{c0=1;break}case"already":{c0=2;break}case"bad-descriptor":{c0=3;break}case"busy":{c0=4;break}case"deadlock":{c0=5;break}case"quota":{c0=6;break}case"exist":{c0=7;break}case"file-too-large":{c0=8;break}case"illegal-byte-sequence":{c0=9;break}case"in-progress":{c0=10;break}case"interrupted":{c0=11;break}case"invalid":{c0=12;break}case"io":{c0=13;break}case"is-directory":{c0=14;break}case"loop":{c0=15;break}case"too-many-links":{c0=16;break}case"message-size":{c0=17;break}case"name-too-long":{c0=18;break}case"no-device":{c0=19;break}case"no-entry":{c0=20;break}case"no-lock":{c0=21;break}case"insufficient-memory":{c0=22;break}case"insufficient-space":{c0=23;break}case"not-directory":{c0=24;break}case"not-empty":{c0=25;break}case"not-recoverable":{c0=26;break}case"unsupported":{c0=27;break}case"no-tty":{c0=28;break}case"no-such-device":{c0=29;break}case"overflow":{c0=30;break}case"not-permitted":{c0=31;break}case"pipe":{c0=32;break}case"read-only":{c0=33;break}case"invalid-seek":{c0=34;break}case"text-file-busy":{c0=35;break}case"cross-device":{c0=36;break}default:throw an instanceof Error&&console.error(an),new TypeError(`"${wn}" is not one of the cases of error-code`)}K(v).setInt8(R+8,c0,!0);break}default:throw new TypeError("invalid variant specified for result")}}function tn(L,i,u,P,R,a,d){var c=L,m=U0[(c<<1)+1]&~G0,o=A0.get(m);if(o||(o=Object.create(a0.prototype),Object.defineProperty(o,I0,{writable:!0,value:c}),Object.defineProperty(o,F0,{writable:!0,value:m})),p0.push(o),(i&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var p={symlinkFollow:!!(i&1)},s=u,w=P,O=Ye.decode(new Uint8Array(v.buffer,s,w));if((R&4294967280)!==0)throw new TypeError("flags have extraneous bits set");var N={create:!!(R&1),directory:!!(R&2),exclusive:!!(R&4),truncate:!!(R&8)};if((a&4294967232)!==0)throw new TypeError("flags have extraneous bits set");var B={read:!!(a&1),write:!!(a&2),fileIntegritySync:!!(a&4),dataIntegritySync:!!(a&8),requestedWriteSync:!!(a&16),mutateDirectory:!!(a&32)};let J;try{J={tag:"ok",val:o.openAt(p,O,N,B)}}catch(u0){J={tag:"err",val:Bt(u0)}}for(let u0 of p0)u0[I0]=null;p0=[];var H=J;switch(H.tag){case"ok":{let u0=H.val;if(K(v).setInt8(d+0,0,!0),!(u0 instanceof a0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var g=u0[I0];if(!g){let _0=u0[F0]||++l0;A0.set(_0,u0),g=xt(U0,_0)}K(v).setInt32(d+4,g,!0);break}case"err":{let u0=H.val;K(v).setInt8(d+0,1,!0);var e0=u0;let _0;switch(e0){case"access":{_0=0;break}case"would-block":{_0=1;break}case"already":{_0=2;break}case"bad-descriptor":{_0=3;break}case"busy":{_0=4;break}case"deadlock":{_0=5;break}case"quota":{_0=6;break}case"exist":{_0=7;break}case"file-too-large":{_0=8;break}case"illegal-byte-sequence":{_0=9;break}case"in-progress":{_0=10;break}case"interrupted":{_0=11;break}case"invalid":{_0=12;break}case"io":{_0=13;break}case"is-directory":{_0=14;break}case"loop":{_0=15;break}case"too-many-links":{_0=16;break}case"message-size":{_0=17;break}case"name-too-long":{_0=18;break}case"no-device":{_0=19;break}case"no-entry":{_0=20;break}case"no-lock":{_0=21;break}case"insufficient-memory":{_0=22;break}case"insufficient-space":{_0=23;break}case"not-directory":{_0=24;break}case"not-empty":{_0=25;break}case"not-recoverable":{_0=26;break}case"unsupported":{_0=27;break}case"no-tty":{_0=28;break}case"no-such-device":{_0=29;break}case"overflow":{_0=30;break}case"not-permitted":{_0=31;break}case"pipe":{_0=32;break}case"read-only":{_0=33;break}case"invalid-seek":{_0=34;break}case"text-file-busy":{_0=35;break}case"cross-device":{_0=36;break}default:throw u0 instanceof Error&&console.error(u0),new TypeError(`"${e0}" is not one of the cases of error-code`)}K(v).setInt8(d+4,_0,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Yt(L,i){var u=L,P=U0[(u<<1)+1]&~G0,R=A0.get(P);R||(R=Object.create(a0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.metadataHash()}}catch(p){a={tag:"err",val:Bt(p)}}for(let p of p0)p[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let p=d.val;K(v).setInt8(i+0,0,!0);var{lower:c,upper:m}=p;K(v).setBigInt64(i+8,Kt(c),!0),K(v).setBigInt64(i+16,Kt(m),!0);break}case"err":{let p=d.val;K(v).setInt8(i+0,1,!0);var o=p;let s;switch(o){case"access":{s=0;break}case"would-block":{s=1;break}case"already":{s=2;break}case"bad-descriptor":{s=3;break}case"busy":{s=4;break}case"deadlock":{s=5;break}case"quota":{s=6;break}case"exist":{s=7;break}case"file-too-large":{s=8;break}case"illegal-byte-sequence":{s=9;break}case"in-progress":{s=10;break}case"interrupted":{s=11;break}case"invalid":{s=12;break}case"io":{s=13;break}case"is-directory":{s=14;break}case"loop":{s=15;break}case"too-many-links":{s=16;break}case"message-size":{s=17;break}case"name-too-long":{s=18;break}case"no-device":{s=19;break}case"no-entry":{s=20;break}case"no-lock":{s=21;break}case"insufficient-memory":{s=22;break}case"insufficient-space":{s=23;break}case"not-directory":{s=24;break}case"not-empty":{s=25;break}case"not-recoverable":{s=26;break}case"unsupported":{s=27;break}case"no-tty":{s=28;break}case"no-such-device":{s=29;break}case"overflow":{s=30;break}case"not-permitted":{s=31;break}case"pipe":{s=32;break}case"read-only":{s=33;break}case"invalid-seek":{s=34;break}case"text-file-busy":{s=35;break}case"cross-device":{s=36;break}default:throw p instanceof Error&&console.error(p),new TypeError(`"${o}" is not one of the cases of error-code`)}K(v).setInt8(i+8,s,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Gt(L,i,u,P,R){var a=L,d=U0[(a<<1)+1]&~G0,c=A0.get(d);if(c||(c=Object.create(a0.prototype),Object.defineProperty(c,I0,{writable:!0,value:a}),Object.defineProperty(c,F0,{writable:!0,value:d})),p0.push(c),(i&4294967294)!==0)throw new TypeError("flags have extraneous bits set");var m={symlinkFollow:!!(i&1)},o=u,p=P,s=Ye.decode(new Uint8Array(v.buffer,o,p));let w;try{w={tag:"ok",val:c.metadataHashAt(m,s)}}catch(H){w={tag:"err",val:Bt(H)}}for(let H of p0)H[I0]=null;p0=[];var O=w;switch(O.tag){case"ok":{let H=O.val;K(v).setInt8(R+0,0,!0);var{lower:N,upper:B}=H;K(v).setBigInt64(R+8,Kt(N),!0),K(v).setBigInt64(R+16,Kt(B),!0);break}case"err":{let H=O.val;K(v).setInt8(R+0,1,!0);var J=H;let g;switch(J){case"access":{g=0;break}case"would-block":{g=1;break}case"already":{g=2;break}case"bad-descriptor":{g=3;break}case"busy":{g=4;break}case"deadlock":{g=5;break}case"quota":{g=6;break}case"exist":{g=7;break}case"file-too-large":{g=8;break}case"illegal-byte-sequence":{g=9;break}case"in-progress":{g=10;break}case"interrupted":{g=11;break}case"invalid":{g=12;break}case"io":{g=13;break}case"is-directory":{g=14;break}case"loop":{g=15;break}case"too-many-links":{g=16;break}case"message-size":{g=17;break}case"name-too-long":{g=18;break}case"no-device":{g=19;break}case"no-entry":{g=20;break}case"no-lock":{g=21;break}case"insufficient-memory":{g=22;break}case"insufficient-space":{g=23;break}case"not-directory":{g=24;break}case"not-empty":{g=25;break}case"not-recoverable":{g=26;break}case"unsupported":{g=27;break}case"no-tty":{g=28;break}case"no-such-device":{g=29;break}case"overflow":{g=30;break}case"not-permitted":{g=31;break}case"pipe":{g=32;break}case"read-only":{g=33;break}case"invalid-seek":{g=34;break}case"text-file-busy":{g=35;break}case"cross-device":{g=36;break}default:throw H instanceof Error&&console.error(H),new TypeError(`"${J}" is not one of the cases of error-code`)}K(v).setInt8(R+8,g,!0);break}default:throw new TypeError("invalid variant specified for result")}}let dt=[G0,0],Dt=new Map,Tt=0;ee[0]=dt;function Mt(L,i){var u=L,P=dt[(u<<1)+1]&~G0,R=Dt.get(P);R||(R=Object.create(It.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a=z0(R);for(let m of p0)m[I0]=null;p0=[];var d=a;if(d==null)K(v).setInt8(i+0,0,!0);else{let m=d;K(v).setInt8(i+0,1,!0);var c=m;let o;switch(c){case"access":{o=0;break}case"would-block":{o=1;break}case"already":{o=2;break}case"bad-descriptor":{o=3;break}case"busy":{o=4;break}case"deadlock":{o=5;break}case"quota":{o=6;break}case"exist":{o=7;break}case"file-too-large":{o=8;break}case"illegal-byte-sequence":{o=9;break}case"in-progress":{o=10;break}case"interrupted":{o=11;break}case"invalid":{o=12;break}case"io":{o=13;break}case"is-directory":{o=14;break}case"loop":{o=15;break}case"too-many-links":{o=16;break}case"message-size":{o=17;break}case"name-too-long":{o=18;break}case"no-device":{o=19;break}case"no-entry":{o=20;break}case"no-lock":{o=21;break}case"insufficient-memory":{o=22;break}case"insufficient-space":{o=23;break}case"not-directory":{o=24;break}case"not-empty":{o=25;break}case"not-recoverable":{o=26;break}case"unsupported":{o=27;break}case"no-tty":{o=28;break}case"no-such-device":{o=29;break}case"overflow":{o=30;break}case"not-permitted":{o=31;break}case"pipe":{o=32;break}case"read-only":{o=33;break}case"invalid-seek":{o=34;break}case"text-file-busy":{o=35;break}case"cross-device":{o=36;break}default:throw m instanceof Error&&console.error(m),new TypeError(`"${c}" is not one of the cases of error-code`)}K(v).setInt8(i+1,o,!0)}}function zt(L,i,u){var P=L,R=S[(P<<1)+1]&~G0,a=H0.get(R);a||(a=Object.create(v0.prototype),Object.defineProperty(a,I0,{writable:!0,value:P}),Object.defineProperty(a,F0,{writable:!0,value:R})),p0.push(a);let d;try{d={tag:"ok",val:a.read(BigInt.asUintN(64,i))}}catch(N){d={tag:"err",val:Bt(N)}}for(let N of p0)N[I0]=null;p0=[];var c=d;switch(c.tag){case"ok":{let N=c.val;K(v).setInt8(u+0,0,!0);var m=N,o=m.byteLength,p=W(0,0,1,o*1),s=new Uint8Array(m.buffer||m,m.byteOffset,o*1);new Uint8Array(v.buffer,p,o*1).set(s),K(v).setInt32(u+8,o,!0),K(v).setInt32(u+4,p,!0);break}case"err":{let N=c.val;K(v).setInt8(u+0,1,!0);var w=N;switch(w.tag){case"last-operation-failed":{let B=w.val;if(K(v).setInt8(u+4,0,!0),!(B instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var O=B[I0];if(!O){let J=B[F0]||++Tt;Dt.set(J,B),O=xt(dt,J)}K(v).setInt32(u+8,O,!0);break}case"closed":{K(v).setInt8(u+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(w.tag)}\` (received \`${w}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function nn(L,i,u){var P=L,R=S[(P<<1)+1]&~G0,a=H0.get(R);a||(a=Object.create(v0.prototype),Object.defineProperty(a,I0,{writable:!0,value:P}),Object.defineProperty(a,F0,{writable:!0,value:R})),p0.push(a);let d;try{d={tag:"ok",val:a.blockingRead(BigInt.asUintN(64,i))}}catch(N){d={tag:"err",val:Bt(N)}}for(let N of p0)N[I0]=null;p0=[];var c=d;switch(c.tag){case"ok":{let N=c.val;K(v).setInt8(u+0,0,!0);var m=N,o=m.byteLength,p=W(0,0,1,o*1),s=new Uint8Array(m.buffer||m,m.byteOffset,o*1);new Uint8Array(v.buffer,p,o*1).set(s),K(v).setInt32(u+8,o,!0),K(v).setInt32(u+4,p,!0);break}case"err":{let N=c.val;K(v).setInt8(u+0,1,!0);var w=N;switch(w.tag){case"last-operation-failed":{let B=w.val;if(K(v).setInt8(u+4,0,!0),!(B instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var O=B[I0];if(!O){let J=B[F0]||++Tt;Dt.set(J,B),O=xt(dt,J)}K(v).setInt32(u+8,O,!0);break}case"closed":{K(v).setInt8(u+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(w.tag)}\` (received \`${w}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function un(L,i){var u=L,P=ut[(u<<1)+1]&~G0,R=et.get(P);R||(R=Object.create(Y0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.checkWrite()}}catch(o){a={tag:"err",val:Bt(o)}}for(let o of p0)o[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let o=d.val;K(v).setInt8(i+0,0,!0),K(v).setBigInt64(i+8,Kt(o),!0);break}case"err":{let o=d.val;K(v).setInt8(i+0,1,!0);var c=o;switch(c.tag){case"last-operation-failed":{let p=c.val;if(K(v).setInt8(i+8,0,!0),!(p instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var m=p[I0];if(!m){let s=p[F0]||++Tt;Dt.set(s,p),m=xt(dt,s)}K(v).setInt32(i+12,m,!0);break}case"closed":{K(v).setInt8(i+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(c.tag)}\` (received \`${c}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function ht(L,i,u,P){var R=L,a=ut[(R<<1)+1]&~G0,d=et.get(a);d||(d=Object.create(Y0.prototype),Object.defineProperty(d,I0,{writable:!0,value:R}),Object.defineProperty(d,F0,{writable:!0,value:a})),p0.push(d);var c=i,m=u,o=new Uint8Array(v.buffer.slice(c,c+m*1));let p;try{p={tag:"ok",val:d.write(o)}}catch(N){p={tag:"err",val:Bt(N)}}for(let N of p0)N[I0]=null;p0=[];var s=p;switch(s.tag){case"ok":{let N=s.val;K(v).setInt8(P+0,0,!0);break}case"err":{let N=s.val;K(v).setInt8(P+0,1,!0);var w=N;switch(w.tag){case"last-operation-failed":{let B=w.val;if(K(v).setInt8(P+4,0,!0),!(B instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var O=B[I0];if(!O){let J=B[F0]||++Tt;Dt.set(J,B),O=xt(dt,J)}K(v).setInt32(P+8,O,!0);break}case"closed":{K(v).setInt8(P+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(w.tag)}\` (received \`${w}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function At(L,i,u,P){var R=L,a=ut[(R<<1)+1]&~G0,d=et.get(a);d||(d=Object.create(Y0.prototype),Object.defineProperty(d,I0,{writable:!0,value:R}),Object.defineProperty(d,F0,{writable:!0,value:a})),p0.push(d);var c=i,m=u,o=new Uint8Array(v.buffer.slice(c,c+m*1));let p;try{p={tag:"ok",val:d.blockingWriteAndFlush(o)}}catch(N){p={tag:"err",val:Bt(N)}}for(let N of p0)N[I0]=null;p0=[];var s=p;switch(s.tag){case"ok":{let N=s.val;K(v).setInt8(P+0,0,!0);break}case"err":{let N=s.val;K(v).setInt8(P+0,1,!0);var w=N;switch(w.tag){case"last-operation-failed":{let B=w.val;if(K(v).setInt8(P+4,0,!0),!(B instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var O=B[I0];if(!O){let J=B[F0]||++Tt;Dt.set(J,B),O=xt(dt,J)}K(v).setInt32(P+8,O,!0);break}case"closed":{K(v).setInt8(P+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(w.tag)}\` (received \`${w}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Ht(L,i){var u=L,P=ut[(u<<1)+1]&~G0,R=et.get(P);R||(R=Object.create(Y0.prototype),Object.defineProperty(R,I0,{writable:!0,value:u}),Object.defineProperty(R,F0,{writable:!0,value:P})),p0.push(R);let a;try{a={tag:"ok",val:R.blockingFlush()}}catch(o){a={tag:"err",val:Bt(o)}}for(let o of p0)o[I0]=null;p0=[];var d=a;switch(d.tag){case"ok":{let o=d.val;K(v).setInt8(i+0,0,!0);break}case"err":{let o=d.val;K(v).setInt8(i+0,1,!0);var c=o;switch(c.tag){case"last-operation-failed":{let p=c.val;if(K(v).setInt8(i+4,0,!0),!(p instanceof It))throw new TypeError('Resource error: Not a valid "Error" resource.');var m=p[I0];if(!m){let s=p[F0]||++Tt;Dt.set(s,p),m=xt(dt,s)}K(v).setInt32(i+8,m,!0);break}case"closed":{K(v).setInt8(i+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(c.tag)}\` (received \`${c}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Hn(L,i){var P=qt(BigInt.asUintN(64,L)),R=P.byteLength,a=W(0,0,1,R*1),d=new Uint8Array(P.buffer||P,P.byteOffset,R*1);new Uint8Array(v.buffer,a,R*1).set(d),K(v).setInt32(i+4,R,!0),K(v).setInt32(i+0,a,!0)}function Wn(L){var u=w0(),P=u.length,R=W(0,0,4,P*12);for(let p=0;p<u.length;p++){let s=u[p],w=R+p*12;var[a,d]=s;if(!(a instanceof a0))throw new TypeError('Resource error: Not a valid "Descriptor" resource.');var c=a[I0];if(!c){let O=a[F0]||++l0;A0.set(O,a),c=xt(U0,O)}K(v).setInt32(w+0,c,!0);var m=Le(d,W,v),o=Te;K(v).setInt32(w+8,o,!0),K(v).setInt32(w+4,m,!0)}K(v).setInt32(L+4,P,!0),K(v).setInt32(L+0,R,!0)}let en=[G0,0],_n=new Map,Tn=0;ee[3]=en;function yn(L){var u=Pn();if(u==null)K(v).setInt8(L+0,0,!0);else{let R=u;if(K(v).setInt8(L+0,1,!0),!(R instanceof Pt))throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');var P=R[I0];if(!P){let a=R[F0]||++Tn;_n.set(a,R),P=xt(en,a)}K(v).setInt32(L+4,P,!0)}}let rn=[G0,0],Xt=new Map,n0=0;ee[4]=rn;function Y(L){var u=tt();if(u==null)K(v).setInt8(L+0,0,!0);else{let R=u;if(K(v).setInt8(L+0,1,!0),!(R instanceof vt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var P=R[I0];if(!P){let a=R[F0]||++n0;Xt.set(a,R),P=xt(rn,a)}K(v).setInt32(L+4,P,!0)}}function E(L){var u=Z0();if(u==null)K(v).setInt8(L+0,0,!0);else{let R=u;if(K(v).setInt8(L+0,1,!0),!(R instanceof vt))throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');var P=R[I0];if(!P){let a=R[F0]||++n0;Xt.set(a,R),P=xt(rn,a)}K(v).setInt32(L+4,P,!0)}}let T,A=[G0,0],h=new Map,C=0;ee[6]=A;function f(L){if(_e(A,L).own)throw new TypeError("unreachable resource trampoline")}function D(L){let i=_e(ut,L);if(i.own){let u=et.get(i.rep);u?(u[On]&&u[On](),et.delete(i.rep)):Y0[Cn]&&Y0[Cn](i.rep)}}function _(L){let i=_e(dt,L);if(i.own){let u=Dt.get(i.rep);u?(u[On]&&u[On](),Dt.delete(i.rep)):It[Cn]&&It[Cn](i.rep)}}function r(L){let i=_e(S,L);if(i.own){let u=H0.get(i.rep);u?(u[On]&&u[On](),H0.delete(i.rep)):v0[Cn]&&v0[Cn](i.rep)}}function t(L){let i=_e(U0,L);if(i.own){let u=A0.get(i.rep);u?(u[On]&&u[On](),A0.delete(i.rep)):a0[Cn]&&a0[Cn](i.rep)}}function e(L){let i=_e(en,L);if(i.own){let u=_n.get(i.rep);u?(u[On]&&u[On](),_n.delete(i.rep)):Pt[Cn]&&Pt[Cn](i.rep)}}function I(L){let i=_e(rn,L);if(i.own){let u=Xt.get(i.rep);u?(u[On]&&u[On](),Xt.delete(i.rep)):vt[Cn]&&vt[Cn](i.rep)}}Promise.all([M,G,z,m0]).catch(()=>{}),{exports:t0}=yield b(yield z),{exports:$}=yield b(yield M,{wasi_snapshot_preview1:{args_get:t0[27],args_sizes_get:t0[28],clock_time_get:t0[31],environ_get:t0[29],environ_sizes_get:t0[30],fd_close:t0[32],fd_fdstat_get:t0[33],fd_fdstat_set_flags:t0[34],fd_filestat_get:t0[35],fd_filestat_set_size:t0[36],fd_pread:t0[37],fd_prestat_dir_name:t0[39],fd_prestat_get:t0[38],fd_read:t0[40],fd_seek:t0[41],fd_write:t0[42],path_filestat_get:t0[43],path_open:t0[44],proc_exit:t0[45],random_get:t0[46]}}),{exports:b0}=yield b(yield G,{__main_module__:{_start:$._start},env:{memory:$.memory},"wasi:cli/environment@0.2.0":{"get-arguments":t0[1],"get-environment":t0[0]},"wasi:cli/exit@0.2.0":{exit:x},"wasi:cli/stderr@0.2.0":{"get-stderr":F},"wasi:cli/stdin@0.2.0":{"get-stdin":lt},"wasi:cli/stdout@0.2.0":{"get-stdout":d0},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":e},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":I},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":t0[26]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":t0[24]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":t0[25]},"wasi:clocks/monotonic-clock@0.2.0":{now:Q0},"wasi:clocks/wall-clock@0.2.0":{now:t0[2]},"wasi:filesystem/preopens@0.2.0":{"get-directories":t0[23]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":t0[5],"[method]descriptor.get-flags":t0[6],"[method]descriptor.get-type":t0[7],"[method]descriptor.metadata-hash":t0[13],"[method]descriptor.metadata-hash-at":t0[14],"[method]descriptor.open-at":t0[12],"[method]descriptor.read":t0[9],"[method]descriptor.read-via-stream":t0[3],"[method]descriptor.set-size":t0[8],"[method]descriptor.stat":t0[10],"[method]descriptor.stat-at":t0[11],"[method]descriptor.write-via-stream":t0[4],"[resource-drop]descriptor":t,"[resource-drop]directory-entry-stream":f,"filesystem-error-code":t0[15]},"wasi:io/error@0.2.0":{"[resource-drop]error":_},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":t0[17],"[method]input-stream.read":t0[16],"[method]output-stream.blocking-flush":t0[21],"[method]output-stream.blocking-write-and-flush":t0[20],"[method]output-stream.check-write":t0[18],"[method]output-stream.write":t0[19],"[resource-drop]input-stream":r,"[resource-drop]output-stream":D},"wasi:random/random@0.2.0":{"get-random-bytes":t0[22]}}),v=$.memory,W=b0.cabi_import_realloc,{exports:T}=yield b(yield m0,{"":{$imports:t0.$imports,0:Rt,1:mt,10:ft,11:Jt,12:tn,13:Yt,14:Gt,15:Mt,16:zt,17:nn,18:un,19:ht,2:Ct,20:At,21:Ht,22:Hn,23:Wn,24:yn,25:Y,26:E,27:b0.args_get,28:b0.args_sizes_get,29:b0.environ_get,3:st,30:b0.environ_sizes_get,31:b0.clock_time_get,32:b0.fd_close,33:b0.fd_fdstat_get,34:b0.fd_fdstat_set_flags,35:b0.fd_filestat_get,36:b0.fd_filestat_set_size,37:b0.fd_pread,38:b0.fd_prestat_get,39:b0.fd_prestat_dir_name,4:Ot,40:b0.fd_read,41:b0.fd_seek,42:b0.fd_write,43:b0.path_filestat_get,44:b0.path_open,45:b0.proc_exit,46:b0.random_get,5:hn,6:gn,7:Bn,8:St,9:ct}});function y(){let L=b0["wasi:cli/run@0.2.0#run"](),i;switch(L){case 0:{i={tag:"ok",val:void 0};break}case 1:{i={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(i.tag==="err")throw new kr(i.val);return i.val}let U={run:y};return{run:U,"wasi:cli/run@0.2.0":U}}(),X,S0,D0;function f0(nt){try{let t0;do({value:nt,done:t0}=r0.next(nt));while(!(nt instanceof Promise)&&!t0);if(t0)if(S0)S0(nt);else return nt;X||(X=new Promise(($,Q0)=>(S0=$,D0=Q0))),nt.then($=>t0?S0():f0($),D0)}catch(t0){if(D0)D0(t0);else throw t0}}let s0=f0(null);return X||s0}var le=()=>Promise.resolve().then(()=>(A_(),T_)),E_=new Ae(le,Nr,"yowasp-icepll"),g_=E_.run.bind(E_),m_=new Ae(le,Pr,"yowasp-icebram"),B_=m_.run.bind(m_),C_=new Ae(le,vr,"yowasp-icemulti"),W_=C_.run.bind(C_),O_=new Ae(le,h_,"yowasp-icepack"),v_=O_.run.bind(O_),N_=new Ae(le,h_,"yowasp-iceunpack"),M_=N_.run.bind(N_),L_=new Ae(le,xr,"yowasp-nextpnr-ice40"),H_=L_.run.bind(L_),Kr={icepll:g_,icebram:B_,icemulti:W_,icepack:v_,iceunpack:M_,"nextpnr-ice40":H_},Yr="0.8.621";var Gr=(async()=>{let n=new Map,l=new Map;for(let[b,M]of Object.entries({yosys:Me,"nextpnr-ice40":$e})){n.set(b,M.version);for(let[G,z]of Object.entries(M.commands))l.set(G,{run:z,Exit:M.Exit})}return postMessage({type:"packages",packages:Object.fromEntries(n.entries())}),l})();function zr(n){let l=new Uint8Array;return b=>{if(b!==null){let M=new Uint8Array(l.length+b.length);M.set(l),M.set(b,l.length),l=M;let G=-1;for(;;){let z=l.indexOf(10,G+1);if(z===-1)break;n(l.subarray(G+1,z+1)),G=z}l=l.subarray(G+1)}}}async function Xr(n,l,b){let M=zr(b),G=JSON.parse(n[l]);for(let z of G.commands){M(new TextEncoder().encode(`+ ${z.join(" ")}
`));let[m0,...J0]=z,x0=(await Gr).get(m0);try{n=await x0.run(J0,n,{stdout:M,stderr:M,decodeASCII:!1})}catch(K0){if(K0 instanceof x0.Exit)return{code:K0.code,files:K0.files};throw K0}}return{code:0,files:n}}onmessage=async n=>{let{files:l,scriptName:b}=n.data,M=await Xr(l,b,G=>{G.length!==0&&(console.log("[Builder Output]",new TextDecoder().decode(G).trimEnd()),postMessage({type:"output",bytes:G}))});console.log("[Builder Result]",M),postMessage({type:"result",...M})};onunhandledrejection=n=>{n.reason instanceof Error&&(console.error("[Builder Error]",n.reason),postMessage({type:"error",error:n.reason}),n.preventDefault())};
//# sourceMappingURL=worker.js.map
